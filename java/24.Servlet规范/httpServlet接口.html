<!DOCTYPE HTML>
<html lang="zh_CN" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>httpServlet接口.md - JAVA笔记库</title>


        <!-- Custom HTML head -->

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="../favicon.svg">
        <link rel="shortcut icon" href="../favicon.png">
        <link rel="stylesheet" href="../css/variables.css">
        <link rel="stylesheet" href="../css/general.css">
        <link rel="stylesheet" href="../css/chrome.css">

        <!-- Fonts -->
        <link rel="stylesheet" href="../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" id="highlight-css" href="../highlight.css">
        <link rel="stylesheet" id="tomorrow-night-css" href="../tomorrow-night.css">
        <link rel="stylesheet" id="ayu-highlight-css" href="../ayu-highlight.css">

        <!-- Custom theme stylesheets -->

        <!-- MathJax -->
        <script async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>

        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "../";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="../toc.js"></script>
    </head>
    <body>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="../toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                    </div>

                    <h1 class="menu-title">JAVA笔记库</h1>

                    <div class="right-buttons">

                    </div>
                </div>


                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <link rel="stylesheet" href="/note-service/java/infisearch_assets/search-ui-light.css">
<style>.light .infi-root,
.rust .infi-root,
.coal .infi-root,
.navy .infi-root,
.ayu .infi-root {
    --infi-shadow: none;
    --infi-border: 3px solid var(--table-header-bg);
    --infi-bg: var(--bg);
    --infi-triangle-bg: var(--table-header-bg);
    --infi-item-box-shadow: 0 1px 5px rgba(196, 192, 187, 0.8);
    --infi-title-fg: var(--fg);
    --infi-title-hover-fg: var(--fg);
    --infi-title-hover-bg: var(--table-header-bg);
    --infi-title-border-bottom-hover: 2px solid var(--table-header-bg);
    --infi-heading-fg: var(--fg);
    --infi-heading-hover-fg: var(--fg);
    --infi-body-fg: var(--fg);
    --infi-body-hover-fg: var(--fg);
    --infi-sub-bg: var(--bg);
    --infi-highlight: var(--search-mark-bg);
    --infi-highlight-bg: none;
    --infi-header-fg: var(--fg);
    --infi-checkbox-bg: #f8f8f8;
    --infi-checkbox-checked-bg: #fff;
    --infi-checkbox-border: #414141;
    --infi-filter-header-active: var(--infi-title-bg);
    --infi-error-fg: var(--fg);
    --infi-fine-print-fg: var(--fg);
    --infi-loading-bg: var(--fg);
    --infi-loading-secondary-bg: var(--fg);
    --infi-load-more-fg: var(--infi-title-fg);
    --infi-load-more-bg: var(--infi-title-bg);
    --infi-load-more-hover-fg: var(--infi-title-hover-fg);
    --infi-load-more-hover-bg: var(--infi-title-hover-bg);
    --infi-scrollbar-bg: none;
    --infi-scrollbar-thumb-bg: var(--sidebar-non-existant);
    --infi-fs-button-input-fg: var(--searchbar-shadow-color);
    --infi-fs-border: 3px solid var(--sidebar-bg);
    --infi-fs-box-shadow: none;
    --infi-fs-header-bg: var(--sidebar-bg);
    --infi-fs-header-box-shadow: none;
    --infi-tip-table-header-border: var(--table-border-color);
    --infi-tip-table-border: transparent;
    --infi-tip-table-alternate: var(--table-alternate-bg);
    --infi-tip-bg: var(--sidebar-bg);
    --infi-tip-fg: var(--sidebar-fg);
    --infi-tip-code-fg: var(--inline-code-color);
    --infi-tip-code-bg: transparent;
    --infi-tip-icon-bg: rgb(230, 230, 230);
    --infi-tip-icon-fg: rgb(80, 80, 80);
}

.light .infi-root {
    --infi-fs-header-close-fg: var(--searchresults-header-fg);
    --infi-fs-header-close-hover-fg: var(--fg);
}

.ayu .infi-root,
.rust .infi-root,
.coal .infi-root,
.navy .infi-root {
    --infi-fs-header-close-fg: var(--sidebar-fg);
    --infi-fs-header-close-hover-fg: white;
}

.ayu .infi-root,
.rust .infi-root {
    --infi-tip-code-fg: var(--search-mark-bg) !important;
    --infi-tip-icon-bg: rgb(200, 200, 200);
    --infi-tip-icon-fg: rgb(50, 50, 50);
}

.light .infi-root .infi-list-item.focus,
.rust .infi-root .infi-list-item.focus,
.coal .infi-root .infi-list-item.focus,
.navy .infi-root .infi-list-item.focus,
.ayu .infi-root .infi-list-item.focus {
    outline: 2px solid grey;
}

.light .infi-root,
.coal .infi-root,
.navy .infi-root,
.ayu .infi-root {
    --infi-title-bg: var(--theme-hover);
    --infi-sub-hover-bg: var(--table-alternate-bg);
    --infi-title-border-bottom: 2px solid var(--theme-hover);
}

.light .infi-root {
    --infi-highlight: #82a6c4;
    --infi-sub-hover-bg: #ebebeb;
}

.rust .infi-root {
    --infi-highlight: #bc8e6a;

    --infi-tip-table-alternate: var(--sidebar-bg);
    --infi-title-bg: var(--table-header-bg);
    --infi-title-border-bottom: 2px solid var(--table-header-bg);

    --infi-sub-hover-bg: #c6bbb1;
    --infi-title-bg: #bbada1;
    --infi-title-border-bottom: 2px solid #bbada1;
    --infi-title-hover-fg: #000;
    --infi-title-hover-bg: #a19488;
    --infi-title-border-bottom-hover: 2px solid #a19488;
    --infi-body-hover-fg: #1e1e1e;
    --infi-heading-hover-fg: #1e1e1e;
}

.coal .infi-root {
    --infi-highlight: #496c8a;
    --infi-sub-hover-bg: #272a2b;
}

.infi-theme .infi-root .infi-tip-item code,
.rust .infi-root .infi-tip-item code {
    color: var(--infi-tip-code-fg) !important;;
}

.coal .infi-root,
.navy .infi-root,
.ayu .infi-root {
    --infi-item-box-shadow: 0 1px 5px rgb(50, 50, 50);
    --infi-fs-input-fg: var(--fg);
    --infi-fs-input-focus-border: 2px solid #4f95cc;
    --infi-fs-input-focus-box-shadow: 0 0 5px -1px #63baff;
    --infi-key-fg: #fff;
    --infi-key-bg: #7d7d7d;
    --infi-checkbox-bg: #313233;
    --infi-checkbox-checked-bg: #424243;
    --infi-checkbox-border: #525354;
}

.rust .infi-root {
    --infi-fs-input-fg: var(--sidebar-fg);
    --infi-fs-input-bg: #29201d;
    --infi-fs-input-border: 2px solid #584d4a;
    --infi-fs-input-focus-border: 2px solid #4f95cc;
    --infi-fs-input-focus-box-shadow: 0 0 5px -1px #63baff;
}

.coal .infi-root {
    --infi-fs-input-bg: #1d1f21;
    --infi-fs-input-border: 2px solid #3e4144;
}

.navy .infi-root {
    --infi-fs-input-bg: #1e222f;
    --infi-fs-input-border: 2px solid #3d4252;
    --infi-sub-hover-bg: #242734;
}

.ayu .infi-root {
    --infi-fs-input-fg: var(--fg);
    --infi-fs-input-bg: #2b3035;
    --infi-fs-input-border: 2px solid #43474c;
    --infi-fs-input-focus-border: 2px solid #4f95cc;
    --infi-fs-input-focus-box-shadow: 0 0 5px -1px #63baff;
    --infi-sub-hover-bg: #282e35;
}

#infi-search {
    width: 100%;
    border-radius: 3px;
    box-sizing: border-box;
    padding: 10px 16px;
    border: 1px solid var(--searchbar-border-color);
    background: var(--searchbar-bg);
    color: var(--searchbar-fg);
}

#infi-search:focus:not(.infi-button-input) {
    box-shadow: 0 0 3px var(--searchbar-shadow-color);
}

#infi-search.infi-button-input {
    width: 100px;
}

#infi-search.infi-button-input::placeholder {
    position: relative;
    left: 14px;
}

#infi-search.infi-button-input:hover {
    transition: 0.3s ease-out;
    background: var(--infi-fs-button-input-bg) !important;
    outline: 2px solid var(--infi-fs-button-input-bg);
}

#infi-search.infi-button-input:hover::placeholder {
    color: var(--infi-fs-button-input-fg) !important;
}

@media print {
    #infi-search {
        display: none;
    }
}

#infisearch-mdbook-target {
    position: relative;
}

/*
 * For this plugin, don't show the controls until there is a query.
 */
#infisearch-mdbook-target.infi-empty-input > * {
    display: none;
}

.infi-root:not(.infi-fs-root) {
    display: block;
}

.light .infi-root .infi-title::after,
.rust .infi-root .infi-title::after,
.coal .infi-root .infi-title::after,
.navy .infi-root .infi-title::after,
.ayu .infi-root .infi-title::after {
    content: none;
    display: none;
}

.infi-header {
    padding-bottom: 9px;
}

.infi-load-more {
    padding: 7px 15px;
}
</style>
<p><input
    type="search"
    id="infi-search"
    placeholder="Search this book ..."
/></p>
<p><span style="font-weight: 600;"><!--preload weight 600--></span></p>
<div id="infisearch-mdbook-target"></div>
<h1 id="servlet接口"><a class="header" href="#servlet接口">Servlet接口</a></h1>
<h2 id="请求处理"><a class="header" href="#请求处理">请求处理</a></h2>
<h3 id="请求方法"><a class="header" href="#请求方法">请求方法</a></h3>
<h4 id="doget"><a class="header" href="#doget">doGet</a></h4>
<p>一般用于查询,资源获取</p>
<h4 id="dopost"><a class="header" href="#dopost">doPost</a></h4>
<p>用于修改服务器资源</p>
<h4 id="doput"><a class="header" href="#doput">doPut</a></h4>
<p>用于文件上传</p>
<h4 id="dodelete"><a class="header" href="#dodelete">doDelete</a></h4>
<p>删除资源</p>
<h4 id="dohead"><a class="header" href="#dohead">doHead</a></h4>
<p>只返回DoGet请求的 头</p>
<h4 id="dooptions"><a class="header" href="#dooptions">doOptions</a></h4>
<p>返回HttpServlet支持的 方法,通过 Allow 响应头返回支持的 HTTP 操作，如 GET、POST</p>
<h4 id="dotrace"><a class="header" href="#dotrace">doTrace</a></h4>
<p>返回的响应包含 TRACE 请求的所有头信息</p>
<h4 id="有条件-get-支持"><a class="header" href="#有条件-get-支持">有条件 GET 支持</a></h4>
<p><em>HttpServlet</em> 定义了用于支持有条件 GET 操作的 <em>getLastModified</em> 方法。所谓的有条件 GET 操作是指客户端
通过 GET 请求获取资源时，当资源自第一次获取那个时间点发生更改后才再次发生数据，否则将使用客户
端缓存的数据。在一些适当的场合，实现此方法可以更有效的利用网络资源，减少不必要的数据发送</p>
<h2 id="servlet实例数量"><a class="header" href="#servlet实例数量">Servlet实例数量</a></h2>
<p><strong>单实例的Servlet</strong></p>
<ul>
<li>
<p>通过注解描述的（第 8 章 注解和可插拔性）或者在 Web 应用程序的部署描述符（第 14 章 部署描述符）中描述的 servlet 声明，控制着 servlet 容器如何提供 servlet 实例</p>
</li>
<li>
<p>对于未托管在分布式环境中（默认）的 <em>servlet</em> 而言，<em>servlet</em> 容器对于每一个 <em>Servlet</em> 声明必须且只能产生一
个实例。不过，如果 Servlet 实现了 <em>SingleThreadModel</em> 接口，servlet 容器可以选择实例化多个实例以便处
理高负荷请求或者串行化请求到一个特定实例。
如果 <em>servlet</em> 以分布式方式进行部署，容器可以为每个虚拟机（JVM）的每个 <em>Servlet</em> 声明产生一个实例。但
是，如果在分布式环境中 servlet 实现了 SingleThreadModel 接口，此时容器可以为每个容器的 JVM 实例化
多个 Servlet 实例</p>
</li>
</ul>
<p><em><strong>SingleThreadModel</strong></em></p>
<ul>
<li>
<p>它保证在  同一时刻 只能由一个 线程执行 <em>service</em>方法</p>
</li>
<li>
<p>实现的方式大致由两种</p>
<ul>
<li>针对 单实例 进行 同步锁定</li>
<li>针对 多实例 维护实例池 , 分配空闲实例</li>
</ul>
</li>
<li>
<p>但是 仍然避免不了 线程安全问题, 尤其是在 多个servlet针对  <em>session</em>的attribute时</p>
</li>
<li>
<p>最好的办法是 不要编写 有状态的 <em>servlet</em></p>
</li>
<li>
<p>已经过时</p>
</li>
</ul>
<h2 id="生命周期"><a class="header" href="#生命周期">生命周期</a></h2>
<h3 id="加载和实例化"><a class="header" href="#加载和实例化">加载和实例化</a></h3>
<p>Servlet 容器负责加载和实例化 Servlet。<strong>加载和实例化可以发生在容器启动时，或者延迟初始化直到容器决定有请求需要处理时</strong>。当 Servlet 引擎启动后，servlet 容器必须定位所需要的 Servlet 类。Servlet 容器使用普通的 Java 类加载设施加载 Servlet 类。可以从本地文件系统或远程文件系统或者其他网络服务加载。加载
完 Servlet 类后，容器就可以实例化它并使用了</p>
<h3 id="初始化"><a class="header" href="#初始化">初始化</a></h3>
<p>一旦一个 Servlet 对象实例化完毕，容器接下来必须在处理客户端请求之前初始化该 Servlet 实例。初始化
的目的是以便 Servlet 能读取持久化配置数据，<strong>初始化一些代价高的资源（比如 JDBC API 连接）</strong>，或者执
行一些一次性的动作。</p>
<pre><code class="language-java">init(ServletConfig config)
</code></pre>
<p><strong>初始化时的错误条件</strong>
在初始化阶段，servlet 实现可能抛出 UnavailableException 或 ServletException 异常。在这种情况下，Servlet
不能放置到活动服务中，而且 Servlet 容器必须释放它。如果初始化没有成功，destroy 方法不应该被调用。
在实例初始化失败后容器可能再实例化和初始化一个新的实例。此规则的例外是，<strong>当抛出的</strong>
<strong>UnavailableException 表示一个不可用的最小时间，容器在创建和初始化一个新的 servlet 实例之前必须等待</strong>
<strong>一段时间</strong>。</p>
<h3 id="请求处理-1"><a class="header" href="#请求处理-1">请求处理</a></h3>
<h4 id="forward与include"><a class="header" href="#forward与include">forward与include</a></h4>
<ul>
<li>
<p><em>forward</em></p>
<p>一旦调用forward,<strong>除了保留forward前的response里的header外</strong>，其它的都不保留</p>
<pre><code class="language-java">//该命令 会立马 分派到指定servlet
request.getRequestDispatcher("/forwardDemo02").forward(request,response);
</code></pre>
</li>
<li>
<p><em>include</em></p>
<p>包含 该URL的 内容,(<em>printer</em>) 其他 <em>header</em> 都不要</p>
</li>
<li>
<p>forward include之间的数据共享可以通过  <em>request.attribute</em> 实现</p>
</li>
</ul>
<h4 id="多线程问题"><a class="header" href="#多线程问题"><strong>多线程问题</strong></a></h4>
<p>不要编写有状态的 <em>Servlet</em></p>
<h4 id="请求处理时的异常"><a class="header" href="#请求处理时的异常">请求处理时的异常</a></h4>
<p><em>UnavailableException</em></p>
<p><strong>永久性不可用</strong></p>
<ul>
<li>Servlet 容器必须从服务中移除这个 Servlet，调用它的 destroy 方法，并释放 Servlet 实例。</li>
<li>所有被容器拒绝的请求，都会返回一个 SC_NOT_FOUND (404) 响
应。</li>
</ul>
<p><strong>临时不可用</strong></p>
<ul>
<li>返回一个 SC_SERVICE_UNAVAILABLE (503)</li>
<li>同时会返回一个 Retry-After 头指示此 Servlet 什么时候可用</li>
</ul>
<p>容器可以选择忽略永久性和临时性不可用的区别，并把 UnavailableExceptions 视为永久性的，从而 Servlet 抛出 UnavailableException 后需要把它从服务中移除。</p>
<h4 id="异步处理"><a class="header" href="#异步处理">异步处理</a></h4>
<blockquote>
<p>Filter 及/或 Servlet 在生成响应之前必须等待一些资源或事件以便完成请求处理,比如，Servlet 在进行生成一个响应之前可能等待一个可用的 JDBC 连接，或者一个远程 web 服务的响应，或者一个 JMS 消息，或者一个应用程序事件, 在 Servlet 中等待是一个低效的操作，因为这是阻塞操作，从而白白占用一个
线程或其他一些受限资源</p>
</blockquote>
<p><strong>异步请求事件顺序</strong></p>
<ul>
<li>收到请求, 通过一系列的 <em>filter</em></li>
<li>处理请求参数</li>
<li>发出请求去获取一些资源或数据 例如获取JDBC连接,发起Web远程服务</li>
<li>servlet 不产生响应并返回</li>
<li>过了一段时间后，所请求的资源变为可用，此时处理线程继续处理事件，要么在同一个线程，要么通过
AsyncContext 分派到容器中的一个资源上</li>
</ul>
<p><strong>异步的操作</strong></p>
<pre><code>startAsync() //使用原生的未经包装的 request对象
startAsync(req,resp)//包装的 req,resp对象
complete() //完成
</code></pre>
<p><strong>异步的限制</strong></p>
<ul>
<li>
<p>所有涉及到 异步调用链的  filter必须是支持异步的</p>
</li>
<li>
<p>当 从一个异步servlet 分派到 同步servlet 时, servlet结束后,会自动调用 complete</p>
</li>
<li>
<p>同步 servlet 不能 分派到 异步servlet</p>
</li>
<li>
<p>异步servlet 的响应 等到 调用 complete 才返回</p>
</li>
<li>
<p>异步超时之后 会自动 提交响应</p>
</li>
</ul>
<pre><code class="language-java">{
        System.out.println("servlet1");
        System.out.println(req.getClass());
        System.out.println(response.getClass());
        AsyncContext asyncContext = req.startAsync();
        if(asyncContext.hasOriginalRequestAndResponse()){
            asyncContext.start(()-&gt;{
                try {
                    Thread.sleep(2000);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
                // 设置响应内容类型
                response.setContentType("text/html;charset=UTF-8");
                //格式化输出
                PrintWriter out;
                try {
                    out = response.getWriter();
                    String title = "自动刷新 Header 设置 - 菜鸟教程实例";
                    String docType =
                            "&lt;!DOCTYPE html&gt;\n";
                    out.println(docType +
                            "&lt;html&gt;\n" +
                            "&lt;head&gt;&lt;title&gt;" + title + "&lt;/title&gt;&lt;/head&gt;\n"+
                            "&lt;body bgcolor=\"#f0f0f0\"&gt;\n" +
                            "&lt;h1 align=\"center\"&gt;" + title + "&lt;/h1&gt;\n" +
                            "&lt;p&gt;当前时间是：" + LocalDateTime.now() + "&lt;/p&gt;\n");
                } catch (IOException e) {
                    e.printStackTrace();
                }
                asyncContext.dispatch();
            });
        }else{
            //开始干另一件事
            System.out.println("异步处理完毕了哈哈哈");
            asyncContext.complete();
        }
        System.out.println("立即返回");
    }
</code></pre>
<p><strong>升级处理</strong></p>
<ul>
<li>
<p>在 HTTP/1.1，Upgrade 通用头（general-header）允许客户端指定其支持和希望使用的其他通信协议。如果
服务器找到合适的切换协议，那么新的协议将在之后的通信中使用。</p>
</li>
<li>
<p>Servlet 容器提供了 HTTP 升级机制。不过，Servlet 容器本身不知道任何升级协议。协议处理封装在 <em>HttpUpgradeHandler</em> 协议处理器。<strong>在容器和HttpUpgradeHandler 协议处理器之间通过字节流进行数据读取或写入</strong></p>
</li>
<li>
<p>流程</p>
<ul>
<li>当收到一个升级（upgrade）请求，servlet 可以调用 HttpServletRequest.upgrade 方法启动升级处理。该方法
实例化给定的 HttpUpgradeHandler 类，返回的 HttpUpgradeHandler 实例可以被进一步的定制。</li>
<li>应用准备发送一个合适的响应到客户端。</li>
<li>退出 servlet service 方法之后，servlet 容器完成所有过滤器的处理并标记连接已交给 HttpUpgradeHandler 协议处理器处理。</li>
<li>然后调用 HttpUpgradeHandler 协议处理器的 init 方法，传入一个 WebConnection 以允许 HttpUpgradeHandler 协议处理器访问数据流。</li>
<li>Servlet 过滤器仅处理初始的 HTTP 请求和响应，然后它们将不会再参与到后续的通信中。换句话说，一旦请求被升级，它们将不会被调用。</li>
<li>协议处理器（ProtocolHandler）可以使用非阻塞 IO（non blocking IO）消费和生产消息。当处理 HTTP 升级时，开发人员负责线程安全的访问 ServletInputStream 和 ServletOutputStream。当升级处理已经完成，将调用 HttpUpgradeHandler.destroy 方法。</li>
</ul>
</li>
</ul>
<h3 id="终止服务"><a class="header" href="#终止服务"><strong>终止服务</strong></a></h3>
<ul>
<li>
<p>Servlet 容器没必要保持装载的 Servlet 持续任何特定的一段时间。</p>
</li>
<li>
<p>一个 Servlet 实例可能会在 servlet 容器内保持活跃（active）持续一段时间（以毫秒为单位），Servlet 容器的寿命可能是几天，几个月，或几年，或者是任何之间的时间。当 Servlet 容器确定 servlet 应该从服务中移除时，将调用 Servlet 接口的 destroy 方法以允许 Servlet 释放它使
用的任何资源和保存任何持久化的状态。例如，当想要节省内存资源或它被关闭时，容器可以做这个。</p>
</li>
<li>
<p>在 servlet 容器调用 destroy 方法之前，它必须让当前正在执行 service 方法的任何线程完成执行，或者超过
了服务器定义的时间限制。一旦调用了 servlet 实例的 destroy 方法，容器无法再路由其他请求到该 servlet 实例了。如果容器需要再次使用该 servlet，它必须用该 servlet 类的一个新的实例。</p>
</li>
</ul>
<script src="/note-service/java/infisearch_assets/search-ui.chinese.bundle.js" type="text/javascript" charset="utf-8"></script>
<script src="/note-service/java/infisearch_assets/mark.min.js" type="text/javascript" charset="utf-8"></script>
<script>
const base_url = '/note-service/java/';
const mode = 'target';
infisearch.init({
  searcherOptions: {
    url: base_url + 'infisearch_output/',
  },
  uiOptions: {
    mode,
    dropdownAlignment: 'bottom-start',
    target: document.getElementById('infisearch-mdbook-target'),
    fsButtonPlaceholder: 'Search',
    sourceFilesUrl: base_url,
    resultsRenderOpts: {
      searchedTermsParam: 'search',
    },
    multiSelectFilters: [
      { fieldName: 'partTitle', displayName: 'Section', defaultOptName: 'None' },
    ],
  },
});

document.getElementById('infi-search').addEventListener('keydown', (ev) => {
  if (['ArrowLeft', 'ArrowRight'].includes(ev.key)) {
    ev.stopPropagation(); // used in global listener to change pages
    return;
  }
});

if (window.location.search) {
  // Adapted from the original searcher.js for mdbook
  // https://github.com/rust-lang/mdBook/blob/master/src/theme/searcher/searcher.js
  const target = document.getElementById('content');
  const marker = new Mark(target);

  function doSearchOrMarkFromUrl() {
    // Check current URL for search request
    var url = new URL(window.location.href);
    var urlParams = new URLSearchParams(url.search);

    if (urlParams.has('search')) {
      var words = JSON.parse(decodeURIComponent(urlParams.get('search')));
      marker.mark(words);

      var markers = document.querySelectorAll('mark');
      function hide() {
        for (var i = 0; i < markers.length; i++) {
          markers[i].classList.add('fade-out');
          window.setTimeout(function () { marker.unmark(); }, 300);
        }
      }
      for (var i = 0; i < markers.length; i++) {
        markers[i].addEventListener('click', hide);
      }
    }
  }
  doSearchOrMarkFromUrl();
}
</script>
<p><span data-infisearch-part-title="未分类"></span></p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../24.Servlet规范/fitler.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="../24.Servlet规范/request.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../24.Servlet规范/fitler.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="../24.Servlet规范/request.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>



        <script src="../clipboard.min.js"></script>
        <script src="../highlight.js"></script>
        <script src="../book.js"></script>

        <!-- Custom JS scripts -->


    </div>
    </body>
</html>
