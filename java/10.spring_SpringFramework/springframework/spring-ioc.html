<!DOCTYPE HTML>
<html lang="zh_CN" class="light" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>spring-ioc.md - JAVA笔记库</title>


        <!-- Custom HTML head -->
        
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="../../favicon.svg">
        <link rel="shortcut icon" href="../../favicon.png">
        <link rel="stylesheet" href="../../css/variables.css">
        <link rel="stylesheet" href="../../css/general.css">
        <link rel="stylesheet" href="../../css/chrome.css">

        <!-- Fonts -->
        <link rel="stylesheet" href="../../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../../fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="../../highlight.css">
        <link rel="stylesheet" href="../../tomorrow-night.css">
        <link rel="stylesheet" href="../../ayu-highlight.css">

        <!-- Custom theme stylesheets -->

        <!-- MathJax -->
        <script async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    </head>
    <body class="sidebar-visible no-js">
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "../../";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('light')
            html.classList.add(theme);
            var body = document.querySelector('body');
            body.classList.remove('no-js')
            body.classList.add('js');
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var body = document.querySelector('body');
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            body.classList.remove('sidebar-visible');
            body.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="spacer"></li><li class="chapter-item affix "><li class="part-title">java基础</li><li class="chapter-item "><a href="../../02.html"><strong aria-hidden="true">0.</strong> 对象拷贝</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../../02.java基础_对象拷贝/mapstruct.html"><strong aria-hidden="true">0.0.</strong> mapstruct.md</a></li></ol></li><li class="chapter-item "><a href="../../03.html"><strong aria-hidden="true">1.</strong> 函数式编程</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../../03.java基础_函数式编程/anyMatchAllMatch.html"><strong aria-hidden="true">1.0.</strong> anyMatchAllMatch.md</a></li><li class="chapter-item "><a href="../../03.java基础_函数式编程/java函数式编程.html"><strong aria-hidden="true">1.1.</strong> java函数式编程.md</a></li><li class="chapter-item "><a href="../../03.java基础_函数式编程/lamba表达式原理.html"><strong aria-hidden="true">1.2.</strong> lamba表达式原理.md</a></li><li class="chapter-item "><a href="../../03.java基础_函数式编程/方法引用.html"><strong aria-hidden="true">1.3.</strong> 方法引用.md</a></li><li class="chapter-item "><a href="../../03.java基础_函数式编程/流操作.html"><strong aria-hidden="true">1.4.</strong> 流操作.md</a></li></ol></li><li class="chapter-item "><a href="../../04.html"><strong aria-hidden="true">2.</strong> Bean校验</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../../04.java基础_Bean校验/javaValidated.html"><strong aria-hidden="true">2.0.</strong> javaValidated.md</a></li><li class="spacer"></li></ol></li><li class="chapter-item "><li class="part-title">jvm</li><li class="chapter-item "><a href="../../07.html"><strong aria-hidden="true">3.</strong> jvm基础</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../../07.jvm_jvm基础/GC后对象地址变化了HashCode如何保持不变.html"><strong aria-hidden="true">3.0.</strong> GC后对象地址变化了HashCode如何保持不变.md</a></li><li class="chapter-item "><a href="../../07.jvm_jvm基础/JMM与volatile关键字.html"><strong aria-hidden="true">3.1.</strong> JMM与volatile关键字.md</a></li><li class="chapter-item "><a href="../../07.jvm_jvm基础/JVMGC.html"><strong aria-hidden="true">3.2.</strong> JVMGC.md</a></li><li class="chapter-item "><a href="../../07.jvm_jvm基础/JVM内存模型.html"><strong aria-hidden="true">3.3.</strong> JVM内存模型.md</a></li><li class="chapter-item "><a href="../../07.jvm_jvm基础/JVM参数.html"><strong aria-hidden="true">3.4.</strong> JVM参数.md</a></li><li class="chapter-item "><a href="../../07.jvm_jvm基础/JVM复制算法.html"><strong aria-hidden="true">3.5.</strong> JVM复制算法.md</a></li><li class="chapter-item "><a href="../../07.jvm_jvm基础/类加载/README.html"><strong aria-hidden="true">3.6.</strong> 类加载</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../../07.jvm_jvm基础/类加载/类加载器.html"><strong aria-hidden="true">3.6.0.</strong> 类加载器.md</a></li><li class="chapter-item "><a href="../../07.jvm_jvm基础/类加载/类加载过程.html"><strong aria-hidden="true">3.6.1.</strong> 类加载过程.md</a></li><li class="chapter-item "><a href="../../07.jvm_jvm基础/类加载/线程上下文加载器.html"><strong aria-hidden="true">3.6.2.</strong> 线程上下文加载器.md</a></li></ol></li><li class="chapter-item "><a href="../../07.jvm_jvm基础/XXSurvivorRatio.html"><strong aria-hidden="true">3.7.</strong> XXSurvivorRatio.md</a></li><li class="chapter-item "><a href="../../07.jvm_jvm基础/javaUnsafe工具类与CAS.html"><strong aria-hidden="true">3.8.</strong> javaUnsafe工具类与CAS.md</a></li><li class="chapter-item "><a href="../../07.jvm_jvm基础/java内存泄露与OOM.html"><strong aria-hidden="true">3.9.</strong> java内存泄露与OOM.md</a></li><li class="chapter-item "><a href="../../07.jvm_jvm基础/java对象分析.html"><strong aria-hidden="true">3.10.</strong> java对象分析.md</a></li><li class="chapter-item "><a href="../../07.jvm_jvm基础/java引用类型.html"><strong aria-hidden="true">3.11.</strong> java引用类型.md</a></li></ol></li><li class="chapter-item "><a href="../../08.html"><strong aria-hidden="true">4.</strong> jvm问题诊断与性能分析</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../../08.jvm_jvm问题诊断与性能分析/MAT.html"><strong aria-hidden="true">4.0.</strong> MAT.md</a></li><li class="chapter-item "><a href="../../08.jvm_jvm问题诊断与性能分析/javaCPU占用高的问题.html"><strong aria-hidden="true">4.1.</strong> javaCPU占用高的问题.md</a></li><li class="chapter-item "><a href="../../08.jvm_jvm问题诊断与性能分析/java远程调试.html"><strong aria-hidden="true">4.2.</strong> java远程调试.md</a></li><li class="chapter-item "><a href="../../08.jvm_jvm问题诊断与性能分析/优雅停服.html"><strong aria-hidden="true">4.3.</strong> 优雅停服.md</a></li><li class="chapter-item "><a href="../../08.jvm_jvm问题诊断与性能分析/元空间溢出.html"><strong aria-hidden="true">4.4.</strong> 元空间溢出.md</a></li><li class="chapter-item "><a href="../../08.jvm_jvm问题诊断与性能分析/排查内存溢出.html"><strong aria-hidden="true">4.5.</strong> 排查内存溢出.md</a></li></ol></li><li class="chapter-item "><a href="../../09.html"><strong aria-hidden="true">5.</strong> Arthas</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../../09.jvm_Arthas/1.安装.html"><strong aria-hidden="true">5.0.</strong> 安装.md</a></li><li class="chapter-item "><a href="../../09.jvm_Arthas/2.快速入门.html"><strong aria-hidden="true">5.1.</strong> 快速入门.md</a></li><li class="chapter-item "><a href="../../09.jvm_Arthas/3.命令.html"><strong aria-hidden="true">5.2.</strong> 命令.md</a></li><li class="chapter-item "><a href="../../09.jvm_Arthas/4.ArthasTunnel.html"><strong aria-hidden="true">5.3.</strong> ArthasTunnel.md</a></li><li class="chapter-item "><a href="../../09.jvm_Arthas/5.Idea插件.html"><strong aria-hidden="true">5.4.</strong> Idea插件.md</a></li><li class="chapter-item "><a href="../../09.jvm_Arthas/6.JavaAgent启动.html"><strong aria-hidden="true">5.5.</strong> JavaAgent启动.md</a></li><li class="chapter-item "><a href="../../09.jvm_Arthas/7.火焰图.html"><strong aria-hidden="true">5.6.</strong> 火焰图.md</a></li><li class="chapter-item "><a href="../../09.jvm_Arthas/8.thread命令.html"><strong aria-hidden="true">5.7.</strong> thread命令.md</a></li><li class="chapter-item "><a href="../../09.jvm_Arthas/9.trace.html"><strong aria-hidden="true">5.8.</strong> trace.md</a></li><li class="spacer"></li></ol></li><li class="chapter-item "><li class="part-title">spring</li><li class="chapter-item expanded "><a href="../../10.html"><strong aria-hidden="true">6.</strong> SpringFramework</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../../10.spring_SpringFramework/0.spring容器启动总览.html"><strong aria-hidden="true">6.0.</strong> spring容器启动总览.md</a></li><li class="chapter-item "><a href="../../10.spring_SpringFramework/1.spring容器启动-bean实例化流程.html"><strong aria-hidden="true">6.1.</strong> spring容器启动-bean实例化流程.md</a></li><li class="chapter-item "><a href="../../10.spring_SpringFramework/2.SpringBean实例化过程.html"><strong aria-hidden="true">6.2.</strong> SpringBean实例化过程.md</a></li><li class="chapter-item "><a href="../../10.spring_SpringFramework/3.Spring依赖注入与初始化.html"><strong aria-hidden="true">6.3.</strong> Spring依赖注入与初始化.md</a></li><li class="chapter-item "><a href="../../10.spring_SpringFramework/4.SpringBean的生命周期.html"><strong aria-hidden="true">6.4.</strong> SpringBean的生命周期.md</a></li><li class="chapter-item "><a href="../../10.spring_SpringFramework/5.SpringSchedule.html"><strong aria-hidden="true">6.5.</strong> SpringSchedule.md</a></li><li class="chapter-item "><a href="../../10.spring_SpringFramework/ClassPathScanningCandidateComponentProvider.html"><strong aria-hidden="true">6.6.</strong> ClassPathScanningCandidateComponentProvider.md</a></li><li class="chapter-item "><a href="../../10.spring_SpringFramework/PropertySource.html"><strong aria-hidden="true">6.7.</strong> PropertySource.md</a></li><li class="chapter-item "><a href="../../10.spring_SpringFramework/springBeanScope/README.html"><strong aria-hidden="true">6.8.</strong> springBeanScope</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../../10.spring_SpringFramework/springBeanScope/spring自定义可刷新的上下文.html"><strong aria-hidden="true">6.8.0.</strong> spring自定义可刷新的上下文.md</a></li></ol></li><li class="chapter-item "><a href="../../10.spring_SpringFramework/编程式注入类/README.html"><strong aria-hidden="true">6.9.</strong> 编程式注入类</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../../10.spring_SpringFramework/编程式注入类/AOP代理相关.html"><strong aria-hidden="true">6.9.0.</strong> AOP代理相关.md</a></li></ol></li><li class="chapter-item "><a href="../../10.spring_SpringFramework/spring-aop/README.html"><strong aria-hidden="true">6.10.</strong> spring-aop</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../../10.spring_SpringFramework/spring-aop/AOP应用解析.html"><strong aria-hidden="true">6.10.0.</strong> AOP应用解析</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../../10.spring_SpringFramework/spring-aop/AOP应用解析/Async异步.html"><strong aria-hidden="true">6.10.0.0.</strong> Async异步.md</a></li><li class="chapter-item "><a href="../../10.spring_SpringFramework/spring-aop/AOP应用解析/依赖懒加载.html"><strong aria-hidden="true">6.10.0.1.</strong> 依赖懒加载.md</a></li><li class="chapter-item "><a href="../../10.spring_SpringFramework/spring-aop/AOP应用解析/缓存.html"><strong aria-hidden="true">6.10.0.2.</strong> 缓存.md</a></li></ol></li><li class="chapter-item "><a href="../../10.spring_SpringFramework/spring-aop/SpringAop-cglib动态代理.html"><strong aria-hidden="true">6.10.1.</strong> SpringAop-cglib动态代理.md</a></li><li class="chapter-item "><a href="../../10.spring_SpringFramework/spring-aop/SpringAop-jdk动态代理.html"><strong aria-hidden="true">6.10.2.</strong> SpringAop-jdk动态代理.md</a></li><li class="chapter-item "><a href="../../10.spring_SpringFramework/spring-aop/SpringAop-涉及到的类.html"><strong aria-hidden="true">6.10.3.</strong> SpringAop-涉及到的类.md</a></li><li class="chapter-item "><a href="../../10.spring_SpringFramework/spring-aop/SpringAop-编程式代理.html"><strong aria-hidden="true">6.10.4.</strong> SpringAop-编程式代理.md</a></li><li class="chapter-item "><a href="../../10.spring_SpringFramework/spring-aop/SpringAop-自动代理.html"><strong aria-hidden="true">6.10.5.</strong> SpringAop-自动代理.md</a></li><li class="chapter-item "><a href="../../10.spring_SpringFramework/spring-aop/SpringAop总结.html"><strong aria-hidden="true">6.10.6.</strong> SpringAop总结.md</a></li><li class="chapter-item "><a href="../../10.spring_SpringFramework/spring-aop/aop包解析.html"><strong aria-hidden="true">6.10.7.</strong> aop包解析.md</a></li></ol></li><li class="chapter-item "><a href="../../10.spring_SpringFramework/postprocessor/README.html"><strong aria-hidden="true">6.11.</strong> postprocessor</a></li><li class="chapter-item "><a href="../../10.spring_SpringFramework/spring-bean定义/README.html"><strong aria-hidden="true">6.12.</strong> spring-bean定义</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../../10.spring_SpringFramework/spring-bean定义/Bean定义.html"><strong aria-hidden="true">6.12.0.</strong> Bean定义.md</a></li></ol></li><li class="chapter-item "><a href="../../10.spring_SpringFramework/Spring总结.html"><strong aria-hidden="true">6.13.</strong> Spring总结.md</a></li><li class="chapter-item "><a href="../../10.spring_SpringFramework/applicationContext与BeanFactory的区别.html"><strong aria-hidden="true">6.14.</strong> applicationContext与BeanFactory的区别.md</a></li><li class="chapter-item expanded "><a href="../../10.spring_SpringFramework/springframework.html"><strong aria-hidden="true">6.15.</strong> springframework</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../../10.spring_SpringFramework/springframework/MessageSource.html"><strong aria-hidden="true">6.15.0.</strong> MessageSource.md</a></li><li class="chapter-item expanded "><a href="../../10.spring_SpringFramework/springframework/spring-ioc.html" class="active"><strong aria-hidden="true">6.15.1.</strong> spring-ioc.md</a></li><li class="chapter-item "><a href="../../10.spring_SpringFramework/springframework/springEL.html"><strong aria-hidden="true">6.15.2.</strong> springEL.md</a></li><li class="chapter-item "><a href="../../10.spring_SpringFramework/springframework/spring代理.html"><strong aria-hidden="true">6.15.3.</strong> spring代理.md</a></li><li class="chapter-item "><a href="../../10.spring_SpringFramework/springframework/基于Ant的路径匹配.html"><strong aria-hidden="true">6.15.4.</strong> 基于Ant的路径匹配.md</a></li><li class="chapter-item "><a href="../../10.spring_SpringFramework/springframework/字段格式化.html"><strong aria-hidden="true">6.15.5.</strong> 字段格式化.md</a></li><li class="chapter-item "><a href="../../10.spring_SpringFramework/springframework/属性源抽象.html"><strong aria-hidden="true">6.15.6.</strong> 属性源抽象.md</a></li><li class="chapter-item "><a href="../../10.spring_SpringFramework/springframework/类型转换.html"><strong aria-hidden="true">6.15.7.</strong> 类型转换.md</a></li><li class="chapter-item "><a href="../../10.spring_SpringFramework/springframework/资源抽象.html"><strong aria-hidden="true">6.15.8.</strong> 资源抽象.md</a></li><li class="chapter-item "><a href="../../10.spring_SpringFramework/springframework/配置全局日期格式化.html"><strong aria-hidden="true">6.15.9.</strong> 配置全局日期格式化.md</a></li></ol></li><li class="chapter-item "><a href="../../10.spring_SpringFramework/spring杂项.html"><strong aria-hidden="true">6.16.</strong> spring杂项.md</a></li><li class="chapter-item "><a href="../../10.spring_SpringFramework/spring组合注解.html"><strong aria-hidden="true">6.17.</strong> spring组合注解.md</a></li><li class="chapter-item "><a href="../../10.spring_SpringFramework/spring解决循环依赖问题.html"><strong aria-hidden="true">6.18.</strong> spring解决循环依赖问题.md</a></li><li class="spacer"></li></ol></li><li class="chapter-item "><li class="part-title">ORM</li><li class="chapter-item "><a href="../../25.html"><strong aria-hidden="true">7.</strong> MyBatis</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../../25.ORM_MyBatis/mybatis-插件开发.html"><strong aria-hidden="true">7.0.</strong> mybatis-插件开发.md</a></li><li class="chapter-item "><a href="../../25.ORM_MyBatis/mybatis.html"><strong aria-hidden="true">7.1.</strong> mybatis.md</a></li><li class="chapter-item "><a href="../../25.ORM_MyBatis/mybatis标签.html"><strong aria-hidden="true">7.2.</strong> mybatis标签.md</a></li><li class="chapter-item "><a href="../../25.ORM_MyBatis/resultHandler.html"><strong aria-hidden="true">7.3.</strong> resultHandler.md</a></li><li class="chapter-item "><a href="../../25.ORM_MyBatis/多结果集分页.html"><strong aria-hidden="true">7.4.</strong> 多结果集分页.md</a></li><li class="spacer"></li></ol></li><li class="chapter-item "><li class="part-title">鉴权</li><li class="chapter-item "><a href="../../27.html"><strong aria-hidden="true">8.</strong> Shiro</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../../27.鉴权_Shiro/shiro频繁访问redis.html"><strong aria-hidden="true">8.0.</strong> shiro频繁访问redis.md</a></li><li class="spacer"></li></ol></li><li class="chapter-item "><li class="part-title">其他</li><li class="chapter-item "><a href="../../30.html"><strong aria-hidden="true">9.</strong> JMH</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../../30.其他_JMH/java基准测试.html"><strong aria-hidden="true">9.0.</strong> java基准测试.md</a></li></ol></li><li class="chapter-item "><a href="../../31.html"><strong aria-hidden="true">10.</strong> JavaCommandLine</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../../31.其他_JavaCommandLine/JAVA命令行工具.html"><strong aria-hidden="true">10.0.</strong> JAVA命令行工具.md</a></li></ol></li><li class="chapter-item "><a href="../../32.html"><strong aria-hidden="true">11.</strong> 分布式与微服务</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../../32.其他_分布式与微服务/JWT无状态Session.html"><strong aria-hidden="true">11.0.</strong> JWT无状态Session.md</a></li><li class="chapter-item "><a href="../../32.其他_分布式与微服务/一致性Hash.html"><strong aria-hidden="true">11.1.</strong> 一致性Hash.md</a></li><li class="chapter-item "><a href="../../32.其他_分布式与微服务/分布式ID.html"><strong aria-hidden="true">11.2.</strong> 分布式ID.md</a></li><li class="chapter-item "><a href="../../32.其他_分布式与微服务/分布式Session案.html"><strong aria-hidden="true">11.3.</strong> 分布式Session案.md</a></li><li class="chapter-item "><a href="../../32.其他_分布式与微服务/分布式事务.html"><strong aria-hidden="true">11.4.</strong> 分布式事务.md</a></li><li class="chapter-item "><a href="../../32.其他_分布式与微服务/分布式协调器-Zookeeper.html"><strong aria-hidden="true">11.5.</strong> 分布式协调器-Zookeeper.md</a></li><li class="chapter-item "><a href="../../32.其他_分布式与微服务/分布式锁.html"><strong aria-hidden="true">11.6.</strong> 分布式锁.md</a></li><li class="chapter-item "><a href="../../32.其他_分布式与微服务/接口幂等性.html"><strong aria-hidden="true">11.7.</strong> 接口幂等性.md</a></li><li class="chapter-item "><a href="../../32.其他_分布式与微服务/负载均衡.html"><strong aria-hidden="true">11.8.</strong> 负载均衡.md</a></li></ol></li><li class="chapter-item "><a href="../../50.html"><strong aria-hidden="true">12.</strong> 未分类</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../../50.其他_未分类/Duration-Parse.html"><strong aria-hidden="true">12.0.</strong> Duration-Parse.md</a></li><li class="chapter-item "><a href="../../50.其他_未分类/EasyRules.html"><strong aria-hidden="true">12.1.</strong> EasyRules.md</a></li><li class="chapter-item "><a href="../../50.其他_未分类/JavaLocalDate.html"><strong aria-hidden="true">12.2.</strong> JavaLocalDate.md</a></li><li class="chapter-item "><a href="../../50.其他_未分类/JavaSPI.html"><strong aria-hidden="true">12.3.</strong> JavaSPI.md</a></li><li class="chapter-item "><a href="../../50.其他_未分类/JavaUnsafe类.html"><strong aria-hidden="true">12.4.</strong> JavaUnsafe类.md</a></li><li class="chapter-item "><a href="../../50.其他_未分类/Java异常.html"><strong aria-hidden="true">12.5.</strong> Java异常.md</a></li><li class="chapter-item "><a href="../../50.其他_未分类/Java泛型的协变与逆变.html"><strong aria-hidden="true">12.6.</strong> Java泛型的协变与逆变.md</a></li><li class="chapter-item "><a href="../../50.其他_未分类/PO、VO、BO.html"><strong aria-hidden="true">12.7.</strong> PO、VO、BO.md</a></li><li class="chapter-item "><a href="../../50.其他_未分类/WeakCache.html"><strong aria-hidden="true">12.8.</strong> WeakCache.md</a></li><li class="chapter-item "><a href="../../50.其他_未分类/apacheUtils类.html"><strong aria-hidden="true">12.9.</strong> apacheUtils类.md</a></li><li class="chapter-item "><a href="../../50.其他_未分类/fastJson.html"><strong aria-hidden="true">12.10.</strong> fastJson.md</a></li><li class="chapter-item "><a href="../../50.其他_未分类/foreach语法糖.html"><strong aria-hidden="true">12.11.</strong> foreach语法糖.md</a></li><li class="chapter-item "><a href="../../50.其他_未分类/formatter.html"><strong aria-hidden="true">12.12.</strong> formatter.md</a></li><li class="chapter-item "><a href="../../50.其他_未分类/integer的比较问题.html"><strong aria-hidden="true">12.13.</strong> integer的比较问题.md</a></li><li class="chapter-item "><a href="../../50.其他_未分类/javaIdea调试.html"><strong aria-hidden="true">12.14.</strong> javaIdea调试.md</a></li><li class="chapter-item "><a href="../../50.其他_未分类/javaPererences工具.html"><strong aria-hidden="true">12.15.</strong> javaPererences工具.md</a></li><li class="chapter-item "><a href="../../50.其他_未分类/java中常见的语法糖.html"><strong aria-hidden="true">12.16.</strong> java中常见的语法糖.md</a></li><li class="chapter-item "><a href="../../50.其他_未分类/java优化指南.html"><strong aria-hidden="true">12.17.</strong> java优化指南.md</a></li><li class="chapter-item "><a href="../../50.其他_未分类/java各版本新特性.html"><strong aria-hidden="true">12.18.</strong> java各版本新特性.md</a></li><li class="chapter-item "><a href="../../50.其他_未分类/java序列化接口.html"><strong aria-hidden="true">12.19.</strong> java序列化接口.md</a></li><li class="chapter-item "><a href="../../50.其他_未分类/java模块化.html"><strong aria-hidden="true">12.20.</strong> java模块化.md</a></li><li class="chapter-item "><a href="../../50.其他_未分类/jdk1.8新特性.html"><strong aria-hidden="true">12.21.</strong> jdk1.8新特性.md</a></li><li class="chapter-item "><a href="../../50.其他_未分类/jdk与jre.html"><strong aria-hidden="true">12.22.</strong> jdk与jre.md</a></li><li class="chapter-item "><a href="../../50.其他_未分类/string常量池.html"><strong aria-hidden="true">12.23.</strong> string常量池.md</a></li><li class="chapter-item "><a href="../../50.其他_未分类/threadLocal.html"><strong aria-hidden="true">12.24.</strong> threadLocal.md</a></li><li class="chapter-item "><a href="../../50.其他_未分类/web项目启动慢.html"><strong aria-hidden="true">12.25.</strong> web项目启动慢.md</a></li><li class="chapter-item "><a href="../../50.其他_未分类/代码异味.html"><strong aria-hidden="true">12.26.</strong> 代码异味.md</a></li><li class="chapter-item "><a href="../../50.其他_未分类/基于jdk1.8的Arrays.sort.html"><strong aria-hidden="true">12.27.</strong> 基于jdk1.8的Arrays.sort.md</a></li><li class="chapter-item "><a href="../../50.其他_未分类/枚举.html"><strong aria-hidden="true">12.28.</strong> 枚举.md</a></li><li class="chapter-item "><a href="../../50.其他_未分类/注解.html"><strong aria-hidden="true">12.29.</strong> 注解.md</a></li><li class="chapter-item "><a href="../../50.其他_未分类/类的关系.html"><strong aria-hidden="true">12.30.</strong> 类的关系.md</a></li><li class="spacer"></li></ol></li><li class="chapter-item "><li class="part-title"></li><li class="chapter-item "><a href="../../20.html"><strong aria-hidden="true">13.</strong> 设计模式</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../../20.设计模式/PipeLine.html"><strong aria-hidden="true">13.0.</strong> PipeLine.md</a></li></ol></li><li class="chapter-item "><a href="../../01.java基础_代理/README.html"><strong aria-hidden="true">14.</strong> 代理</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../../01.java基础_代理/CGLIB.html"><strong aria-hidden="true">14.0.</strong> CGLIB.md</a></li><li class="chapter-item "><a href="../../01.java基础_代理/cglib的几种Callback.html"><strong aria-hidden="true">14.1.</strong> cglib的几种Callback.md</a></li><li class="chapter-item "><a href="../../01.java基础_代理/jdk动态代理.html"><strong aria-hidden="true">14.2.</strong> jdk动态代理.md</a></li></ol></li><li class="chapter-item "><a href="../../21.单元测试_JUNIT5/README.html"><strong aria-hidden="true">15.</strong> JUNIT5</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../../21.单元测试_JUNIT5/ConsoleLaunch.html"><strong aria-hidden="true">15.0.</strong> ConsoleLaunch.md</a></li><li class="chapter-item "><a href="../../21.单元测试_JUNIT5/DependencyMetadata.html"><strong aria-hidden="true">15.1.</strong> DependencyMetadata.md</a></li><li class="chapter-item "><a href="../../21.单元测试_JUNIT5/writtingTest.html"><strong aria-hidden="true">15.2.</strong> writtingTest</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../../21.单元测试_JUNIT5/writtingTest/Annotations.html"><strong aria-hidden="true">15.2.0.</strong> Annotations.md</a></li></ol></li></ol></li><li class="chapter-item "><a href="../../12.spring_SpringBoot/README.html"><strong aria-hidden="true">16.</strong> SpringBoot</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../../12.spring_SpringBoot/springBoot资源处理.html"><strong aria-hidden="true">16.0.</strong> springBoot资源处理.md</a></li><li class="chapter-item "><a href="../../12.spring_SpringBoot/springboot-HiKariCP连接池动态数据源配置.html"><strong aria-hidden="true">16.1.</strong> springboot-HiKariCP连接池动态数据源配置.md</a></li><li class="chapter-item "><a href="../../12.spring_SpringBoot/springboot-devtools.html"><strong aria-hidden="true">16.2.</strong> springboot-devtools.md</a></li><li class="chapter-item "><a href="../../12.spring_SpringBoot/springboot-元数据.html"><strong aria-hidden="true">16.3.</strong> springboot-元数据.md</a></li><li class="chapter-item "><a href="../../12.spring_SpringBoot/springboot-多模块.html"><strong aria-hidden="true">16.4.</strong> springboot-多模块.md</a></li><li class="chapter-item "><a href="../../12.spring_SpringBoot/springboot-日志.html"><strong aria-hidden="true">16.5.</strong> springboot-日志.md</a></li><li class="chapter-item "><a href="../../12.spring_SpringBoot/springboot-自动配置原理.html"><strong aria-hidden="true">16.6.</strong> springboot-自动配置原理.md</a></li><li class="chapter-item "><a href="../../12.spring_SpringBoot/springboot-过滤器.html"><strong aria-hidden="true">16.7.</strong> springboot-过滤器.md</a></li><li class="chapter-item "><a href="../../12.spring_SpringBoot/springboot-配置文件与jar分离.html"><strong aria-hidden="true">16.8.</strong> springboot-配置文件与jar分离.md</a></li><li class="chapter-item "><a href="../../12.spring_SpringBoot/springboot配置文件加载.html"><strong aria-hidden="true">16.9.</strong> springboot配置文件加载</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../../12.spring_SpringBoot/springboot配置文件加载/propertySource原理.html"><strong aria-hidden="true">16.9.0.</strong> propertySource原理.md</a></li><li class="chapter-item "><a href="../../12.spring_SpringBoot/springboot配置文件加载/默认加载原则.html"><strong aria-hidden="true">16.9.1.</strong> 默认加载原则.md</a></li></ol></li><li class="chapter-item "><a href="../../12.spring_SpringBoot/官方文档.html"><strong aria-hidden="true">16.10.</strong> 官方文档</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../../12.spring_SpringBoot/官方文档/SpringApplication.html"><strong aria-hidden="true">16.10.0.</strong> SpringApplication.md</a></li></ol></li><li class="chapter-item "><a href="../../12.spring_SpringBoot/快速入门.html"><strong aria-hidden="true">16.11.</strong> 快速入门.md</a></li><li class="chapter-item "><a href="../../12.spring_SpringBoot/自定义springBootStarter.html"><strong aria-hidden="true">16.12.</strong> 自定义springBootStarter.md</a></li></ol></li><li class="chapter-item "><a href="../../11.spring_SpringWebMvc/README.html"><strong aria-hidden="true">17.</strong> SpringWebMvc</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../../11.spring_SpringWebMvc/URI-Links.html"><strong aria-hidden="true">17.0.</strong> URI-Links.md</a></li><li class="chapter-item "><a href="../../11.spring_SpringWebMvc/functional-endpoints.html"><strong aria-hidden="true">17.1.</strong> functional-endpoints.md</a></li><li class="chapter-item "><a href="../../11.spring_SpringWebMvc/mvcannotation-driven注解的作用.html"><strong aria-hidden="true">17.2.</strong> mvcannotation-driven注解的作用.md</a></li><li class="chapter-item "><a href="../../11.spring_SpringWebMvc/spring-mvc.html"><strong aria-hidden="true">17.3.</strong> spring-mvc.md</a></li><li class="chapter-item "><a href="../../11.spring_SpringWebMvc/springMVC自定义参数解析注解.html"><strong aria-hidden="true">17.4.</strong> springMVC自定义参数解析注解.md</a></li><li class="chapter-item "><a href="../../11.spring_SpringWebMvc/springMVC路径映射.html"><strong aria-hidden="true">17.5.</strong> springMVC路径映射.md</a></li><li class="chapter-item "><a href="../../11.spring_SpringWebMvc/springMVC返回后.html"><strong aria-hidden="true">17.6.</strong> springMVC返回后.md</a></li><li class="chapter-item "><a href="../../11.spring_SpringWebMvc/springMvcController配置.html"><strong aria-hidden="true">17.7.</strong> springMvcController配置.md</a></li><li class="chapter-item "><a href="../../11.spring_SpringWebMvc/内置四种filters.html"><strong aria-hidden="true">17.8.</strong> 内置四种filters.md</a></li><li class="chapter-item "><a href="../../11.spring_SpringWebMvc/基于注解的控制器.html"><strong aria-hidden="true">17.9.</strong> 基于注解的控制器.md</a></li></ol></li><li class="chapter-item "><a href="../../34.源编程_AnnotationProcessor/README.html"><strong aria-hidden="true">18.</strong> AnnotationProcessor</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../../34.源编程_AnnotationProcessor/TreeMarker.html"><strong aria-hidden="true">18.0.</strong> TreeMarker.md</a></li></ol></li><li class="chapter-item "><a href="../../15.spring_SpringCloud/README.html"><strong aria-hidden="true">19.</strong> SpringCloud</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../../15.spring_SpringCloud/Ribbon与Feign/README.html"><strong aria-hidden="true">19.0.</strong> Ribbon与Feign</a></li><li class="chapter-item "><a href="../../15.spring_SpringCloud/服务注册与发现.html"><strong aria-hidden="true">19.1.</strong> 服务注册与发现</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../../15.spring_SpringCloud/服务注册与发现/nacos/README.html"><strong aria-hidden="true">19.1.0.</strong> nacos</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../../15.spring_SpringCloud/服务注册与发现/nacos/nacos-with-spring-clound.html"><strong aria-hidden="true">19.1.0.0.</strong> nacos-with-spring-clound.md</a></li><li class="chapter-item "><a href="../../15.spring_SpringCloud/服务注册与发现/nacos/nacos-with-spring.html"><strong aria-hidden="true">19.1.0.1.</strong> nacos-with-spring.md</a></li></ol></li></ol></li><li class="chapter-item "><a href="../../15.spring_SpringCloud/网关.html"><strong aria-hidden="true">19.2.</strong> 网关</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../../15.spring_SpringCloud/网关/springCloudGateway/README.html"><strong aria-hidden="true">19.2.0.</strong> springCloudGateway</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../../15.spring_SpringCloud/网关/springCloudGateway/springCloud中的构造者模式.html"><strong aria-hidden="true">19.2.0.0.</strong> springCloud中的构造者模式.md</a></li></ol></li></ol></li></ol></li><li class="chapter-item "><a href="../../13.spring_SpringSecurity/README.html"><strong aria-hidden="true">20.</strong> SpringSecurity</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../../13.spring_SpringSecurity/SpringSecurity鉴权流程.html"><strong aria-hidden="true">20.0.</strong> SpringSecurity鉴权流程.md</a></li><li class="chapter-item "><a href="../../13.spring_SpringSecurity/spring核心逻辑.html"><strong aria-hidden="true">20.1.</strong> spring核心逻辑.md</a></li></ol></li><li class="chapter-item "><a href="../../35.源编程_Javapoet/README.html"><strong aria-hidden="true">21.</strong> Javapoet</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../../35.源编程_Javapoet/1.Code&ControlFlow.html"><strong aria-hidden="true">21.0.</strong> Code&ControlFlow.md</a></li><li class="chapter-item "><a href="../../35.源编程_Javapoet/2.Placehold.html"><strong aria-hidden="true">21.1.</strong> Placehold.md</a></li><li class="chapter-item "><a href="../../35.源编程_Javapoet/3.Methods.html"><strong aria-hidden="true">21.2.</strong> Methods.md</a></li><li class="chapter-item "><a href="../../35.源编程_Javapoet/4.Constructors.html"><strong aria-hidden="true">21.3.</strong> Constructors.md</a></li><li class="chapter-item "><a href="../../35.源编程_Javapoet/5.ParametersAndFields.html"><strong aria-hidden="true">21.4.</strong> ParametersAndFields.md</a></li><li class="chapter-item "><a href="../../35.源编程_Javapoet/6.InterfacesAndEnums.html"><strong aria-hidden="true">21.5.</strong> InterfacesAndEnums.md</a></li><li class="chapter-item "><a href="../../35.源编程_Javapoet/7.AnonymousInnerClasses.html"><strong aria-hidden="true">21.6.</strong> AnonymousInnerClasses.md</a></li><li class="chapter-item "><a href="../../35.源编程_Javapoet/8.Annotations.html"><strong aria-hidden="true">21.7.</strong> Annotations.md</a></li><li class="chapter-item "><a href="../../35.源编程_Javapoet/9.JavaDoc.html"><strong aria-hidden="true">21.8.</strong> JavaDoc.md</a></li></ol></li><li class="chapter-item "><a href="../../22.Maven/README.html"><strong aria-hidden="true">22.</strong> Maven</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../../22.Maven/AutoConfig插件.html"><strong aria-hidden="true">22.0.</strong> AutoConfig插件.md</a></li><li class="chapter-item "><a href="../../22.Maven/Executions.html"><strong aria-hidden="true">22.1.</strong> Executions.md</a></li><li class="chapter-item "><a href="../../22.Maven/MavenArcheType.html"><strong aria-hidden="true">22.2.</strong> MavenArcheType.md</a></li><li class="chapter-item "><a href="../../22.Maven/maven-Maven-Resources-Plugin.html"><strong aria-hidden="true">22.3.</strong> maven-Maven-Resources-Plugin.md</a></li><li class="chapter-item "><a href="../../22.Maven/maven-archiver.html"><strong aria-hidden="true">22.4.</strong> maven-archiver.md</a></li><li class="chapter-item "><a href="../../22.Maven/maven-assembly-plugin.html"><strong aria-hidden="true">22.5.</strong> maven-assembly-plugin.md</a></li><li class="chapter-item "><a href="../../22.Maven/maven-bom.html"><strong aria-hidden="true">22.6.</strong> maven-bom.md</a></li><li class="chapter-item "><a href="../../22.Maven/maven-profile.html"><strong aria-hidden="true">22.7.</strong> maven-profile.md</a></li><li class="chapter-item "><a href="../../22.Maven/maven-依赖管理.html"><strong aria-hidden="true">22.8.</strong> maven-依赖管理.md</a></li><li class="chapter-item "><a href="../../22.Maven/maven-编译源码.html"><strong aria-hidden="true">22.9.</strong> maven-编译源码.md</a></li><li class="chapter-item "><a href="../../22.Maven/maven.html"><strong aria-hidden="true">22.10.</strong> maven.md</a></li><li class="chapter-item "><a href="../../22.Maven/maven中的生命周期、插件、目标.html"><strong aria-hidden="true">22.11.</strong> maven中的生命周期、插件、目标.md</a></li><li class="chapter-item "><a href="../../22.Maven/maven打包方式.html"><strong aria-hidden="true">22.12.</strong> maven打包方式.md</a></li><li class="chapter-item "><a href="../../22.Maven/maven聚合项目版本管理实践.html"><strong aria-hidden="true">22.13.</strong> maven聚合项目版本管理实践.md</a></li></ol></li><li class="chapter-item "><a href="../../33.其他_Graavml/README.html"><strong aria-hidden="true">23.</strong> Graavml</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../../33.其他_Graavml/安装.html"><strong aria-hidden="true">23.0.</strong> 安装</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../../33.其他_Graavml/安装/Macos安装.html"><strong aria-hidden="true">23.0.0.</strong> Macos安装.md</a></li></ol></li></ol></li><li class="chapter-item "><a href="../../18.响应式编程/README.html"><strong aria-hidden="true">24.</strong> 响应式编程</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../../18.响应式编程/ProjectReactor/README.html"><strong aria-hidden="true">24.0.</strong> ProjectReactor</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../../18.响应式编程/ProjectReactor/core-features/README.html"><strong aria-hidden="true">24.0.0.</strong> core-features</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../../18.响应式编程/ProjectReactor/core-features/FlatMapConcatMap区别.html"><strong aria-hidden="true">24.0.0.0.</strong> FlatMapConcatMap区别.md</a></li><li class="chapter-item "><a href="../../18.响应式编程/ProjectReactor/core-features/FluxAndMono.html"><strong aria-hidden="true">24.0.0.1.</strong> FluxAndMono.md</a></li><li class="chapter-item "><a href="../../18.响应式编程/ProjectReactor/core-features/ProcessorOrSinks.html"><strong aria-hidden="true">24.0.0.2.</strong> ProcessorOrSinks.md</a></li><li class="chapter-item "><a href="../../18.响应式编程/ProjectReactor/core-features/线程和调度.html"><strong aria-hidden="true">24.0.0.3.</strong> 线程和调度.md</a></li><li class="chapter-item "><a href="../../18.响应式编程/ProjectReactor/core-features/编程式创建序列.html"><strong aria-hidden="true">24.0.0.4.</strong> 编程式创建序列.md</a></li><li class="chapter-item "><a href="../../18.响应式编程/ProjectReactor/core-features/错误处理.html"><strong aria-hidden="true">24.0.0.5.</strong> 错误处理.md</a></li></ol></li><li class="chapter-item "><a href="../../18.响应式编程/ProjectReactor/创建发布者.html"><strong aria-hidden="true">24.0.1.</strong> 创建发布者.md</a></li><li class="chapter-item "><a href="../../18.响应式编程/ProjectReactor/创建订阅.html"><strong aria-hidden="true">24.0.2.</strong> 创建订阅.md</a></li><li class="chapter-item "><a href="../../18.响应式编程/ProjectReactor/响应式流的动作.html"><strong aria-hidden="true">24.0.3.</strong> 响应式流的动作.md</a></li><li class="chapter-item "><a href="../../18.响应式编程/ProjectReactor/选择合适的操作符.html"><strong aria-hidden="true">24.0.4.</strong> 选择合适的操作符.md</a></li></ol></li></ol></li><li class="chapter-item "><a href="../../29.其他_JSR/README.html"><strong aria-hidden="true">25.</strong> JSR</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../../29.其他_JSR/jar包规范.html"><strong aria-hidden="true">25.0.</strong> jar包规范.md</a></li></ol></li><li class="chapter-item "><a href="../../16.spring_SpringCache/README.html"><strong aria-hidden="true">26.</strong> SpringCache</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../../16.spring_SpringCache/1.基于申明式缓存.html"><strong aria-hidden="true">26.0.</strong> 基于申明式缓存.md</a></li><li class="chapter-item "><a href="../../16.spring_SpringCache/2.JCacheAnnotations.html"><strong aria-hidden="true">26.1.</strong> JCacheAnnotations.md</a></li><li class="chapter-item "><a href="../../16.spring_SpringCache/3.XML的申明式缓存.html"><strong aria-hidden="true">26.2.</strong> XML的申明式缓存.md</a></li><li class="chapter-item "><a href="../../16.spring_SpringCache/4.配置缓存库.html"><strong aria-hidden="true">26.3.</strong> 配置缓存库.md</a></li></ol></li><li class="chapter-item "><a href="../../26.ORM_JPA/README.html"><strong aria-hidden="true">27.</strong> JPA</a></li><li class="chapter-item "><a href="../../28.其他_Security/README.html"><strong aria-hidden="true">28.</strong> Security</a></li><li class="chapter-item "><a href="../../06.java基础_集合框架/README.html"><strong aria-hidden="true">29.</strong> 集合框架</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../../06.java基础_集合框架/ArrayBlockingQueue.html"><strong aria-hidden="true">29.0.</strong> ArrayBlockingQueue.md</a></li><li class="chapter-item "><a href="../../06.java基础_集合框架/ArrayList.html"><strong aria-hidden="true">29.1.</strong> ArrayList.md</a></li><li class="chapter-item "><a href="../../06.java基础_集合框架/Collections工具类.html"><strong aria-hidden="true">29.2.</strong> Collections工具类.md</a></li><li class="chapter-item "><a href="../../06.java基础_集合框架/ConcurrentHashMap.html"><strong aria-hidden="true">29.3.</strong> ConcurrentHashMap.md</a></li><li class="chapter-item "><a href="../../06.java基础_集合框架/LinkedList与双向队列.html"><strong aria-hidden="true">29.4.</strong> LinkedList与双向队列.md</a></li><li class="chapter-item "><a href="../../06.java基础_集合框架/List.html"><strong aria-hidden="true">29.5.</strong> List.md</a></li><li class="chapter-item "><a href="../../06.java基础_集合框架/Map接口.html"><strong aria-hidden="true">29.6.</strong> Map接口.md</a></li><li class="chapter-item "><a href="../../06.java基础_集合框架/Queue与Deque.html"><strong aria-hidden="true">29.7.</strong> Queue与Deque.md</a></li><li class="chapter-item "><a href="../../06.java基础_集合框架/Set与LinkedHashMap.html"><strong aria-hidden="true">29.8.</strong> Set与LinkedHashMap.md</a></li><li class="chapter-item "><a href="../../06.java基础_集合框架/SynchronousQueue.html"><strong aria-hidden="true">29.9.</strong> SynchronousQueue.md</a></li><li class="chapter-item "><a href="../../06.java基础_集合框架/arraylist和linkedlist.html"><strong aria-hidden="true">29.10.</strong> arraylist和linkedlist.md</a></li><li class="chapter-item "><a href="../../06.java基础_集合框架/hashMap.html"><strong aria-hidden="true">29.11.</strong> hashMap.md</a></li></ol></li><li class="chapter-item "><a href="../../14.spring_SpringWebFlux/README.html"><strong aria-hidden="true">30.</strong> SpringWebFlux</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../../14.spring_SpringWebFlux/CoreFeatures.html"><strong aria-hidden="true">30.0.</strong> CoreFeatures.md</a></li><li class="chapter-item "><a href="../../14.spring_SpringWebFlux/DispatcherHandler.html"><strong aria-hidden="true">30.1.</strong> DispatcherHandler.md</a></li><li class="chapter-item "><a href="../../14.spring_SpringWebFlux/FunctionEndpoint.html"><strong aria-hidden="true">30.2.</strong> FunctionEndpoint.md</a></li><li class="chapter-item "><a href="../../14.spring_SpringWebFlux/基于注解的控制器/README.html"><strong aria-hidden="true">30.3.</strong> 基于注解的控制器</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../../14.spring_SpringWebFlux/基于注解的控制器/HandlerMethod.html"><strong aria-hidden="true">30.3.0.</strong> HandlerMethod.md</a></li><li class="chapter-item "><a href="../../14.spring_SpringWebFlux/基于注解的控制器/RequestMapping.html"><strong aria-hidden="true">30.3.1.</strong> RequestMapping.md</a></li></ol></li><li class="chapter-item "><a href="../../14.spring_SpringWebFlux/源码分析/README.html"><strong aria-hidden="true">30.4.</strong> 源码分析</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../../14.spring_SpringWebFlux/源码分析/springBoot创建WebFlux分析.html"><strong aria-hidden="true">30.4.0.</strong> springBoot创建WebFlux分析.md</a></li></ol></li><li class="chapter-item "><a href="../../14.spring_SpringWebFlux/URILinks.html"><strong aria-hidden="true">30.5.</strong> URILinks.md</a></li><li class="chapter-item "><a href="../../14.spring_SpringWebFlux/WebFluxConfig.html"><strong aria-hidden="true">30.6.</strong> WebFluxConfig.md</a></li><li class="chapter-item "><a href="../../14.spring_SpringWebFlux/taskList.html"><strong aria-hidden="true">30.7.</strong> taskList.md</a></li></ol></li><li class="chapter-item "><a href="../../23.IO/README.html"><strong aria-hidden="true">31.</strong> IO</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../../23.IO/Buffer.html"><strong aria-hidden="true">31.0.</strong> Buffer.md</a></li><li class="chapter-item "><a href="../../23.IO/Channel.html"><strong aria-hidden="true">31.1.</strong> Channel.md</a></li><li class="chapter-item "><a href="../../23.IO/LinuxIO模型演变.html"><strong aria-hidden="true">31.2.</strong> LinuxIO模型演变.md</a></li><li class="chapter-item "><a href="../../23.IO/FileIO(NIO-2.0)/README.html"><strong aria-hidden="true">31.3.</strong> FileIO(NIO-2.0)</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../../23.IO/FileIO(NIO-2.0)/LinksSymbolicOtherwise.html"><strong aria-hidden="true">31.3.0.</strong> LinksSymbolicOtherwise.md</a></li><li class="chapter-item "><a href="../../23.IO/FileIO(NIO-2.0)/RandomAccessFiles.html"><strong aria-hidden="true">31.3.1.</strong> RandomAccessFiles.md</a></li><li class="chapter-item "><a href="../../23.IO/FileIO(NIO-2.0)/传统IO与NIO的API迁移.html"><strong aria-hidden="true">31.3.2.</strong> 传统IO与NIO的API迁移.md</a></li><li class="chapter-item "><a href="../../23.IO/FileIO(NIO-2.0)/元数据管理.html"><strong aria-hidden="true">31.3.3.</strong> 元数据管理.md</a></li><li class="chapter-item "><a href="../../23.IO/FileIO(NIO-2.0)/其他有用方法.html"><strong aria-hidden="true">31.3.4.</strong> 其他有用方法.md</a></li><li class="chapter-item "><a href="../../23.IO/FileIO(NIO-2.0)/开发自定义文件系统.html"><strong aria-hidden="true">31.3.5.</strong> 开发自定义文件系统.md</a></li><li class="chapter-item "><a href="../../23.IO/FileIO(NIO-2.0)/文件查找.html"><strong aria-hidden="true">31.3.6.</strong> 文件查找.md</a></li><li class="chapter-item "><a href="../../23.IO/FileIO(NIO-2.0)/文件管理.html"><strong aria-hidden="true">31.3.7.</strong> 文件管理.md</a></li><li class="chapter-item "><a href="../../23.IO/FileIO(NIO-2.0)/文件读写.html"><strong aria-hidden="true">31.3.8.</strong> 文件读写.md</a></li><li class="chapter-item "><a href="../../23.IO/FileIO(NIO-2.0)/监控目录变化.html"><strong aria-hidden="true">31.3.9.</strong> 监控目录变化.md</a></li><li class="chapter-item "><a href="../../23.IO/FileIO(NIO-2.0)/目录管理.html"><strong aria-hidden="true">31.3.10.</strong> 目录管理.md</a></li><li class="chapter-item "><a href="../../23.IO/FileIO(NIO-2.0)/路径操作.html"><strong aria-hidden="true">31.3.11.</strong> 路径操作.md</a></li><li class="chapter-item "><a href="../../23.IO/FileIO(NIO-2.0)/遍历目录树.html"><strong aria-hidden="true">31.3.12.</strong> 遍历目录树.md</a></li></ol></li><li class="chapter-item "><a href="../../23.IO/Selector（选择器）.html"><strong aria-hidden="true">31.4.</strong> Selector（选择器）.md</a></li><li class="chapter-item "><a href="../../23.IO/主流IO模型.html"><strong aria-hidden="true">31.5.</strong> 主流IO模型.md</a></li><li class="chapter-item "><a href="../../23.IO/从IO到NIO个人理解.html"><strong aria-hidden="true">31.6.</strong> 从IO到NIO个人理解.md</a></li><li class="chapter-item "><a href="../../23.IO/字符集.html"><strong aria-hidden="true">31.7.</strong> 字符集.md</a></li></ol></li><li class="chapter-item "><a href="../../19.日志/README.html"><strong aria-hidden="true">32.</strong> 日志</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../../19.日志/JUL.html"><strong aria-hidden="true">32.0.</strong> JUL.md</a></li><li class="chapter-item "><a href="../../19.日志/log4j2/README.html"><strong aria-hidden="true">32.1.</strong> log4j2</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../../19.日志/log4j2/Log4j2API.html"><strong aria-hidden="true">32.1.0.</strong> Log4j2API.md</a></li><li class="chapter-item "><a href="../../19.日志/log4j2/layouts/README.html"><strong aria-hidden="true">32.1.1.</strong> layouts</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../../19.日志/log4j2/layouts/CSVLayouts.html"><strong aria-hidden="true">32.1.1.0.</strong> CSVLayouts.md</a></li><li class="chapter-item "><a href="../../19.日志/log4j2/layouts/HTMLayouts.html"><strong aria-hidden="true">32.1.1.1.</strong> HTMLayouts.md</a></li><li class="chapter-item "><a href="../../19.日志/log4j2/layouts/JSONLayout.html"><strong aria-hidden="true">32.1.1.2.</strong> JSONLayout.md</a></li><li class="chapter-item "><a href="../../19.日志/log4j2/layouts/JSONTemplateLayouts.html"><strong aria-hidden="true">32.1.1.3.</strong> JSONTemplateLayouts.md</a></li><li class="chapter-item "><a href="../../19.日志/log4j2/layouts/PatternLayout.html"><strong aria-hidden="true">32.1.1.4.</strong> PatternLayout.md</a></li></ol></li><li class="chapter-item "><a href="../../19.日志/log4j2/appenders/README.html"><strong aria-hidden="true">32.1.2.</strong> appenders</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../../19.日志/log4j2/appenders/AsyncAppender.html"><strong aria-hidden="true">32.1.2.0.</strong> AsyncAppender.md</a></li><li class="chapter-item "><a href="../../19.日志/log4j2/appenders/CassandraAppender.html"><strong aria-hidden="true">32.1.2.1.</strong> CassandraAppender.md</a></li><li class="chapter-item "><a href="../../19.日志/log4j2/appenders/ConsoleAppender.html"><strong aria-hidden="true">32.1.2.2.</strong> ConsoleAppender.md</a></li><li class="chapter-item "><a href="../../19.日志/log4j2/appenders/FailoverAppender.html"><strong aria-hidden="true">32.1.2.3.</strong> FailoverAppender.md</a></li><li class="chapter-item "><a href="../../19.日志/log4j2/appenders/FileAppender.html"><strong aria-hidden="true">32.1.2.4.</strong> FileAppender.md</a></li><li class="chapter-item "><a href="../../19.日志/log4j2/appenders/JDBCAppender.html"><strong aria-hidden="true">32.1.2.5.</strong> JDBCAppender.md</a></li><li class="chapter-item "><a href="../../19.日志/log4j2/appenders/OutputStreamAppender.html"><strong aria-hidden="true">32.1.2.6.</strong> OutputStreamAppender.md</a></li><li class="chapter-item "><a href="../../19.日志/log4j2/appenders/RandomAccessFileAppender.html"><strong aria-hidden="true">32.1.2.7.</strong> RandomAccessFileAppender.md</a></li><li class="chapter-item "><a href="../../19.日志/log4j2/appenders/RewriteAppender.html"><strong aria-hidden="true">32.1.2.8.</strong> RewriteAppender.md</a></li><li class="chapter-item "><a href="../../19.日志/log4j2/appenders/RollingFileAppender.html"><strong aria-hidden="true">32.1.2.9.</strong> RollingFileAppender.md</a></li><li class="chapter-item "><a href="../../19.日志/log4j2/appenders/RollingRandomAccessFileAppender.html"><strong aria-hidden="true">32.1.2.10.</strong> RollingRandomAccessFileAppender.md</a></li><li class="chapter-item "><a href="../../19.日志/log4j2/appenders/RoutingAppender.html"><strong aria-hidden="true">32.1.2.11.</strong> RoutingAppender.md</a></li></ol></li><li class="chapter-item "><a href="../../19.日志/log4j2/log4j2配置/README.html"><strong aria-hidden="true">32.1.3.</strong> log4j2配置</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../../19.日志/log4j2/log4j2配置/高级配置.html"><strong aria-hidden="true">32.1.3.0.</strong> 高级配置.md</a></li></ol></li><li class="chapter-item "><a href="../../19.日志/log4j2/log4j2-web.html"><strong aria-hidden="true">32.1.4.</strong> log4j2-web.md</a></li><li class="chapter-item "><a href="../../19.日志/log4j2/lookups.html"><strong aria-hidden="true">32.1.5.</strong> lookups.md</a></li><li class="chapter-item "><a href="../../19.日志/log4j2/依赖管理.html"><strong aria-hidden="true">32.1.6.</strong> 依赖管理.md</a></li></ol></li><li class="chapter-item "><a href="../../19.日志/SL4j.html"><strong aria-hidden="true">32.2.</strong> SL4j.md</a></li><li class="chapter-item "><a href="../../19.日志/日志处理进化史.html"><strong aria-hidden="true">32.3.</strong> 日志处理进化史.md</a></li></ol></li><li class="chapter-item "><a href="../../24.Servlet规范/readme.html"><strong aria-hidden="true">33.</strong> Servlet规范</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../../24.Servlet规范/fitler.html"><strong aria-hidden="true">33.0.</strong> fitler.md</a></li><li class="chapter-item "><a href="../../24.Servlet规范/httpServlet接口.html"><strong aria-hidden="true">33.1.</strong> httpServlet接口.md</a></li><li class="chapter-item "><a href="../../24.Servlet规范/request.html"><strong aria-hidden="true">33.2.</strong> request.md</a></li><li class="chapter-item "><a href="../../24.Servlet规范/response.html"><strong aria-hidden="true">33.3.</strong> response.md</a></li><li class="chapter-item "><a href="../../24.Servlet规范/servletContext.html"><strong aria-hidden="true">33.4.</strong> servletContext.md</a></li><li class="chapter-item "><a href="../../24.Servlet规范/servlet初始化.html"><strong aria-hidden="true">33.5.</strong> servlet初始化.md</a></li><li class="chapter-item "><a href="../../24.Servlet规范/session.html"><strong aria-hidden="true">33.6.</strong> session.md</a></li><li class="chapter-item "><a href="../../24.Servlet规范/入门.html"><strong aria-hidden="true">33.7.</strong> 入门.md</a></li><li class="chapter-item "><a href="../../24.Servlet规范/注解与可插拔.html"><strong aria-hidden="true">33.8.</strong> 注解与可插拔.md</a></li></ol></li><li class="chapter-item "><a href="../../05.java基础_多线程与锁/readme.html"><strong aria-hidden="true">34.</strong> 多线程与锁</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../../05.java基础_多线程与锁/JUC线程同步工具.html"><strong aria-hidden="true">34.0.</strong> JUC线程同步工具.md</a></li><li class="chapter-item "><a href="../../05.java基础_多线程与锁/LockSupport.html"><strong aria-hidden="true">34.1.</strong> LockSupport.md</a></li><li class="chapter-item "><a href="../../05.java基础_多线程与锁/java内存模型.html"><strong aria-hidden="true">34.2.</strong> java内存模型.md</a></li><li class="chapter-item "><a href="../../05.java基础_多线程与锁/java线程状态.html"><strong aria-hidden="true">34.3.</strong> java线程状态.md</a></li><li class="chapter-item "><a href="../../05.java基础_多线程与锁/java锁.html"><strong aria-hidden="true">34.4.</strong> java锁.md</a></li><li class="chapter-item "><a href="../../05.java基础_多线程与锁/jvm线程模型.html"><strong aria-hidden="true">34.5.</strong> jvm线程模型.md</a></li><li class="chapter-item "><a href="../../05.java基础_多线程与锁/关于多线程与并发编码的心得.html"><strong aria-hidden="true">34.6.</strong> 关于多线程与并发编码的心得.md</a></li><li class="chapter-item "><a href="../../05.java基础_多线程与锁/基于AQS的同步工具.html"><strong aria-hidden="true">34.7.</strong> 基于AQS的同步工具</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../../05.java基础_多线程与锁/基于AQS的同步工具/AQS.html"><strong aria-hidden="true">34.7.0.</strong> AQS.md</a></li><li class="chapter-item "><a href="../../05.java基础_多线程与锁/基于AQS的同步工具/Condition条件等待.html"><strong aria-hidden="true">34.7.1.</strong> Condition条件等待.md</a></li><li class="chapter-item "><a href="../../05.java基础_多线程与锁/基于AQS的同步工具/CountDownLatch.html"><strong aria-hidden="true">34.7.2.</strong> CountDownLatch.md</a></li><li class="chapter-item "><a href="../../05.java基础_多线程与锁/基于AQS的同步工具/CyclicBarrier.html"><strong aria-hidden="true">34.7.3.</strong> CyclicBarrier.md</a></li><li class="chapter-item "><a href="../../05.java基础_多线程与锁/基于AQS的同步工具/Lock锁接口.html"><strong aria-hidden="true">34.7.4.</strong> Lock锁接口.md</a></li><li class="chapter-item "><a href="../../05.java基础_多线程与锁/基于AQS的同步工具/ReentrantLock.html"><strong aria-hidden="true">34.7.5.</strong> ReentrantLock.md</a></li><li class="chapter-item "><a href="../../05.java基础_多线程与锁/基于AQS的同步工具/ReentrantReadWriteLock.html"><strong aria-hidden="true">34.7.6.</strong> ReentrantReadWriteLock.md</a></li><li class="chapter-item "><a href="../../05.java基础_多线程与锁/基于AQS的同步工具/Semaphore.html"><strong aria-hidden="true">34.7.7.</strong> Semaphore.md</a></li><li class="chapter-item "><a href="../../05.java基础_多线程与锁/基于AQS的同步工具/StampedLock.html"><strong aria-hidden="true">34.7.8.</strong> StampedLock.md</a></li></ol></li><li class="chapter-item "><a href="../../05.java基础_多线程与锁/线程操作.html"><strong aria-hidden="true">34.8.</strong> 线程操作.md</a></li><li class="chapter-item "><a href="../../05.java基础_多线程与锁/线程池.html"><strong aria-hidden="true">34.9.</strong> 线程池.md</a></li></ol></li><li class="chapter-item "><a href="../../17.spring_SpringDataRedis/readme.html"><strong aria-hidden="true">35.</strong> SpringDataRedis</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <!-- Track and set sidebar scroll position -->
        <script>
            var sidebarScrollbox = document.querySelector('#sidebar .sidebar-scrollbox');
            sidebarScrollbox.addEventListener('click', function(e) {
                if (e.target.tagName === 'A') {
                    sessionStorage.setItem('sidebar-scroll', sidebarScrollbox.scrollTop);
                }
            }, { passive: true });
            var sidebarScrollTop = sessionStorage.getItem('sidebar-scroll');
            sessionStorage.removeItem('sidebar-scroll');
            if (sidebarScrollTop) {
                // preserve sidebar scroll position when navigating via links within sidebar
                sidebarScrollbox.scrollTop = sidebarScrollTop;
            } else {
                // scroll sidebar to current active section when navigating via "next/previous chapter" buttons
                var activeSection = document.querySelector('#sidebar .active');
                if (activeSection) {
                    activeSection.scrollIntoView({ block: 'center' });
                }
            }
        </script>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                    </div>

                    <h1 class="menu-title">JAVA笔记库</h1>

                    <div class="right-buttons">

                    </div>
                </div>


                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <link rel="stylesheet" href="/note-service/java/infisearch_assets/search-ui-light.css">
<style>.light .infi-root,
.rust .infi-root,
.coal .infi-root,
.navy .infi-root,
.ayu .infi-root {
    --infi-shadow: none;
    --infi-border: 3px solid var(--table-header-bg);
    --infi-bg: var(--bg);
    --infi-triangle-bg: var(--table-header-bg);
    --infi-item-box-shadow: 0 1px 5px rgba(196, 192, 187, 0.8);
    --infi-title-fg: var(--fg);
    --infi-title-hover-fg: var(--fg);
    --infi-title-hover-bg: var(--table-header-bg);
    --infi-title-border-bottom-hover: 2px solid var(--table-header-bg);
    --infi-heading-fg: var(--fg);
    --infi-heading-hover-fg: var(--fg);
    --infi-body-fg: var(--fg);
    --infi-body-hover-fg: var(--fg);
    --infi-sub-bg: var(--bg);
    --infi-highlight: var(--search-mark-bg);
    --infi-highlight-bg: none;
    --infi-header-fg: var(--fg);
    --infi-checkbox-bg: #f8f8f8;
    --infi-checkbox-checked-bg: #fff;
    --infi-checkbox-border: #414141;
    --infi-filter-header-active: var(--infi-title-bg);
    --infi-error-fg: var(--fg);
    --infi-fine-print-fg: var(--fg);
    --infi-loading-bg: var(--fg);
    --infi-loading-secondary-bg: var(--fg);
    --infi-load-more-fg: var(--infi-title-fg);
    --infi-load-more-bg: var(--infi-title-bg);
    --infi-load-more-hover-fg: var(--infi-title-hover-fg);
    --infi-load-more-hover-bg: var(--infi-title-hover-bg);
    --infi-scrollbar-bg: none;
    --infi-scrollbar-thumb-bg: var(--sidebar-non-existant);
    --infi-fs-button-input-fg: var(--searchbar-shadow-color);
    --infi-fs-border: 3px solid var(--sidebar-bg);
    --infi-fs-box-shadow: none;
    --infi-fs-header-bg: var(--sidebar-bg);
    --infi-fs-header-box-shadow: none;
    --infi-tip-table-header-border: var(--table-border-color);
    --infi-tip-table-border: transparent;
    --infi-tip-table-alternate: var(--table-alternate-bg);
    --infi-tip-bg: var(--sidebar-bg);
    --infi-tip-fg: var(--sidebar-fg);
    --infi-tip-code-fg: var(--inline-code-color);
    --infi-tip-code-bg: transparent;
    --infi-tip-icon-bg: rgb(230, 230, 230);
    --infi-tip-icon-fg: rgb(80, 80, 80);
}

.light .infi-root {
    --infi-fs-header-close-fg: var(--searchresults-header-fg);
    --infi-fs-header-close-hover-fg: var(--fg);
}

.ayu .infi-root,
.rust .infi-root,
.coal .infi-root,
.navy .infi-root {
    --infi-fs-header-close-fg: var(--sidebar-fg);
    --infi-fs-header-close-hover-fg: white;
}

.ayu .infi-root,
.rust .infi-root {
    --infi-tip-code-fg: var(--search-mark-bg) !important;
    --infi-tip-icon-bg: rgb(200, 200, 200);
    --infi-tip-icon-fg: rgb(50, 50, 50);
}

.light .infi-root .infi-list-item.focus,
.rust .infi-root .infi-list-item.focus,
.coal .infi-root .infi-list-item.focus,
.navy .infi-root .infi-list-item.focus,
.ayu .infi-root .infi-list-item.focus {
    outline: 2px solid grey;
}

.light .infi-root,
.coal .infi-root,
.navy .infi-root,
.ayu .infi-root {
    --infi-title-bg: var(--theme-hover);
    --infi-sub-hover-bg: var(--table-alternate-bg);
    --infi-title-border-bottom: 2px solid var(--theme-hover);
}

.light .infi-root {
    --infi-highlight: #82a6c4;
    --infi-sub-hover-bg: #ebebeb;
}

.rust .infi-root {
    --infi-highlight: #bc8e6a;

    --infi-tip-table-alternate: var(--sidebar-bg);
    --infi-title-bg: var(--table-header-bg);
    --infi-title-border-bottom: 2px solid var(--table-header-bg);

    --infi-sub-hover-bg: #c6bbb1;
    --infi-title-bg: #bbada1;
    --infi-title-border-bottom: 2px solid #bbada1;
    --infi-title-hover-fg: #000;
    --infi-title-hover-bg: #a19488;
    --infi-title-border-bottom-hover: 2px solid #a19488;
    --infi-body-hover-fg: #1e1e1e;
    --infi-heading-hover-fg: #1e1e1e;
}

.coal .infi-root {
    --infi-highlight: #496c8a;
    --infi-sub-hover-bg: #272a2b;
}

.infi-theme .infi-root .infi-tip-item code,
.rust .infi-root .infi-tip-item code {
    color: var(--infi-tip-code-fg) !important;;
}

.coal .infi-root,
.navy .infi-root,
.ayu .infi-root {
    --infi-item-box-shadow: 0 1px 5px rgb(50, 50, 50);
    --infi-fs-input-fg: var(--fg);
    --infi-fs-input-focus-border: 2px solid #4f95cc;
    --infi-fs-input-focus-box-shadow: 0 0 5px -1px #63baff;
    --infi-key-fg: #fff;
    --infi-key-bg: #7d7d7d;
    --infi-checkbox-bg: #313233;
    --infi-checkbox-checked-bg: #424243;
    --infi-checkbox-border: #525354;
}

.rust .infi-root {
    --infi-fs-input-fg: var(--sidebar-fg);
    --infi-fs-input-bg: #29201d;
    --infi-fs-input-border: 2px solid #584d4a;
    --infi-fs-input-focus-border: 2px solid #4f95cc;
    --infi-fs-input-focus-box-shadow: 0 0 5px -1px #63baff;
}

.coal .infi-root {
    --infi-fs-input-bg: #1d1f21;
    --infi-fs-input-border: 2px solid #3e4144;
}

.navy .infi-root {
    --infi-fs-input-bg: #1e222f;
    --infi-fs-input-border: 2px solid #3d4252;
    --infi-sub-hover-bg: #242734;
}

.ayu .infi-root {
    --infi-fs-input-fg: var(--fg);
    --infi-fs-input-bg: #2b3035;
    --infi-fs-input-border: 2px solid #43474c;
    --infi-fs-input-focus-border: 2px solid #4f95cc;
    --infi-fs-input-focus-box-shadow: 0 0 5px -1px #63baff;
    --infi-sub-hover-bg: #282e35;
}

#infi-search {
    width: 100%;
    border-radius: 3px;
    box-sizing: border-box;
    padding: 10px 16px;
    border: 1px solid var(--searchbar-border-color);
    background: var(--searchbar-bg);
    color: var(--searchbar-fg);
}

#infi-search:focus:not(.infi-button-input) {
    box-shadow: 0 0 3px var(--searchbar-shadow-color);
}

#infi-search.infi-button-input {
    width: 100px;
}

#infi-search.infi-button-input::placeholder {
    position: relative;
    left: 14px;
}

#infi-search.infi-button-input:hover {
    transition: 0.3s ease-out;
    background: var(--infi-fs-button-input-bg) !important;
    outline: 2px solid var(--infi-fs-button-input-bg);
}

#infi-search.infi-button-input:hover::placeholder {
    color: var(--infi-fs-button-input-fg) !important;
}

@media print {
    #infi-search {
        display: none;
    }
}

#infisearch-mdbook-target {
    position: relative;
}

/*
 * For this plugin, don't show the controls until there is a query.
 */
#infisearch-mdbook-target.infi-empty-input > * {
    display: none;
}

.infi-root:not(.infi-fs-root) {
    display: block;
}

.light .infi-root .infi-title::after,
.rust .infi-root .infi-title::after,
.coal .infi-root .infi-title::after,
.navy .infi-root .infi-title::after,
.ayu .infi-root .infi-title::after {
    content: none;
    display: none;
}

.infi-header {
    padding-bottom: 9px;
}

.infi-load-more {
    padding: 7px 15px;
}
</style>
<p><input
    type="search"
    id="infi-search"
    placeholder="Search this book ..."
/></p>
<p><span style="font-weight: 600;"><!--preload weight 600--></span></p>
<div id="infisearch-mdbook-target"></div>
<p>{% raw %}</p>
<h1 id="spring总结"><a class="header" href="#spring总结">spring总结</a></h1>
<h2 id="beanfactory与-applicationcontext-有什么区别"><a class="header" href="#beanfactory与-applicationcontext-有什么区别"><em>beanFactory</em>与 <em>ApplicationContext</em> 有什么区别</a></h2>
<p><em>beanFactory</em>提供了配置框架的基本功能</p>
<ul>
<li>提供 获取bean及其相关信息</li>
</ul>
<p>而<em>ApplicationContext</em>作为它的子类 多了一些企业级的功能</p>
<ul>
<li>AOP集成</li>
<li>消息资源处理</li>
<li>事件发布</li>
<li>应用专用容器,例如 <em>WebApplicationContext</em></li>
</ul>
<p>通过元数据配置, 告诉容器如何</p>
<ul>
<li>初始化 , 实例化 , 组装一个bean</li>
</ul>
<h2 id="配置bean的方式"><a class="header" href="#配置bean的方式">配置bean的方式</a></h2>
<ul>
<li><em>xml</em></li>
<li>注解</li>
<li>java代码</li>
</ul>
<h1 id="配置bean元数据"><a class="header" href="#配置bean元数据">配置Bean元数据</a></h1>
<h2 id="基于xml"><a class="header" href="#基于xml">基于xml</a></h2>
<pre><code class="language-xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
    xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
    xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans
        https://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;

    &lt;bean id=&quot;...&quot; class=&quot;...&quot;&gt;  
        &lt;!-- collaborators and configuration for this bean go here --&gt;
    &lt;/bean&gt;

    &lt;bean id=&quot;...&quot; class=&quot;...&quot;&gt;
        &lt;!-- collaborators and configuration for this bean go here --&gt;
    &lt;/bean&gt;
    &lt;!-- more bean definitions go here --&gt;
&lt;/beans&gt;
</code></pre>
<h2 id="导入其他xml定义"><a class="header" href="#导入其他xml定义">导入其他XML定义</a></h2>
<pre><code class="language-xml">&lt;beans&gt;
    &lt;import resource=&quot;services.xml&quot;/&gt;
    &lt;import resource=&quot;resources/messageSource.xml&quot;/&gt;
    &lt;import resource=&quot;/resources/themeSource.xml&quot;/&gt;

    &lt;bean id=&quot;bean1&quot; class=&quot;...&quot;/&gt;
    &lt;bean id=&quot;bean2&quot; class=&quot;...&quot;/&gt;
&lt;/beans&gt;
</code></pre>
<h1 id="容器"><a class="header" href="#容器">容器</a></h1>
<h2 id="spring容器类"><a class="header" href="#spring容器类">spring容器类</a></h2>
<ul>
<li><em>ClassPathXmlApplicationContext</em> 基于类路径下的xml装载的容器类</li>
<li><em>FileSystemXmlApplicationContext</em> 基于文件系统下的xml装载的容器类</li>
</ul>
<h3 id="实例化容器"><a class="header" href="#实例化容器">实例化容器</a></h3>
<pre><code class="language-java">ApplicationContext context = new ClassPathXmlApplicationContext(&quot;services.xml&quot;, &quot;daos.xml&quot;);
//通用容器对象
ApplicationContext context = new GenericGroovyApplicationContext(&quot;services.groovy&quot;, &quot;daos.groovy&quot;);
//加入xmlbean定义
new XmlBeanDefinitionReader(context).loadBeanDefinitions(&quot;services.xml&quot;, &quot;daos.xml&quot;);
context.refresh();
//加入grouvybean定义
new GroovyBeanDefinitionReader(context).loadBeanDefinitions(&quot;services.groovy&quot;, &quot;daos.groovy&quot;);
context.refresh();

// xml容器对象
ApplicationContext context = new ClassPathXmlApplicationContext(&quot;services.xml&quot;, &quot;daos.xml&quot;);
// retrieve configured instance
PetStoreService service = context.getBean(&quot;petStore&quot;, PetStoreService.class);
</code></pre>
<h1 id="beandefintion"><a class="header" href="#beandefintion">BeanDefintion</a></h1>
<ul>
<li>
<p>bean定义描述了以何种方式创建bean</p>
</li>
<li>
<p>除了从bean定义创建bean,还可以从外部注册bean</p>
<pre><code class="language-java">getBeanFactory().registerSingleton(..)
getBeanFactory().registerBeanDefinition(..)
</code></pre>
</li>
</ul>
<h3 id="bean属性"><a class="header" href="#bean属性">bean属性</a></h3>
<div class="table-wrapper"><table><thead><tr><th style="text-align: left">Property</th><th style="text-align: left">Explained in…</th></tr></thead><tbody>
<tr><td style="text-align: left">Class</td><td style="text-align: left"><a href="https://docs.spring.io/spring/docs/5.2.7.RELEASE/spring-framework-reference/core.html#beans-factory-class">Instantiating Beans</a></td></tr>
<tr><td style="text-align: left">Name</td><td style="text-align: left"><a href="https://docs.spring.io/spring/docs/5.2.7.RELEASE/spring-framework-reference/core.html#beans-beanname">Naming Beans</a></td></tr>
<tr><td style="text-align: left">Scope</td><td style="text-align: left"><a href="https://docs.spring.io/spring/docs/5.2.7.RELEASE/spring-framework-reference/core.html#beans-factory-scopes">Bean Scopes</a></td></tr>
<tr><td style="text-align: left">Constructor arguments</td><td style="text-align: left"><a href="https://docs.spring.io/spring/docs/5.2.7.RELEASE/spring-framework-reference/core.html#beans-factory-collaborators">Dependency Injection</a></td></tr>
<tr><td style="text-align: left">Properties</td><td style="text-align: left"><a href="https://docs.spring.io/spring/docs/5.2.7.RELEASE/spring-framework-reference/core.html#beans-factory-collaborators">Dependency Injection</a></td></tr>
<tr><td style="text-align: left">Autowiring mode</td><td style="text-align: left"><a href="https://docs.spring.io/spring/docs/5.2.7.RELEASE/spring-framework-reference/core.html#beans-factory-autowire">Autowiring Collaborators</a></td></tr>
<tr><td style="text-align: left">Lazy initialization mode</td><td style="text-align: left"><a href="https://docs.spring.io/spring/docs/5.2.7.RELEASE/spring-framework-reference/core.html#beans-factory-lazy-init">Lazy-initialized Beans</a></td></tr>
<tr><td style="text-align: left">Initialization method</td><td style="text-align: left"><a href="https://docs.spring.io/spring/docs/5.2.7.RELEASE/spring-framework-reference/core.html#beans-factory-lifecycle-initializingbean">Initialization Callbacks</a></td></tr>
<tr><td style="text-align: left">Destruction method</td><td style="text-align: left"><a href="https://docs.spring.io/spring/docs/5.2.7.RELEASE/spring-framework-reference/core.html#beans-factory-lifecycle-disposablebean">Destruction Callbacks</a></td></tr>
</tbody></table>
</div>
<h3 id="bean别名"><a class="header" href="#bean别名">bean别名</a></h3>
<p>id唯一,name可以多个,以 空格,逗号,分号,分隔</p>
<pre><code class="language-xml">&lt;alias name=&quot;myApp-dataSource&quot; alias=&quot;subsystemA-dataSource&quot;/&gt;
</code></pre>
<h3 id="bean实例化"><a class="header" href="#bean实例化">bean实例化</a></h3>
<pre><code class="language-xml">构造方法
&lt;bean id=&quot;exampleBean&quot; class=&quot;examples.ExampleBean&quot;/&gt;
静态工厂
&lt;bean id=&quot;clientService&quot;
    class=&quot;examples.ClientService&quot;
    factory-method=&quot;createInstance&quot;/&gt;
实例工厂
&lt;!-- the factory bean, which contains a method called createInstance() --&gt;
&lt;bean id=&quot;serviceLocator&quot; class=&quot;examples.DefaultServiceLocator&quot;&gt;
    &lt;!-- inject any dependencies required by this locator bean --&gt;
&lt;/bean&gt;

&lt;!-- the bean to be created via the factory bean --&gt;
&lt;bean id=&quot;clientService&quot;
    factory-bean=&quot;serviceLocator&quot;
    factory-method=&quot;createClientServiceInstance&quot;/&gt;

</code></pre>
<h1 id="依赖注入"><a class="header" href="#依赖注入">依赖注入</a></h1>
<h2 id="构造注入"><a class="header" href="#构造注入">构造注入</a></h2>
<pre><code>构造注入-引用类型
&lt;bean id=&quot;beanOne&quot; class=&quot;x.y.ThingOne&quot;&gt;
        &lt;constructor-arg ref=&quot;beanTwo&quot;/&gt;
        &lt;constructor-arg ref=&quot;beanThree&quot;/&gt;
&lt;/bean&gt;
构造注入-基本类型
&lt;bean id=&quot;exampleBean&quot; class=&quot;examples.ExampleBean&quot;&gt;
    &lt;constructor-arg type=&quot;int&quot; value=&quot;7500000&quot;/&gt;
    &lt;constructor-arg type=&quot;java.lang.String&quot; value=&quot;42&quot;/&gt;
&lt;/bean&gt;

构造注入-按索引注入
&lt;bean id=&quot;exampleBean&quot; class=&quot;examples.ExampleBean&quot;&gt;
    &lt;constructor-arg index=&quot;0&quot; value=&quot;7500000&quot;/&gt;
    &lt;constructor-arg index=&quot;1&quot; value=&quot;42&quot;/&gt;
&lt;/bean&gt;
构造注入-按参数名注入-
前提是 jvm开启Debug选项
可以使用 @ConstructorProperties注解给定参数名
&lt;bean id=&quot;exampleBean&quot; class=&quot;examples.ExampleBean&quot;&gt;
    &lt;constructor-arg name=&quot;years&quot; value=&quot;7500000&quot;/&gt;
    &lt;constructor-arg name=&quot;ultimateAnswer&quot; value=&quot;42&quot;/&gt;
&lt;/bean&gt;
</code></pre>
<pre><code class="language-java">    @ConstructorProperties({&quot;years&quot;, &quot;ultimateAnswer&quot;})
    public ExampleBean(int years, String ultimateAnswer) {
        this.years = years;
        this.ultimateAnswer = ultimateAnswer;
    }
</code></pre>
<h2 id="setter方法注入"><a class="header" href="#setter方法注入">setter方法注入</a></h2>
<pre><code class="language-xml">&lt;bean id=&quot;exampleBean&quot; class=&quot;examples.ExampleBean&quot;&gt;
    &lt;properties name=&quot;ddd&quot; ref=&quot;dd&quot;/&gt;
&lt;/bean&gt;
</code></pre>
<p><strong>推荐使用构造注入注入必须的变量, 使用setter注入不是必须的变量</strong></p>
<h2 id="被注入的值的写法"><a class="header" href="#被注入的值的写法">被注入的值的写法</a></h2>
<h3 id="字面量"><a class="header" href="#字面量">字面量</a></h3>
<p><strong>字符串和基本数据类型原样写</strong></p>
<h3 id="集合"><a class="header" href="#集合">集合</a></h3>
<p><code>&lt;list/&gt;</code>, <code>&lt;set/&gt;</code>, <code>&lt;map/&gt;</code>, and <code>&lt;props/&gt;</code></p>
<pre><code class="language-xml">&lt;bean id=&quot;moreComplexObject&quot; class=&quot;example.ComplexObject&quot;&gt;
    &lt;!-- results in a setAdminEmails(java.util.Properties) call --&gt;
    &lt;property name=&quot;adminEmails&quot;&gt;
        &lt;props&gt;
            &lt;prop key=&quot;administrator&quot;&gt;administrator@example.org&lt;/prop&gt;
            &lt;prop key=&quot;support&quot;&gt;support@example.org&lt;/prop&gt;
            &lt;prop key=&quot;development&quot;&gt;development@example.org&lt;/prop&gt;
        &lt;/props&gt;
    &lt;/property&gt;
    &lt;!-- results in a setSomeList(java.util.List) call --&gt;
    &lt;property name=&quot;someList&quot;&gt;
        &lt;list&gt;
            &lt;value&gt;a list element followed by a reference&lt;/value&gt;
            &lt;ref bean=&quot;myDataSource&quot; /&gt;
        &lt;/list&gt;
    &lt;/property&gt;
    &lt;!-- results in a setSomeMap(java.util.Map) call --&gt;
    &lt;property name=&quot;someMap&quot;&gt;
        &lt;map&gt;
            &lt;entry key=&quot;an entry&quot; value=&quot;just some string&quot;/&gt;
            &lt;entry key =&quot;a ref&quot; value-ref=&quot;myDataSource&quot;/&gt;
        &lt;/map&gt;
    &lt;/property&gt;
    &lt;!-- results in a setSomeSet(java.util.Set) call --&gt;
    &lt;property name=&quot;someSet&quot;&gt;
        &lt;set&gt;
            &lt;value&gt;just some string&lt;/value&gt;
            &lt;ref bean=&quot;myDataSource&quot; /&gt;
        &lt;/set&gt;
    &lt;/property&gt;
&lt;/bean&gt;

集合合并 merge=true
&lt;beans&gt;
    &lt;bean id=&quot;parent&quot; abstract=&quot;true&quot; class=&quot;example.ComplexObject&quot;&gt;
        &lt;property name=&quot;adminEmails&quot;&gt;
            &lt;props&gt;
                &lt;prop key=&quot;administrator&quot;&gt;administrator@example.com&lt;/prop&gt;
                &lt;prop key=&quot;support&quot;&gt;support@example.com&lt;/prop&gt;
            &lt;/props&gt;
        &lt;/property&gt;
    &lt;/bean&gt;
    &lt;bean id=&quot;child&quot; parent=&quot;parent&quot;&gt;
        &lt;property name=&quot;adminEmails&quot;&gt;
            &lt;!-- the merge is specified on the child collection definition --&gt;
            &lt;props merge=&quot;true&quot;&gt;
                &lt;prop key=&quot;sales&quot;&gt;sales@example.com&lt;/prop&gt;
                &lt;prop key=&quot;support&quot;&gt;support@example.co.uk&lt;/prop&gt;
            &lt;/props&gt;
        &lt;/property&gt;
    &lt;/bean&gt;
&lt;beans&gt;
</code></pre>
<h3 id="空串与null"><a class="header" href="#空串与null">空串与null</a></h3>
<pre><code>等价于 &quot;&quot;
&lt;bean class=&quot;ExampleBean&quot;&gt;
    &lt;property name=&quot;email&quot; value=&quot;&quot;/&gt;
&lt;/bean&gt;


&lt;bean class=&quot;ExampleBean&quot;&gt;
    &lt;property name=&quot;email&quot;&gt;
        &lt;null/&gt;
    &lt;/property&gt;
&lt;/bean&gt;
</code></pre>
<h3 id="名称空间注入"><a class="header" href="#名称空间注入">名称空间注入</a></h3>
<pre><code class="language-xml">p名称空间
&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
    xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
    xmlns:p=&quot;http://www.springframework.org/schema/p&quot;
    xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans
    https://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;

    &lt;bean id=&quot;myDataSource&quot; class=&quot;org.apache.commons.dbcp.BasicDataSource&quot;
        destroy-method=&quot;close&quot;
        p:driverClassName=&quot;com.mysql.jdbc.Driver&quot;
        p:url=&quot;jdbc:mysql://localhost:3306/mydb&quot;
        p:username=&quot;root&quot;
        p:password=&quot;masterkaoli&quot;/&gt;

&lt;/beans&gt;
c名称空间
&lt;!-- c-namespace index declaration --&gt;
&lt;bean id=&quot;beanOne&quot; class=&quot;x.y.ThingOne&quot; c:_0-ref=&quot;beanTwo&quot; c:_1-ref=&quot;beanThree&quot;
    c:_2=&quot;something@somewhere.com&quot;/&gt;

</code></pre>
<h3 id="嵌套注入"><a class="header" href="#嵌套注入">嵌套注入</a></h3>
<pre><code class="language-xml">&lt;bean id=&quot;something&quot; class=&quot;things.ThingOne&quot;&gt;
    &lt;property name=&quot;fred.bob.sammy&quot; value=&quot;123&quot; /&gt;
&lt;/bean&gt;
</code></pre>
<h3 id="properties实例注入"><a class="header" href="#properties实例注入">properties实例注入</a></h3>
<pre><code class="language-xml">&lt;bean id=&quot;mappings&quot;
    class=&quot;org.springframework.context.support.PropertySourcesPlaceholderConfigurer&quot;&gt;

    &lt;!-- typed as a java.util.Properties --&gt;
    &lt;property name=&quot;properties&quot;&gt;
        &lt;value&gt;
            jdbc.driver.className=com.mysql.jdbc.Driver
            jdbc.url=jdbc:mysql://localhost:3306/mydb
        &lt;/value&gt;
    &lt;/property&gt;
&lt;/bean&gt;
</code></pre>
<h3 id="idref"><a class="header" href="#idref"><em>idref</em></a></h3>
<pre><code class="language-xml">避免 值与引用混淆
&lt;!-- in the child (descendant) context --&gt;
&lt;bean id=&quot;accountService&quot; &lt;!-- bean name is the same as the parent bean --&gt;
    class=&quot;org.springframework.aop.framework.ProxyFactoryBean&quot;&gt;
    &lt;property name=&quot;target&quot;&gt;
        &lt;ref parent=&quot;accountService&quot;/&gt; &lt;!-- notice how we refer to the parent bean --&gt;
    &lt;/property&gt;
    &lt;!-- insert other configuration and dependencies as required here --&gt;
&lt;/bean&gt;
</code></pre>
<h3 id="depends-on"><a class="header" href="#depends-on"><em>depends-on</em></a></h3>
<p>在某个bean之前实例化,用于两个不直接依赖的bean</p>
<pre><code>&lt;bean id=&quot;beanOne&quot; class=&quot;ExampleBean&quot; depends-on=&quot;manager&quot;/&gt;
&lt;bean id=&quot;manager&quot; class=&quot;ManagerBean&quot; /&gt;
</code></pre>
<h3 id="context手动获取"><a class="header" href="#context手动获取">Context手动获取</a></h3>
<p>使用场景: 两个bean的生命周期不一致,使用自动注入只会调用一次,</p>
<p>可以使用 getBean(String name)来获得</p>
<pre><code class="language-java">// a class that uses a stateful Command-style class to perform some processing
package fiona.apple;

// Spring-API imports
import org.springframework.beans.BeansException;
import org.springframework.context.ApplicationContext;
import org.springframework.context.ApplicationContextAware;

public class CommandManager implements ApplicationContextAware {

    private ApplicationContext applicationContext;

    public Object process(Map commandState) {
        // grab a new instance of the appropriate Command
        Command command = createCommand();
        // set the state on the (hopefully brand new) Command instance
        command.setState(commandState);
        return command.execute();
    }

    protected Command createCommand() {
        // notice the Spring API dependency!
        return this.applicationContext.getBean(&quot;command&quot;, Command.class);
    }

    public void setApplicationContext(
            ApplicationContext applicationContext) throws BeansException {
        this.applicationContext = applicationContext;
    }
}
</code></pre>
<h3 id="抽象方法注入"><a class="header" href="#抽象方法注入">抽象方法注入</a></h3>
<pre><code class="language-xml">&lt;!-- a stateful bean deployed as a prototype (non-singleton) --&gt;
&lt;bean id=&quot;myCommand&quot; class=&quot;fiona.apple.AsyncCommand&quot; scope=&quot;prototype&quot;&gt;
    &lt;!-- inject dependencies here as required --&gt;
&lt;/bean&gt;

&lt;!-- commandProcessor uses statefulCommandHelper --&gt;
&lt;bean id=&quot;commandManager&quot; class=&quot;fiona.apple.CommandManager&quot;&gt;
    &lt;lookup-method name=&quot;createCommand&quot; bean=&quot;myCommand&quot;/&gt;
&lt;/bean&gt;
</code></pre>
<pre><code class="language-java">package fiona.apple;

// no more Spring imports!

public abstract class CommandManager {

    public Object process(Object commandState) {
        // grab a new instance of the appropriate Command interface
        Command command = createCommand();
        // set the state on the (hopefully brand new) Command instance
        command.setState(commandState);
        return command.execute();
    }

    // okay... but where is the implementation of this method?
    protected abstract Command createCommand();
}

或者使用注解
@Lookup(&quot;name&quot;)
    如果不写名称则根据 方法的返回值类型查找,如果不写名字则需要写具体类名
    
​ Spring的Lookup method inject实现原理的是使用CGLIB动态生成一个类去继承CommandManager，重写createCommand方法。然后根据@Lookup中指定的bean Name或者createCommand方法的返回类型判断需要返回的bean。createCommand可以是abstract和可以不是。因为使用的是继承，所以CommandManager类和createCommand方法都不能是final的。

createCommand方法的签名需要满足如下要求

&lt;public|protected&gt; [abstract] &lt;return-type&gt; theMethodName(no-arguments);
</code></pre>
<h3 id="方法替换"><a class="header" href="#方法替换">方法替换</a></h3>
<p>待替换的方法</p>
<pre><code class="language-java">public class MyValueCalculator {

    public String computeValue(String input) {
        // some real code...
    }

    // some other methods...
}
</code></pre>
<p>重新实现的方法</p>
<pre><code class="language-java">public class ReplacementComputeValue implements MethodReplacer {

    public Object reimplement(Object o, Method m, Object[] args) throws Throwable {
        // get the input value, work with it, and return a computed result
        String input = (String) args[0];
        ...
        return ...;
    }
}
</code></pre>
<p>配置</p>
<pre><code>&lt;bean id=&quot;myValueCalculator&quot; class=&quot;x.y.z.MyValueCalculator&quot;&gt;
    &lt;!-- arbitrary method replacement --&gt;
    &lt;replaced-method name=&quot;computeValue&quot; replacer=&quot;replacementComputeValue&quot;&gt;
        &lt;arg-type&gt;String&lt;/arg-type&gt;
    &lt;/replaced-method&gt;
&lt;/bean&gt;

&lt;bean id=&quot;replacementComputeValue&quot; class=&quot;a.b.c.ReplacementComputeValue&quot;/&gt;
构造参数类型主要是为了区别 重载的方法
只能配置
</code></pre>
<h1 id="作用域"><a class="header" href="#作用域">作用域</a></h1>
<h3 id="属性列表"><a class="header" href="#属性列表">属性列表</a></h3>
<div class="table-wrapper"><table><thead><tr><th style="text-align: left">Scope</th><th style="text-align: left">Description</th></tr></thead><tbody>
<tr><td style="text-align: left"><a href="https://docs.spring.io/spring/docs/5.2.7.RELEASE/spring-framework-reference/core.html#beans-factory-scopes-singleton">singleton</a></td><td style="text-align: left">单例</td></tr>
<tr><td style="text-align: left"><a href="https://docs.spring.io/spring/docs/5.2.7.RELEASE/spring-framework-reference/core.html#beans-factory-scopes-prototype">prototype</a></td><td style="text-align: left">多例</td></tr>
<tr><td style="text-align: left"><a href="https://docs.spring.io/spring/docs/5.2.7.RELEASE/spring-framework-reference/core.html#beans-factory-scopes-request">request</a></td><td style="text-align: left">每来一个 Http请求中 就会产生一个</td></tr>
<tr><td style="text-align: left"><a href="https://docs.spring.io/spring/docs/5.2.7.RELEASE/spring-framework-reference/core.html#beans-factory-scopes-session">session</a></td><td style="text-align: left">Httpsession</td></tr>
<tr><td style="text-align: left"><a href="https://docs.spring.io/spring/docs/5.2.7.RELEASE/spring-framework-reference/core.html#beans-factory-scopes-application">application</a></td><td style="text-align: left">Scopes a single bean definition to the lifecycle of a <code>ServletContext</code>. Only valid in the context of a web-aware Spring <code>ApplicationContext</code>.</td></tr>
<tr><td style="text-align: left"><a href="https://docs.spring.io/spring/docs/5.2.7.RELEASE/spring-framework-reference/web.html#websocket-stomp-websocket-scope">websocket</a></td><td style="text-align: left">Scopes a single bean definition to the lifecycle of a <code>WebSocket</code>. Only valid in the context of a web-aware Spring <code>ApplicationContext</code>.</td></tr>
</tbody></table>
</div>
<h3 id="生存周期不一致的bean-访问方式"><a class="header" href="#生存周期不一致的bean-访问方式">生存周期不一致的bean 访问方式</a></h3>
<ul>
<li>单例a依赖注入 prototype的实例b时, 每次访问b, b不会变,就是直接访问,不会去scope中取</li>
<li>如果 proxyMode=ScopedProxyMode.TARGET_CLASS 或者<em>interface</em>,则 会访问b时 会生成一个代理类,里面根据 scope取值</li>
</ul>
<pre><code>package com.weisanju.javaconfig.config;

import org.springframework.context.annotation.Scope;
import org.springframework.context.annotation.ScopedProxyMode;
import org.springframework.stereotype.Component;

@Component
@Scope(proxyMode=ScopedProxyMode.NO,value = &quot;prototype&quot;)
public class MyValueCalculator {
    public String computeValue(String input) {
        System.out.println(input);
        return input;
    }
}
在被注入的时候指定代理形式
</code></pre>
<h3 id="自定义-scope"><a class="header" href="#自定义-scope">自定义 <em>scope</em></a></h3>
<ol>
<li>
<p>实现 <em>org.springframework.beans.factory.config.Scope</em>接口</p>
<p>基于 时间的作用域</p>
<pre><code class="language-java">/**
 * 首先自定义作用域范围类TimeScope:
 * Scope接口提供了五个方法，只有get()和remove()是必须实现，get()中写获取逻辑，
 * 如果已有存储中没有该名称的bean，则通过objectFactory.getObject()创建实例。
 */
@Slf4j
public class TimeScope implements Scope {

    private static Map&lt;String, Map&lt;Integer, Object&gt;&gt; scopeBeanMap = new HashMap&lt;&gt;();

    @Override
    public Object get(String name, ObjectFactory&lt;?&gt; objectFactory) {
        Integer hour = Calendar.getInstance().get(Calendar.HOUR_OF_DAY);
        // 当前是一天内的第多少分钟
        Integer minute = hour * 60 + Calendar.getInstance().get(Calendar.MINUTE);
        log.info(&quot;当前是第 {} 分钟&quot;, minute);
        Map&lt;Integer, Object&gt; objectMap = scopeBeanMap.get(name);
        Object object = null;
        if (Objects.isNull(objectMap)) {
            objectMap = new HashMap&lt;&gt;();
            object = objectFactory.getObject();
            objectMap.put(minute, object);
            scopeBeanMap.put(name, objectMap);
        } else {
            object = objectMap.get(minute);
            if (Objects.isNull(object)) {
                object = objectFactory.getObject();
                objectMap.put(minute, object);
                scopeBeanMap.put(name, objectMap);
            }
        }
        return object;
    }

    @Override
    public Object remove(String name) {
        return scopeBeanMap.remove(name);
    }

    @Override
    public void registerDestructionCallback(String name, Runnable callback) {
    }
    @Override
    public Object resolveContextualObject(String key) {
        return null;
    }
    @Override
    public String getConversationId() {
        return null;
    }
}
</code></pre>
</li>
<li>
<p>注册到 <em>org.springframework.beans.factory.config.CustomScopeConfigurer</em> 上</p>
<pre><code class="language-java">@Configuration
@Slf4j
public class BeanScopeConfig {
    @Bean
    public CustomScopeConfigurer customScopeConfigurer() {
        CustomScopeConfigurer customScopeConfigurer = new CustomScopeConfigurer();
        Map&lt;String, Object&gt; map = new HashMap&lt;&gt;();
        map.put(&quot;timeScope&quot;, new TimeScope());
        customScopeConfigurer.setScopes(map);
        return customScopeConfigurer;
    }
    
    @Bean
    @Scope(value = &quot;timeScope&quot;, proxyMode = ScopedProxyMode.TARGET_CLASS)
    public TimeScopeBean timeScopeBean() {
        TimeScopeBean timeScopeBean = new TimeScopeBean();
        timeScopeBean.setCurrentTime(System.currentTimeMillis());
        log.info(&quot;time scope bean&quot;);
        return timeScopeBean;
    }
}
</code></pre>
</li>
<li>
<p>使用 </p>
<p><em>@Scope(proxyMode=ScopedProxyMode.TARGET_CLASS,value = &quot;thread&quot;)</em></p>
</li>
</ol>
<h2 id="自定义bean的特性"><a class="header" href="#自定义bean的特性">自定义bean的特性</a></h2>
<h3 id="三类回调形式"><a class="header" href="#三类回调形式">三类回调形式</a></h3>
<p><a href="https://docs.spring.io/spring/docs/5.2.7.RELEASE/spring-framework-reference/core.html#beans-factory-lifecycle">Lifecycle Callbacks</a> 生命周期回调</p>
<p><a href="https://docs.spring.io/spring/docs/5.2.7.RELEASE/spring-framework-reference/core.html#beans-factory-aware"><code>ApplicationContextAware</code> and <code>BeanNameAware</code></a> bean注入的回调</p>
<p><a href="https://docs.spring.io/spring/docs/5.2.7.RELEASE/spring-framework-reference/core.html#aware-list">Other <code>Aware</code> Interfaces</a> 其他的回调接口</p>
<h3 id="生命周期回调"><a class="header" href="#生命周期回调">生命周期回调</a></h3>
<h4 id="bean生命周期回调"><a class="header" href="#bean生命周期回调">Bean生命周期回调</a></h4>
<ul>
<li>
<p>通过 实现 <em>InitializingBean</em> ,<em>DisposableBean</em></p>
</li>
<li>
<p>推荐使用 @PostConstruct<code>and</code>@PreDestroy ,这可与 spring特定接口 松耦合</p>
</li>
<li>
<p>或者使用 bean定义 init-method<code>and</code>destroy-method 属性</p>
</li>
<li>
<p>spring通过 <em>BeanPostProcessor</em> 接口 进行回调处理,如果需要自定义可以自行实现</p>
</li>
<li>
<p>被管理的bean可以实现 <em>Lifecycle</em> 接口</p>
</li>
</ul>
<p><strong>Initialization Callbacks</strong></p>
<ul>
<li>发生于 容器初始完 所有必须的属性时</li>
<li>推荐使用 * <a href="https://docs.spring.io/spring/docs/5.2.7.RELEASE/spring-framework-reference/core.html#beans-postconstruct-and-predestroy-annotations"><code>@PostConstruct</code></a> * 或者使用  Beandefinition 的  init-method<code>and</code>destroy-method 或者java注解的@Bean的属性,initMethod</li>
</ul>
<p><strong>Destruction Callbacks</strong></p>
<ul>
<li>类似于上面</li>
</ul>
<p><strong>Default Initialization and Destroy Methods</strong></p>
<p>或者指定全局默认的 init,destroy方法</p>
<pre><code>&lt;beans default-init-method=&quot;init&quot;&gt;

    &lt;bean id=&quot;blogService&quot; class=&quot;com.something.DefaultBlogService&quot;&gt;
        &lt;property name=&quot;blogDao&quot; ref=&quot;blogDao&quot; /&gt;
    &lt;/bean&gt;

&lt;/beans&gt;
// destroy-method
</code></pre>
<p><strong>以上各个 回调实现的组合调用顺序</strong></p>
<p>Multiple lifecycle mechanisms configured for the same bean, with different initialization methods, are called as follows:</p>
<ol>
<li>Methods annotated with <code>@PostConstruct</code></li>
<li><code>afterPropertiesSet()</code> as defined by the <code>InitializingBean</code> callback interface</li>
<li>A custom configured <code>init()</code> method</li>
</ol>
<p>Destroy methods are called in the same order:</p>
<ol>
<li>Methods annotated with <code>@PreDestroy</code></li>
<li><code>destroy()</code> as defined by the <code>DisposableBean</code> callback interface</li>
<li>A custom configured <code>destroy()</code> method</li>
</ol>
<h4 id="startup-and-shutdown-callbacks"><a class="header" href="#startup-and-shutdown-callbacks">Startup and Shutdown Callbacks</a></h4>
<ul>
<li>
<p><em>Lifecycle</em> 定义了 bean自己的 生命周期</p>
</li>
<li>
<p>容器会在收到 start stop信号后,将调用所有实现了该接口的方法,容器将委托给 <em>LifecycleProcessor</em> 去处理</p>
</li>
<li>
<p>只会在显示启动,或者显示停止时调用,要更细粒度的控制, 参照<em>SmartLifecycle</em></p>
<pre><code>	Note that the regular org.springframework.context.Lifecycle interface is a plain contract for explicit start and stop notifications and does not imply auto-startup at context refresh time. For fine-grained control over auto-startup of a specific bean (including startup phases), consider implementing org.springframework.context.SmartLifecycle instead.

Also, please note that stop notifications are not guaranteed to come before destruction. On regular shutdown, all Lifecycle beans first receive a stop notification before the general destruction callbacks are being propagated. However, on hot refresh during a context’s lifetime or on aborted refresh attempts, only destroy methods are called.
</code></pre>
</li>
<li>
<p>bean 对象 之间的 start,stop决定于 <em>depends-on</em> 和显示依赖注入,对于 某一类型 与另一类型的顺序 这 在 <em>SmartLifecycle</em> 有实现</p>
<pre><code class="language-java">public interface Phased {
    int getPhase();
}
</code></pre>
</li>
<li>
<p>当启动时, 最小的 <em>phase</em> 先启动, 关闭时 最大的 phase先关闭</p>
</li>
<li>
<p>对于普通的  “normal” <code>Lifecycle</code>  ,他们的 phase为0</p>
</li>
<li>
<p><code>SmartLifecycle</code> 的stop方法有回调,所有实现 <code>SmartLifecycle</code> 接口的 类 必须在 stop完后 回调该 stop方法</p>
<pre><code>	default void stop(Runnable callback) {
		stop();
		callback.run();
	}
</code></pre>
</li>
<li>
<p>processor的默认实现 在各个 bean关闭时的 默认超时时间 30s</p>
<pre><code class="language-java">&lt;bean id=&quot;lifecycleProcessor&quot; class=&quot;org.springframework.context.support.DefaultLifecycleProcessor&quot;&gt;
    &lt;!-- timeout value in milliseconds --&gt;
    &lt;property name=&quot;timeoutPerShutdownPhase&quot; value=&quot;10000&quot;/&gt;
&lt;/bean&gt;
</code></pre>
</li>
<li>
<p>processor还提供了  <em>onRefresh</em> 的回调 , 它会判断 <code>SmartLifecycle</code>  的isAutoStart 的标志</p>
</li>
</ul>
<h4 id="优雅的关闭非web的容器"><a class="header" href="#优雅的关闭非web的容器">优雅的关闭非web的容器</a></h4>
<ul>
<li>
<p>springWebmvc的容器已经实现了该特性</p>
</li>
<li>
<p>在jvm那里 注册一个 钩子回调,实际上是 在jvm那里 注册一个 线程用于关闭</p>
<pre><code>        ConfigurableApplicationContext ctx = new ClassPathXmlApplicationContext(&quot;beans.xml&quot;);

        // add a shutdown hook for the above context...
        ctx.registerShutdownHook();
        
        
{
		if (this.shutdownHook == null) {
			// No shutdown hook registered yet.
			this.shutdownHook = new Thread(SHUTDOWN_HOOK_THREAD_NAME) {
				@Override
				public void run() {
					synchronized (startupShutdownMonitor) {
						doClose();
					}
				}
			};
			Runtime.getRuntime().addShutdownHook(this.shutdownHook);
		}
	}
</code></pre>
</li>
</ul>
<h3 id="applicationcontextaware-and-beannameaware"><a class="header" href="#applicationcontextaware-and-beannameaware"><code>ApplicationContextAware</code> and <code>BeanNameAware</code></a></h3>
<ul>
<li>
<p>用于获取 容器引用或者 bean引用,推荐使用 注解注入</p>
</li>
<li>
<p><code>BeanNameAware</code> 回调 迟于 各种属性填充前, 早于 各种初始化回调前</p>
</li>
</ul>
<h3 id="other-aware-interfaces"><a class="header" href="#other-aware-interfaces">Other <code>Aware</code> Interfaces</a></h3>
<div class="table-wrapper"><table><thead><tr><th style="text-align: left">Name</th><th style="text-align: left">Injected Dependency</th><th style="text-align: left">Explained in…</th></tr></thead><tbody>
<tr><td style="text-align: left"><code>ApplicationContextAware</code></td><td style="text-align: left">Declaring <code>ApplicationContext</code>.</td><td style="text-align: left"><a href="https://docs.spring.io/spring/docs/5.2.7.RELEASE/spring-framework-reference/core.html#beans-factory-aware"><code>ApplicationContextAware</code> and <code>BeanNameAware</code></a></td></tr>
<tr><td style="text-align: left"><code>ApplicationEventPublisherAware</code></td><td style="text-align: left">Event publisher of the enclosing <code>ApplicationContext</code>.</td><td style="text-align: left"><a href="https://docs.spring.io/spring/docs/5.2.7.RELEASE/spring-framework-reference/core.html#context-introduction">Additional Capabilities of the <code>ApplicationContext</code></a></td></tr>
<tr><td style="text-align: left"><code>BeanClassLoaderAware</code></td><td style="text-align: left">Class loader used to load the bean classes.</td><td style="text-align: left"><a href="https://docs.spring.io/spring/docs/5.2.7.RELEASE/spring-framework-reference/core.html#beans-factory-class">Instantiating Beans</a></td></tr>
<tr><td style="text-align: left"><code>BeanFactoryAware</code></td><td style="text-align: left">Declaring <code>BeanFactory</code>.</td><td style="text-align: left"><a href="https://docs.spring.io/spring/docs/5.2.7.RELEASE/spring-framework-reference/core.html#beans-factory-aware"><code>ApplicationContextAware</code> and <code>BeanNameAware</code></a></td></tr>
<tr><td style="text-align: left"><code>BeanNameAware</code></td><td style="text-align: left">Name of the declaring bean.</td><td style="text-align: left"><a href="https://docs.spring.io/spring/docs/5.2.7.RELEASE/spring-framework-reference/core.html#beans-factory-aware"><code>ApplicationContextAware</code> and <code>BeanNameAware</code></a></td></tr>
<tr><td style="text-align: left"><code>BootstrapContextAware</code></td><td style="text-align: left">Resource adapter <code>BootstrapContext</code> the container runs in. Typically available only in JCA-aware <code>ApplicationContext</code> instances.</td><td style="text-align: left"><a href="https://docs.spring.io/spring/docs/5.2.7.RELEASE/spring-framework-reference/integration.html#cci">JCA CCI</a></td></tr>
<tr><td style="text-align: left"><code>LoadTimeWeaverAware</code></td><td style="text-align: left">Defined weaver for processing class definition at load time.</td><td style="text-align: left"><a href="https://docs.spring.io/spring/docs/5.2.7.RELEASE/spring-framework-reference/core.html#aop-aj-ltw">Load-time Weaving with AspectJ in the Spring Framework</a></td></tr>
<tr><td style="text-align: left"><code>MessageSourceAware</code></td><td style="text-align: left">Configured strategy for resolving messages (with support for parametrization and internationalization).</td><td style="text-align: left"><a href="https://docs.spring.io/spring/docs/5.2.7.RELEASE/spring-framework-reference/core.html#context-introduction">Additional Capabilities of the <code>ApplicationContext</code></a></td></tr>
<tr><td style="text-align: left"><code>NotificationPublisherAware</code></td><td style="text-align: left">Spring JMX notification publisher.</td><td style="text-align: left"><a href="https://docs.spring.io/spring/docs/5.2.7.RELEASE/spring-framework-reference/integration.html#jmx-notifications">Notifications</a></td></tr>
<tr><td style="text-align: left"><code>ResourceLoaderAware</code></td><td style="text-align: left">Configured loader for low-level access to resources.</td><td style="text-align: left"><a href="https://docs.spring.io/spring/docs/5.2.7.RELEASE/spring-framework-reference/core.html#resources">Resources</a></td></tr>
<tr><td style="text-align: left"><code>ServletConfigAware</code></td><td style="text-align: left">Current <code>ServletConfig</code> the container runs in. Valid only in a web-aware Spring <code>ApplicationContext</code>.</td><td style="text-align: left"><a href="https://docs.spring.io/spring/docs/5.2.7.RELEASE/spring-framework-reference/web.html#mvc">Spring MVC</a></td></tr>
<tr><td style="text-align: left"><code>ServletContextAware</code></td><td style="text-align: left">Current <code>ServletContext</code> the container runs in. Valid only in a web-aware Spring <code>ApplicationContext</code>.</td><td style="text-align: left"><a href="https://docs.spring.io/spring/docs/5.2.7.RELEASE/spring-framework-reference/web.html#mvc">Spring MVC</a></td></tr>
</tbody></table>
</div>
<h2 id="bean-definition-inheritance"><a class="header" href="#bean-definition-inheritance">Bean Definition Inheritance</a></h2>
<p>bean定义继承</p>
<ul>
<li>bean继承以 子类为准</li>
<li>父类可以如果不写 class,必须abstract为true</li>
<li>bean之间的同名属性必须是 兼容的</li>
<li>如果abstract 定义为 true 则该bean定义为模板,不会产生实例</li>
</ul>
<pre><code class="language-xml">&lt;bean id=&quot;inheritedTestBean&quot; abstract=&quot;true&quot;
        class=&quot;org.springframework.beans.TestBean&quot;&gt;
    &lt;property name=&quot;name&quot; value=&quot;parent&quot;/&gt;
    &lt;property name=&quot;age&quot; value=&quot;1&quot;/&gt;
&lt;/bean&gt;

&lt;bean id=&quot;inheritsWithDifferentClass&quot;
        class=&quot;org.springframework.beans.DerivedTestBean&quot;
        parent=&quot;inheritedTestBean&quot; init-method=&quot;initialize&quot;&gt;  
    &lt;property name=&quot;name&quot; value=&quot;override&quot;/&gt;
    &lt;!-- the age property value of 1 will be inherited from parent --&gt;
&lt;/bean&gt;

//不指定class
&lt;bean id=&quot;inheritedTestBeanWithoutClass&quot; abstract=&quot;true&quot;&gt;
    &lt;property name=&quot;name&quot; value=&quot;parent&quot;/&gt;
    &lt;property name=&quot;age&quot; value=&quot;1&quot;/&gt;
&lt;/bean&gt;

&lt;bean id=&quot;inheritsWithClass&quot; class=&quot;org.springframework.beans.DerivedTestBean&quot;
        parent=&quot;inheritedTestBeanWithoutClass&quot; init-method=&quot;initialize&quot;&gt;
    &lt;property name=&quot;name&quot; value=&quot;override&quot;/&gt;
    &lt;!-- age will inherit the value of 1 from the parent bean definition--&gt;
&lt;/bean&gt;
</code></pre>
<h2 id="container-extension-points"><a class="header" href="#container-extension-points">Container Extension Points</a></h2>
<p>容器扩展点</p>
<p>spring容器提供各种接口 以供开发人员扩展</p>
<h3 id="beanpostprocessor"><a class="header" href="#beanpostprocessor"><code>BeanPostProcessor</code></a></h3>
<ul>
<li><em>BeanPostProcessor</em>  可以设置任意个</li>
<li>通过order属性 排序</li>
<li>作用域是 容器中,容器间得另外注册</li>
<li><em>BeanFactoryPostProcessor</em> 可以改变BeanDefintion</li>
<li>回调发生在每个bean对象 创建后, <em><code>InitializingBean.afterPropertiesSet()</code> or any declared <code>init</code> method</em>  容器初始化完,或者任何申明得初始化方法,在其他bean初始化后</li>
<li>它可以对任何 bean采取行动, 一般用于bean的代理</li>
<li>容器会根据 配置元数据(xml,或java) 注册 这些 beanpostProcessor</li>
<li>beanpostprocessor 的初始化需要早于其他bean的初始化</li>
<li>编程方式 注册
<ul>
<li><em>ConfigurableBeanFactory.addBeanPostProcessor</em>通过这个 手动注册,当你有业务逻辑时</li>
<li>不会遵守 order 顺序,注册的顺序决定 执行顺序</li>
<li>调用发生在 自动检测bean之前</li>
</ul>
</li>
<li><em>AOP auto-proxying</em> 是基于这个接口的 ,所以任何引用该类型的 类都不应该 对其 使用AOP</li>
</ul>
<p><strong>Example</strong></p>
<p><em>RequiredAnnotationBeanPostProcessor</em> 依赖注入时 确保属性的必输项都输入( 现在更推荐 构造器注入)已过期</p>
<h3 id="beanfactorypostprocessor"><a class="header" href="#beanfactorypostprocessor"><code>BeanFactoryPostProcessor</code></a></h3>
<p>Customizing Configuration Metadata with a <code>BeanFactoryPostProcessor</code></p>
<ul>
<li>用来修改bean定义本身,这种改变时不可逆的</li>
<li>通过实现 <em>order</em>接口 来配置  BeanFactoryPostProcessor间的 顺序</li>
<li>作用域时容器范围内</li>
<li>所有的postProcessor会忽略 懒加载</li>
</ul>
<p><strong>Example</strong></p>
<p><code>PropertySourcesPlaceholderConfigurer</code></p>
<p>可以使用<em>PropertySource</em>替代</p>
<ul>
<li>
<p>可以配置多个外部属性配置文件,用来替换  ${}表达式</p>
</li>
<li>
<p>或者手写配置文件</p>
</li>
<li>
<p>如果它失败了则 这时 容器处于 <code>preInstantiateSingletons()</code> phase of an <code>ApplicationContext</code> for a non-lazy-init bean</p>
<p>预加载阶段</p>
</li>
</ul>
<pre><code class="language-xml">&lt;bean class=&quot;org.springframework.beans.factory.config.PropertySourcesPlaceholderConfigurer&quot;&gt;
    &lt;property name=&quot;locations&quot;&gt;
        &lt;value&gt;classpath:com/something/strategy.properties&lt;/value&gt;
    &lt;/property&gt;
    &lt;property name=&quot;properties&quot;&gt;
        &lt;value&gt;custom.strategy.class=com.something.DefaultStrategy&lt;/value&gt;
    &lt;/property&gt;
&lt;/bean&gt;

&lt;bean id=&quot;serviceStrategy&quot; class=&quot;${custom.strategy.class}&quot;/&gt;
</code></pre>
<p><strong><code>PropertyOverrideConfigurer</code></strong></p>
<p>替换 Bean定义的 参数属性</p>
<p>使用标签 :<em>&lt;context:property-override location=&quot;classpath:override.properties&quot;/&gt;</em></p>
<pre><code>person.name=大师傅似的
beanname.properteis=value
</code></pre>
<pre><code>@Bean
public PropertyOverrideConfigurer propertyOverrideConfigurer(){
    PropertyOverrideConfigurer propertyOverrideConfigurer = new PropertyOverrideConfigurer();
    propertyOverrideConfigurer.setFileEncoding(&quot;UTF-8&quot;);
    propertyOverrideConfigurer.setLocation(new ClassPathResource(&quot;my.properties&quot;));
    return propertyOverrideConfigurer;
}
</code></pre>
<h3 id="factorybean"><a class="header" href="#factorybean"><code>FactoryBean</code></a></h3>
<p>Customizing Instantiation Logic with a factoryBean</p>
<p>实现自定义 bean定义 逻辑</p>
<h2 id="annotation-based-container-configuration"><a class="header" href="#annotation-based-container-configuration">Annotation-based Container Configuration</a></h2>
<ul>
<li>基于注解的注入 比XML 注入更早执行,所以xml的注入会覆盖注解的注入</li>
<li>基于注解的注入实际上是 一个个beanPostProcessor</li>
<li>隐式注册这些beanPostProcessor :  <a href="context:annotation-config/">context:annotation-config/</a>
<ul>
<li><a href="https://docs.spring.io/spring-framework/docs/5.2.7.RELEASE/javadoc-api/org/springframework/beans/factory/annotation/AutowiredAnnotationBeanPostProcessor.html"><code>AutowiredAnnotationBeanPostProcessor</code></a></li>
<li><a href="https://docs.spring.io/spring-framework/docs/5.2.7.RELEASE/javadoc-api/org/springframework/context/annotation/CommonAnnotationBeanPostProcessor.html"><code>CommonAnnotationBeanPostProcessor</code></a></li>
<li><a href="https://docs.spring.io/spring-framework/docs/5.2.7.RELEASE/javadoc-api/org/springframework/orm/jpa/support/PersistenceAnnotationBeanPostProcessor.html"><code>PersistenceAnnotationBeanPostProcessor</code></a> </li>
<li><a href="https://docs.spring.io/spring-framework/docs/5.2.7.RELEASE/javadoc-api/org/springframework/beans/factory/annotation/RequiredAnnotationBeanPostProcessor.html"><code>RequiredAnnotationBeanPostProcessor</code></a></li>
</ul>
</li>
</ul>
<h3 id="required"><a class="header" href="#required">@Required</a></h3>
<p>标识该setter方法的注入必须, 已过期,推荐使用构造器注入</p>
<pre><code>public class SimpleMovieLister {

    private MovieFinder movieFinder;

    @Required
    public void setMovieFinder(MovieFinder movieFinder) {
        this.movieFinder = movieFinder;
    }

    // ...
}
</code></pre>
<h3 id="autowired"><a class="header" href="#autowired">@Autowired</a></h3>
<p>构造方法上(当 只有一个构造方法时,不是很必要)</p>
<pre><code class="language-java">public class MovieRecommender {

    private final CustomerPreferenceDao customerPreferenceDao;

    @Autowired
    public MovieRecommender(CustomerPreferenceDao customerPreferenceDao) {
        this.customerPreferenceDao = customerPreferenceDao;
    }
}
</code></pre>
<p>setter注入</p>
<pre><code>public class SimpleMovieLister {

    private MovieFinder movieFinder;

    @Autowired
    public void setMovieFinder(MovieFinder movieFinder) {
        this.movieFinder = movieFinder;
    }

    // ...
}
</code></pre>
<p>字段注入</p>
<pre><code class="language-java"> @Autowired
    private MovieCatalog movieCatalog;
</code></pre>
<p>可以注入某一类Bean</p>
<p>可以@Order或者order接口,实现注入的排序,否则顺序以注册顺序为准,@Order也会影响依赖注入顺序</p>
<pre><code class="language-java">public class MovieRecommender {
    @Autowired
    private MovieCatalog[] movieCatalogs;
}
public class MovieRecommender {
    private Set&lt;MovieCatalog&gt; movieCatalogs;
    @Autowired
    public void setMovieCatalogs(Set&lt;MovieCatalog&gt; movieCatalogs) {
        this.movieCatalogs = movieCatalogs;
    }
}
</code></pre>
<p>Map注入</p>
<p>这回注入所有 beanname,和某一类型的bean</p>
<pre><code class="language-java">public class MovieRecommender {
    private Map&lt;String, MovieCatalog&gt; movieCatalogs;
    @Autowired
    public void setMovieCatalogs(Map&lt;String, MovieCatalog&gt; movieCatalogs) {
        this.movieCatalogs = movieCatalogs;
    }
}
</code></pre>
<p>可以不启用</p>
<pre><code>public class SimpleMovieLister {
    private MovieFinder movieFinder;
    @Autowired(required = false)
    public void setMovieFinder(MovieFinder movieFinder) {
        this.movieFinder = movieFinder;
    }
}
</code></pre>
<p>注入Optional类</p>
<pre><code class="language-java">public class SimpleMovieLister {
    @Autowired
    public void setMovieFinder(Optional&lt;MovieFinder&gt; movieFinder) {
    }
}
</code></pre>
<p>可以使用@nullable</p>
<pre><code class="language-java">    @Autowired
    public void setMovieFinder(@Nullable MovieFinder movieFinder) {
        ...
    }
</code></pre>
<p>可以注入spring相关的bean</p>
<pre><code>BeanFactory, ApplicationContext, Environment, ResourceLoader, ApplicationEventPublisher, and MessageSource
ConfigurableApplicationContext or ResourcePatternResolver
public class MovieRecommender {

    @Autowired
    private ApplicationContext context;

    public MovieRecommender() {
    }
}
</code></pre>
<p><strong>注意事项</strong></p>
<ul>
<li>一个bean可能有多个 构造器, 但只有一个 构造器能 @Autowired(required = true),其他的必须是false</li>
<li>通过 匹配容器中的bean 满足依赖关系最多的 构造器 将会被使用,如果都不满足 使用默认构造器</li>
<li>'@Autowired<code>, </code>@Inject<code>, </code>@Value<code>, and </code>@Resource' 这些注入 不能用于BeanPostProcessor或者BeanFactoryPostProcessor</li>
</ul>
<h3 id="primary"><a class="header" href="#primary">@Primary</a></h3>
<ul>
<li>通过类型注册可能有多个类型的候选者,可以使用primary指定</li>
</ul>
<pre><code class="language-java">@Configuration
public class MovieConfiguration {

    @Bean
    @Primary
    public MovieCatalog firstMovieCatalog() { ... }

    @Bean
    public MovieCatalog secondMovieCatalog() { ... }

    // ...
}
</code></pre>
<p>xml配置</p>
<pre><code class="language-xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
    xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
    xmlns:context=&quot;http://www.springframework.org/schema/context&quot;
    xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans
        https://www.springframework.org/schema/beans/spring-beans.xsd
        http://www.springframework.org/schema/context
        https://www.springframework.org/schema/context/spring-context.xsd&quot;&gt;

    &lt;context:annotation-config/&gt;

    &lt;bean class=&quot;example.SimpleMovieCatalog&quot; primary=&quot;true&quot;&gt;
        &lt;!-- inject any dependencies required by this bean --&gt;
    &lt;/bean&gt;

    &lt;bean class=&quot;example.SimpleMovieCatalog&quot;&gt;
        &lt;!-- inject any dependencies required by this bean --&gt;
    &lt;/bean&gt;

    &lt;bean id=&quot;movieRecommender&quot; class=&quot;example.MovieRecommender&quot;/&gt;

&lt;/beans&gt;
</code></pre>
<h3 id="qualifiers"><a class="header" href="#qualifiers">@Qualifiers</a></h3>
<ul>
<li>
<p>与id不同,类似于 手动给定bean分类, 类似于某种bean的过滤器</p>
</li>
<li>
<p>这在注入 集合类的时候 作用尤为明显 <code>Set&lt;MovieCatalog&gt;</code></p>
</li>
<li>
<p>如果没有其他指示器(类似primary,qualifier) ,而且存在多个候选者,则spring会根据 注入字段名或参数名匹配bean</p>
</li>
<li>
<p>如果你想通过bean名匹配,最好使用@Resource, @Autowired的语义是:先找同类型的,然后寻找指定的Qualifer</p>
</li>
<li>
<p>可以通过@Resource引用集合</p>
</li>
<li>
<p>qualifier可以自引用,但顺序是最后的</p>
</li>
</ul>
<pre><code class="language-java">public class MovieRecommender {

    @Autowired
    @Qualifier(&quot;main&quot;)
    private MovieCatalog movieCatalog;

    // ...
}


public class MovieRecommender {

    private MovieCatalog movieCatalog;

    private CustomerPreferenceDao customerPreferenceDao;

    @Autowired
    public void prepare(@Qualifier(&quot;main&quot;) MovieCatalog movieCatalog,
            CustomerPreferenceDao customerPreferenceDao) {
        this.movieCatalog = movieCatalog;
        this.customerPreferenceDao = customerPreferenceDao;
    }

    // ...
}
</code></pre>
<p>xml配置</p>
<pre><code class="language-hxml"> &lt;bean class=&quot;example.SimpleMovieCatalog&quot;&gt;
        &lt;qualifier value=&quot;main&quot;/&gt; 

        &lt;!-- inject any dependencies required by this bean --&gt;
    &lt;/bean&gt;
</code></pre>
<p><strong>创建自己的qualifier注解</strong>,给qualifier分类</p>
<pre><code class="language-java">@Target({ElementType.FIELD, ElementType.PARAMETER})
@Retention(RetentionPolicy.RUNTIME)
@Qualifier
public @interface Genre {

    String value();
}
</code></pre>
<p>使用注解</p>
<pre><code class="language-java">public class MovieRecommender {

    @Autowired
    @Genre(&quot;Action&quot;)
    private MovieCatalog actionCatalog;

    private MovieCatalog comedyCatalog;

    @Autowired
    public void setComedyCatalog(@Genre(&quot;Comedy&quot;) MovieCatalog comedyCatalog) {
        this.comedyCatalog = comedyCatalog;
    }

    // ...
}
</code></pre>
<p>可以使用短类名,或者全限定类名</p>
<pre><code class="language-xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
    xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
    xmlns:context=&quot;http://www.springframework.org/schema/context&quot;
    xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans
        https://www.springframework.org/schema/beans/spring-beans.xsd
        http://www.springframework.org/schema/context
        https://www.springframework.org/schema/context/spring-context.xsd&quot;&gt;

    &lt;context:annotation-config/&gt;

    &lt;bean class=&quot;example.SimpleMovieCatalog&quot;&gt;
        &lt;qualifier type=&quot;Genre&quot; value=&quot;Action&quot;/&gt;
        &lt;!-- inject any dependencies required by this bean --&gt;
    &lt;/bean&gt;

    &lt;bean class=&quot;example.SimpleMovieCatalog&quot;&gt;
        &lt;qualifier type=&quot;example.Genre&quot; value=&quot;Comedy&quot;/&gt;
        &lt;!-- inject any dependencies required by this bean --&gt;
    &lt;/bean&gt;

    &lt;bean id=&quot;movieRecommender&quot; class=&quot;example.MovieRecommender&quot;/&gt;

&lt;/beans&gt;
</code></pre>
<p>给qualifier添加类别,属性</p>
<pre><code class="language-java">@Target({ElementType.FIELD, ElementType.PARAMETER})
@Retention(RetentionPolicy.RUNTIME)
@Qualifier
public @interface MovieQualifier {

    String genre();

    Format format();
}
public enum Format {
    VHS, DVD, BLURAY
}
</code></pre>
<p>按照分类注入</p>
<pre><code class="language-java">public class MovieRecommender {

    @Autowired
    @MovieQualifier(format=Format.VHS, genre=&quot;Action&quot;)
    private MovieCatalog actionVhsCatalog;

    @Autowired
    @MovieQualifier(format=Format.VHS, genre=&quot;Comedy&quot;)
    private MovieCatalog comedyVhsCatalog;

    @Autowired
    @MovieQualifier(format=Format.DVD, genre=&quot;Action&quot;)
    private MovieCatalog actionDvdCatalog;

    @Autowired
    @MovieQualifier(format=Format.BLURAY, genre=&quot;Comedy&quot;)
    private MovieCatalog comedyBluRayCatalog;

    // ...
}
</code></pre>
<p>同样可以使用meta标签 简写 qualifier标签,会自动查找该qualifier的值</p>
<pre><code class="language-xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
    xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
    xmlns:context=&quot;http://www.springframework.org/schema/context&quot;
    xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans
        https://www.springframework.org/schema/beans/spring-beans.xsd
        http://www.springframework.org/schema/context
        https://www.springframework.org/schema/context/spring-context.xsd&quot;&gt;

    &lt;context:annotation-config/&gt;

    &lt;bean class=&quot;example.SimpleMovieCatalog&quot;&gt;
        &lt;qualifier type=&quot;MovieQualifier&quot;&gt;
            &lt;attribute key=&quot;format&quot; value=&quot;VHS&quot;/&gt;
            &lt;attribute key=&quot;genre&quot; value=&quot;Action&quot;/&gt;
        &lt;/qualifier&gt;
        &lt;!-- inject any dependencies required by this bean --&gt;
    &lt;/bean&gt;

    &lt;bean class=&quot;example.SimpleMovieCatalog&quot;&gt;
        &lt;qualifier type=&quot;MovieQualifier&quot;&gt;
            &lt;attribute key=&quot;format&quot; value=&quot;VHS&quot;/&gt;
            &lt;attribute key=&quot;genre&quot; value=&quot;Comedy&quot;/&gt;
        &lt;/qualifier&gt;
        &lt;!-- inject any dependencies required by this bean --&gt;
    &lt;/bean&gt;

    &lt;bean class=&quot;example.SimpleMovieCatalog&quot;&gt;
        &lt;meta key=&quot;format&quot; value=&quot;DVD&quot;/&gt;
        &lt;meta key=&quot;genre&quot; value=&quot;Action&quot;/&gt;
        &lt;!-- inject any dependencies required by this bean --&gt;
    &lt;/bean&gt;

    &lt;bean class=&quot;example.SimpleMovieCatalog&quot;&gt;
        &lt;meta key=&quot;format&quot; value=&quot;BLURAY&quot;/&gt;
        &lt;meta key=&quot;genre&quot; value=&quot;Comedy&quot;/&gt;
        &lt;!-- inject any dependencies required by this bean --&gt;
    &lt;/bean&gt;

&lt;/beans&gt;
</code></pre>
<h3 id="using-generics"><a class="header" href="#using-generics">Using Generics</a></h3>
<p>使用泛型自动注入</p>
<p>假设下面的类 实现了 某个泛型接口</p>
<pre><code class="language-j">Store&lt;String&gt;` and `Store&lt;Integer&gt;
</code></pre>
<pre><code class="language-java">@Configuration
public class MyConfiguration {

    @Bean
    public StringStore stringStore() {
        return new StringStore();
    }

    @Bean
    public IntegerStore integerStore() {
        return new IntegerStore();
    }
}


@Autowired
private Store&lt;String&gt; s1; // &lt;String&gt; qualifier, injects the stringStore bean

@Autowired
private Store&lt;Integer&gt; s2; // &lt;Integer&gt; qualifier, injects the integerStore bean
</code></pre>
<p>泛型同样支持 集合类</p>
<pre><code class="language-java">@Autowired
private List&lt;Store&lt;Integer&gt;&gt; s;
</code></pre>
<h3 id="customautowireconfigurer"><a class="header" href="#customautowireconfigurer">CustomAutowireConfigurer</a></h3>
<p><em><code>CustomAutowireConfigurer</code> 是一个 BeanFactoryPostProcessor</em>  可以让你注册自己的 qualifier</p>
<p>xml配置</p>
<pre><code class="language-xml">&lt;bean id=&quot;customAutowireConfigurer&quot;
        class=&quot;org.springframework.beans.factory.annotation.CustomAutowireConfigurer&quot;&gt;
    &lt;property name=&quot;customQualifierTypes&quot;&gt;
        &lt;set&gt;
            &lt;value&gt;example.CustomQualifier&lt;/value&gt;
        &lt;/set&gt;
    &lt;/property&gt;
&lt;/bean&gt;
</code></pre>
<p><em>AutowireCandidateResolver</em> (QualifierAnnotationAutowireCandidateResolver)选取候选者的方式</p>
<ul>
<li>autowire-candidate 每一个bean的 自动注入候选者</li>
<li>在<code>&lt;beans&gt;</code>中的 default-autowire-candidates</li>
<li>@qualifier的限定类</li>
<li>CustomAutowireConfigurer 中的候选类</li>
</ul>
<h3 id="resource"><a class="header" href="#resource">@Resource</a></h3>
<ul>
<li>如果没有指定名字 取 方法参数名或者 字段名</li>
<li>名称是由 ApplicationContext 提供查找(由CommonAnnotationBeanPostProcessor 注入)</li>
</ul>
<h3 id="value"><a class="header" href="#value">@Value</a></h3>
<p>注入外部属性</p>
<pre><code class="language-java">@Component
public class MovieRecommender {

    private final String catalog;

    public MovieRecommender(@Value(&quot;${catalog.name}&quot;) String catalog) {
        this.catalog = catalog;
    }
}

@Configuration
@PropertySource(&quot;classpath:application.properties&quot;)
public class AppConfig { }

catalog.name=MovieCatalog
</code></pre>
<p>如果想要严格控制 不存在的值可以如下申明</p>
<pre><code class="language-java">@Configuration
public class AppConfig {

     @Bean
     public static PropertySourcesPlaceholderConfigurer propertyPlaceholderConfigurer() {
           return new PropertySourcesPlaceholderConfigurer();
     }
}

</code></pre>
<ul>
<li>
<p>当配置这个JavaConfig Bean时,必须是static</p>
</li>
<li>
<p>可以设置前缀后缀 分隔符,setPlaceholderPrefix<code>, </code>setPlaceholderSuffix<code>, or </code>setValueSeparator</p>
</li>
<li>
<p><em>PropertySourcesPlaceholderConfigurer</em> springboot自动带一个,会从 application.properties<code>and</code>application.yml解析</p>
</li>
<li>
<p>值转换的过程 可以自定义ConversionService</p>
<pre><code class="language-java">@Configuration
public class AppConfig {

    @Bean
    public ConversionService conversionService() {
        DefaultFormattingConversionService conversionService = new DefaultFormattingConversionService();
        conversionService.addConverter(new MyCustomConverter());
        return conversionService;
    }
}
</code></pre>
</li>
<li>
<p>支持 EL表达式</p>
<pre><code class="language-java">@Component
public class MovieRecommender {

    private final String catalog;

    public MovieRecommender(@Value(&quot;#{systemProperties['user.catalog'] + 'Catalog' }&quot;) String catalog) {
        this.catalog = catalog;
    }
}

@Component
public class MovieRecommender {

    private final Map&lt;String, Integer&gt; countOfMoviesPerCatalog;

    public MovieRecommender(
            @Value(&quot;#{{'Thriller': 100, 'Comedy': 300}}&quot;) Map&lt;String, Integer&gt; countOfMoviesPerCatalog) {
        this.countOfMoviesPerCatalog = countOfMoviesPerCatalog;
    }
}
</code></pre>
</li>
</ul>
<h3 id="postconstruct-predestroy"><a class="header" href="#postconstruct-predestroy">@PostConstruct @PreDestroy</a></h3>
<ul>
<li>这两个注解也是 <em>CommonAnnotationBeanPostProcessor</em> 实现的</li>
<li><code>@Resource</code>, the <code>@PostConstruct</code> and <code>@PreDestroy</code>  这个在 java9被移包,在11被分离需要手动引入javax.annotation-api</li>
</ul>
<h2 id="类路径扫描容器管理"><a class="header" href="#类路径扫描容器管理">类路径扫描,容器管理</a></h2>
<h3 id="component"><a class="header" href="#component">Component</a></h3>
<p>模板注解,@Repository<code>, </code>@Service<code>, and </code>@Controller是 它的特例,目前没有什么区别,以后可能会增加区别</p>
<h3 id="使用元注解或组合注解"><a class="header" href="#使用元注解或组合注解">使用元注解或组合注解</a></h3>
<p>元注解</p>
<pre><code class="language-java">@Target(ElementType.TYPE)
@Retention(RetentionPolicy.RUNTIME)
@Documented
@Component 
public @interface Service {

    // ...
}

Component 导致 service 跟 component同样对待
</code></pre>
<p>组合注解</p>
<p>@RestController等价于 @Controller<code>and</code>@ResponseBody</p>
<p>元注解可以重新申明 属性自定义属性的值</p>
<pre><code class="language-java">@Target({ElementType.TYPE, ElementType.METHOD})
@Retention(RetentionPolicy.RUNTIME)
@Documented
@Scope(WebApplicationContext.SCOPE_SESSION)
public @interface SessionScope {

    /**
     * Alias for {@link Scope#proxyMode}.
     * &lt;p&gt;Defaults to {@link ScopedProxyMode#TARGET_CLASS}.
     */
    @AliasFor(annotation = Scope.class)
    ScopedProxyMode proxyMode() default ScopedProxyMode.TARGET_CLASS;

}

@Service
@SessionScope
public class SessionScopedService {
    // ...
}
</code></pre>
<h3 id="自动注册bean定义"><a class="header" href="#自动注册bean定义">自动注册bean定义</a></h3>
<p>spring会自动注册带有 模板注解component的类,并生成相应的bean定义 在applicationContext中</p>
<pre><code class="language-java">@Service
public class SimpleMovieLister {

    private MovieFinder movieFinder;

    public SimpleMovieLister(MovieFinder movieFinder) {
        this.movieFinder = movieFinder;
    }
}
</code></pre>
<p>为了自动注册上面的类型必须 要在 带有 @Configuration的 类中 申明 ,包扫描,包之间可以用 空格, 逗号,冒号</p>
<pre><code class="language-java">@Configuration
@ComponentScan(basePackages = &quot;org.example&quot;)
public class AppConfig  {
    // ...
}

//@ComponentScan(&quot;org.example&quot;)简写形式

//xml 形式
 &lt;context:component-scan base-package=&quot;org.example&quot;/&gt;
 它会激活 &lt;context:annotation-config&gt;注解
</code></pre>
<p>使用Ant编译工程时, you do not activate the files-only switch of the JAR task</p>
<p>同时 AutowiredAnnotationBeanPostProcessor<code>and</code>CommonAnnotationBeanPostProcessor这两个beanPostProcessor也会被注册</p>
<pre><code>You can disable the registration of AutowiredAnnotationBeanPostProcessor and CommonAnnotationBeanPostProcessor by including the annotation-config attribute with a value of false.
</code></pre>
<h3 id="使用过滤器-自定义扫描"><a class="header" href="#使用过滤器-自定义扫描">使用过滤器 自定义扫描</a></h3>
<ul>
<li>
<p>'@Component<code>, </code>@Repository<code>, </code>@Service<code>, </code>@Controller<code>, </code>@Configuration'默认只扫描带有这些注解的类 </p>
</li>
<li>
<p>通过ComponentScan的 includeFilters ,excludeFilters 属性 设定不同类型的过滤器去 取 或者排除 相应的类</p>
</li>
<li>
<p>过滤器的类型</p>
<div class="table-wrapper"><table><thead><tr><th style="text-align: left">ilter Type</th><th style="text-align: left">Example Expression</th><th style="text-align: left">Description</th></tr></thead><tbody>
<tr><td style="text-align: left">annotation (default)</td><td style="text-align: left"><code>org.example.SomeAnnotation</code></td><td style="text-align: left">指定  注释类上或者元类上的注解类</td></tr>
<tr><td style="text-align: left">assignable</td><td style="text-align: left"><code>org.example.SomeClass</code></td><td style="text-align: left">A class (or interface) that the target components are assignable to (extend or implement).</td></tr>
<tr><td style="text-align: left">aspectj</td><td style="text-align: left"><code>org.example..*Service+</code></td><td style="text-align: left">使用 aspectj注入语法</td></tr>
<tr><td style="text-align: left">regex</td><td style="text-align: left"><code>org\.example\.Default.*</code></td><td style="text-align: left">使用正则匹配类全限定名</td></tr>
<tr><td style="text-align: left">custom</td><td style="text-align: left"><code>org.example.MyTypeFilter</code></td><td style="text-align: left">A custom implementation of the <code>org.springframework.core.type.TypeFilter</code> interface.</td></tr>
</tbody></table>
</div></li>
<li>
<p>使用</p>
<pre><code class="language-java">@Configuration
@ComponentScan(basePackages = &quot;org.example&quot;,
        includeFilters = @Filter(type = FilterType.REGEX, pattern = &quot;.*Stub.*Repository&quot;),
        excludeFilters = @Filter(Repository.class))
public class AppConfig {
    ...
}
</code></pre>
<pre><code class="language-xml">&lt;beans&gt;
    &lt;context:component-scan base-package=&quot;org.example&quot;&gt;
        &lt;context:include-filter type=&quot;regex&quot;
                expression=&quot;.*Stub.*Repository&quot;/&gt;
        &lt;context:exclude-filter type=&quot;annotation&quot;
                expression=&quot;org.springframework.stereotype.Repository&quot;/&gt;
    &lt;/context:component-scan&gt;
&lt;/beans&gt;

</code></pre>
</li>
<li>
<p>'useDefaultFilters=false use-default-filters=&quot;false&quot;' 可以使得系统不会自动 <em><code>@Component</code>, <code>@Repository</code>, <code>@Service</code>, <code>@Controller</code>, <code>@RestController</code>, or <code>@Configuration</code>.</em> 扫描这些注解</p>
</li>
</ul>
<h3 id="使用component定义元数据"><a class="header" href="#使用component定义元数据">使用component定义元数据</a></h3>
<ul>
<li>可以使用component定义元数据</li>
<li>方法级别的bean定义,类似于 提供一个工厂方法</li>
</ul>
<pre><code class="language-java">@Component
public class FactoryMethodComponent {

    @Bean
    @Qualifier(&quot;public&quot;)
    public TestBean publicInstance() {
        return new TestBean(&quot;publicInstance&quot;);
    }

    public void doWork() {
        // Component method implementation omitted
    }
}
</code></pre>
<pre><code class="language-java">@Component
public class FactoryMethodComponent {

    private static int i;

    @Bean
    @Qualifier(&quot;public&quot;)
    public TestBean publicInstance() {
        return new TestBean(&quot;publicInstance&quot;);
    }

    // use of a custom qualifier and autowiring of method parameters
    @Bean
    protected TestBean protectedInstance(
            @Qualifier(&quot;public&quot;) TestBean spouse,
            @Value(&quot;#{privateInstance.age}&quot;) String country) {
        TestBean tb = new TestBean(&quot;protectedInstance&quot;, 1);
        tb.setSpouse(spouse);
        tb.setCountry(country);
        return tb;
    }

    @Bean
    private TestBean privateInstance() {
        return new TestBean(&quot;privateInstance&quot;, i++);
    }

    @Bean
    @RequestScope
    public TestBean requestScopedInstance() {
        return new TestBean(&quot;requestScopedInstance&quot;, 3);
    }
}
</code></pre>
<pre><code class="language-java">@Component
public class FactoryMethodComponent {

    @Bean @Scope(&quot;prototype&quot;)
    public TestBean prototypeInstance(InjectionPoint injectionPoint) {
        return new TestBean(&quot;prototypeInstance for &quot; + injectionPoint.getMember());
    }
}
</code></pre>
<p>As of Spring Framework 4.3,可以使用 InjectionPoint(DependencyDescriptor更详细的子类) 可以访问到请求注入点,当然这适用于 原型作用域,</p>
<ul>
<li>在普通 component的 @bean与 @configuration的@Bean不同
<ul>
<li>configuration 中 cglib会对其增强, 通过 代理@bean方法的调用来创建元数据引用</li>
<li>component 下的@bean是正常的java语义</li>
<li>由于CGLIB需要继承 该类,所以@bean方法不能是final和 private,可以设置成 static,这样避免spring拦截</li>
</ul>
</li>
</ul>
<h3 id="componet自动命名"><a class="header" href="#componet自动命名">componet自动命名</a></h3>
<ul>
<li>自动命名取 短类名</li>
<li>如果命名重复  <a href="https://docs.spring.io/spring-framework/docs/5.2.7.RELEASE/javadoc-api/org/springframework/beans/factory/support/BeanNameGenerator.html"><code>BeanNameGenerator</code></a> 可以注册这个类实现自定义自动命名它的子类为,FullyQualifiedAnnotationBeanNameGenerator</li>
</ul>
<pre><code class="language-java">@Configuration
@ComponentScan(basePackages = &quot;org.example&quot;, nameGenerator = MyNameGenerator.class)
public class AppConfig {
    // ...
}
</code></pre>
<pre><code class="language-xml">&lt;beans&gt;
    &lt;context:component-scan base-package=&quot;org.example&quot;
        name-generator=&quot;org.example.MyNameGenerator&quot; /&gt;
&lt;/beans&gt;
</code></pre>
<h3 id="component设置作用域"><a class="header" href="#component设置作用域">component设置作用域</a></h3>
<pre><code class="language-java">@Scope(&quot;prototype&quot;)
@Repository
public class MovieFinderImpl implements MovieFinder {
    // ...
}
</code></pre>
<p>扫描特定作用域</p>
<p>实现 <a href="https://docs.spring.io/spring-framework/docs/5.2.7.RELEASE/javadoc-api/org/springframework/context/annotation/ScopeMetadataResolver.html"><code>ScopeMetadataResolver</code></a> </p>
<pre><code class="language-java">@Configuration
@ComponentScan(basePackages = &quot;org.example&quot;, scopeResolver = MyScopeResolver.class)
public class AppConfig {
    // ...
}
</code></pre>
<p>扫描特定 作用域代理方式</p>
<pre><code class="language-java">@Configuration
@ComponentScan(basePackages = &quot;org.example&quot;, scopedProxy = ScopedProxyMode.INTERFACES)
public class AppConfig {
    // ...
}
</code></pre>
<h3 id="qualifier标注component"><a class="header" href="#qualifier标注component">Qualifier标注Component</a></h3>
<pre><code class="language-java">@Component
@Qualifier(&quot;Action&quot;)
public class ActionMovieCatalog implements MovieCatalog {
    // ...
}
</code></pre>
<h3 id="产生候选组件索引"><a class="header" href="#产生候选组件索引">产生候选组件索引</a></h3>
<pre><code class="language-xml">&lt;dependencies&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;org.springframework&lt;/groupId&gt;
        &lt;artifactId&gt;spring-context-indexer&lt;/artifactId&gt;
        &lt;version&gt;5.2.7.RELEASE&lt;/version&gt;
        &lt;optional&gt;true&lt;/optional&gt;
    &lt;/dependency&gt;
&lt;/dependencies&gt;
</code></pre>
<p>在编译期产生 候选者的索引,可以避免在类路径扫描,提升查找速度</p>
<pre><code class="language-kotlin">dependencies {
    compileOnly &quot;org.springframework:spring-context-indexer:5.2.7.RELEASE&quot;
}
</code></pre>
<ul>
<li>会产生  META-INF/spring.components 文件</li>
<li>spring-context-indexer必须要注册到容器中来</li>
<li>如果类路径下 META-INF/spring.components 有这个文件,且有相关依赖,则该特性会被激活,spring.index.ignore可以关闭</li>
</ul>
<h2 id="使用jsr330标准注解"><a class="header" href="#使用jsr330标准注解">使用JSR330标准注解</a></h2>
<ul>
<li>
<p>需要引入</p>
<pre><code class="language-xml">&lt;dependency&gt;
    &lt;groupId&gt;javax.inject&lt;/groupId&gt;
    &lt;artifactId&gt;javax.inject&lt;/artifactId&gt;
    &lt;version&gt;1&lt;/version&gt;
&lt;/dependency&gt;
</code></pre>
</li>
</ul>
<h3 id="依赖注入injectnamed"><a class="header" href="#依赖注入injectnamed">依赖注入:Inject,Named</a></h3>
<pre><code class="language-java">import javax.inject.Inject;

public class SimpleMovieLister {

    private MovieFinder movieFinder;

    @Inject
    public void setMovieFinder(MovieFinder movieFinder) {
        this.movieFinder = movieFinder;
    }

    public void listMovies() {
        this.movieFinder.findMovies(...);
        // ...
    }
}
</code></pre>
<h3 id="provider注入"><a class="header" href="#provider注入">provider注入</a></h3>
<p>可以注入 Provider包装的类, 提供懒加载,按需加载</p>
<pre><code class="language-java">import javax.inject.Inject;
import javax.inject.Provider;

public class SimpleMovieLister {

    private Provider&lt;MovieFinder&gt; movieFinder;

    @Inject
    public void setMovieFinder(Provider&lt;MovieFinder&gt; movieFinder) {
        this.movieFinder = movieFinder;
    }

    public void listMovies() {
        this.movieFinder.get().findMovies(...);
        // ...
    }
}
</code></pre>
<h3 id="optional注入"><a class="header" href="#optional注入">Optional注入</a></h3>
<p>注入Optional 包装类,或者使用@nullable</p>
<pre><code class="language-jav">public class SimpleMovieLister {

    @Inject
    public void setMovieFinder(Optional&lt;MovieFinder&gt; movieFinder) {
        // ...
    }
}
</code></pre>
<h3 id="named注入"><a class="header" href="#named注入">named注入</a></h3>
<p>名称注入named</p>
<pre><code class="language-java">import javax.inject.Inject;
import javax.inject.Named;

public class SimpleMovieLister {

    private MovieFinder movieFinder;

    @Inject
    public void setMovieFinder(@Named(&quot;main&quot;) MovieFinder movieFinder) {
        this.movieFinder = movieFinder;
    }

    // ...
}
</code></pre>
<h3 id="namedmanagedbean"><a class="header" href="#namedmanagedbean">@named,@ManagedBean</a></h3>
<p>与Component相同的 @named,@ManagedBean,二者不可组合</p>
<pre><code class="language-java">import javax.inject.Inject;
import javax.inject.Named;

@Named(&quot;movieListener&quot;)  // @ManagedBean(&quot;movieListener&quot;) could be used as well
public class SimpleMovieLister {

    private MovieFinder movieFinder;

    @Inject
    public void setMovieFinder(MovieFinder movieFinder) {
        this.movieFinder = movieFinder;
    }

    // ...
}

import javax.inject.Inject;
import javax.inject.Named;

@Named
public class SimpleMovieLister {

    private MovieFinder movieFinder;

    @Inject
    public void setMovieFinder(MovieFinder movieFinder) {
        this.movieFinder = movieFinder;
    }

    // ...
}
</code></pre>
<h3 id="jsr330注解限制"><a class="header" href="#jsr330注解限制">JSR330注解限制</a></h3>
<div class="table-wrapper"><table><thead><tr><th style="text-align: left">Spring</th><th style="text-align: left">javax.inject.*</th><th style="text-align: left">javax.inject restrictions / comments</th></tr></thead><tbody>
<tr><td style="text-align: left">@Autowired</td><td style="text-align: left">@Inject</td><td style="text-align: left"><code>@Inject</code> has no 'required' attribute. Can be used with Java 8’s <code>Optional</code> instead.</td></tr>
<tr><td style="text-align: left">@Component</td><td style="text-align: left">@Named / @ManagedBean</td><td style="text-align: left">JSR-330 does not provide a composable model, only a way to identify named components.</td></tr>
<tr><td style="text-align: left">@Scope(&quot;singleton&quot;)</td><td style="text-align: left">@Singleton</td><td style="text-align: left">The JSR-330 default scope is like Spring’s <code>prototype</code>. However, in order to keep it consistent with Spring’s general defaults, a JSR-330 bean declared in the Spring container is a <code>singleton</code> by default. In order to use a scope other than <code>singleton</code>, you should use Spring’s <code>@Scope</code> annotation. <code>javax.inject</code> also provides a <a href="https://download.oracle.com/javaee/6/api/javax/inject/Scope.html">@Scope</a> annotation. Nevertheless, this one is only intended to be used for creating your own annotations.</td></tr>
<tr><td style="text-align: left">@Qualifier</td><td style="text-align: left">@Qualifier / @Named</td><td style="text-align: left"><code>javax.inject.Qualifier</code> is just a meta-annotation for building custom qualifiers. Concrete <code>String</code> qualifiers (like Spring’s <code>@Qualifier</code> with a value) can be associated through <code>javax.inject.Named</code>.</td></tr>
<tr><td style="text-align: left">@Value</td><td style="text-align: left">-</td><td style="text-align: left">no equivalent</td></tr>
<tr><td style="text-align: left">@Required</td><td style="text-align: left">-</td><td style="text-align: left">no equivalent</td></tr>
<tr><td style="text-align: left">@Lazy</td><td style="text-align: left">-</td><td style="text-align: left">no equivalent</td></tr>
<tr><td style="text-align: left">ObjectFactory</td><td style="text-align: left">Provider</td><td style="text-align: left"><code>javax.inject.Provider</code> is a direct alternative to Spring’s <code>ObjectFactory</code>, only with a shorter <code>get()</code> method name. It can also be used in combination with Spring’s <code>@Autowired</code> or with non-annotated constructors and setter methods.</td></tr>
</tbody></table>
</div>
<h2 id="基于java的注解"><a class="header" href="#基于java的注解">基于Java的注解.</a></h2>
<h3 id="实例化-注解配置容器"><a class="header" href="#实例化-注解配置容器">实例化 注解配置容器</a></h3>
<p><code>AnnotationConfigApplicationContext</code> </p>
<ul>
<li>这个通用的applicationContext可以接受@configuration的配置,也可以接受@Component的注解</li>
<li>带有@configuration注解的类被解析成 bean定义,@bean也会被解析成bean定义</li>
</ul>
<p>实例化</p>
<pre><code class="language-java">public static void main(String[] args) {
    ApplicationContext ctx = new AnnotationConfigApplicationContext(AppConfig.class);
    MyService myService = ctx.getBean(MyService.class);
    myService.doStuff();
}

public static void main(String[] args) {
    ApplicationContext ctx = new AnnotationConfigApplicationContext(MyServiceImpl.class, Dependency1.class, Dependency2.class);
    MyService myService = ctx.getBean(MyService.class);
    myService.doStuff();
}
</code></pre>
<p>编程方式实例化</p>
<pre><code class="language-java">public static void main(String[] args) {
    AnnotationConfigApplicationContext ctx = new AnnotationConfigApplicationContext();
    ctx.register(AppConfig.class, OtherConfig.class);
    ctx.register(AdditionalConfig.class);
    ctx.refresh();
    MyService myService = ctx.getBean(MyService.class);
    myService.doStuff();
}
</code></pre>
<p>扫描</p>
<pre><code class="language-java">public static void main(String[] args) {
    AnnotationConfigApplicationContext ctx = new AnnotationConfigApplicationContext();
    ctx.scan(&quot;com.acme&quot;);
    ctx.refresh();
    MyService myService = ctx.getBean(MyService.class);
}

@Configuration
@ComponentScan(basePackages = &quot;com.acme&quot;) 
public class AppConfig  {
    ...
}
</code></pre>
<p>web应用 <code>AnnotationConfigWebApplicationContext</code></p>
<ul>
<li>'WebApplicationContext'的变体 <code>AnnotationConfigWebApplicationContext</code> 来配置spring的 ContextLoaderListener servlet</li>
<li>Spring MVC <code>DispatcherServlet</code></li>
</ul>
<pre><code class="language-xml">&lt;web-app&gt;
    &lt;!-- Configure ContextLoaderListener to use AnnotationConfigWebApplicationContext
        instead of the default XmlWebApplicationContext --&gt;
    &lt;context-param&gt;
        &lt;param-name&gt;contextClass&lt;/param-name&gt;
        &lt;param-value&gt;
            org.springframework.web.context.support.AnnotationConfigWebApplicationContext
        &lt;/param-value&gt;
    &lt;/context-param&gt;

    &lt;!-- Configuration locations must consist of one or more comma- or space-delimited
        fully-qualified @Configuration classes. Fully-qualified packages may also be
        specified for component-scanning --&gt;
    &lt;context-param&gt;
        &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt;
        &lt;param-value&gt;com.acme.AppConfig&lt;/param-value&gt;
    &lt;/context-param&gt;

    &lt;!-- Bootstrap the root application context as usual using ContextLoaderListener --&gt;
    &lt;listener&gt;
        &lt;listener-class&gt;org.springframework.web.context.ContextLoaderListener&lt;/listener-class&gt;
    &lt;/listener&gt;

    &lt;!-- Declare a Spring MVC DispatcherServlet as usual --&gt;
    &lt;servlet&gt;
        &lt;servlet-name&gt;dispatcher&lt;/servlet-name&gt;
        &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt;
        &lt;!-- Configure DispatcherServlet to use AnnotationConfigWebApplicationContext
            instead of the default XmlWebApplicationContext --&gt;
        &lt;init-param&gt;
            &lt;param-name&gt;contextClass&lt;/param-name&gt;
            &lt;param-value&gt;
                org.springframework.web.context.support.AnnotationConfigWebApplicationContext
            &lt;/param-value&gt;
        &lt;/init-param&gt;
        &lt;!-- Again, config locations must consist of one or more comma- or space-delimited
            and fully-qualified @Configuration classes --&gt;
        &lt;init-param&gt;
            &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt;
            &lt;param-value&gt;com.acme.web.MvcConfig&lt;/param-value&gt;
        &lt;/init-param&gt;
    &lt;/servlet&gt;

    &lt;!-- map all requests for /app/* to the dispatcher servlet --&gt;
    &lt;servlet-mapping&gt;
        &lt;servlet-name&gt;dispatcher&lt;/servlet-name&gt;
        &lt;url-pattern&gt;/app/*&lt;/url-pattern&gt;
    &lt;/servlet-mapping&gt;
&lt;/web-app&gt;
</code></pre>
<h3 id="bean注解"><a class="header" href="#bean注解">@Bean注解</a></h3>
<h4 id="生命周期回调-1"><a class="header" href="#生命周期回调-1">生命周期回调</a></h4>
<ul>
<li>
<p>'@PostConstruct<code>and</code>@PreDestroy' 构造器调用完后,setter注入前,  销毁前</p>
</li>
<li>
<p>支持 spring常规的 回调'InitializingBean<code>, </code>DisposableBean<code>, or </code>Lifecycle' </p>
</li>
<li>
<p><code>*Aware</code> interfaces 注入接口回调</p>
</li>
<li>
<p>支持 init-method<code>and</code>destroy-method 属性</p>
</li>
<li>
<p>关闭生命周期回调</p>
<pre><code class="language-java">@Bean(destroyMethod=&quot;&quot;)
public DataSource dataSource() throws NamingException {
    return (DataSource) jndiTemplate.lookup(&quot;MyDS&quot;);
}
</code></pre>
</li>
</ul>
<h4 id="指定scope域"><a class="header" href="#指定scope域">指定scope域</a></h4>
<pre><code class="language-java">// an HTTP Session-scoped bean exposed as a proxy
@Bean
@SessionScope
public UserPreferences userPreferences() {
    return new UserPreferences();
}

@Bean
public Service userService() {
    UserService service = new SimpleUserService();
    // a reference to the proxied userPreferences bean
    service.setUserPreferences(userPreferences());
    return service;
}
</code></pre>
<h4 id="bean别名-1"><a class="header" href="#bean别名-1">bean别名</a></h4>
<pre><code class="language-java">@Configuration
public class AppConfig {

    @Bean({&quot;dataSource&quot;, &quot;subsystemA-dataSource&quot;, &quot;subsystemB-dataSource&quot;})
    public DataSource dataSource() {
        // instantiate, configure and return DataSource bean...
    }
}
</code></pre>
<h4 id="bean描述"><a class="header" href="#bean描述">bean描述</a></h4>
<pre><code class="language-java">@Configuration
public class AppConfig {

    @Bean
    @Description(&quot;Provides a basic example of a bean&quot;)
    public Thing thing() {
        return new Thing();
    }
}
</code></pre>
<h3 id="import"><a class="header" href="#import">@import</a></h3>
<pre><code class="language-java">@Configuration
public class ConfigA {

    @Bean
    public A a() {
        return new A();
    }
}

@Configuration
@Import(ConfigA.class)
public class ConfigB {

    @Bean
    public B b() {
        return new B();
    }
}


public static void main(String[] args) {
    ApplicationContext ctx = new AnnotationConfigApplicationContext(ConfigB.class);

    // now both beans A and B will be available...
    A a = ctx.getBean(A.class);
    B b = ctx.getBean(B.class);
}
</code></pre>
<p>这样只用引入 ConfigB就可以同时引入ConfigA</p>
<h3 id="条件性的包含bean"><a class="header" href="#条件性的包含bean">条件性的包含bean</a></h3>
<p><a href="https://docs.spring.io/spring-framework/docs/5.2.7.RELEASE/javadoc-api/org/springframework/context/annotation/Conditional.html"><code>@Conditional</code></a>.</p>
<p>实现Conditional接口</p>
<p>@Profile的实现</p>
<pre><code class="language-java">@Override
public boolean matches(ConditionContext context, AnnotatedTypeMetadata metadata) {
    // Read the @Profile annotation attributes
    MultiValueMap&lt;String, Object&gt; attrs = metadata.getAllAnnotationAttributes(Profile.class.getName());
    if (attrs != null) {
        for (Object value : attrs.get(&quot;value&quot;)) {
            if (context.getEnvironment().acceptsProfiles(((String[]) value))) {
                return true;
            }
        }
        return false;
    }
    return true;
}
</code></pre>
<p>Condition接口</p>
<pre><code class="language-java">boolean matches(ConditionContext context, AnnotatedTypeMetadata metadata);
</code></pre>
<h3 id="java配置与xml配置结合"><a class="header" href="#java配置与xml配置结合">Java配置与XML配置结合</a></h3>
<ul>
<li>以Java为中心的配置 AnnotationConfigApplicationContext and the  @ImportResource 导入xml</li>
</ul>
<pre><code class="language-javascript">@Configuration
@ImportResource(&quot;classpath:/com/acme/properties-config.xml&quot;)
public class AppConfig {

    @Value(&quot;${jdbc.url}&quot;)
    private String url;

    @Value(&quot;${jdbc.username}&quot;)
    private String username;

    @Value(&quot;${jdbc.password}&quot;)
    private String password;

    @Bean
    public DataSource dataSource() {
        return new DriverManagerDataSource(url, username, password);
    }
}
</code></pre>
<h2 id="环境抽象"><a class="header" href="#环境抽象">环境抽象</a></h2>
<p>spring对环境的抽象建模 主要是 两块: properties 和 profile</p>
<ul>
<li>
<p>profile的含义是 条件选择</p>
</li>
<li>
<p>properties (包括配置文件,系统属性,系统环境变量,JNDI,servletContext参数,等等)</p>
</li>
</ul>
<h3 id="profile"><a class="header" href="#profile">profile</a></h3>
<pre><code class="language-java">@Configuration
@Profile(&quot;development&quot;)
public class StandaloneDataConfig {

    @Bean
    public DataSource dataSource() {
        return new EmbeddedDatabaseBuilder()
            .setType(EmbeddedDatabaseType.HSQL)
            .addScript(&quot;classpath:com/bank/config/sql/schema.sql&quot;)
            .addScript(&quot;classpath:com/bank/config/sql/test-data.sql&quot;)
            .build();
    }
}
</code></pre>
<p>profile名称支持 如下语法</p>
<ul>
<li><code>!</code>: A logical “not” of the profile</li>
<li><code>&amp;</code>: A logical “and” of the profiles</li>
<li><code>|</code>: A logical “or” of the profiles</li>
</ul>
<p>可以自定义注解</p>
<pre><code class="language-java">@Target(ElementType.TYPE)
@Retention(RetentionPolicy.RUNTIME)
@Profile(&quot;production&quot;)
public @interface Production {
}
</code></pre>
<p>@Profile({&quot;p1&quot;, &quot;!p2&quot;}) {} 标识 或逻辑</p>
<p>基于xml的配置</p>
<pre><code class="language-xml">&lt;beans profile=&quot;development&quot;
    xmlns=&quot;http://www.springframework.org/schema/beans&quot;
    xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
    xmlns:jdbc=&quot;http://www.springframework.org/schema/jdbc&quot;
    xsi:schemaLocation=&quot;...&quot;&gt;

    &lt;jdbc:embedded-database id=&quot;dataSource&quot;&gt;
        &lt;jdbc:script location=&quot;classpath:com/bank/config/sql/schema.sql&quot;/&gt;
        &lt;jdbc:script location=&quot;classpath:com/bank/config/sql/test-data.sql&quot;/&gt;
    &lt;/jdbc:embedded-database&gt;
&lt;/beans&gt;

&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
    xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
    xmlns:jdbc=&quot;http://www.springframework.org/schema/jdbc&quot;
    xmlns:jee=&quot;http://www.springframework.org/schema/jee&quot;
    xsi:schemaLocation=&quot;...&quot;&gt;

    &lt;!-- other bean definitions --&gt;

    &lt;beans profile=&quot;development&quot;&gt;
        &lt;jdbc:embedded-database id=&quot;dataSource&quot;&gt;
            &lt;jdbc:script location=&quot;classpath:com/bank/config/sql/schema.sql&quot;/&gt;
            &lt;jdbc:script location=&quot;classpath:com/bank/config/sql/test-data.sql&quot;/&gt;
        &lt;/jdbc:embedded-database&gt;
    &lt;/beans&gt;

    &lt;beans profile=&quot;production&quot;&gt;
        &lt;jee:jndi-lookup id=&quot;dataSource&quot; jndi-name=&quot;java:comp/env/jdbc/datasource&quot;/&gt;
    &lt;/beans&gt;
&lt;/beans&gt;
</code></pre>
<h3 id="激活profile"><a class="header" href="#激活profile">激活profile</a></h3>
<p>通过编程的方式 ,使用Environment接口 通过容器</p>
<pre><code class="language-java">AnnotationConfigApplicationContext ctx = new AnnotationConfigApplicationContext();
ctx.getEnvironment().setActiveProfiles(&quot;development&quot;);
ctx.register(SomeConfig.class, StandaloneDataConfig.class, JndiDataConfig.class);
ctx.refresh();
</code></pre>
<p>使用注解 @ActiveProfiles</p>
<p>使用变量名spring.profiles.active</p>
<pre><code>  -Dspring.profiles.active=&quot;profile1,profile2&quot;
</code></pre>
<p>spring.profiles.default设置默认环境变量</p>
<pre><code class="language-java">@Configuration
@Profile(&quot;default&quot;)
public class DefaultDataConfig {

    @Bean
    public DataSource dataSource() {
        return new EmbeddedDatabaseBuilder()
            .setType(EmbeddedDatabaseType.HSQL)
            .addScript(&quot;classpath:com/bank/config/sql/schema.sql&quot;)
            .build();
    }
}
</code></pre>
<h3 id="propertiessource"><a class="header" href="#propertiessource">PropertiesSource</a></h3>
<ul>
<li>
<p>propertiesSource是 spring对环境变量的抽象,基于键值对的抽象</p>
</li>
<li>
<p>standardEnvironment 是包含两个 properties Source </p>
<ul>
<li>JVM system properties (<code>System.getProperties()</code></li>
<li>system environment variables (<code>System.getenv()</code>).</li>
</ul>
</li>
<li>
<p>StandardServletEnvrionment 包含 servletconfig,servletContext参数,可选的JNDIPropertySource</p>
</li>
<li>
<p>环境变量的查找有层级优先级,以StandardServletEnvrionment 为例</p>
<ul>
<li>ServletConfig parameters (if applicable — for example, in case of a <code>DispatcherServlet</code> context)</li>
<li>ServletContext parameters (web.xml context-param entries)</li>
<li>JNDI environment variables (<code>java:comp/env/</code> entries)</li>
<li>JVM system properties (<code>-D</code> command-line arguments)</li>
<li>JVM system environment (operating system environment variables)</li>
</ul>
</li>
<li>
<p>以上查找机制是可配的,可自定义</p>
<pre><code class="language-java">ConfigurableApplicationContext ctx = new GenericApplicationContext();
MutablePropertySources sources = ctx.getEnvironment().getPropertySources();
sources.addFirst(new MyPropertySource());
</code></pre>
<p>经过以上配置,可以注册自定义的MypropertySource 并且由先先级是最高</p>
</li>
</ul>
<h3 id="propertysource"><a class="header" href="#propertysource">@PropertySource</a></h3>
<pre><code class="language-java">@Configuration
@PropertySource(&quot;classpath:/com/myco/app.properties&quot;)
public class AppConfig {

    @Autowired
    Environment env;

    @Bean
    public TestBean testBean() {
        TestBean testBean = new TestBean();
        testBean.setName(env.getProperty(&quot;testbean.name&quot;));
        return testBean;
    }
}
</code></pre>
<pre><code class="language-java">@Configuration
@PropertySource(&quot;classpath:/com/${my.placeholder:default/path}/app.properties&quot;)
public class AppConfig {

    @Autowired
    Environment env;

    @Bean
    public TestBean testBean() {
        TestBean testBean = new TestBean();
        testBean.setName(env.getProperty(&quot;testbean.name&quot;));
        return testBean;
    }
}
</code></pre>
<p>my.placeholder是其他已经定义过的 属性,default/path是找不到数据源使用默认的属性</p>
<h3 id="占位符解析"><a class="header" href="#占位符解析">占位符解析</a></h3>
<p>环境变量贯穿整个容器,只要在定义之前这个变量已经被注册进去就可以</p>
<pre><code class="language-xml">&lt;beans&gt;
    &lt;import resource=&quot;com/bank/service/${customer}-config.xml&quot;/&gt;
&lt;/beans&gt;
</code></pre>
<h2 id="registering-a-loadtimeweaver"><a class="header" href="#registering-a-loadtimeweaver">Registering a LoadTimeWeaver</a></h2>
<p>当类被装载进虚拟机时,动态的转换类</p>
<pre><code class="language-java">@Configuration
@EnableLoadTimeWeaving
public class AppConfig {
}
</code></pre>
<pre><code class="language-xml">&lt;beans&gt;
    &lt;context:load-time-weaver/&gt;
&lt;/beans&gt;
</code></pre>
<h2 id="applicationcontext额外的功能"><a class="header" href="#applicationcontext额外的功能">ApplicationContext额外的功能</a></h2>
<ul>
<li><em>org.springframework.beans.factory</em> 提供基本的管理和维护bean的功能,org.springframework.context 添加了<a href="https://docs.spring.io/spring-framework/docs/5.2.7.RELEASE/javadoc-api/org/springframework/context/ApplicationContext.html"><code>ApplicationContext</code></a>接口不仅扩展了beanFactory接口,也提供了其他功能</li>
<li>大部分应用程序以声明的方式 使用ApplicationContext,例如依赖 ContextLoader的类 </li>
<li>额外的功能如下
<ul>
<li><em>i18n</em> 风格的 消息访问,  MessageSource</li>
<li>访问URL资源: ResourceLoader</li>
<li>时间发布: ApplicationListener,ApplicationEventPublisher</li>
<li>带有层次接口的多上下文,每个applicationContext只关注特定的层, 例如web层, 通过 HierarchicalBeanFactory接口</li>
</ul>
</li>
</ul>
<h3 id="使用-messagesource-国际化"><a class="header" href="#使用-messagesource-国际化">使用 <code>MessageSource</code> 国际化</a></h3>
<pre><code class="language-java">String getMessage(String code, @Nullable Object[] args, @Nullable String defaultMessage, Locale locale);
</code></pre>
<p>根据Loclae,  code对应的 带参数的message</p>
<ol>
<li>
<p>applicationContext首先会查找当前容器中有没有 messageSource的bean名</p>
</li>
<li>
<p>如果找到了则使用该 bean作为 消息源</p>
</li>
<li>
<p>如果没找到 则往父 bean找,如果还是找不到则 在 messageSource代理类 <em>DelegatingMessageSource</em> 设置空的source</p>
</li>
<li>
<p>spring提供了 两个 messageSource</p>
<ol>
<li>
<p><em>ResourceBundleMessageSource</em></p>
</li>
<li>
<p><em>StaticMessageSource</em></p>
</li>
<li>
<p>都继承于HierarchicalMessageSource(为了处理 嵌套的消息)</p>
</li>
<li>
<p>名称要覆盖messageSource</p>
</li>
<li>
<p>basename,即资源包的名称,会默认去类路径下查找:  classpath:basename.properties, basename-en.properties,等不同地域的文件</p>
</li>
</ol>
</li>
</ol>
<pre><code>    @Bean(&quot;messageSource&quot;)
    public  ResourceBundleMessageSource resourceBundleMessageSource(){
        ResourceBundleMessageSource resourceBundleMessageSource = new ResourceBundleMessageSource();
        resourceBundleMessageSource.setAlwaysUseMessageFormat(true);
        resourceBundleMessageSource.setBasenames(&quot;format&quot;,&quot;exceptions&quot;,&quot;windows&quot;,&quot;messages&quot;);
        return resourceBundleMessageSource;
    }
    
</code></pre>
<ul>
<li>还有可重载的 <em>ResourceBundleMessageSource</em> : ReloadableResourceBundleMessageSource
<ul>
<li>允许从spring 任意的 location 加载文件</li>
<li>支持热加载</li>
</ul>
</li>
</ul>
<h3 id="标准事件和自定义事件"><a class="header" href="#标准事件和自定义事件">标准事件和自定义事件</a></h3>
<h4 id="spring提供的内置事件"><a class="header" href="#spring提供的内置事件">spring提供的内置事件</a></h4>
<div class="table-wrapper"><table><thead><tr><th style="text-align: left">Event</th><th style="text-align: left">Explanation</th></tr></thead><tbody>
<tr><td style="text-align: left"><code>ContextRefreshedEvent</code></td><td style="text-align: left">1. 当<code>ApplicationContext</code>被初始化或者被刷新时(例如调用`refresh) 2. 在容器关闭前,context可以被刷新任意次</td></tr>
<tr><td style="text-align: left"><code>ContextStartedEvent</code></td><td style="text-align: left">Published when the <code>ApplicationContext</code> is started by using the <code>start()</code> method on the <code>ConfigurableApplicationContext</code> interface</td></tr>
<tr><td style="text-align: left"><code>ContextStoppedEvent</code></td><td style="text-align: left">Published when the <code>ApplicationContext</code> is stopped by using the <code>stop()</code> method on the <code>ConfigurableApplicationContext</code> interface. Here, “stopped” means that all <code>Lifecycle</code> beans receive an explicit stop signal. A stopped context may be restarted through a <code>start()</code> call.</td></tr>
<tr><td style="text-align: left"><code>ContextClosedEvent</code></td><td style="text-align: left">Published when the <code>ApplicationContext</code> is being closed by using the <code>close()</code> method on the <code>ConfigurableApplicationContext</code> interface or via a JVM shutdown hook. Here, &quot;closed&quot; means that all singleton beans will be destroyed. Once the context is closed, it reaches its end of life and cannot be refreshed or restarted.</td></tr>
<tr><td style="text-align: left"><code>RequestHandledEvent</code></td><td style="text-align: left">A web-specific event telling all beans that an HTTP request has been serviced. This event is published after the request is complete. This event is only applicable to web applications that use Spring’s <code>DispatcherServlet</code>.</td></tr>
<tr><td style="text-align: left"><code>ServletRequestHandledEvent</code></td><td style="text-align: left">A subclass of <code>RequestHandledEvent</code> that adds Servlet-specific context information</td></tr>
</tbody></table>
</div>
<h4 id="自定义事件"><a class="header" href="#自定义事件">自定义事件</a></h4>
<p>通过ApplicationEvent自定义事件发布,ApplicationListener 自定义事件接收, ApplicationEventPublisher在容器bean中发布事件</p>
<pre><code class="language-java">//定义事件
public class BlackListEvent extends ApplicationEvent {

    private final String address;
    private final String content;

    public BlackListEvent(Object source, String address, String content) {
        super(source);
        this.address = address;
        this.content = content;
    }

    // accessor and other methods...
}
//定义 发布事件的服务
public class EmailService implements ApplicationEventPublisherAware {

    private List&lt;String&gt; blackList;
    private ApplicationEventPublisher publisher;

    public void setBlackList(List&lt;String&gt; blackList) {
        this.blackList = blackList;
    }

    public void setApplicationEventPublisher(ApplicationEventPublisher publisher) {
        this.publisher = publisher;
    }

    public void sendEmail(String address, String content) {
        if (blackList.contains(address)) {
            publisher.publishEvent(new BlackListEvent(this, address, content));
            return;
        }
        // send email...
    }
}
//定义监听该事件的类
public class BlackListNotifier implements ApplicationListener&lt;BlackListEvent&gt; {

    private String notificationAddress;

    public void setNotificationAddress(String notificationAddress) {
        this.notificationAddress = notificationAddress;
    }

    public void onApplicationEvent(BlackListEvent event) {
        // notify appropriate parties via notificationAddress...
    }
}
</code></pre>
<h4 id="注意事项"><a class="header" href="#注意事项">注意事项</a></h4>
<ul>
<li>
<p>该事件发布是同步的,会等待所有监听者 处理完事件才会返回,比较利于事务</p>
</li>
<li>
<p>另外一个事件发布的策略:异步多播 <a href="https://docs.spring.io/spring-framework/docs/5.2.7.RELEASE/javadoc-api/org/springframework/context/event/ApplicationEventMulticaster.html"><code>ApplicationEventMulticaster</code></a> interface and <a href="https://docs.spring.io/spring-framework/docs/5.2.7.RELEASE/javadoc-api/org/springframework/context/event/SimpleApplicationEventMulticaster.html"><code>SimpleApplicationEventMulticaster</code></a></p>
</li>
</ul>
<h4 id="基于注解的事件监听"><a class="header" href="#基于注解的事件监听">基于注解的事件监听</a></h4>
<pre><code class="language-java">public class BlackListNotifier {

    private String notificationAddress;

    public void setNotificationAddress(String notificationAddress) {
        this.notificationAddress = notificationAddress;
    }

    @EventListener
    public void processBlackListEvent(BlackListEvent event) {
        // notify appropriate parties via notificationAddress...
    }
}

//多事件 监听
@EventListener({ContextStartedEvent.class, ContextRefreshedEvent.class})
public void handleContextStart() {
    // ...
}

//运行时对事件 过滤
@EventListener(condition = &quot;#blEvent.content == 'my-event'&quot;)
public void processBlackListEvent(BlackListEvent blEvent) {
    // notify appropriate parties via notificationAddress...
}

//处理完事件后 发布另一事件,可以通过集合发布多个事件
@EventListener
public ListUpdateEvent handleBlackListEvent(BlackListEvent event) {
    // notify appropriate parties via notificationAddress and
    // then publish a ListUpdateEvent...
}

//异步事件处理
@EventListener
@Async
public void processBlackListEvent(BlackListEvent event) {
    // BlackListEvent is processed in a separate thread
}
异步事件的限制
如果异步调用发生异常,不会传给调用者,详见AsyncUncaughtExceptionHandler 
无法通过返回值 发布事件,只能手动 注入ApplicationEventPublisher,发布
    
//可排序的监听器执行    
@EventListener
@Order(42)
public void processBlackListEvent(BlackListEvent event) {
    // notify appropriate parties via notificationAddress...
}    

//基于泛型的 监听器选择
@EventListener
public void onPersonCreated(EntityCreatedEvent&lt;Person&gt; event) {
    // ...
}
只会选择 Person类型的监听器
前提是 此类已将泛型具体化

//可以使用 ResolveableTypeProvider 来让spring自动识别解析类型
public class EntityCreatedEvent&lt;T&gt; extends ApplicationEvent implements ResolvableTypeProvider {

    public EntityCreatedEvent(T entity) {
        super(entity);
    }

    @Override
    public ResolvableType getResolvableType() {
        return ResolvableType.forClassWithGenerics(getClass(), ResolvableType.forInstance(getSource()));
    }
}
</code></pre>
<p>el表达式有专门语义环境的变量</p>
<div class="table-wrapper"><table><thead><tr><th style="text-align: left">Name</th><th style="text-align: left">Location</th><th style="text-align: left">Description</th><th style="text-align: left">Example</th></tr></thead><tbody>
<tr><td style="text-align: left">Event</td><td style="text-align: left">root object</td><td style="text-align: left">The actual <code>ApplicationEvent</code>.</td><td style="text-align: left"><code>#root.event</code> or <code>event</code></td></tr>
<tr><td style="text-align: left">Arguments array</td><td style="text-align: left">root object</td><td style="text-align: left">The arguments (as an object array) used to invoke the method.</td><td style="text-align: left"><code>#root.args</code> or <code>args</code>; <code>args[0]</code> to access the first argument, etc.</td></tr>
<tr><td style="text-align: left"><em>Argument name</em></td><td style="text-align: left">evaluation context</td><td style="text-align: left">The name of any of the method arguments. If, for some reason, the names are not available (for example, because there is no debug information in the compiled byte code), individual arguments are also available using the <code>#a&lt;#arg&gt;</code> syntax where <code>&lt;#arg&gt;</code> stands for the argument index (starting from 0).</td><td style="text-align: left"><code>#blEvent</code> or <code>#a0</code> (you can also use <code>#p0</code> or <code>#p&lt;#arg&gt;</code> parameter notation as an alias)</td></tr>
</tbody></table>
</div>
<h3 id="资源访问"><a class="header" href="#资源访问">资源访问</a></h3>
<ul>
<li>application context 是一个ResourceLoader,可以导入resource对象</li>
<li>resource对象本质上是一个 更加版本丰富的 java.net.URL</li>
<li>Resource对象可以以间接的方式,透明的从大多数路径 下获取资源</li>
<li>包括 类路径,文件系统路径,任何以URL标准形式的路径</li>
<li>如果一个资源 没有指定任何  资源前缀, 则默认是 application context type</li>
<li>提供给 ApplicationContext构造函数的 路径, 以string格式,根据实现的不同会当作不同路径的资源,例如(ClassPathXmlApplicationContext) 类路径下的</li>
<li>通过ResourceLoaderAware 注入 ResourceLoader,直接访问资源文件</li>
</ul>
<h3 id="访问applicationcontext"><a class="header" href="#访问applicationcontext">访问ApplicationContext</a></h3>
<ul>
<li>
<p>通过申明式创建 ApplicationContext</p>
<pre><code class="language-java">&lt;context-param&gt;
    &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt;
    &lt;param-value&gt;/WEB-INF/daoContext.xml /WEB-INF/applicationContext.xml&lt;/param-value&gt;
&lt;/context-param&gt;

&lt;listener&gt;
    &lt;listener-class&gt;org.springframework.web.context.ContextLoaderListener&lt;/listener-class&gt;
&lt;/listener&gt;
1. 监听器检测contextConfigLocation  参数下的文件
2. 如果参数不存在,取默认/WEB-INF/applicationContext.xml
3. 文件之间使用 : ; 空格等分隔
4. 支持ANtPath风格
</code></pre>
</li>
</ul>
<h3 id="springcontextrar部署"><a class="header" href="#springcontextrar部署">springContextRAR部署</a></h3>
<p>Deploying a Spring <code>ApplicationContext</code> as a Java EE RAR File</p>
<p>基于RAR的springContext部署</p>
<p>不需要web端</p>
<p><a href="https://docs.spring.io/spring-framework/docs/5.2.7.RELEASE/javadoc-api/org/springframework/jca/context/SpringContextResourceAdapter.html"><code>SpringContextResourceAdapter</code></a></p>
<h2 id="beanfactory"><a class="header" href="#beanfactory"><code>BeanFactory</code></a></h2>
<p><em>BeanFactory</em> 极其相关接口(BeanFactoryAware<code>, </code>InitializingBean<code>, </code>DisposableBean)  是集成第三方组件 的接入点,可以不需要注解或者反射,就能有效的使第三方组件与容器沟通</p>
<h3 id="beanfactory-or-applicationcontext"><a class="header" href="#beanfactory-or-applicationcontext"><code>BeanFactory</code> or <code>ApplicationContext</code></a></h3>
<p>这两者的容器级别 与 对启动的影响</p>
<p><em>ApplicationContext</em> 子类:GenericApplicationContext,AnnotationConfigApplicationContext 主要完成的工作</p>
<ul>
<li>配置文件加载</li>
<li>类路径扫描</li>
<li>注册bean定义</li>
<li>(as of 5.0) registering functional bean definitions.</li>
</ul>
<p><em>ApplicationContext</em>  包含了所有 beanfactory的功能,除非想完全把控bean的处理过程</p>
<ul>
<li><em>简单实现</em> DefaultListableBeanFactory 不会检测到  <a href="https://docs.spring.io/spring/docs/5.2.7.RELEASE/spring-framework-reference/core.html#beans-factory-extension-bpp"><code>BeanPostProcessor</code></a> </li>
</ul>
<p>beanfactory与applicationContext对比</p>
<div class="table-wrapper"><table><thead><tr><th style="text-align: left">Feature</th><th style="text-align: left"><code>BeanFactory</code></th><th style="text-align: left"><code>ApplicationContext</code></th></tr></thead><tbody>
<tr><td style="text-align: left">Bean instantiation/wiring</td><td style="text-align: left">Yes</td><td style="text-align: left">Yes</td></tr>
<tr><td style="text-align: left">Integrated lifecycle management</td><td style="text-align: left">No</td><td style="text-align: left">Yes</td></tr>
<tr><td style="text-align: left">Automatic <code>BeanPostProcessor</code> registration</td><td style="text-align: left">No</td><td style="text-align: left">Yes</td></tr>
<tr><td style="text-align: left">Automatic <code>BeanFactoryPostProcessor</code> registration</td><td style="text-align: left">No</td><td style="text-align: left">Yes</td></tr>
<tr><td style="text-align: left">Convenient <code>MessageSource</code> access (for internalization)</td><td style="text-align: left">No</td><td style="text-align: left">Yes</td></tr>
<tr><td style="text-align: left">Built-in <code>ApplicationEvent</code> publication mechanism</td><td style="text-align: left">No</td><td style="text-align: left">Yes</td></tr>
</tbody></table>
</div>
<p>{% raw %}</p>
<h1 id="resource-1"><a class="header" href="#resource-1">Resource</a></h1>
<ul>
<li>本章节介绍了spring如何处理资源,如何在spring中使用资源</li>
<li>对Java URL类的封装,提供了更强大的功能 ,推荐在自己代码中使用</li>
</ul>
<h2 id="内置的resource实现"><a class="header" href="#内置的resource实现">内置的Resource实现</a></h2>
<p>UrlResource</p>
<ul>
<li>UrlResource 包装了java.net.URL ,可以用来访问 Http,Ftp,file文件系统的访问</li>
<li>会解析 已知的关键字 classpath</li>
</ul>
<p>ClassPathResource</p>
<ul>
<li>加载类路径的资源文件</li>
<li>要么使用当前线程的类加载器或者给定类加载器,或者 指定类</li>
</ul>
<p>FileSystemResource</p>
<p>ServletContextResource</p>
<ul>
<li>ServletContext*的实现,从web跟目录的相对路径加载文件</li>
</ul>
<h2 id="resourceloader"><a class="header" href="#resourceloader">ResourceLoader</a></h2>
<ul>
<li>
<p>用于加载resource的类</p>
</li>
<li>
<p>所有application context 实现了该接口,对于不同的容器返回不同类型的 Resource</p>
<pre><code class="language-java">Resource template = ctx.getResource(&quot;some/resource/path/myTemplate.txt&quot;);
</code></pre>
<ul>
<li>
<p><em>ClassPathXmlApplicationContext</em> 返回 ClassPathResource</p>
</li>
<li>
<p><em>FileSystemXmlApplicationContext</em> 返回FileSystemResource</p>
</li>
<li>
<p>WebApplicationContext 返回ServletContextResource</p>
</li>
<li>
<p>可以强制返回指定类型的资源</p>
<pre><code class="language-java">//返回类路径下的资源
Resource template = ctx.getResource(&quot;classpath:some/resource/path/myTemplate.txt&quot;);
//返回文件系统下的资源
Resource template = ctx.getResource(&quot;file:///some/resource/path/myTemplate.txt&quot;);
//返回http资源
Resource template = ctx.getResource(&quot;https://myhost.com/resource/path/myTemplate.txt&quot;);
</code></pre>
</li>
</ul>
<p>显示指定前缀</p>
</li>
</ul>
<div class="table-wrapper"><table><thead><tr><th style="text-align: left">Prefix</th><th style="text-align: left">Example</th><th style="text-align: left">Explanation</th></tr></thead><tbody>
<tr><td style="text-align: left">classpath:</td><td style="text-align: left"><code>classpath:com/myapp/config.xml</code></td><td style="text-align: left">Loaded from the classpath.</td></tr>
<tr><td style="text-align: left">file:</td><td style="text-align: left"><code>file:///data/config.xml</code></td><td style="text-align: left">Loaded as a <code>URL</code> from the filesystem. See also <a href="https://docs.spring.io/spring/docs/5.2.7.RELEASE/spring-framework-reference/core.html#resources-filesystemresource-caveats"><code>FileSystemResource</code> Caveats</a>.</td></tr>
<tr><td style="text-align: left">http:</td><td style="text-align: left"><code>https://myserver/logo.png</code></td><td style="text-align: left">Loaded as a <code>URL</code>.</td></tr>
<tr><td style="text-align: left">(none)</td><td style="text-align: left"><code>/data/config.xml</code></td><td style="text-align: left">Depends on the underlying <code>ApplicationContext</code>.</td></tr>
</tbody></table>
</div>
<h2 id="resourceloaderaware"><a class="header" href="#resourceloaderaware">ResourceLoaderAware</a></h2>
<ul>
<li>申明注入resourceloader的接口</li>
<li>因为所有 ApplicationContext 都实现了resourceloader 所以可以使用他 来加载资源</li>
</ul>
<h2 id="依赖注入资源属性"><a class="header" href="#依赖注入资源属性">依赖注入资源属性</a></h2>
<ul>
<li>
<p>使用PropertyEditor 注入自定义的属性文件,</p>
<pre><code class="language-xml">//注入的路径取决于 你的 applicationContext的类型,可以指定前缀来使用指定资源
&lt;bean id=&quot;myBean&quot; class=&quot;...&quot;&gt;
    &lt;property name=&quot;template&quot; value=&quot;some/resource/path/myTemplate.txt&quot;/&gt;
&lt;/bean&gt;

</code></pre>
</li>
</ul>
<h2 id="使用resource创建-applicationcontext"><a class="header" href="#使用resource创建-applicationcontext">使用resource创建 applicationContext</a></h2>
<pre><code class="language-java">ApplicationContext ctx = new ClassPathXmlApplicationContext(&quot;conf/appContext.xml&quot;);

ApplicationContext ctx =
    new FileSystemXmlApplicationContext(&quot;conf/appContext.xml&quot;);
</code></pre>
<pre><code class="language-java">com/
  foo/
    services.xml
    daos.xml
    MessengerService.class
    
使用上述路径的资源加载文件
ApplicationContext ctx = new ClassPathXmlApplicationContext(
    new String[] {&quot;services.xml&quot;, &quot;daos.xml&quot;}, MessengerService.class);
</code></pre>
<p>资源加载中的通配符</p>
<h2 id="文件系统资源使用-警告"><a class="header" href="#文件系统资源使用-警告">文件系统资源使用 警告</a></h2>
<p>为了向后兼容的原因 spring使用 FileSystemApplicationContext 时,会通通当成相对路径,</p>
<pre><code class="language-java">这两个示例 时相等价的
ApplicationContext ctx =
    new FileSystemXmlApplicationContext(&quot;conf/context.xml&quot;);
    
ApplicationContext ctx =
    new FileSystemXmlApplicationContext(&quot;/conf/context.xml&quot;);
</code></pre>
<h1 id="验证数据绑定类型转换"><a class="header" href="#验证数据绑定类型转换">验证,数据绑定,类型转换</a></h1>
<p>Validation, Data Binding, and Type Conversion</p>
<ul>
<li><em>Validator</em> 与 <em>DataBinder</em> 组成 validation 包</li>
<li><em>BeanWrapper</em> 是spring非常基础的概念,在很多地方使用到</li>
<li><em>DataBinder</em> 和BeanWrapper 都使用 PropertyEditorSupport 的实现去 解析和格式化属性值</li>
</ul>
<h2 id="spring-validtor使用示例"><a class="header" href="#spring-validtor使用示例">spring validtor使用示例</a></h2>
<pre><code class="language-java">public class PersonValidator implements Validator {

    /**
     * This Validator validates only Person instances
     */
    public boolean supports(Class clazz) {
        return Person.class.equals(clazz);
    }

    public void validate(Object obj, Errors e) {
        ValidationUtils.rejectIfEmpty(e, &quot;name&quot;, &quot;name.empty&quot;);
        Person p = (Person) obj;
        if (p.getAge() &lt; 0) {
            e.rejectValue(&quot;age&quot;, &quot;negativevalue&quot;);
        } else if (p.getAge() &gt; 110) {
            e.rejectValue(&quot;age&quot;, &quot;too.darn.old&quot;);
        }
    }
}
</code></pre>
<h2 id="resolving-codes-to-error-messages"><a class="header" href="#resolving-codes-to-error-messages">Resolving Codes to Error Messages</a></h2>
<ul>
<li>使用前面的验证器产生的错误消息,可以通过 <em>MessageCodesResolver</em> 解析code</li>
<li>例如默认的实现 DefaultMessageCodesResolver ,调用 rejectValue(&quot;age&quot;, &quot;too.darn.old&quot;) 方法会在resource中注册 <em>too.darn.old</em>  <em>too.darn.old.age</em>,<em>too.darn.old.age.int</em></li>
</ul>
<h2 id="bean-manipulation-and-the-beanwrapper"><a class="header" href="#bean-manipulation-and-the-beanwrapper"><em>Bean Manipulation and the <code>BeanWrapper</code></em></a></h2>
<ul>
<li>BeanWrapper* 和它的实现 BeanWrapperImpl 可以批量设置或者读取 JavaBean属性</li>
<li>支持嵌套属性</li>
<li>能够添加 PropertyChangeListeners,VetoableChangeListeners</li>
<li>支持字段索引</li>
<li>Bean Wrapper通常是 DataBinder和 BeanFactory 使用,不是给应用程序直接使用</li>
</ul>
<h3 id="访问语法"><a class="header" href="#访问语法">访问语法</a></h3>
<div class="table-wrapper"><table><thead><tr><th style="text-align: left">Expression</th><th style="text-align: left">Explanation</th></tr></thead><tbody>
<tr><td style="text-align: left"><code>name</code></td><td style="text-align: left">javabean的属性名</td></tr>
<tr><td style="text-align: left"><code>account.name</code></td><td style="text-align: left">嵌套的属性名<code>getAccount().setName()</code> or <code>getAccount().getName()</code> methods.</td></tr>
<tr><td style="text-align: left"><code>account[2]</code></td><td style="text-align: left">集合索引Indicates the <em>third</em> element of the indexed property <code>account</code>. Indexed properties can be of type <code>array</code>, <code>list</code>, or other naturally ordered collection.</td></tr>
<tr><td style="text-align: left"><code>account[COMPANYNAME]</code></td><td style="text-align: left">map索引</td></tr>
</tbody></table>
</div>
<h3 id="如何使用-beanwrapper"><a class="header" href="#如何使用-beanwrapper">如何使用 beanWrapper</a></h3>
<pre><code class="language-java">public class Company {

    private String name;
    private Employee managingDirector;

    public String getName() {
        return this.name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public Employee getManagingDirector() {
        return this.managingDirector;
    }

    public void setManagingDirector(Employee managingDirector) {
        this.managingDirector = managingDirector;
    }
}


public class Employee {

    private String name;

    private float salary;

    public String getName() {
        return this.name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public float getSalary() {
        return salary;
    }

    public void setSalary(float salary) {
        this.salary = salary;
    }
}
//使用
BeanWrapper company = new BeanWrapperImpl(new Company());
// setting the company name..
company.setPropertyValue(&quot;name&quot;, &quot;Some Company Inc.&quot;);
// ... can also be done like this:
PropertyValue value = new PropertyValue(&quot;name&quot;, &quot;Some Company Inc.&quot;);
company.setPropertyValue(value);

// ok, let's create the director and tie it to the company:
BeanWrapper jim = new BeanWrapperImpl(new Employee());
jim.setPropertyValue(&quot;name&quot;, &quot;Jim Stravinsky&quot;);
company.setPropertyValue(&quot;managingDirector&quot;, jim.getWrappedInstance());

// retrieving the salary of the managingDirector through the company
Float salary = (Float) company.getPropertyValue(&quot;managingDirector.salary&quot;);
</code></pre>
<h3 id="propertyeditor-内置的beanwrapper的实现"><a class="header" href="#propertyeditor-内置的beanwrapper的实现"><em>PropertyEditor</em> 内置的beanwrapper的实现</a></h3>
<ul>
<li>spring使用 PropertyEditor 在 string名称的属性,与 对象 之间 转换</li>
<li>springBean wrapper有两个使用场景
<ul>
<li>通过使用 PropertyEditor 的实现 来实现 设置 bean,例如基于xml的依赖注入</li>
<li>spring MVC的Http参数解析中绑定,使用各种各样的 PropertyEditor</li>
<li>您可以在CommandController的所有子类中手动绑定这些实现。</li>
</ul>
</li>
<li>spring 有很多 PropertyEditor 在 org.springframework.beans.propertyeditors包中,大部分由 BeanWrapperImpl 默认注册</li>
</ul>
<div class="table-wrapper"><table><thead><tr><th style="text-align: left">Class</th><th style="text-align: left">Explanation</th></tr></thead><tbody>
<tr><td style="text-align: left"><code>ByteArrayPropertyEditor</code></td><td style="text-align: left">Editor for byte arrays. Converts strings to their corresponding byte representations. Registered by default by <code>BeanWrapperImpl</code>.</td></tr>
<tr><td style="text-align: left"><code>ClassEditor</code></td><td style="text-align: left">Parses Strings that represent classes to actual classes and vice-versa. When a class is not found, an <code>IllegalArgumentException</code> is thrown. By default, registered by <code>BeanWrapperImpl</code>.</td></tr>
<tr><td style="text-align: left"><code>CustomBooleanEditor</code></td><td style="text-align: left">Customizable property editor for <code>Boolean</code> properties. By default, registered by <code>BeanWrapperImpl</code> but can be overridden by registering a custom instance of it as a custom editor.</td></tr>
<tr><td style="text-align: left"><code>CustomCollectionEditor</code></td><td style="text-align: left">Property editor for collections, converting any source <code>Collection</code> to a given target <code>Collection</code> type.</td></tr>
<tr><td style="text-align: left"><code>CustomDateEditor</code></td><td style="text-align: left">Customizable property editor for <code>java.util.Date</code>, supporting a custom <code>DateFormat</code>. NOT registered by default. Must be user-registered with the appropriate format as needed.</td></tr>
<tr><td style="text-align: left"><code>CustomNumberEditor</code></td><td style="text-align: left">Customizable property editor for any <code>Number</code> subclass, such as <code>Integer</code>, <code>Long</code>, <code>Float</code>, or <code>Double</code>. By default, registered by <code>BeanWrapperImpl</code> but can be overridden by registering a custom instance of it as a custom editor.</td></tr>
<tr><td style="text-align: left"><code>FileEditor</code></td><td style="text-align: left">Resolves strings to <code>java.io.File</code> objects. By default, registered by <code>BeanWrapperImpl</code>.</td></tr>
<tr><td style="text-align: left"><code>InputStreamEditor</code></td><td style="text-align: left">One-way property editor that can take a string and produce (through an intermediate <code>ResourceEditor</code> and <code>Resource</code>) an <code>InputStream</code> so that <code>InputStream</code> properties may be directly set as strings. Note that the default usage does not close the <code>InputStream</code> for you. By default, registered by <code>BeanWrapperImpl</code>.</td></tr>
<tr><td style="text-align: left"><code>LocaleEditor</code></td><td style="text-align: left">Can resolve strings to <code>Locale</code> objects and vice-versa (the string format is <code>*[country]*[variant]</code>, same as the <code>toString()</code> method of <code>Locale</code>). By default, registered by <code>BeanWrapperImpl</code>.</td></tr>
<tr><td style="text-align: left"><code>PatternEditor</code></td><td style="text-align: left">Can resolve strings to <code>java.util.regex.Pattern</code> objects and vice-versa.</td></tr>
<tr><td style="text-align: left"><code>PropertiesEditor</code></td><td style="text-align: left">Can convert strings (formatted with the format defined in the javadoc of the <code>java.util.Properties</code> class) to <code>Properties</code> objects. By default, registered by <code>BeanWrapperImpl</code>.</td></tr>
<tr><td style="text-align: left"><code>StringTrimmerEditor</code></td><td style="text-align: left">Property editor that trims strings. Optionally allows transforming an empty string into a <code>null</code> value. NOT registered by default — must be user-registered.</td></tr>
<tr><td style="text-align: left"><code>URLEditor</code></td><td style="text-align: left">Can resolve a string representation of a URL to an actual <code>URL</code> object. By default, registered by <code>BeanWrapperImpl</code>.</td></tr>
</tbody></table>
</div>
<ul>
<li>通过使用 java.beans.PropertyEditorManager 为  PropertyEditor 设置 搜索路径</li>
<li>搜索路径默认 包括 <em>sun.bean.editors</em> </li>
<li>JavaBean对象 自动发现 与他同名同包的 PropertyEditor 例如 <em>SomethingEditor</em> 与 <em>Something</em></li>
</ul>
<pre><code class="language-java">public class SomethingBeanInfo extends SimpleBeanInfo {

    public PropertyDescriptor[] getPropertyDescriptors() {
        try {
            final PropertyEditor numberPE = new CustomNumberEditor(Integer.class, true);
            PropertyDescriptor ageDescriptor = new PropertyDescriptor(&quot;age&quot;, Something.class) {
                public PropertyEditor createPropertyEditor(Object bean) {
                    return numberPE;
                };
            };
            return new PropertyDescriptor[] { ageDescriptor };
        }
        catch (IntrospectionException ex) {
            throw new Error(ex.toString());
        }
    }
}
</code></pre>
<p>注册自定义的propertyEditor</p>
<ul>
<li>
<p>spring会自动注册 内置的propertyEditor</p>
</li>
<li>
<p>javabean 框架会自动 发现 与javabean同名同包的 propertyEditor</p>
</li>
<li>
<p>也可以注册自己的propertyeditor</p>
<ul>
<li>
<p>手动注册: ConfigurableBeanFactory.registerCustomEditor.</p>
</li>
<li>
<p>使用 post-processor , CustomEditorConfigurer 来注册</p>
</li>
<li>
<p>使用 e bean factory post-processors  with <code>BeanFactory</code> </p>
</li>
<li>
<p>使用 PropertyEditorRegistrar</p>
</li>
</ul>
<pre><code class="language-java">package com.foo.editors.spring;

public final class CustomPropertyEditorRegistrar implements PropertyEditorRegistrar {

    public void registerCustomEditors(PropertyEditorRegistry registry) {

        // it is expected that new PropertyEditor instances are created
        registry.registerCustomEditor(ExoticType.class, new ExoticTypeEditor());

        // you could register as many custom property editors as are required here...
    }
}

</code></pre>
<pre><code class="language-xml">&lt;bean class=&quot;org.springframework.beans.factory.config.CustomEditorConfigurer&quot;&gt;
    &lt;property name=&quot;propertyEditorRegistrars&quot;&gt;
        &lt;list&gt;
            &lt;ref bean=&quot;customPropertyEditorRegistrar&quot;/&gt;
        &lt;/list&gt;
    &lt;/property&gt;
&lt;/bean&gt;

&lt;bean id=&quot;customPropertyEditorRegistrar&quot;
    class=&quot;com.foo.editors.spring.CustomPropertyEditorRegistrar&quot;/&gt;
</code></pre>
<pre><code>继承SimpleFormController 初始化自定义的属性注册
public final class RegisterUserController extends SimpleFormController {

    private final PropertyEditorRegistrar customPropertyEditorRegistrar;

    public RegisterUserController(PropertyEditorRegistrar propertyEditorRegistrar) {
        this.customPropertyEditorRegistrar = propertyEditorRegistrar;
    }

    protected void initBinder(HttpServletRequest request,
            ServletRequestDataBinder binder) throws Exception {
        this.customPropertyEditorRegistrar.registerCustomEditors(binder);
    }

    // other methods to do with registering a User
}
</code></pre>
<h2 id="类型转换"><a class="header" href="#类型转换">类型转换</a></h2>
<pre><code class="language-java">package org.springframework.core.convert.converter;

public interface Converter&lt;S, T&gt; {

    T convert(S source);
}
</code></pre>
<pre><code class="language-java">// 类型转换器 位于 core.convert.support
package org.springframework.core.convert.support;

final class StringToInteger implements Converter&lt;String, Integer&gt; {

    public Integer convert(String source) {
        return Integer.valueOf(source);
    }
}
</code></pre>
<pre><code class="language-java">使用ConverterFactory
package org.springframework.core.convert.converter;

public interface ConverterFactory&lt;S, R&gt; {

    &lt;T extends R&gt; Converter&lt;S, T&gt; getConverter(Class&lt;T&gt; targetType);
}

</code></pre>
<pre><code class="language-java">package org.springframework.core.convert.support;

final class StringToEnumConverterFactory implements ConverterFactory&lt;String, Enum&gt; {

    public &lt;T extends Enum&gt; Converter&lt;String, T&gt; getConverter(Class&lt;T&gt; targetType) {
        return new StringToEnumConverter(targetType);
    }

    private final class StringToEnumConverter&lt;T extends Enum&gt; implements Converter&lt;String, T&gt; {

        private Class&lt;T&gt; enumType;

        public StringToEnumConverter(Class&lt;T&gt; enumType) {
            this.enumType = enumType;
        }

        public T convert(String source) {
            return (T) Enum.valueOf(this.enumType, source.trim());
        }
    }
}
</code></pre>
</li>
</ul>
<p>GenericConverter</p>
<pre><code class="language-java">package org.springframework.core.convert.converter;

public interface GenericConverter {

    public Set&lt;ConvertiblePair&gt; getConvertibleTypes();

    Object convert(Object source, TypeDescriptor sourceType, TypeDescriptor targetType);
}
</code></pre>
<p>ConditionalGenericConverter</p>
<pre><code class="language-java">public interface ConditionalConverter {

    boolean matches(TypeDescriptor sourceType, TypeDescriptor targetType);
}

public interface ConditionalGenericConverter extends GenericConverter, ConditionalConverter {
}
</code></pre>
<p>ConversionService</p>
<pre><code class="language-java">package org.springframework.core.convert;

public interface ConversionService {

    boolean canConvert(Class&lt;?&gt; sourceType, Class&lt;?&gt; targetType);

    &lt;T&gt; T convert(Object source, Class&lt;T&gt; targetType);

    boolean canConvert(TypeDescriptor sourceType, TypeDescriptor targetType);

    Object convert(Object source, TypeDescriptor sourceType, TypeDescriptor targetType);

}
</code></pre>
<ul>
<li>配置conversionService</li>
<li>编程方式使用 conversionService</li>
</ul>
<p>Formatt</p>
<p>前面提到的 Type Convert类型转换 , spel,formatter,databinder就是基于 类型转换类 来工作的</p>
<ul>
<li>使用</li>
<li>注解</li>
<li>注册</li>
</ul>
<p><em>Configuring a Global Date and Time Format</em></p>
<p>spring全局默认使用 DateFormat.SHORT </p>
<pre><code class="language-java">org.springframework.format.datetime.standard.DateTimeFormatterRegistrar

org.springframework.format.datetime.DateFormatterRegistrar, or org.springframework.format.datetime.joda.JodaTimeFormatterRegistrar
</code></pre>
<p>注册全局日期格式</p>
<pre><code class="language-java">@Configuration
public class AppConfig {

    @Bean
    public FormattingConversionService conversionService() {

        // Use the DefaultFormattingConversionService but do not register defaults
        DefaultFormattingConversionService conversionService = new DefaultFormattingConversionService(false);

        // Ensure @NumberFormat is still supported
        conversionService.addFormatterForFieldAnnotation(new NumberFormatAnnotationFormatterFactory());

        // Register JSR-310 date conversion with a specific global format
        DateTimeFormatterRegistrar registrar = new DateTimeFormatterRegistrar();
        registrar.setDateFormatter(DateTimeFormatter.ofPattern(&quot;yyyyMMdd&quot;));
        registrar.registerFormatters(conversionService);

        // Register date conversion with a specific global format
        DateFormatterRegistrar registrar = new DateFormatterRegistrar();
        registrar.setFormatter(new DateFormatter(&quot;yyyyMMdd&quot;));
        registrar.registerFormatters(conversionService);

        return conversionService;
    }
}
</code></pre>
<pre><code class="language-xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
    xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
    xsi:schemaLocation=&quot;
        http://www.springframework.org/schema/beans
        https://www.springframework.org/schema/beans/spring-beans.xsd&gt;

    &lt;bean id=&quot;conversionService&quot; class=&quot;org.springframework.format.support.FormattingConversionServiceFactoryBean&quot;&gt;
        &lt;property name=&quot;registerDefaultFormatters&quot; value=&quot;false&quot; /&gt;
        &lt;property name=&quot;formatters&quot;&gt;
            &lt;set&gt;
                &lt;bean class=&quot;org.springframework.format.number.NumberFormatAnnotationFormatterFactory&quot; /&gt;
            &lt;/set&gt;
        &lt;/property&gt;
        &lt;property name=&quot;formatterRegistrars&quot;&gt;
            &lt;set&gt;
                &lt;bean class=&quot;org.springframework.format.datetime.joda.JodaTimeFormatterRegistrar&quot;&gt;
                    &lt;property name=&quot;dateFormatter&quot;&gt;
                        &lt;bean class=&quot;org.springframework.format.datetime.joda.DateTimeFormatterFactoryBean&quot;&gt;
                            &lt;property name=&quot;pattern&quot; value=&quot;yyyyMMdd&quot;/&gt;
                        &lt;/bean&gt;
                    &lt;/property&gt;
                &lt;/bean&gt;
            &lt;/set&gt;
        &lt;/property&gt;
    &lt;/bean&gt;
&lt;/beans&gt;
</code></pre>
<h2 id="bean验证"><a class="header" href="#bean验证">Bean验证</a></h2>
<pre><code class="language-java">public class PersonForm {

    @NotNull
    @Size(max=64)
    private String name;

    @Min(0)
    private int age;
}
</code></pre>
<p>注入bean</p>
<pre><code class="language-java">import javax.validation.Validator;

@Service
public class MyService {

    @Autowired
    private Validator validator;
}
</code></pre>
<p>自定义约束</p>
<p>每个自定义约束包含两个部分</p>
<ul>
<li>@Constraint 注解申明约束</li>
<li><em>javax.validation.ConstraintValidator</em>的实现</li>
</ul>
<p>声明注解</p>
<pre><code class="language-java">@Target({ElementType.METHOD, ElementType.FIELD})
@Retention(RetentionPolicy.RUNTIME)
@Constraint(validatedBy=MyConstraintValidator.class)
public @interface MyConstraint {
}
</code></pre>
<p>实现validator</p>
<pre><code class="language-java">import javax.validation.ConstraintValidator;

public class MyConstraintValidator implements ConstraintValidator {

    @Autowired;
    private Foo aDependency;

    // ...
}
</code></pre>
<pre><code class="language-java">import org.springframework.validation.beanvalidation.MethodValidationPostProcessor;

@Configuration

public class AppConfig {

    @Bean
    public MethodValidationPostProcessor validationPostProcessor() {
        return new MethodValidationPostProcessor;
    }
}
</code></pre>
<h1 id="spel表达式"><a class="header" href="#spel表达式">SPEL表达式</a></h1>
<p>Spring Expression Language (SpEL)</p>
<h2 id="spel支持的功能"><a class="header" href="#spel支持的功能">SPEL支持的功能</a></h2>
<ul>
<li>Literal expressions 字面量表达式:数学表达式</li>
<li>Boolean and relational operators  布尔运算符,关系运算符</li>
<li>Regular expressions : 正则表达式</li>
<li>Class expressions : 类表达式</li>
<li>Accessing properties, arrays, lists, and maps :访问数组,列表,map</li>
<li>Method invocation:静态方法调用,对象方法调用</li>
<li>Relational operators 关系运算符</li>
<li>Assignment 赋值</li>
<li>Calling constructors 调用构造器</li>
<li>Bean references bean引用</li>
<li>Array construction 数组构建</li>
<li>Inline lists 内联lists</li>
<li>Inline maps 内联 map</li>
<li>Ternary operator  三元运算符</li>
<li>Variables 变量</li>
<li>User-defined functions 用户定义功能</li>
<li>Collection projection 集合投影</li>
<li>Collection selection 集合选择</li>
<li>Templated expressions 模板表达式</li>
</ul>
<h2 id="evaluation"><a class="header" href="#evaluation">Evaluation</a></h2>
<ul>
<li>
<p>spel的包 位于 <em>org.springframework.expression</em> ,它的子包 <em>spel.support</em></p>
</li>
<li>
<p><em>ExpressionParser</em> 接口负责 解析 string类型的 表达式,可能会抛出两个异常,<em>ParseException</em> <em>EvaluationException</em></p>
</li>
<li>
<p>string类型的字面量用 单引号 包裹</p>
</li>
<li>
<p><em>parser.parseExpression<code>and</code>exp.getValue</em> 必须成对的调用</p>
<pre><code class="language-java">ExpressionParser parser = new SpelExpressionParser();
Expression exp = parser.parseExpression(&quot;'Hello World'&quot;); 
String message = (String) exp.getValue();
</code></pre>
</li>
</ul>
<h3 id="example"><a class="header" href="#example">Example</a></h3>
<h4 id="调用stringconcat"><a class="header" href="#调用stringconcat">调用string.concat</a></h4>
<pre><code class="language-java">ExpressionParser parser = new SpelExpressionParser();
Expression exp = parser.parseExpression(&quot;'Hello World'.concat('!')&quot;); 
String message = (String) exp.getValue();
</code></pre>
<h4 id="标准的点式调用"><a class="header" href="#标准的点式调用">标准的点式调用</a></h4>
<pre><code class="language-java">ExpressionParser parser = new SpelExpressionParser();

// invokes 'getBytes().length'
Expression exp = parser.parseExpression(&quot;'Hello World'.bytes.length&quot;); 
int length = (Integer) exp.getValue();
</code></pre>
<h4 id="按照java语法"><a class="header" href="#按照java语法">按照Java语法</a></h4>
<pre><code class="language-java">ExpressionParser parser = new SpelExpressionParser();
Expression exp = parser.parseExpression(&quot;new String('hello world').toUpperCase()&quot;); 
String message = exp.getValue(String.class);
</code></pre>
<p>从对象示例中取 变量的值</p>
<pre><code class="language-java">// Create and set a calendar
GregorianCalendar c = new GregorianCalendar();
c.set(1856, 7, 9);

// The constructor arguments are name, birthday, and nationality.
Inventor tesla = new Inventor(&quot;Nikola Tesla&quot;, c.getTime(), &quot;Serbian&quot;);

ExpressionParser parser = new SpelExpressionParser();

Expression exp = parser.parseExpression(&quot;name&quot;); // Parse name as an expression
String name = (String) exp.getValue(tesla);
// name == &quot;Nikola Tesla&quot;

exp = parser.parseExpression(&quot;name == 'Nikola Tesla'&quot;);
boolean result = exp.getValue(tesla, Boolean.class);
// result == true
</code></pre>
<p>{% endraw %}</p>
<script src="/note-service/java/infisearch_assets/search-ui.ascii.bundle.js" type="text/javascript" charset="utf-8"></script>
<script src="/note-service/java/infisearch_assets/mark.min.js" type="text/javascript" charset="utf-8"></script>
<script>
const base_url = '/note-service/java/';
const mode = 'target';
infisearch.init({
  searcherOptions: {
    url: base_url + 'infisearch_output/',
  },
  uiOptions: {
    mode,
    dropdownAlignment: 'bottom-start',
    target: document.getElementById('infisearch-mdbook-target'),
    fsButtonPlaceholder: 'Search',
    sourceFilesUrl: base_url,
    resultsRenderOpts: {
      searchedTermsParam: 'search',
    },
    multiSelectFilters: [
      { fieldName: 'partTitle', displayName: 'Section', defaultOptName: 'None' },
    ],
  },
});

document.getElementById('infi-search').addEventListener('keydown', (ev) => {
  if (['ArrowLeft', 'ArrowRight'].includes(ev.key)) {
    ev.stopPropagation(); // used in global listener to change pages
    return;
  }
});

if (window.location.search) {
  // Adapted from the original searcher.js for mdbook
  // https://github.com/rust-lang/mdBook/blob/master/src/theme/searcher/searcher.js
  const target = document.getElementById('content');
  const marker = new Mark(target);

  function doSearchOrMarkFromUrl() {
    // Check current URL for search request
    var url = new URL(window.location.href);
    var urlParams = new URLSearchParams(url.search);

    if (urlParams.has('search')) {
      var words = JSON.parse(decodeURIComponent(urlParams.get('search')));
      marker.mark(words);

      var markers = document.querySelectorAll('mark');
      function hide() {
        for (var i = 0; i < markers.length; i++) {
          markers[i].classList.add('fade-out');
          window.setTimeout(function () { marker.unmark(); }, 300);
        }
      }
      for (var i = 0; i < markers.length; i++) {
        markers[i].addEventListener('click', hide);
      }
    }
  }
  doSearchOrMarkFromUrl();
}
</script>
<p><span data-infisearch-part-title="spring"></span></p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../../10.spring_SpringFramework/springframework/MessageSource.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="../../10.spring_SpringFramework/springframework/springEL.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../../10.spring_SpringFramework/springframework/MessageSource.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="../../10.spring_SpringFramework/springframework/springEL.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>



        <script src="../../clipboard.min.js"></script>
        <script src="../../highlight.js"></script>
        <script src="../../book.js"></script>

        <!-- Custom JS scripts -->


    </div>
    </body>
</html>
