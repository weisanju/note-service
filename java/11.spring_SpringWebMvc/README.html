<!DOCTYPE HTML>
<html lang="zh_CN" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>SpringWebMvc - JAVA笔记库</title>


        <!-- Custom HTML head -->

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="../favicon.svg">
        <link rel="shortcut icon" href="../favicon.png">
        <link rel="stylesheet" href="../css/variables.css">
        <link rel="stylesheet" href="../css/general.css">
        <link rel="stylesheet" href="../css/chrome.css">

        <!-- Fonts -->
        <link rel="stylesheet" href="../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" id="highlight-css" href="../highlight.css">
        <link rel="stylesheet" id="tomorrow-night-css" href="../tomorrow-night.css">
        <link rel="stylesheet" id="ayu-highlight-css" href="../ayu-highlight.css">

        <!-- Custom theme stylesheets -->

        <!-- MathJax -->
        <script async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>

        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "../";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="../toc.js"></script>
    </head>
    <body>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="../toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                    </div>

                    <h1 class="menu-title">JAVA笔记库</h1>

                    <div class="right-buttons">

                    </div>
                </div>


                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <link rel="stylesheet" href="/note-service/java/infisearch_assets/search-ui-light.css">
<style>.light .infi-root,
.rust .infi-root,
.coal .infi-root,
.navy .infi-root,
.ayu .infi-root {
    --infi-shadow: none;
    --infi-border: 3px solid var(--table-header-bg);
    --infi-bg: var(--bg);
    --infi-triangle-bg: var(--table-header-bg);
    --infi-item-box-shadow: 0 1px 5px rgba(196, 192, 187, 0.8);
    --infi-title-fg: var(--fg);
    --infi-title-hover-fg: var(--fg);
    --infi-title-hover-bg: var(--table-header-bg);
    --infi-title-border-bottom-hover: 2px solid var(--table-header-bg);
    --infi-heading-fg: var(--fg);
    --infi-heading-hover-fg: var(--fg);
    --infi-body-fg: var(--fg);
    --infi-body-hover-fg: var(--fg);
    --infi-sub-bg: var(--bg);
    --infi-highlight: var(--search-mark-bg);
    --infi-highlight-bg: none;
    --infi-header-fg: var(--fg);
    --infi-checkbox-bg: #f8f8f8;
    --infi-checkbox-checked-bg: #fff;
    --infi-checkbox-border: #414141;
    --infi-filter-header-active: var(--infi-title-bg);
    --infi-error-fg: var(--fg);
    --infi-fine-print-fg: var(--fg);
    --infi-loading-bg: var(--fg);
    --infi-loading-secondary-bg: var(--fg);
    --infi-load-more-fg: var(--infi-title-fg);
    --infi-load-more-bg: var(--infi-title-bg);
    --infi-load-more-hover-fg: var(--infi-title-hover-fg);
    --infi-load-more-hover-bg: var(--infi-title-hover-bg);
    --infi-scrollbar-bg: none;
    --infi-scrollbar-thumb-bg: var(--sidebar-non-existant);
    --infi-fs-button-input-fg: var(--searchbar-shadow-color);
    --infi-fs-border: 3px solid var(--sidebar-bg);
    --infi-fs-box-shadow: none;
    --infi-fs-header-bg: var(--sidebar-bg);
    --infi-fs-header-box-shadow: none;
    --infi-tip-table-header-border: var(--table-border-color);
    --infi-tip-table-border: transparent;
    --infi-tip-table-alternate: var(--table-alternate-bg);
    --infi-tip-bg: var(--sidebar-bg);
    --infi-tip-fg: var(--sidebar-fg);
    --infi-tip-code-fg: var(--inline-code-color);
    --infi-tip-code-bg: transparent;
    --infi-tip-icon-bg: rgb(230, 230, 230);
    --infi-tip-icon-fg: rgb(80, 80, 80);
}

.light .infi-root {
    --infi-fs-header-close-fg: var(--searchresults-header-fg);
    --infi-fs-header-close-hover-fg: var(--fg);
}

.ayu .infi-root,
.rust .infi-root,
.coal .infi-root,
.navy .infi-root {
    --infi-fs-header-close-fg: var(--sidebar-fg);
    --infi-fs-header-close-hover-fg: white;
}

.ayu .infi-root,
.rust .infi-root {
    --infi-tip-code-fg: var(--search-mark-bg) !important;
    --infi-tip-icon-bg: rgb(200, 200, 200);
    --infi-tip-icon-fg: rgb(50, 50, 50);
}

.light .infi-root .infi-list-item.focus,
.rust .infi-root .infi-list-item.focus,
.coal .infi-root .infi-list-item.focus,
.navy .infi-root .infi-list-item.focus,
.ayu .infi-root .infi-list-item.focus {
    outline: 2px solid grey;
}

.light .infi-root,
.coal .infi-root,
.navy .infi-root,
.ayu .infi-root {
    --infi-title-bg: var(--theme-hover);
    --infi-sub-hover-bg: var(--table-alternate-bg);
    --infi-title-border-bottom: 2px solid var(--theme-hover);
}

.light .infi-root {
    --infi-highlight: #82a6c4;
    --infi-sub-hover-bg: #ebebeb;
}

.rust .infi-root {
    --infi-highlight: #bc8e6a;

    --infi-tip-table-alternate: var(--sidebar-bg);
    --infi-title-bg: var(--table-header-bg);
    --infi-title-border-bottom: 2px solid var(--table-header-bg);

    --infi-sub-hover-bg: #c6bbb1;
    --infi-title-bg: #bbada1;
    --infi-title-border-bottom: 2px solid #bbada1;
    --infi-title-hover-fg: #000;
    --infi-title-hover-bg: #a19488;
    --infi-title-border-bottom-hover: 2px solid #a19488;
    --infi-body-hover-fg: #1e1e1e;
    --infi-heading-hover-fg: #1e1e1e;
}

.coal .infi-root {
    --infi-highlight: #496c8a;
    --infi-sub-hover-bg: #272a2b;
}

.infi-theme .infi-root .infi-tip-item code,
.rust .infi-root .infi-tip-item code {
    color: var(--infi-tip-code-fg) !important;;
}

.coal .infi-root,
.navy .infi-root,
.ayu .infi-root {
    --infi-item-box-shadow: 0 1px 5px rgb(50, 50, 50);
    --infi-fs-input-fg: var(--fg);
    --infi-fs-input-focus-border: 2px solid #4f95cc;
    --infi-fs-input-focus-box-shadow: 0 0 5px -1px #63baff;
    --infi-key-fg: #fff;
    --infi-key-bg: #7d7d7d;
    --infi-checkbox-bg: #313233;
    --infi-checkbox-checked-bg: #424243;
    --infi-checkbox-border: #525354;
}

.rust .infi-root {
    --infi-fs-input-fg: var(--sidebar-fg);
    --infi-fs-input-bg: #29201d;
    --infi-fs-input-border: 2px solid #584d4a;
    --infi-fs-input-focus-border: 2px solid #4f95cc;
    --infi-fs-input-focus-box-shadow: 0 0 5px -1px #63baff;
}

.coal .infi-root {
    --infi-fs-input-bg: #1d1f21;
    --infi-fs-input-border: 2px solid #3e4144;
}

.navy .infi-root {
    --infi-fs-input-bg: #1e222f;
    --infi-fs-input-border: 2px solid #3d4252;
    --infi-sub-hover-bg: #242734;
}

.ayu .infi-root {
    --infi-fs-input-fg: var(--fg);
    --infi-fs-input-bg: #2b3035;
    --infi-fs-input-border: 2px solid #43474c;
    --infi-fs-input-focus-border: 2px solid #4f95cc;
    --infi-fs-input-focus-box-shadow: 0 0 5px -1px #63baff;
    --infi-sub-hover-bg: #282e35;
}

#infi-search {
    width: 100%;
    border-radius: 3px;
    box-sizing: border-box;
    padding: 10px 16px;
    border: 1px solid var(--searchbar-border-color);
    background: var(--searchbar-bg);
    color: var(--searchbar-fg);
}

#infi-search:focus:not(.infi-button-input) {
    box-shadow: 0 0 3px var(--searchbar-shadow-color);
}

#infi-search.infi-button-input {
    width: 100px;
}

#infi-search.infi-button-input::placeholder {
    position: relative;
    left: 14px;
}

#infi-search.infi-button-input:hover {
    transition: 0.3s ease-out;
    background: var(--infi-fs-button-input-bg) !important;
    outline: 2px solid var(--infi-fs-button-input-bg);
}

#infi-search.infi-button-input:hover::placeholder {
    color: var(--infi-fs-button-input-fg) !important;
}

@media print {
    #infi-search {
        display: none;
    }
}

#infisearch-mdbook-target {
    position: relative;
}

/*
 * For this plugin, don't show the controls until there is a query.
 */
#infisearch-mdbook-target.infi-empty-input > * {
    display: none;
}

.infi-root:not(.infi-fs-root) {
    display: block;
}

.light .infi-root .infi-title::after,
.rust .infi-root .infi-title::after,
.coal .infi-root .infi-title::after,
.navy .infi-root .infi-title::after,
.ayu .infi-root .infi-title::after {
    content: none;
    display: none;
}

.infi-header {
    padding-bottom: 9px;
}

.infi-load-more {
    padding: 7px 15px;
}
</style>
<p><input
    type="search"
    id="infi-search"
    placeholder="Search this book ..."
/></p>
<p><span style="font-weight: 600;"><!--preload weight 600--></span></p>
<div id="infisearch-mdbook-target"></div>
<h1 id="dispatcherservlet"><a class="header" href="#dispatcherservlet">DispatcherServlet</a></h1>
<ul>
<li>
<p>Spring MVC, 与其他Web框架一样,基于  central <code>Servlet</code>的控制器模式， the <code>DispatcherServlet</code>, 提供了一个共享的 请求处理算法，实际工作交给 其他配置配置的组件执行，这个模型是可弹性的，可划分工作流的</p>
</li>
<li>
<p>The <code>DispatcherServlet</code>, as any <code>Servlet</code>, 需要被申明，要么通过 Java配置指定，要么通过 web.xml 申明，然后, the <code>DispatcherServlet</code></p>
<p>使用spring注解，发现实际处理请求的 组件, 例如 视图解析器, 异常处理以及其他</p>
</li>
<li>
<p>下面的Java配置注册，并实例化一个 <code>DispatcherServlet</code> ，被<em>ServletContainer</em> 自动 发现(see <a href="https://docs.spring.io/spring-framework/docs/current/reference/html/web.html#mvc-container-config">Servlet Config</a>):</p>
</li>
</ul>
<pre><code class="language-java">public class MyWebApplicationInitializer implements WebApplicationInitializer {
    @Override
    public void onStartup(ServletContext servletContext) {
        // Load Spring web application configuration,实例化容器
        AnnotationConfigWebApplicationContext context = new AnnotationConfigWebApplicationContext();
        context.register(AppConfig.class);

        // Create and register the DispatcherServlet
        DispatcherServlet servlet = new DispatcherServlet(context); //注册servlet
        ServletRegistration.Dynamic registration = servletContext.addServlet("app", servlet);
        registration.setLoadOnStartup(1);
        registration.addMapping("/app/*");
    }
}
</code></pre>
<p>在 <em>Servlet3.0</em> 环境中，编程式配置 <em>ServletContext</em> 所要实现的接口 （与 <em>web.xml</em> 配置 相反）</p>
<p>这个 <em>SPI</em> 的实现类都会被 <em>SpringServletContainerInitializer</em> 自动检测到</p>
<h1 id="contexthierarchy"><a class="header" href="#contexthierarchy">ContextHierarchy</a></h1>
<h2 id="介绍"><a class="header" href="#介绍">介绍</a></h2>
<ul>
<li><em>DispatcherServlet</em> 需要 <em>WebApplicationContext</em> 作为配置来源</li>
<li>一般 一个 <em>WebApplicationContext</em>  对应一个 <em>Servlet</em></li>
<li>多个Servlet 对应 多个 <em>WebApplicationContext</em>  ，且共享 一个 <em>RootWebApplicationContext</em> ，共享一些基础设施的 Bean对象，例如 数据访问，通用业务服务</li>
</ul>
<p><img src="https://weisanju.github.io/note-service/java/images/mvc-context-hierarchy.png" alt="servletContext继承图" /></p>
<h2 id="配置contexthierarchy"><a class="header" href="#配置contexthierarchy">配置<em>ContextHierarchy</em></a></h2>
<pre><code class="language-java">public class MyWebAppInitializer extends AbstractAnnotationConfigDispatcherServletInitializer {

    @Override
    protected Class&lt;?&gt;[] getRootConfigClasses() {
        return new Class&lt;?&gt;[] { RootConfig.class };
    }

    @Override
    protected Class&lt;?&gt;[] getServletConfigClasses() {
        return new Class&lt;?&gt;[] { App1Config.class };
    }

    @Override
    protected String[] getServletMappings() {
        return new String[] { "/app1/*" };
    }
}
</code></pre>
<p><strong>相对应的XML配置</strong></p>
<pre><code class="language-xml">&lt;web-app&gt;

    &lt;listener&gt;
        &lt;listener-class&gt;org.springframework.web.context.ContextLoaderListener&lt;/listener-class&gt;
    &lt;/listener&gt;

    &lt;context-param&gt;
        &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt;
        &lt;param-value&gt;/WEB-INF/root-context.xml&lt;/param-value&gt;
    &lt;/context-param&gt;

    &lt;servlet&gt;
        &lt;servlet-name&gt;app1&lt;/servlet-name&gt;
        &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt;
        &lt;init-param&gt;
            &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt;
            &lt;param-value&gt;/WEB-INF/app1-context.xml&lt;/param-value&gt;
        &lt;/init-param&gt;
        &lt;load-on-startup&gt;1&lt;/load-on-startup&gt;
    &lt;/servlet&gt;

    &lt;servlet-mapping&gt;
        &lt;servlet-name&gt;app1&lt;/servlet-name&gt;
        &lt;url-pattern&gt;/app1/*&lt;/url-pattern&gt;
    &lt;/servlet-mapping&gt;

&lt;/web-app&gt;

</code></pre>
<h1 id="special-bean-types"><a class="header" href="#special-bean-types">Special Bean Types</a></h1>
<ul>
<li><code>DispatcherServlet</code> 委托各个不同的bean处理 不同的请求，渲染合适的响应</li>
<li><code>special beans</code> 意思是 spring管理的 对象</li>
<li>以下表格列出的 被 <code>DispatcherServlet</code> 检测到的   special beans</li>
</ul>
<div class="table-wrapper"><table><thead><tr><th style="text-align: left">Bean type</th><th style="text-align: left">Explanation</th></tr></thead><tbody>
<tr><td style="text-align: left"><code>HandlerMapping</code></td><td style="text-align: left">通过一系列 拦截器 将请求映射给 <em>handler</em> <br />不通的 <em>handleMapping</em> 映射逻辑各有不同<br />有两个主要的 实现 <br /><code>RequestMappingHandlerMapping</code> (支持@RequestMapping注解) <br /><code>SimpleUrlHandlerMapping</code> (维护 显示的 URLPattern To Handler的 注册)</td></tr>
<tr><td style="text-align: left"><code>HandlerAdapter</code></td><td style="text-align: left">Help the <code>DispatcherServlet</code> to invoke a handler mapped to a request,</td></tr>
<tr><td style="text-align: left"><a href="https://docs.spring.io/spring-framework/docs/current/reference/html/web.html#mvc-exceptionhandlers"><code>HandlerExceptionResolver</code></a></td><td style="text-align: left">异常处理策略, 通常把 异常 映射到 handler，HTML error views, or other targets. See <a href="https://docs.spring.io/spring-framework/docs/current/reference/html/web.html#mvc-exceptionhandlers">Exceptions</a>.</td></tr>
<tr><td style="text-align: left"><a href="https://docs.spring.io/spring-framework/docs/current/reference/html/web.html#mvc-viewresolver"><code>ViewResolver</code></a></td><td style="text-align: left">Resolve logical <code>String</code>-based view names returned from a handler to an actual <code>View</code> with which to render to the response. See <a href="https://docs.spring.io/spring-framework/docs/current/reference/html/web.html#mvc-viewresolver">View Resolution</a> and <a href="https://docs.spring.io/spring-framework/docs/current/reference/html/web.html#mvc-view">View Technologies</a>.</td></tr>
<tr><td style="text-align: left"><a href="https://docs.spring.io/spring-framework/docs/current/reference/html/web.html#mvc-localeresolver"><code>LocaleResolver</code></a>, <a href="https://docs.spring.io/spring-framework/docs/current/reference/html/web.html#mvc-timezone">LocaleContextResolver</a></td><td style="text-align: left">解决客户端国际化问题</td></tr>
<tr><td style="text-align: left"><a href="https://docs.spring.io/spring-framework/docs/current/reference/html/web.html#mvc-themeresolver"><code>ThemeResolver</code></a></td><td style="text-align: left">Resolve themes your web application can use — for example, to offer personalized layouts. See <a href="https://docs.spring.io/spring-framework/docs/current/reference/html/web.html#mvc-themeresolver">Themes</a>.</td></tr>
<tr><td style="text-align: left"><a href="https://docs.spring.io/spring-framework/docs/current/reference/html/web.html#mvc-multipart"><code>MultipartResolver</code></a></td><td style="text-align: left">Abstraction for parsing a multi-part request (for example, browser form file upload) with the help of some multipart parsing library. See <a href="https://docs.spring.io/spring-framework/docs/current/reference/html/web.html#mvc-multipart">Multipart Resolver</a>.</td></tr>
<tr><td style="text-align: left"><a href="https://docs.spring.io/spring-framework/docs/current/reference/html/web.html#mvc-flash-attributes"><code>FlashMapManager</code></a></td><td style="text-align: left">Store and retrieve the “input” and the “output” <code>FlashMap</code> that can be used to pass attributes from one request to another, usually across a redirect. See <a href="https://docs.spring.io/spring-framework/docs/current/reference/html/web.html#mvc-flash-attributes">Flash Attributes</a>.</td></tr>
</tbody></table>
</div>
<p>核心功能包括 handler映射，handler方法执行，handler异常处理，handler返回视图解析，</p>
<p>其他功能包括 客户端国际化，主题，文件上传，跨请求数据共享</p>
<h1 id="web-mvc-config"><a class="header" href="#web-mvc-config">Web MVC Config</a></h1>
<blockquote>
<p>配置 sepcial beans</p>
</blockquote>
<p>可以在容器中申明 以上提到的 <em>special beans</em> ,<code>DispatcherServlet</code>  会检查容器中的 <em>special bean</em> 如果不存在则使用声明在 <code>DispatcherServlet.properties</code> 的默认实现，</p>
<h1 id="servlet-config"><a class="header" href="#servlet-config">Servlet Config</a></h1>
<p><em>Servlet3.0</em>+ 环境中，你可以选择以 编程方式申明 Servlet容器，或者 结合 <em>web.xml</em>，以下配置 注册了一个 <code>DispatcherServlet</code></p>
<pre><code class="language-java">import org.springframework.web.WebApplicationInitializer;

public class MyWebApplicationInitializer implements WebApplicationInitializer {

    @Override
    public void onStartup(ServletContext container) {
        XmlWebApplicationContext appContext = new XmlWebApplicationContext();
        appContext.setConfigLocation("/WEB-INF/spring/dispatcher-config.xml");
        
        ServletRegistration.Dynamic registration = container.addServlet("dispatcher", new DispatcherServlet(appContext));
        registration.setLoadOnStartup(1);
        registration.addMapping("/");
    }
}
</code></pre>
<p><code>WebApplicationInitializer</code> 由springMVC提供的接口，确保你的实现能够被自动 使用，用来初始化 任何 <em>Servlet3</em> 容器，</p>
<p>抽象基类  <code>AbstractDispatcherServletInitializer</code> 使之更简单的 注册一个 <code>DispatcherServlet</code>  ，只要指定 servletMapping,和 <code>DispatcherServlet</code>  的 配置文件的位置，当然更推荐用以下方式 配置</p>
<p><strong>基于Java的Servlet配置</strong></p>
<pre><code class="language-java">public class MyWebAppInitializer extends AbstractAnnotationConfigDispatcherServletInitializer {

    @Override
    protected Class&lt;?&gt;[] getRootConfigClasses() {
        return null;
    }

    @Override
    protected Class&lt;?&gt;[] getServletConfigClasses() {
        return new Class&lt;?&gt;[] { MyWebConfig.class };
    }

    @Override
    protected String[] getServletMappings() {
        return new String[] { "/" };
    }
}
</code></pre>
<p><strong>使用XML配置的方式</strong></p>
<pre><code class="language-java">public class MyWebAppInitializer extends AbstractDispatcherServletInitializer {

    @Override
    protected WebApplicationContext createRootApplicationContext() {
        return null;
    }

    @Override
    protected WebApplicationContext createServletApplicationContext() {
        XmlWebApplicationContext cxt = new XmlWebApplicationContext();
        cxt.setConfigLocation("/WEB-INF/spring/dispatcher-config.xml");
        return cxt;
    }

    @Override
    protected String[] getServletMappings() {
        return new String[] { "/" };
    }
}
</code></pre>
<p><strong>给<em>Servlet</em>注册 <em>Filter</em></strong></p>
<pre><code class="language-java">public class MyWebAppInitializer extends AbstractDispatcherServletInitializer {

    // ...

    @Override
    protected Filter[] getServletFilters() {
        return new Filter[] {
            new HiddenHttpMethodFilter(), new CharacterEncodingFilter() };
    }
}
</code></pre>
<p>每一个<em>Filter</em> 会使用 具体类名进行命名，自动映射到 <code>DispatcherServlet</code></p>
<p>The <code>isAsyncSupported</code> protected method of <code>AbstractDispatcherServletInitializer</code>提供了一个 地方 在 <code>DispatcherServlet</code> 和所有映射到它身上的 <em>filters</em> 异步支持</p>
<p>默认为 <em>true</em></p>
<p>如果你需要 更加定制化，则 <code>createDispatcherServlet</code>  方法</p>
<h1 id="processing"><a class="header" href="#processing">Processing</a></h1>
<p>The <code>DispatcherServlet</code> 请求处理过程</p>
<ul>
<li>查询 <code>WebApplicationContext</code>  ，并绑定在 请求中，作为一个属性，供<em>Controller</em> 和其他元素使用，默认 绑定的Key是   <code>DispatcherServlet.WEB_APPLICATION_CONTEXT_ATTRIBUTE</code></li>
<li>给请求绑定 <em>locale resolver</em>  ，以便 让 元素 在处理过程中， 解析 locale</li>
<li>theme resolver 绑定主题解析器 给请求，  能构让 视图呈现不通的布局样式</li>
<li>如果你指定了 multipart file resolver, 就会检查请求是否 是<em>multipart</em>. 如果是<em>multipart</em> ，将会以<code>MultipartHttpServletRequest</code> 包装. See <a href="https://docs.spring.io/spring-framework/docs/current/reference/html/web.html#mvc-multipart">Multipart Resolver</a> for further information about multipart handling.</li>
<li>查找 指定的 <em>Handler</em>. 如果找到 ，跟执行链相关的 handler（预处理器，后处理器，控制器等）会被执行以渲染 视图响应，对于基础注解的控制器，响应能够被在 <code>HandlerAdapter</code> 中渲染，而不需要返回一个视图</li>
<li>如果 <em>model</em> 返回，则渲染视图，如果没有model返回，则不渲染视图，因为请求可能已经被 处理了</li>
</ul>
<p><code>HandlerExceptionResolver</code>  是为了处理异常，</p>
<p><code>DispatcherServlet</code> 同样支持 指定返回的  <code>last-modification-date</code> 通过Servlet API提供</p>
<p>确定特定请求的 上次修改日期 很简单，<code>DispatcherServlet</code>查找合适的 <em>handler</em>时，会判断它是否 实现了<code>LastModified</code> 接口，如果实现了则返回给 客户端</p>
<p>你能够自定义 独立的<code>DispatcherServlet</code>  实例，通过 向 <code>web.xml</code> servlet申明中，添加  Servlet initialization parameters</p>
<p>以下是支持的参数：</p>
<div class="table-wrapper"><table><thead><tr><th style="text-align: left">Parameter</th><th style="text-align: left">Explanation</th></tr></thead><tbody>
<tr><td style="text-align: left"><code>contextClass</code></td><td style="text-align: left">spring容器的类，必须要实现 <code>ConfigurableWebApplicationContext</code>，由该 <em>Servlet</em>实例化<br />默认使用 <em>XmlWebApplicationContext</em></td></tr>
<tr><td style="text-align: left">`contextConfigLocation</td><td style="text-align: left">XML配置路径<br />逗号分隔支持的多个Context. 重复定义的bean，最近优先</td></tr>
<tr><td style="text-align: left"><code>namespace</code></td><td style="text-align: left">Namespace of the <code>WebApplicationContext</code>. Defaults to <code>[servlet-name]-servlet</code>.</td></tr>
<tr><td style="text-align: left"><code>throwExceptionIfNoHandlerFound</code></td><td style="text-align: left">如果没有handler找到，要不要抛  <code>NoHandlerFoundException</code> <br />这个异常可以被 <code>HandlerExceptionResolver</code>捕获<br />(例如, by using an <code>@ExceptionHandler</code> controller method) <br />默认false, <br /> 如果false,<code>DispatcherServlet</code> sets the response status to 404 (NOT_FOUND) without raising an exception.<br />Note that, if <a href="https://docs.spring.io/spring-framework/docs/current/reference/html/web.html#mvc-default-servlet-handler">default servlet handling</a> is also configured, unresolved requests are always forwarded to the default servlet and a 404 is never raised.</td></tr>
</tbody></table>
</div>
<h1 id="interception"><a class="header" href="#interception">Interception</a></h1>
<p>所有 <code>HandlerMapping</code> 的实现都支持 拦截器，例如 身份检查。</p>
<p>拦截器实现 <code>HandlerInterceptor</code>   <code>org.springframework.web.servlet</code> 包下。</p>
<ul>
<li><code>preHandle(..)</code>: Before the actual handler is run
<ul>
<li>返回true才能继续执行</li>
<li>返回true，<code>DispatcherServlet</code> 认为 拦截器本身已处理了请求，然后渲染合适的视图</li>
</ul>
</li>
<li><code>postHandle(..)</code>: After the handler is run</li>
<li><code>afterCompletion(..)</code>: After the complete request has finished</li>
</ul>
<p>See <a href="https://docs.spring.io/spring-framework/docs/current/reference/html/web.html#mvc-config-interceptors">Interceptors</a> in the section on MVC configuration for examples of how to configure interceptors.</p>
<p>你可以在 各自<code>HandlerMapping</code>  实现里 使用 setters 直接注册</p>
<p><strong>注意</strong> <code>postHandle</code> 和  <code>@ResponseBody</code> and <code>ResponseEntity</code> 方法一起使用用处不大，因为响应已经在 <em>posthandler</em> 执行前 被 写入，提交</p>
<p>，无法对 响应做改变。例如添加额外的头，对于这种场景，建议使用  <a href="https://docs.spring.io/spring-framework/docs/current/reference/html/web.html#mvc-ann-controller-advice">Controller Advice</a> ，要么实现 <code>ResponseBodyAdvice</code>  要么申明为 <em>ControllerAdvice</em> 要么 直接配置在 <code>RequestMappingHandlerAdapter</code></p>
<h1 id="exceptions"><a class="header" href="#exceptions">Exceptions</a></h1>
<h2 id="异常实现类"><a class="header" href="#异常实现类">异常实现类</a></h2>
<p>如果在执行请求处理过程中发生异常，<code>DispatcherServlet</code> 将它 交给 <code>HandlerExceptionResolver</code>  bean做处理，</p>
<p>以下表列出了 <code>HandlerExceptionResolver</code> implementations:</p>
<div class="table-wrapper"><table><thead><tr><th style="text-align: left"><code>HandlerExceptionResolver</code></th><th style="text-align: left">Description</th></tr></thead><tbody>
<tr><td style="text-align: left"><code>SimpleMappingExceptionResolver</code></td><td style="text-align: left">异常类与 错误视图的映射处理器</td></tr>
<tr><td style="text-align: left"><a href="https://docs.spring.io/spring-framework/docs/5.3.3/javadoc-api/org/springframework/web/servlet/mvc/support/DefaultHandlerExceptionResolver.html"><code>DefaultHandlerExceptionResolver</code></a></td><td style="text-align: left">Resolves exceptions raised by Spring MVC and maps them to HTTP status codes. See also alternative <code>ResponseEntityExceptionHandler</code> and <a href="https://docs.spring.io/spring-framework/docs/current/reference/html/web.html#mvc-ann-rest-exceptions">REST API exceptions</a>.</td></tr>
<tr><td style="text-align: left"><code>ResponseStatusExceptionResolver</code></td><td style="text-align: left">Resolves exceptions with the <code>@ResponseStatus</code> annotation and maps them to HTTP status codes based on the value in the annotation.</td></tr>
<tr><td style="text-align: left"><code>ExceptionHandlerExceptionResolver</code></td><td style="text-align: left">Resolves exceptions by invoking an <code>@ExceptionHandler</code> method in a <code>@Controller</code> or a <code>@ControllerAdvice</code> class. See <a href="https://docs.spring.io/spring-framework/docs/current/reference/html/web.html#mvc-ann-exceptionhandler">@ExceptionHandler methods</a>.</td></tr>
</tbody></table>
</div>
<h2 id="chain-of-resolvers"><a class="header" href="#chain-of-resolvers">Chain of Resolvers</a></h2>
<p>You can form an exception resolver chain by declaring multiple <code>HandlerExceptionResolver</code> beans in your Spring configuration</p>
<p>您可以通过在Spring配置中声明多个<code>HandlerExceptionResolver</code> bean来形成异常解析器链。必要时可以设置顺序，顺序越高，链中的位置越后</p>
<p><code>HandlerExceptionResolver</code>接口的返回值</p>
<ul>
<li>a <code>ModelAndView</code> that points to an error view.</li>
<li>An empty <code>ModelAndView</code> if the exception was handled within the resolver.</li>
<li><code>null</code> if the exception remains unresolved, for subsequent resolvers to try, and, if the exception remains at the end, it is allowed to bubble up to the Servlet container.</li>
</ul>
<p>The <a href="https://docs.spring.io/spring-framework/docs/current/reference/html/web.html#mvc-config">MVC Config</a> automatically declares built-in resolvers for default Spring MVC exceptions, for <code>@ResponseStatus</code> annotated exceptions, and for support of <code>@ExceptionHandler</code> methods. You can customize that list or replace it.</p>
<h2 id="container-error-page"><a class="header" href="#container-error-page">Container Error Page</a></h2>
<p>If an exception remains unresolved by any <code>HandlerExceptionResolver</code> and is,</p>
<p>如果任何 异常处理 都没有解决异常，则让它继续传播，Servlet containers能够渲染 默认的HTML错误视图，自定义容器默认错误页，可以在 <em>web.xml</em> 指定错误页</p>
<pre><code class="language-xml">&lt;error-page&gt;
    &lt;location&gt;/error&lt;/location&gt;
&lt;/error-page&gt;
</code></pre>
<p>Given the preceding example, when an exception bubbles up or the response has an error status,</p>
<p>the Servlet container makes an ERROR dispatch within the container to the configured URL (for example, <code>/error</code>). This is then processed by the <code>DispatcherServlet</code>, possibly mapping it to a <code>@Controller</code>, which could be implemented to return an error view name with a model or to render a JSON response, as the following example shows:</p>
<p>基于前面的示例，当异常冒出或响应具有错误状态时，Servlet容器在容器内向配置的URL（例如，/ error）进行ERROR调度。
然后由DispatcherServlet处理，可能将其映射到@Controller，可以实现返回错误视图名称或呈现JSON响应，如以下示例所示：</p>
<pre><code class="language-java">@RestController
public class ErrorController {

    @RequestMapping(path = "/error")
    public Map&lt;String, Object&gt; handle(HttpServletRequest request) {
        Map&lt;String, Object&gt; map = new HashMap&lt;String, Object&gt;();
        map.put("status", request.getAttribute("javax.servlet.error.status_code"));
        map.put("reason", request.getAttribute("javax.servlet.error.message"));
        return map;
    }
}
</code></pre>
<blockquote>
<p>The Servlet API does not provide a way to create error page mappings in Java. You can, however, use both a <code>WebApplicationInitializer</code> and a minimal <code>web.xml</code>.</p>
</blockquote>
<h1 id="view-resolution"><a class="header" href="#view-resolution">View Resolution</a></h1>
<h2 id="viewresolver"><a class="header" href="#viewresolver">ViewResolver</a></h2>
<p><code>ViewResolver</code> 提供 view 名称与 实际 view的映射关系</p>
<p>在移交给特定的视图渲染技术之前。  <code>View</code> 主要是用来准备数据</p>
<p>以下是 <code>ViewResolver</code>的继承结构</p>
<div class="table-wrapper"><table><thead><tr><th style="text-align: left">ViewResolver</th><th style="text-align: left">Description</th></tr></thead><tbody>
<tr><td style="text-align: left"><code>AbstractCachingViewResolver</code></td><td style="text-align: left">视图缓存</td></tr>
<tr><td style="text-align: left"><code>UrlBasedViewResolver</code></td><td style="text-align: left">将URL直接映射到 视图.</td></tr>
<tr><td style="text-align: left"><code>InternalResourceViewResolver</code></td><td style="text-align: left">Convenient subclass of <code>UrlBasedViewResolver</code> that supports <code>InternalResourceView</code> (in effect, Servlets and JSPs) and subclasses such as <code>JstlView</code> and <code>TilesView</code>. You can specify the view class for all views generated by this resolver by using <code>setViewClass(..)</code>.</td></tr>
<tr><td style="text-align: left"><code>FreeMarkerViewResolver</code></td><td style="text-align: left">Convenient subclass of <code>UrlBasedViewResolver</code> that supports <code>FreeMarkerView</code> and custom subclasses of them.</td></tr>
<tr><td style="text-align: left"><code>ContentNegotiatingViewResolver</code></td><td style="text-align: left">Implementation of the <code>ViewResolver</code> interface that resolves a view based on the request file name or <code>Accept</code> header. See <a href="https://docs.spring.io/spring-framework/docs/current/reference/html/web.html#mvc-multiple-representations">Content Negotiation</a>.</td></tr>
<tr><td style="text-align: left"><code>BeanNameViewResolver</code></td><td style="text-align: left">Implementation of the <code>ViewResolver</code> interface that interprets a view name as a bean name in the current application context. This is a very flexible variant which allows for mixing and matching different view types based on distinct view names. Each such <code>View</code> can be defined as a bean e.g. in XML or in configuration classes.</td></tr>
</tbody></table>
</div>
<h1 id="locale"><a class="header" href="#locale">Locale</a></h1>
<p>spring大部分 架构支持国际化，springMVC也支持</p>
<p><code>DispatcherServlet</code> 根据 客户端的 <em>locale</em> 自动解析消息，通过 <code>LocaleResolver</code>  实现</p>
<p>当请求过来时，<code>DispatcherServlet</code> 查找 <em>locale resolver</em>  ，一旦找到一个，则尝试设置 <em>locale</em></p>
<p>使用  <code>RequestContext.getLocale()</code> 可也始终获得  locale resolve 解析的 <em>locale</em></p>
<p>另外，为了自动 locale解析，可以给 <em>handlerMapping</em> 添加 locale解析器，这适用于 根据 请求参数 改变<em>locale</em></p>
<p>以下类是常见的 locale解析实现， 定义在 org.springframework.web.servlet.i18n 包下，</p>
<ul>
<li>Time Zone</li>
</ul>
<p>In addition to obtaining the client’s locale, it is often useful to know its time zone. The <code>LocaleContextResolver</code> interface offers an extension to <code>LocaleResolver</code> that lets resolvers provide a richer <code>LocaleContext</code>, which may include time zone information.</p>
<p>When available, the user’s <code>TimeZone</code> can be obtained by using the <code>RequestContext.getTimeZone()</code> method. Time zone information is automatically used by any Date/Time <code>Converter</code> and <code>Formatter</code> objects that are registered with Spring’s <code>ConversionService</code>.</p>
<ul>
<li>Header Resolver</li>
</ul>
<p>解析客户端传过来的  <code>accept-language</code> 请求头，不支持时区信息</p>
<ul>
<li>
<p>Cookie Resolver</p>
<ul>
<li>检查 <em>Cookie</em> 钟可能会存在的   <code>Locale</code> or <code>TimeZone</code></li>
</ul>
<pre><code class="language-xml">&lt;bean id="localeResolver" class="org.springframework.web.servlet.i18n.CookieLocaleResolver"&gt;

    &lt;property name="cookieName" value="clientlanguage"/&gt;

    &lt;!-- in seconds. If set to -1, the cookie is not persisted (deleted when browser shuts down) --&gt;
    &lt;property name="cookieMaxAge" value="100000"/&gt;

&lt;/bean&gt;
</code></pre>
<div class="table-wrapper"><table><thead><tr><th style="text-align: left">Property</th><th style="text-align: left">Default</th><th style="text-align: left">Description</th></tr></thead><tbody>
<tr><td style="text-align: left"><code>cookieName</code></td><td style="text-align: left">classname + LOCALE</td><td style="text-align: left">The name of the cookie</td></tr>
<tr><td style="text-align: left"><code>cookieMaxAge</code></td><td style="text-align: left">Servlet container default</td><td style="text-align: left">The maximum time a cookie persists on the client. If <code>-1</code> is specified, the cookie will not be persisted. It is available only until the client shuts down the browser.</td></tr>
<tr><td style="text-align: left"><code>cookiePath</code></td><td style="text-align: left">/</td><td style="text-align: left">Limits the visibility of the cookie to a certain part of your site. When <code>cookiePath</code> is specified, the cookie is visible only to that path and the paths below it.</td></tr>
</tbody></table>
</div></li>
<li>
<p>Session Resolver</p>
</li>
</ul>
<p>从<em>session</em> 中取 <em>Locale and TimeZone</em> ，将本地请求的语言环境，设置在 <em>Session</em></p>
<ul>
<li>Locale Interceptor</li>
</ul>
<p>可以给 任何<code>HandlerMapping</code>  定义 应用 该 拦截器，</p>
<p>它检查请求中的参数，并改变<em>locale</em> ，以下是实例</p>
<pre><code class="language-xml">&lt;bean id="localeChangeInterceptor"
        class="org.springframework.web.servlet.i18n.LocaleChangeInterceptor"&gt;
    &lt;property name="paramName" value="siteLanguage"/&gt;
&lt;/bean&gt;

&lt;bean id="localeResolver"
        class="org.springframework.web.servlet.i18n.CookieLocaleResolver"/&gt;

&lt;bean id="urlMapping"
        class="org.springframework.web.servlet.handler.SimpleUrlHandlerMapping"&gt;
    &lt;property name="interceptors"&gt;
        &lt;list&gt;
            &lt;ref bean="localeChangeInterceptor"/&gt;
        &lt;/list&gt;
    &lt;/property&gt;
    &lt;property name="mappings"&gt;
        &lt;value&gt;/**/*.view=someController&lt;/value&gt;
    &lt;/property&gt;
&lt;/bean&gt;
</code></pre>
<h1 id="themes"><a class="header" href="#themes">Themes</a></h1>
<p>您可以应用Spring Web MVC框架主题来设置应用程序的整体外观</p>
<p>主题是 静态资源的集合，包括样式表，图片等等</p>
<h2 id="defining-a-theme"><a class="header" href="#defining-a-theme">Defining a theme</a></h2>
<p>首先实现 <code>org.springframework.ui.context.ThemeSource</code> 接口</p>
<p><code>WebApplicationContext</code>  实现了 <code>ThemeSource</code>接口，但它的实现委托给了特定的实现，默认是  <code>org.springframework.ui.context.support.ResourceBundleThemeSource</code> 这个实现，从 <em>classpath</em> 根路径加载资源</p>
<p>自定义实现，需要主动往容器中 注入 一个 themeSource</p>
<p>当您使用<code>ResourceBundleThemeSource</code>时，将在一个简单的属性文件中定义一个主题。
属性文件列出了组成主题的资源，如以下示例所示：</p>
<pre><code>styleSheet=/themes/cool/style.css
background=/themes/cool/img/coolBg.jpg
</code></pre>
<p>属性的键是从 视图 引用主题元素的名称。</p>
<p>对于  JSP 使用 <code>spring:theme</code>  标签</p>
<pre><code class="language-html">&lt;%@ taglib prefix="spring" uri="http://www.springframework.org/tags"%&gt;
&lt;html&gt;
    &lt;head&gt;
        &lt;link rel="stylesheet" href="&lt;spring:theme code='styleSheet'/&gt;" type="text/css"/&gt;
    &lt;/head&gt;
    &lt;body style="background=&lt;spring:theme code='background'/&gt;"&gt;
        ...
    &lt;/body&gt;
&lt;/html&gt;
</code></pre>
<p>默认的，<code>ResourceBundleThemeSource</code> 使用空 前缀，从 <em>classpath</em> 加载<em>properties files</em></p>
<h2 id="resolving-themes"><a class="header" href="#resolving-themes">Resolving Themes</a></h2>
<p>定义完之后，要使用，<code>DispatcherServlet</code>查找 名为 <code>themeResolver</code> 的bean，以下是已有的实现</p>
<div class="table-wrapper"><table><thead><tr><th style="text-align: left">Class</th><th style="text-align: left">Description</th></tr></thead><tbody>
<tr><td style="text-align: left"><code>FixedThemeResolver</code></td><td style="text-align: left">Selects a fixed theme, set by using the <code>defaultThemeName</code> property.</td></tr>
<tr><td style="text-align: left"><code>SessionThemeResolver</code></td><td style="text-align: left">The theme is maintained in the user’s HTTP session. It needs to be set only once for each session but is not persisted between sessions.</td></tr>
<tr><td style="text-align: left"><code>CookieThemeResolver</code></td><td style="text-align: left">The selected theme is stored in a cookie on the client.</td></tr>
</tbody></table>
</div>
<p>Spring also provides a <code>ThemeChangeInterceptor</code> that lets theme changes on every request with a simple request parameter.</p>
<h1 id="multipart-resolver"><a class="header" href="#multipart-resolver">Multipart Resolver</a></h1>
<p><code>MultipartResolver</code>  属于  <code>org.springframework.web.multipart</code>  包，是 解析 多部件请求包括文件上传 的 策略类</p>
<p>有一个实现类是 基于 <a href="https://jakarta.apache.org/commons/fileupload">Commons FileUpload</a>   有一个是 基于  Servlet 3.0 multipart request parsing</p>
<p>要启用 多部件解析，需要声明 <code>MultipartResolver</code>  ，且bean名 为 <code>multipartResolver</code></p>
<p>When a POST with content-type of <code>multipart/form-data</code> is received，<code>HttpServletRequest</code> 会被包装成<code>MultipartHttpServletRequest</code></p>
<h5 id="apache-commons-fileupload"><a class="header" href="#apache-commons-fileupload">Apache Commons <code>FileUpload</code></a></h5>
<p>使用  Apache Commons <code>FileUpload</code>，需要配置bean名为   <code>multipartResolver</code>  的  <code>CommonsMultipartResolver</code></p>
<p>需要引入 <code>commons-fileupload</code>依赖</p>
<h5 id="servlet-30"><a class="header" href="#servlet-30">Servlet 3.0</a></h5>
<p>Servlet 3.0 multipart parsing needs to be enabled through Servlet container configuration. To do so:</p>
<ul>
<li>In Java, set a <code>MultipartConfigElement</code> on the Servlet registration.注册<em>MultipartConfigElement</em></li>
</ul>
<pre><code class="language-java">public class AppInitializer extends AbstractAnnotationConfigDispatcherServletInitializer {

    // ...

    @Override
    protected void customizeRegistration(ServletRegistration.Dynamic registration) {

        // Optionally also set maxFileSize, maxRequestSize, fileSizeThreshold
        registration.setMultipartConfig(new MultipartConfigElement("/tmp"));
    }

}
</code></pre>
<ul>
<li>In <code>web.xml</code>, add a <code>"&lt;multipart-config&gt;"</code> section to the servlet declaration.</li>
</ul>
<p>一旦 Servlet3.0配置好之后, you can add a bean of type <code>StandardServletMultipartResolver</code> with a name of <code>multipartResolver</code>.</p>
<h1 id="logging"><a class="header" href="#logging">Logging</a></h1>
<p>Spring MVC中的DEBUG级别的日志记录旨在紧凑，最少且人性化</p>
<p><strong>Sensitive Data</strong></p>
<p>DEBUG and TRACE logging may log sensitive information.</p>
<p>需要启用 <code>DispatcherServlet</code> 的 <code>enableLoggingRequestDetails</code> 属性</p>
<pre><code class="language-java">public class MyInitializer
        extends AbstractAnnotationConfigDispatcherServletInitializer {

    @Override
    protected Class&lt;?&gt;[] getRootConfigClasses() {
        return ... ;
    }

    @Override
    protected Class&lt;?&gt;[] getServletConfigClasses() {
        return ... ;
    }

    @Override
    protected String[] getServletMappings() {
        return ... ;
    }

    @Override
    protected void customizeRegistration(ServletRegistration.Dynamic registration) {
        registration.setInitParameter("enableLoggingRequestDetails", "true");
    }

}
</code></pre>
<script src="/note-service/java/infisearch_assets/search-ui.chinese.bundle.js" type="text/javascript" charset="utf-8"></script>
<script src="/note-service/java/infisearch_assets/mark.min.js" type="text/javascript" charset="utf-8"></script>
<script>
const base_url = '/note-service/java/';
const mode = 'target';
infisearch.init({
  searcherOptions: {
    url: base_url + 'infisearch_output/',
  },
  uiOptions: {
    mode,
    dropdownAlignment: 'bottom-start',
    target: document.getElementById('infisearch-mdbook-target'),
    fsButtonPlaceholder: 'Search',
    sourceFilesUrl: base_url,
    resultsRenderOpts: {
      searchedTermsParam: 'search',
    },
    multiSelectFilters: [
      { fieldName: 'partTitle', displayName: 'Section', defaultOptName: 'None' },
    ],
  },
});

document.getElementById('infi-search').addEventListener('keydown', (ev) => {
  if (['ArrowLeft', 'ArrowRight'].includes(ev.key)) {
    ev.stopPropagation(); // used in global listener to change pages
    return;
  }
});

if (window.location.search) {
  // Adapted from the original searcher.js for mdbook
  // https://github.com/rust-lang/mdBook/blob/master/src/theme/searcher/searcher.js
  const target = document.getElementById('content');
  const marker = new Mark(target);

  function doSearchOrMarkFromUrl() {
    // Check current URL for search request
    var url = new URL(window.location.href);
    var urlParams = new URLSearchParams(url.search);

    if (urlParams.has('search')) {
      var words = JSON.parse(decodeURIComponent(urlParams.get('search')));
      marker.mark(words);

      var markers = document.querySelectorAll('mark');
      function hide() {
        for (var i = 0; i < markers.length; i++) {
          markers[i].classList.add('fade-out');
          window.setTimeout(function () { marker.unmark(); }, 300);
        }
      }
      for (var i = 0; i < markers.length; i++) {
        markers[i].addEventListener('click', hide);
      }
    }
  }
  doSearchOrMarkFromUrl();
}
</script>
<p><span data-infisearch-part-title="未分类"></span></p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../26.ORM_JPA/README.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="../11.spring_SpringWebMvc/URI-Links.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../26.ORM_JPA/README.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="../11.spring_SpringWebMvc/URI-Links.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>



        <script src="../clipboard.min.js"></script>
        <script src="../highlight.js"></script>
        <script src="../book.js"></script>

        <!-- Custom JS scripts -->


    </div>
    </body>
</html>
