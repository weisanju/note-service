<!DOCTYPE HTML>
<html lang="zh_CN" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>基于注解的控制器.md - JAVA笔记库</title>


        <!-- Custom HTML head -->

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="../favicon.svg">
        <link rel="shortcut icon" href="../favicon.png">
        <link rel="stylesheet" href="../css/variables.css">
        <link rel="stylesheet" href="../css/general.css">
        <link rel="stylesheet" href="../css/chrome.css">

        <!-- Fonts -->
        <link rel="stylesheet" href="../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" id="highlight-css" href="../highlight.css">
        <link rel="stylesheet" id="tomorrow-night-css" href="../tomorrow-night.css">
        <link rel="stylesheet" id="ayu-highlight-css" href="../ayu-highlight.css">

        <!-- Custom theme stylesheets -->

        <!-- MathJax -->
        <script async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>

        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "../";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="../toc.js"></script>
    </head>
    <body>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="../toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                    </div>

                    <h1 class="menu-title">JAVA笔记库</h1>

                    <div class="right-buttons">

                    </div>
                </div>


                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <link rel="stylesheet" href="/note-service/java/infisearch_assets/search-ui-light.css">
<style>.light .infi-root,
.rust .infi-root,
.coal .infi-root,
.navy .infi-root,
.ayu .infi-root {
    --infi-shadow: none;
    --infi-border: 3px solid var(--table-header-bg);
    --infi-bg: var(--bg);
    --infi-triangle-bg: var(--table-header-bg);
    --infi-item-box-shadow: 0 1px 5px rgba(196, 192, 187, 0.8);
    --infi-title-fg: var(--fg);
    --infi-title-hover-fg: var(--fg);
    --infi-title-hover-bg: var(--table-header-bg);
    --infi-title-border-bottom-hover: 2px solid var(--table-header-bg);
    --infi-heading-fg: var(--fg);
    --infi-heading-hover-fg: var(--fg);
    --infi-body-fg: var(--fg);
    --infi-body-hover-fg: var(--fg);
    --infi-sub-bg: var(--bg);
    --infi-highlight: var(--search-mark-bg);
    --infi-highlight-bg: none;
    --infi-header-fg: var(--fg);
    --infi-checkbox-bg: #f8f8f8;
    --infi-checkbox-checked-bg: #fff;
    --infi-checkbox-border: #414141;
    --infi-filter-header-active: var(--infi-title-bg);
    --infi-error-fg: var(--fg);
    --infi-fine-print-fg: var(--fg);
    --infi-loading-bg: var(--fg);
    --infi-loading-secondary-bg: var(--fg);
    --infi-load-more-fg: var(--infi-title-fg);
    --infi-load-more-bg: var(--infi-title-bg);
    --infi-load-more-hover-fg: var(--infi-title-hover-fg);
    --infi-load-more-hover-bg: var(--infi-title-hover-bg);
    --infi-scrollbar-bg: none;
    --infi-scrollbar-thumb-bg: var(--sidebar-non-existant);
    --infi-fs-button-input-fg: var(--searchbar-shadow-color);
    --infi-fs-border: 3px solid var(--sidebar-bg);
    --infi-fs-box-shadow: none;
    --infi-fs-header-bg: var(--sidebar-bg);
    --infi-fs-header-box-shadow: none;
    --infi-tip-table-header-border: var(--table-border-color);
    --infi-tip-table-border: transparent;
    --infi-tip-table-alternate: var(--table-alternate-bg);
    --infi-tip-bg: var(--sidebar-bg);
    --infi-tip-fg: var(--sidebar-fg);
    --infi-tip-code-fg: var(--inline-code-color);
    --infi-tip-code-bg: transparent;
    --infi-tip-icon-bg: rgb(230, 230, 230);
    --infi-tip-icon-fg: rgb(80, 80, 80);
}

.light .infi-root {
    --infi-fs-header-close-fg: var(--searchresults-header-fg);
    --infi-fs-header-close-hover-fg: var(--fg);
}

.ayu .infi-root,
.rust .infi-root,
.coal .infi-root,
.navy .infi-root {
    --infi-fs-header-close-fg: var(--sidebar-fg);
    --infi-fs-header-close-hover-fg: white;
}

.ayu .infi-root,
.rust .infi-root {
    --infi-tip-code-fg: var(--search-mark-bg) !important;
    --infi-tip-icon-bg: rgb(200, 200, 200);
    --infi-tip-icon-fg: rgb(50, 50, 50);
}

.light .infi-root .infi-list-item.focus,
.rust .infi-root .infi-list-item.focus,
.coal .infi-root .infi-list-item.focus,
.navy .infi-root .infi-list-item.focus,
.ayu .infi-root .infi-list-item.focus {
    outline: 2px solid grey;
}

.light .infi-root,
.coal .infi-root,
.navy .infi-root,
.ayu .infi-root {
    --infi-title-bg: var(--theme-hover);
    --infi-sub-hover-bg: var(--table-alternate-bg);
    --infi-title-border-bottom: 2px solid var(--theme-hover);
}

.light .infi-root {
    --infi-highlight: #82a6c4;
    --infi-sub-hover-bg: #ebebeb;
}

.rust .infi-root {
    --infi-highlight: #bc8e6a;

    --infi-tip-table-alternate: var(--sidebar-bg);
    --infi-title-bg: var(--table-header-bg);
    --infi-title-border-bottom: 2px solid var(--table-header-bg);

    --infi-sub-hover-bg: #c6bbb1;
    --infi-title-bg: #bbada1;
    --infi-title-border-bottom: 2px solid #bbada1;
    --infi-title-hover-fg: #000;
    --infi-title-hover-bg: #a19488;
    --infi-title-border-bottom-hover: 2px solid #a19488;
    --infi-body-hover-fg: #1e1e1e;
    --infi-heading-hover-fg: #1e1e1e;
}

.coal .infi-root {
    --infi-highlight: #496c8a;
    --infi-sub-hover-bg: #272a2b;
}

.infi-theme .infi-root .infi-tip-item code,
.rust .infi-root .infi-tip-item code {
    color: var(--infi-tip-code-fg) !important;;
}

.coal .infi-root,
.navy .infi-root,
.ayu .infi-root {
    --infi-item-box-shadow: 0 1px 5px rgb(50, 50, 50);
    --infi-fs-input-fg: var(--fg);
    --infi-fs-input-focus-border: 2px solid #4f95cc;
    --infi-fs-input-focus-box-shadow: 0 0 5px -1px #63baff;
    --infi-key-fg: #fff;
    --infi-key-bg: #7d7d7d;
    --infi-checkbox-bg: #313233;
    --infi-checkbox-checked-bg: #424243;
    --infi-checkbox-border: #525354;
}

.rust .infi-root {
    --infi-fs-input-fg: var(--sidebar-fg);
    --infi-fs-input-bg: #29201d;
    --infi-fs-input-border: 2px solid #584d4a;
    --infi-fs-input-focus-border: 2px solid #4f95cc;
    --infi-fs-input-focus-box-shadow: 0 0 5px -1px #63baff;
}

.coal .infi-root {
    --infi-fs-input-bg: #1d1f21;
    --infi-fs-input-border: 2px solid #3e4144;
}

.navy .infi-root {
    --infi-fs-input-bg: #1e222f;
    --infi-fs-input-border: 2px solid #3d4252;
    --infi-sub-hover-bg: #242734;
}

.ayu .infi-root {
    --infi-fs-input-fg: var(--fg);
    --infi-fs-input-bg: #2b3035;
    --infi-fs-input-border: 2px solid #43474c;
    --infi-fs-input-focus-border: 2px solid #4f95cc;
    --infi-fs-input-focus-box-shadow: 0 0 5px -1px #63baff;
    --infi-sub-hover-bg: #282e35;
}

#infi-search {
    width: 100%;
    border-radius: 3px;
    box-sizing: border-box;
    padding: 10px 16px;
    border: 1px solid var(--searchbar-border-color);
    background: var(--searchbar-bg);
    color: var(--searchbar-fg);
}

#infi-search:focus:not(.infi-button-input) {
    box-shadow: 0 0 3px var(--searchbar-shadow-color);
}

#infi-search.infi-button-input {
    width: 100px;
}

#infi-search.infi-button-input::placeholder {
    position: relative;
    left: 14px;
}

#infi-search.infi-button-input:hover {
    transition: 0.3s ease-out;
    background: var(--infi-fs-button-input-bg) !important;
    outline: 2px solid var(--infi-fs-button-input-bg);
}

#infi-search.infi-button-input:hover::placeholder {
    color: var(--infi-fs-button-input-fg) !important;
}

@media print {
    #infi-search {
        display: none;
    }
}

#infisearch-mdbook-target {
    position: relative;
}

/*
 * For this plugin, don't show the controls until there is a query.
 */
#infisearch-mdbook-target.infi-empty-input > * {
    display: none;
}

.infi-root:not(.infi-fs-root) {
    display: block;
}

.light .infi-root .infi-title::after,
.rust .infi-root .infi-title::after,
.coal .infi-root .infi-title::after,
.navy .infi-root .infi-title::after,
.ayu .infi-root .infi-title::after {
    content: none;
    display: none;
}

.infi-header {
    padding-bottom: 9px;
}

.infi-load-more {
    padding: 7px 15px;
}
</style>
<p><input
    type="search"
    id="infi-search"
    placeholder="Search this book ..."
/></p>
<p><span style="font-weight: 600;"><!--preload weight 600--></span></p>
<div id="infisearch-mdbook-target"></div>
<h1 id="简介"><a class="header" href="#简介">简介</a></h1>
<p>SpringMVC提供了 基于注解的编程模型  <code>@Controller</code> and <code>@RestController</code>，用来 请求映射，请求解析，异常处理等等</p>
<h1 id="申明"><a class="header" href="#申明">申明</a></h1>
<p>You can define controller beans by using a standard Spring bean definition in the.</p>
<p>可以使用 标准 spring bean定义  方式  在 Servlet’s <code>WebApplicationContext</code>中   定义 Controller bean</p>
<p><code>@Controller</code> 能自动检测，</p>
<p>To enable auto-detection of such <code>@Controller</code> beans,</p>
<p>为了能自动 检测 <em>Controller</em> <em>bean</em> ，通过java配置自动扫描</p>
<p>Java</p>
<pre><code class="language-java">@Configuration
@ComponentScan("org.example.web")
public class WebConfig {

    // ...
}
</code></pre>
<p>等价的 XML配置</p>
<pre><code class="language-xml">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;beans xmlns="http://www.springframework.org/schema/beans"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xmlns:p="http://www.springframework.org/schema/p"
    xmlns:context="http://www.springframework.org/schema/context"
    xsi:schemaLocation="
        http://www.springframework.org/schema/beans
        https://www.springframework.org/schema/beans/spring-beans.xsd
        http://www.springframework.org/schema/context
        https://www.springframework.org/schema/context/spring-context.xsd"&gt;

    &lt;context:component-scan base-package="org.example.web"/&gt;

    &lt;!-- ... --&gt;

&lt;/beans&gt;
</code></pre>
<h2 id="aop-proxies"><a class="header" href="#aop-proxies">AOP Proxies</a></h2>
<p>在某些时候，你可能需要 对 <em>Controller</em> 使用 Aop 代理</p>
<p>例如 <code>@Transactional</code> ，在这种情况，最好使用基于 类的 代理</p>
<p>For example, with <code>&lt;tx:annotation-driven/&gt;</code> you can change to <code>&lt;tx:annotation-driven proxy-target-class="true"/&gt;</code>, and with <code>@EnableTransactionManagement</code> you can change to <code>@EnableTransactionManagement(proxyTargetClass = true)</code>.</p>
<h1 id="request-mapping"><a class="header" href="#request-mapping">Request Mapping</a></h1>
<p>There are also HTTP method specific shortcut variants of <code>@RequestMapping</code>:</p>
<ul>
<li><code>@GetMapping</code></li>
<li><code>@PostMapping</code></li>
<li><code>@PutMapping</code></li>
<li><code>@DeleteMapping</code></li>
<li><code>@PatchMapping</code></li>
</ul>
<p>The shortcuts are <a href="https://docs.spring.io/spring-framework/docs/current/reference/html/web.html#mvc-ann-requestmapping-composed">Custom Annotations</a> that are provided because, arguably, most controller methods should be mapped to a specific HTTP method versus using <code>@RequestMapping</code>, which, by default, matches to all HTTP methods. At the same, a <code>@RequestMapping</code> is still needed at the class level to express shared mappings.</p>
<h2 id="uri-patterns"><a class="header" href="#uri-patterns">URI patterns</a></h2>
<p><code>@RequestMapping</code> 使用以下两种方式是进行映射</p>
<ul>
<li><code>PathPattern</code> — 直接路径匹配</li>
<li><code>AntPathMatcher</code> — 基于Ant风格</li>
</ul>
<p>Some example patterns:</p>
<ul>
<li><code>"/resources/ima?e.png"</code> - match one character in a path segment</li>
<li><code>"/resources/*.png"</code> - match zero or more characters in a path segment</li>
<li><code>"/resources/**"</code> - match multiple path segments</li>
<li><code>"/projects/{project}/versions"</code> - match a path segment and capture it as a variable URL捕获</li>
<li><code>"/projects/{project:[a-z]+}/versions"</code> - match and capture a variable with a regex</li>
</ul>
<p>Captured URI variables can be accessed with <code>@PathVariable</code>.</p>
<pre><code class="language-java">@GetMapping("/owners/{ownerId}/pets/{petId}")
public Pet findPet(@PathVariable Long ownerId, @PathVariable Long petId) {
    // ...
}
</code></pre>
<pre><code class="language-java">@Controller
@RequestMapping("/owners/{ownerId}")
public class OwnerController {

    @GetMapping("/pets/{petId}")
    public Pet findPet(@PathVariable Long ownerId, @PathVariable Long petId) {
        // ...
    }
}
</code></pre>
<p><strong>基于正则的匹配与捕获</strong></p>
<pre><code class="language-java">@GetMapping("/{name:[a-z-]+}-{version:\\d\\.\\d\\.\\d}{ext:\\.[a-z]+}")
public void handle(@PathVariable String name, @PathVariable String version, @PathVariable String ext) {
    // ...
}
</code></pre>
<h2 id="pattern-comparison"><a class="header" href="#pattern-comparison">Pattern Comparison</a></h2>
<p>多个pattern匹配时，会选择最佳匹配</p>
<p>This is done with one of the following depending on whether parsed `PathPattern’s are enabled for use or not:</p>
<ul>
<li><a href="https://docs.spring.io/spring-framework/docs/5.3.3/javadoc-api/org/springframework/web/util/pattern/PathPattern.html#SPECIFICITY_COMPARATOR"><code>PathPattern.SPECIFICITY_COMPARATOR</code></a></li>
<li><a href="https://docs.spring.io/spring-framework/docs/5.3.3/javadoc-api/org/springframework/util/AntPathMatcher.html#getPatternComparator-java.lang.String-"><code>AntPathMatcher.getPatternComparator(String path)</code></a></li>
</ul>
<p><strong>计分规则</strong></p>
<ul>
<li>
<p>URI 变量 计分为1，单 wildcard 计分为1，双wildcard 计分为2</p>
</li>
<li>
<p>分数相等，越长的优先，长度分数一致，更多的 URI变量 优先于 通配符</p>
</li>
<li>
<p>默认映射模式（<code>/ **</code>）被排除在评分之外，并且始终排在最后。</p>
</li>
<li>
<p>另外，前缀模式（例如<code>/ public / **</code> 比 /public/ 更具体 ）被认为比其他没有双通配符的模式更具体。</p>
</li>
</ul>
<h2 id="suffix-match后缀匹配"><a class="header" href="#suffix-match后缀匹配">Suffix Match后缀匹配</a></h2>
<p>从 Spring5.3，默认Spring MVC 不再支持 后缀 匹配模式， 例如 <code>/person</code>  -&gt; <code>/person.*</code></p>
<p>浏览器过去发送难以一致解释的<code>Accept</code>标头时，以这种方式使用文件扩展名是必要的。</p>
<p>随着时间的流逝，文件扩展名的使用已被证明有各种问题</p>
<p>To completely disable the use of path extensions in versions prior to 5.3, set the following:</p>
<ul>
<li><code>useSuffixPatternMatching(false)</code>, see <a href="https://docs.spring.io/spring-framework/docs/current/reference/html/web.html#mvc-config-path-matching">PathMatchConfigurer</a></li>
<li><code>favorPathExtension(false)</code>, see <a href="https://docs.spring.io/spring-framework/docs/current/reference/html/web.html#mvc-config-content-negotiation">ContentNegotiationConfigurer</a></li>
</ul>
<p>If you must use file extensions, consider restricting them to a list of explicitly registered extensions through the <code>mediaTypes</code> property of <a href="https://docs.spring.io/spring-framework/docs/current/reference/html/web.html#mvc-config-content-negotiation">ContentNegotiationConfigurer</a>.</p>
<h2 id="suffix-match-and-rfd"><a class="header" href="#suffix-match-and-rfd">Suffix Match and RFD</a></h2>
<p>A reflected file download (RFD) attack is similar to XSS in that it relies on request input (for example, a query parameter and a URI variable) being reflected in the response. However, instead of inserting JavaScript into HTML, an RFD attack relies on the browser switching to perform a download and treating the response as an executable script when double-clicked later.</p>
<p>In Spring MVC, <code>@ResponseBody</code> and <code>ResponseEntity</code> methods are at risk, because they can render different content types, which clients can request through URL path extensions. Disabling suffix pattern matching and using path extensions for content negotiation lower the risk but are not sufficient to prevent RFD attacks.</p>
<p>To prevent RFD attacks, prior to rendering the response body, Spring MVC adds a <code>Content-Disposition:inline;filename=f.txt</code> header to suggest a fixed and safe download file. This is done only if the URL path contains a file extension that is neither allowed as safe nor explicitly registered for content negotiation. However, it can potentially have side effects when URLs are typed directly into a browser.</p>
<p>Many common path extensions are allowed as safe by default. Applications with custom <code>HttpMessageConverter</code> implementations can explicitly register file extensions for content negotiation to avoid having a <code>Content-Disposition</code> header added for those extensions. See <a href="https://docs.spring.io/spring-framework/docs/current/reference/html/web.html#mvc-config-content-negotiation">Content Types</a>.</p>
<p>See <a href="https://pivotal.io/security/cve-2015-5211">CVE-2015-5211</a> for additional recommendations related to RFD.</p>
<h2 id="consumable-media-types"><a class="header" href="#consumable-media-types">Consumable Media Types</a></h2>
<pre><code class="language-java">@PostMapping(path = "/pets", consumes = "application/json") 
public void addPet(@RequestBody Pet pet) {
    // ...
}
</code></pre>
<p><strong>可以取反</strong></p>
<pre><code class="language-java">@PostMapping(path = "/pets", consumes = "!application/json") 
public void addPet(@RequestBody Pet pet) {
    // ...
}
</code></pre>
<h2 id="producible-media-types"><a class="header" href="#producible-media-types">Producible Media Types</a></h2>
<pre><code class="language-java">@GetMapping(path = "/pets/{petId}", produces = "application/json") 
@ResponseBody
public Pet getPet(@PathVariable String petId) {
    // ...
}
</code></pre>
<h2 id="parameters-headers"><a class="header" href="#parameters-headers">Parameters, headers</a></h2>
<p>You can narrow request mappings based on request parameter conditions. You can test for the presence of a request parameter (<code>myParam</code>), for the absence of one (<code>!myParam</code>), or for a specific value (<code>myParam=myValue</code>). The following example shows how to test for a specific value:</p>
<pre><code class="language-java">@GetMapping(path = "/pets/{petId}", params = "myParam=myValue") 
public void findPet(@PathVariable String petId) {
    // ...
}
</code></pre>
<h2 id="handler-methods"><a class="header" href="#handler-methods">Handler Methods</a></h2>
<p><strong>方法可以设置的参数</strong></p>
<div class="table-wrapper"><table><thead><tr><th style="text-align: left">Controller method argument</th><th style="text-align: left">Description</th></tr></thead><tbody>
<tr><td style="text-align: left"><code>WebRequest</code>, <code>NativeWebRequest</code></td><td style="text-align: left">Generic access to request parameters and request and session attributes, without direct use of the Servlet API.</td></tr>
<tr><td style="text-align: left"><code>javax.servlet.ServletRequest</code>, <code>javax.servlet.ServletResponse</code></td><td style="text-align: left">Choose any specific request or response type — for example, <code>ServletRequest</code>, <code>HttpServletRequest</code>, or Spring’s <code>MultipartRequest</code>, <code>MultipartHttpServletRequest</code>.</td></tr>
<tr><td style="text-align: left"><code>javax.servlet.http.HttpSession</code></td><td style="text-align: left">Enforces the presence of a session. As a consequence, such an argument is never <code>null</code>. Note that session access is not thread-safe. Consider setting the <code>RequestMappingHandlerAdapter</code> instance’s <code>synchronizeOnSession</code> flag to <code>true</code> if multiple requests are allowed to concurrently access a session.</td></tr>
<tr><td style="text-align: left"><code>javax.servlet.http.PushBuilder</code></td><td style="text-align: left">Servlet 4.0 push builder API for programmatic HTTP/2 resource pushes. Note that, per the Servlet specification, the injected <code>PushBuilder</code> instance can be null if the client does not support that HTTP/2 feature.</td></tr>
<tr><td style="text-align: left"><code>java.security.Principal</code></td><td style="text-align: left">Currently authenticated user — possibly a specific <code>Principal</code> implementation class if known.</td></tr>
<tr><td style="text-align: left"><code>HttpMethod</code></td><td style="text-align: left">The HTTP method of the request.</td></tr>
<tr><td style="text-align: left"><code>java.util.Locale</code></td><td style="text-align: left">The current request locale, determined by the most specific <code>LocaleResolver</code> available (in effect, the configured <code>LocaleResolver</code> or <code>LocaleContextResolver</code>).</td></tr>
<tr><td style="text-align: left"><code>java.util.TimeZone</code> + <code>java.time.ZoneId</code></td><td style="text-align: left">The time zone associated with the current request, as determined by a <code>LocaleContextResolver</code>.</td></tr>
<tr><td style="text-align: left"><code>java.io.InputStream</code>, <code>java.io.Reader</code></td><td style="text-align: left">For access to the raw request body as exposed by the Servlet API.</td></tr>
<tr><td style="text-align: left"><code>java.io.OutputStream</code>, <code>java.io.Writer</code></td><td style="text-align: left">For access to the raw response body as exposed by the Servlet API.</td></tr>
<tr><td style="text-align: left"><code>@PathVariable</code></td><td style="text-align: left">For access to URI template variables. See <a href="https://docs.spring.io/spring-framework/docs/current/reference/html/web.html#mvc-ann-requestmapping-uri-templates">URI patterns</a>.</td></tr>
<tr><td style="text-align: left"><code>@MatrixVariable</code></td><td style="text-align: left">For access to name-value pairs in URI path segments. See <a href="https://docs.spring.io/spring-framework/docs/current/reference/html/web.html#mvc-ann-matrix-variables">Matrix Variables</a>.</td></tr>
<tr><td style="text-align: left"><code>@RequestParam</code></td><td style="text-align: left">For access to the Servlet request parameters, including multipart files. Parameter values are converted to the declared method argument type. See <a href="https://docs.spring.io/spring-framework/docs/current/reference/html/web.html#mvc-ann-requestparam"><code>@RequestParam</code></a> as well as <a href="https://docs.spring.io/spring-framework/docs/current/reference/html/web.html#mvc-multipart-forms">Multipart</a>.Note that use of <code>@RequestParam</code> is optional for simple parameter values. See “Any other argument”, at the end of this table.</td></tr>
<tr><td style="text-align: left"><code>@RequestHeader</code></td><td style="text-align: left">For access to request headers. Header values are converted to the declared method argument type. See <a href="https://docs.spring.io/spring-framework/docs/current/reference/html/web.html#mvc-ann-requestheader"><code>@RequestHeader</code></a>.</td></tr>
<tr><td style="text-align: left"><code>@CookieValue</code></td><td style="text-align: left">For access to cookies. Cookies values are converted to the declared method argument type. See <a href="https://docs.spring.io/spring-framework/docs/current/reference/html/web.html#mvc-ann-cookievalue"><code>@CookieValue</code></a>.</td></tr>
<tr><td style="text-align: left"><code>@RequestBody</code></td><td style="text-align: left">For access to the HTTP request body. Body content is converted to the declared method argument type by using <code>HttpMessageConverter</code> implementations. See <a href="https://docs.spring.io/spring-framework/docs/current/reference/html/web.html#mvc-ann-requestbody"><code>@RequestBody</code></a>.</td></tr>
<tr><td style="text-align: left"><code>HttpEntity&lt;B&gt;</code></td><td style="text-align: left">For access to request headers and body. The body is converted with an <code>HttpMessageConverter</code>. See <a href="https://docs.spring.io/spring-framework/docs/current/reference/html/web.html#mvc-ann-httpentity">HttpEntity</a>.</td></tr>
<tr><td style="text-align: left"><code>@RequestPart</code></td><td style="text-align: left">For access to a part in a <code>multipart/form-data</code> request, converting the part’s body with an <code>HttpMessageConverter</code>. See <a href="https://docs.spring.io/spring-framework/docs/current/reference/html/web.html#mvc-multipart-forms">Multipart</a>.</td></tr>
<tr><td style="text-align: left"><code>java.util.Map</code>, <code>org.springframework.ui.Model</code>, <code>org.springframework.ui.ModelMap</code></td><td style="text-align: left">For access to the model that is used in HTML controllers and exposed to templates as part of view rendering.</td></tr>
<tr><td style="text-align: left"><code>RedirectAttributes</code></td><td style="text-align: left">Specify attributes to use in case of a redirect (that is, to be appended to the query string) and flash attributes to be stored temporarily until the request after redirect. See <a href="https://docs.spring.io/spring-framework/docs/current/reference/html/web.html#mvc-redirecting-passing-data">Redirect Attributes</a> and <a href="https://docs.spring.io/spring-framework/docs/current/reference/html/web.html#mvc-flash-attributes">Flash Attributes</a>.</td></tr>
<tr><td style="text-align: left"><code>@ModelAttribute</code></td><td style="text-align: left">For access to an existing attribute in the model (instantiated if not present) with data binding and validation applied. See <a href="https://docs.spring.io/spring-framework/docs/current/reference/html/web.html#mvc-ann-modelattrib-method-args"><code>@ModelAttribute</code></a> as well as <a href="https://docs.spring.io/spring-framework/docs/current/reference/html/web.html#mvc-ann-modelattrib-methods">Model</a> and <a href="https://docs.spring.io/spring-framework/docs/current/reference/html/web.html#mvc-ann-initbinder"><code>DataBinder</code></a>.Note that use of <code>@ModelAttribute</code> is optional (for example, to set its attributes). See “Any other argument” at the end of this table.</td></tr>
<tr><td style="text-align: left"><code>Errors</code>, <code>BindingResult</code></td><td style="text-align: left">For access to errors from validation and data binding for a command object (that is, a <code>@ModelAttribute</code> argument) or errors from the validation of a <code>@RequestBody</code> or <code>@RequestPart</code> arguments. You must declare an <code>Errors</code>, or <code>BindingResult</code> argument immediately after the validated method argument.</td></tr>
<tr><td style="text-align: left"><code>SessionStatus</code> + class-level <code>@SessionAttributes</code></td><td style="text-align: left">For marking form processing complete, which triggers cleanup of session attributes declared through a class-level <code>@SessionAttributes</code> annotation. See <a href="https://docs.spring.io/spring-framework/docs/current/reference/html/web.html#mvc-ann-sessionattributes"><code>@SessionAttributes</code></a> for more details.</td></tr>
<tr><td style="text-align: left"><code>UriComponentsBuilder</code></td><td style="text-align: left">For preparing a URL relative to the current request’s host, port, scheme, context path, and the literal part of the servlet mapping. See <a href="https://docs.spring.io/spring-framework/docs/current/reference/html/web.html#mvc-uri-building">URI Links</a>.</td></tr>
<tr><td style="text-align: left"><code>@SessionAttribute</code></td><td style="text-align: left">For access to any session attribute, in contrast to model attributes stored in the session as a result of a class-level <code>@SessionAttributes</code> declaration. See <a href="https://docs.spring.io/spring-framework/docs/current/reference/html/web.html#mvc-ann-sessionattribute"><code>@SessionAttribute</code></a> for more details.</td></tr>
<tr><td style="text-align: left"><code>@RequestAttribute</code></td><td style="text-align: left">For access to request attributes. See <a href="https://docs.spring.io/spring-framework/docs/current/reference/html/web.html#mvc-ann-requestattrib"><code>@RequestAttribute</code></a> for more details.</td></tr>
<tr><td style="text-align: left">Any other argument</td><td style="text-align: left">If a method argument is not matched to any of the earlier values in this table and it is a simple type (as determined by <a href="https://docs.spring.io/spring-framework/docs/5.3.3/javadoc-api/org/springframework/beans/BeanUtils.html#isSimpleProperty-java.lang.Class-">BeanUtils#isSimpleProperty</a>, it is a resolved as a <code>@RequestParam</code>. Otherwise, it is resolved as a <code>@ModelAttribute</code>.</td></tr>
</tbody></table>
</div>
<h3 id="返回值"><a class="header" href="#返回值">返回值</a></h3>
<div class="table-wrapper"><table><thead><tr><th style="text-align: left">Controller method return value</th><th style="text-align: left">Description</th></tr></thead><tbody>
<tr><td style="text-align: left"><code>@ResponseBody</code></td><td style="text-align: left">The return value is converted through <code>HttpMessageConverter</code> implementations and written to the response. See <a href="https://docs.spring.io/spring-framework/docs/current/reference/html/web.html#mvc-ann-responsebody"><code>@ResponseBody</code></a>.</td></tr>
<tr><td style="text-align: left"><code>HttpEntity&lt;B&gt;</code>, <code>ResponseEntity&lt;B&gt;</code></td><td style="text-align: left">The return value that specifies the full response (including HTTP headers and body) is to be converted through <code>HttpMessageConverter</code> implementations and written to the response. See <a href="https://docs.spring.io/spring-framework/docs/current/reference/html/web.html#mvc-ann-responseentity">ResponseEntity</a>.</td></tr>
<tr><td style="text-align: left"><code>HttpHeaders</code></td><td style="text-align: left">For returning a response with headers and no body.</td></tr>
<tr><td style="text-align: left"><code>String</code></td><td style="text-align: left">A view name to be resolved with <code>ViewResolver</code> implementations and used together with the implicit model — determined through command objects and <code>@ModelAttribute</code> methods. The handler method can also programmatically enrich the model by declaring a <code>Model</code> argument (see <a href="https://docs.spring.io/spring-framework/docs/current/reference/html/web.html#mvc-ann-requestmapping-registration">Explicit Registrations</a>).</td></tr>
<tr><td style="text-align: left"><code>View</code></td><td style="text-align: left">A <code>View</code> instance to use for rendering together with the implicit model — determined through command objects and <code>@ModelAttribute</code> methods. The handler method can also programmatically enrich the model by declaring a <code>Model</code> argument (see <a href="https://docs.spring.io/spring-framework/docs/current/reference/html/web.html#mvc-ann-requestmapping-registration">Explicit Registrations</a>).</td></tr>
<tr><td style="text-align: left"><code>java.util.Map</code>, <code>org.springframework.ui.Model</code></td><td style="text-align: left">Attributes to be added to the implicit model, with the view name implicitly determined through a <code>RequestToViewNameTranslator</code>.</td></tr>
<tr><td style="text-align: left"><code>@ModelAttribute</code></td><td style="text-align: left">An attribute to be added to the model, with the view name implicitly determined through a <code>RequestToViewNameTranslator</code>.Note that <code>@ModelAttribute</code> is optional. See "Any other return value" at the end of this table.</td></tr>
<tr><td style="text-align: left"><code>ModelAndView</code> object</td><td style="text-align: left">The view and model attributes to use and, optionally, a response status.</td></tr>
<tr><td style="text-align: left"><code>void</code></td><td style="text-align: left">A method with a <code>void</code> return type (or <code>null</code> return value) is considered to have fully handled the response if it also has a <code>ServletResponse</code>, an <code>OutputStream</code> argument, or an <code>@ResponseStatus</code> annotation. The same is also true if the controller has made a positive <code>ETag</code> or <code>lastModified</code> timestamp check (see <a href="https://docs.spring.io/spring-framework/docs/current/reference/html/web.html#mvc-caching-etag-lastmodified">Controllers</a> for details).If none of the above is true, a <code>void</code> return type can also indicate “no response body” for REST controllers or a default view name selection for HTML controllers.</td></tr>
<tr><td style="text-align: left"><code>DeferredResult&lt;V&gt;</code></td><td style="text-align: left">Produce any of the preceding return values asynchronously from any thread — for example, as a result of some event or callback. See <a href="https://docs.spring.io/spring-framework/docs/current/reference/html/web.html#mvc-ann-async">Asynchronous Requests</a> and <a href="https://docs.spring.io/spring-framework/docs/current/reference/html/web.html#mvc-ann-async-deferredresult"><code>DeferredResult</code></a>.</td></tr>
<tr><td style="text-align: left"><code>Callable&lt;V&gt;</code></td><td style="text-align: left">Produce any of the above return values asynchronously in a Spring MVC-managed thread. See <a href="https://docs.spring.io/spring-framework/docs/current/reference/html/web.html#mvc-ann-async">Asynchronous Requests</a> and <a href="https://docs.spring.io/spring-framework/docs/current/reference/html/web.html#mvc-ann-async-callable"><code>Callable</code></a>.</td></tr>
<tr><td style="text-align: left"><code>ListenableFuture&lt;V&gt;</code>, <code>java.util.concurrent.CompletionStage&lt;V&gt;</code>, <code>java.util.concurrent.CompletableFuture&lt;V&gt;</code></td><td style="text-align: left">Alternative to <code>DeferredResult</code>, as a convenience (for example, when an underlying service returns one of those).</td></tr>
<tr><td style="text-align: left"><code>ResponseBodyEmitter</code>, <code>SseEmitter</code></td><td style="text-align: left">Emit a stream of objects asynchronously to be written to the response with <code>HttpMessageConverter</code> implementations. Also supported as the body of a <code>ResponseEntity</code>. See <a href="https://docs.spring.io/spring-framework/docs/current/reference/html/web.html#mvc-ann-async">Asynchronous Requests</a> and <a href="https://docs.spring.io/spring-framework/docs/current/reference/html/web.html#mvc-ann-async-http-streaming">HTTP Streaming</a>.</td></tr>
<tr><td style="text-align: left"><code>StreamingResponseBody</code></td><td style="text-align: left">Write to the response <code>OutputStream</code> asynchronously. Also supported as the body of a <code>ResponseEntity</code>. See <a href="https://docs.spring.io/spring-framework/docs/current/reference/html/web.html#mvc-ann-async">Asynchronous Requests</a> and <a href="https://docs.spring.io/spring-framework/docs/current/reference/html/web.html#mvc-ann-async-http-streaming">HTTP Streaming</a>.</td></tr>
<tr><td style="text-align: left">Reactive types — Reactor, RxJava, or others through <code>ReactiveAdapterRegistry</code></td><td style="text-align: left">Alternative to <code>DeferredResult</code> with multi-value streams (for example, <code>Flux</code>, <code>Observable</code>) collected to a <code>List</code>.For streaming scenarios (for example, <code>text/event-stream</code>, <code>application/json+stream</code>), <code>SseEmitter</code> and <code>ResponseBodyEmitter</code> are used instead, where <code>ServletOutputStream</code> blocking I/O is performed on a Spring MVC-managed thread and back pressure is applied against the completion of each write.See <a href="https://docs.spring.io/spring-framework/docs/current/reference/html/web.html#mvc-ann-async">Asynchronous Requests</a> and <a href="https://docs.spring.io/spring-framework/docs/current/reference/html/web.html#mvc-ann-async-reactive-types">Reactive Types</a>.</td></tr>
<tr><td style="text-align: left">Any other return value</td><td style="text-align: left">Any return value that does not match any of the earlier values in this table and that is a <code>String</code> or <code>void</code> is treated as a view name (default view name selection through <code>RequestToViewNameTranslator</code> applies), provided it is not a simple type, as determined by <a href="https://docs.spring.io/spring-framework/docs/5.3.3/javadoc-api/org/springframework/beans/BeanUtils.html#isSimpleProperty-java.lang.Class-">BeanUtils#isSimpleProperty</a>. Values that are simple types remain unresolved.</td></tr>
</tbody></table>
</div>
<h2 id="type-conversion"><a class="header" href="#type-conversion">Type Conversion</a></h2>
<ul>
<li>
<p>Some annotated controller method arguments that represent <code>String</code>-based request input (such as <code>@RequestParam</code>, <code>@RequestHeader</code>, <code>@PathVariable</code>, <code>@MatrixVariable</code>, and <code>@CookieValue</code>) can require type conversion if the argument is declared as something other than <code>String</code>.</p>
</li>
<li>
<p>For such cases, type conversion is automatically applied based on the configured converters. By default, simple types (<code>int</code>, <code>long</code>, <code>Date</code>, and others) are supported. You can customize type conversion through a <code>WebDataBinder</code> (see <a href="https://docs.spring.io/spring-framework/docs/current/reference/html/web.html#mvc-ann-initbinder"><code>DataBinder</code></a>) or by registering <code>Formatters</code> with the <code>FormattingConversionService</code>. See <a href="https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#format">Spring Field Formatting</a>.</p>
</li>
<li>
<p>类型转换中的一个实际问题是处理空的String源值。This can be the case for <code>Long</code>, <code>UUID</code>, and other target types.如果要允许注入“ null”，请在参数注释上使用“ required”标志，或将参数声明为“ @Nullable”。</p>
</li>
</ul>
<p><strong>Null值处理</strong></p>
<ul>
<li>
<p>从5.3开始，即使在类型转换之后，也将强制使用非null参数，如果您的处理程序方法也打算接受null值，请在相应的@RequestParam等注释中将您的参数声明为@Nullable或将其标记为required = false。这是最佳实践，也是针对5.3升级中遇到的回归问题的推荐解决方案。</p>
</li>
<li>
<p>the resulting <code>MissingPathVariableException</code> in the case of a required <code>@PathVariable</code>.</p>
</li>
<li>
<p>转换后的空值将被视为空的原始值，因此将抛出相应的“ Missing…Exception”变体。</p>
</li>
</ul>
<h2 id="matrix-variables"><a class="header" href="#matrix-variables">Matrix Variables</a></h2>
<p><a href="https://tools.ietf.org/html/rfc3986#section-3.3">RFC 3986</a> 讨论了路径段中的 名称/值对. 在Spring MVC中，我们根据Tim Berners-Lee的<a href="https://www.w3.org/DesignIssues/MatrixURIs.html">“旧帖子”</a>将其称为“矩阵变量”，但它们也可以是被称为URI路径参数。</p>
<p>矩阵变量可以出现在任何路径段中，每个变量用分号分隔，多个值用逗号分隔，也可以通过重复的变量名称指定多个值</p>
<p><em>/cars;color=red,green;year=2012</em>  <code>color=red;color=green;color=blue</code></p>
<p>如果期望URL包含矩阵变量，则控制器方法的请求映射  必须使用URI变量来屏蔽该变量内容，并确保可以成功地匹配请求，而与矩阵变量的顺序和状态无关。
以下示例使用矩阵变量：</p>
<pre><code class="language-java">// GET /pets/42;q=11;r=22

@GetMapping("/pets/{petId}")
public void findPet(@PathVariable String petId, @MatrixVariable int q) {

    // petId == 42
    // q == 11
}
</code></pre>
<p>鉴于所有路径段都可能包含矩阵变量，因此有时您可能需要消除矩阵变量应位于哪个路径变量的歧义。下面的示例演示了如何做到这一点：</p>
<pre><code class="language-java">// GET /owners/42;q=11/pets/21;q=22, 手动指定路径变量

@GetMapping("/owners/{ownerId}/pets/{petId}")
public void findPet(
        @MatrixVariable(name="q", pathVar="ownerId") int q1,
        @MatrixVariable(name="q", pathVar="petId") int q2) {

    // q1 == 11
    // q2 == 22
}
</code></pre>
<p>矩阵变量可以 被定义为可选，并且可以指定默认值</p>
<pre><code class="language-java">// GET /pets/42

@GetMapping("/pets/{petId}")
public void findPet(@MatrixVariable(required=false, defaultValue="1") int q) {

    // q == 1
}
</code></pre>
<p><strong>获取所有矩阵变量</strong></p>
<pre><code class="language-java">// GET /owners/42;q=11;r=12/pets/21;q=22;s=23

@GetMapping("/owners/{ownerId}/pets/{petId}")
public void findPet(
        @MatrixVariable MultiValueMap&lt;String, String&gt; matrixVars,
        @MatrixVariable(pathVar="petId") MultiValueMap&lt;String, String&gt; petMatrixVars) {

    // matrixVars: ["q" : [11,22], "r" : 12, "s" : 23]
    // petMatrixVars: ["q" : 22, "s" : 23]
}
</code></pre>
<p>Note that you need to enable the use of matrix variables.</p>
<p>请注意，您需要启用矩阵变量的使用。在MVCJava配置中，设置 <code>UrlPathHelper</code> ，参数为 <code>removeSemicolonContent=false</code></p>
<p>XML配置  <code>&lt;mvc:annotation-driven enable-matrix-variables="true"/&gt;</code>.</p>
<h2 id="requestparam"><a class="header" href="#requestparam"><code>@RequestParam</code></a></h2>
<p><strong>绑定请求参数</strong></p>
<p>您可以使用@RequestParam注解将Servlet请求参数（即查询参数或表单数据）绑定到控制器中的方法参数</p>
<pre><code class="language-java">@Controller
@RequestMapping("/pets")
public class EditPetForm {

    // ...

    @GetMapping
    public String setupForm(@RequestParam("petId") int petId, Model model) { 
        Pet pet = this.clinic.loadPet(petId);
        model.addAttribute("pet", pet);
        return "petForm";
    }

    // ...

}
</code></pre>
<p>申明该注解的参数 不能为空，可以设置 <code>required</code> flag为 <em>false</em> 或者 申明为<code>java.util.Optional</code></p>
<p>将参数类型声明为数组或列表，可以为同一参数名称解析多个参数值。</p>
<p>当将@RequestParam注解 声明为 <em>Map</em> 或 <em>MultiValueMap</em> 时，在注解中未指定参数名称时，则将为每个给定参数名称 填充请求参数值</p>
<p>注意，使用@RequestParam是可选的（例如，设置其属性）。
默认情况下，任何简单值类型的参数（由<a href="https://docs.spring.io/spring-framework/docs/5.3.3/javadoc-api/org/springframework/beans/BeanUtils.html#isSimpleProperty-java.lang.Class-">BeanUtils＃isSimpleProperty</a>） 决定，并且未由其他任何参数解析器解析，则将其视为用@RequestParam注释。</p>
<h2 id="requestheader"><a class="header" href="#requestheader"><code>@RequestHeader</code></a></h2>
<p>You can use the <code>@RequestHeader</code> annotation to bind a request header to a method argument in a controller.</p>
<p>Consider the following request, with headers:</p>
<pre><code>Host                    localhost:8080
Accept                  text/html,application/xhtml+xml,application/xml;q=0.9
Accept-Language         fr,en-gb;q=0.7,en;q=0.3
Accept-Encoding         gzip,deflate
Accept-Charset          ISO-8859-1,utf-8;q=0.7,*;q=0.7
Keep-Alive              300
</code></pre>
<p>The following example gets the value of the <code>Accept-Encoding</code> and <code>Keep-Alive</code> headers:</p>
<pre><code class="language-java">@GetMapping("/demo")
public void handle(
        @RequestHeader("Accept-Encoding") String encoding, 
        @RequestHeader("Keep-Alive") long keepAlive) { 
    //...
}
</code></pre>
<p>当在Map ，MultiValueMap 或HttpHeaders参数上使用@RequestHeader 注解时，将使用所有标头值填充映射。</p>
<p>将逗号分隔的字符串转换为数组或字符串集合或类型转换系统已知的其他类型。是内置支持的，例如 @RequestHeader("Accept") 可以是 String[],List[]</p>
<h2 id="cookievalue"><a class="header" href="#cookievalue"><code>@CookieValue</code></a></h2>
<pre><code class="language-java">@GetMapping("/demo")
public void handle(@CookieValue("JSESSIONID") String cookie) { 
    //...
}
</code></pre>
<h2 id="modelattribute"><a class="header" href="#modelattribute"><code>@ModelAttribute</code></a></h2>
<p>您可以在方法参数上使用@ModelAttribute注解，以从模型访问属性，或将其实例化（如果不存在）。
model属性还覆盖了   名称与字段名称匹配的HTTP Servlet请求参数中的值。 这称为数据绑定，</p>
<p>它使您不必处理解析和转换单个查询参数和表单字段的工作。
以下示例显示了如何执行此操作：</p>
<pre><code class="language-java">@PostMapping("/owners/{ownerId}/pets/{petId}/edit")
public String processSubmit(@ModelAttribute Pet pet) { } 
</code></pre>
<p>The <code>Pet</code> instance above is resolved as follows:</p>
<ul>
<li>From the model if already added by using <a href="https://docs.spring.io/spring-framework/docs/current/reference/html/web.html#mvc-ann-modelattrib-methods">Model</a>. 首先尝试从模型中取</li>
<li>From the HTTP session by using <a href="https://docs.spring.io/spring-framework/docs/current/reference/html/web.html#mvc-ann-sessionattributes"><code>@SessionAttributes</code></a>. 从Session中取</li>
<li>From a URI path variable passed through a <code>Converter</code> (see the next example). 从Http 参数中取</li>
<li>From the invocation of a default constructor.  调用默认构造函数实例化</li>
<li>从调用具有与Servlet请求参数匹配的参数的“主要构造函数”开始。
参数名称是通过JavaBeans @ConstructorProperties或字节码中  运行时保留的参数名称确定的。</li>
</ul>
<p>另一种替代方法是将“ Converter ”与URI路径变量约定结合使用。
在以下示例中，模型属性名称“ account”与URI路径变量“ account”匹配，并且通过将“ String”帐号传递给已注册的“ Converter ”来加载“ Account”。</p>
<pre><code class="language-java">@PutMapping("/accounts/{account}")
public String save(@ModelAttribute("account") Account account) {
    // ...
}
</code></pre>
<p>The <code>WebDataBinder</code> class  匹配 请求参数名与 目标对象的字段名。匹配的名称对象在应用 类型转换之后 会被填充，有必要时  see <a href="https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#validation">Validation</a>.see <a href="https://docs.spring.io/spring-framework/docs/current/reference/html/web.html#mvc-ann-initbinder"><code>DataBinder</code></a>.</p>
<p>数据绑定可能导致错误。默认情况下，引发BindException。但是，要检查控制器方法中的此类错误，可以在@ModelAttribute旁边立即添加BindingResult参数，如以下示例所示：</p>
<pre><code class="language-java">@PostMapping("/owners/{ownerId}/pets/{petId}/edit")
public String processSubmit(@ModelAttribute("pet") Pet pet, BindingResult result) { 
    if (result.hasErrors()) {
        return "petForm";
    }
    // ...
}
</code></pre>
<p>在某些情况下，您可能希望访问没有数据绑定的模型属性。对于这种情况，可以将模型注入控制器并直接访问它，或者设置@ModelAttribute（binding = false），如以下示例所示：</p>
<pre><code class="language-java">@ModelAttribute
public AccountForm setUpForm() {
    return new AccountForm();
}

@ModelAttribute
public Account findAccount(@PathVariable String accountId) {
    return accountRepository.findOne(accountId);
}

@PostMapping("update")
public String update(@Valid AccountForm form, BindingResult result,
        @ModelAttribute(binding=false) Account account) { 
    // ...
}
</code></pre>
<p>您可以在数据绑定之后通过添加javax.validation.Valid注解 或Spring的@Validated注解 自动应用校验 (<a href="https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#validation-beanvalidation">Bean Validation</a> and <a href="https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#validation">Spring validation</a>).</p>
<pre><code class="language-java">@PostMapping("/owners/{ownerId}/pets/{petId}/edit")
public String processSubmit(@Valid @ModelAttribute("pet") Pet pet, BindingResult result) { 
    if (result.hasErrors()) {
        return "petForm";
    }
    // ...
}
</code></pre>
<p>注意，使用@ModelAttribute是可选的（例如，设置其属性）,</p>
<p>默认情况下，任何不是简单值类型的参数（由<a href="https://docs.spring.io/spring-framework/docs/5.3.3/javadoc-api/org/springframework/beans/BeanUtils.html#isSimpleProperty-java.lang.Class-">BeanUtils＃isSimpleProperty</a>）并且未由其他任何参数解析器解析，就如同使用@ModelAttribute注释一样。</p>
<h2 id="sessionattributes"><a class="header" href="#sessionattributes"><code>@SessionAttributes</code></a></h2>
<p>@SessionAttributes用于在请求之间的HTTP Servlet会话中存储模型属性。</p>
<p>它是类型级别的注释，用于声明特定控制器使用的会话属性。</p>
<p>这通常列出  应该透明地存储在会话中以供后续访问请求的模型<strong>属性的名称</strong>或模型<strong>属性的类型</strong>。</p>
<pre><code class="language-java">@Controller
@SessionAttributes("pet") 
public class EditPetForm {
    // ...
}
</code></pre>
<p>在第一个请求中，将名称为“ pet”的模型属性添加到模型时，该属性会自动提升为HTTP Servlet会话并保存在该会话中。
它会一直保留在那里，直到另一个控制器方法使用一个SessionStatus方法参数来清除存储空间为止，如以下示例所示：</p>
<pre><code class="language-java">@Controller
@SessionAttributes("pet")  //存储 pet在session中
public class EditPetForm {

    // ...

    @PostMapping("/pets/{id}")
    public String handle(Pet pet, BindingResult errors, SessionStatus status) {
        if (errors.hasErrors) {
            // ...
        }
            status.setComplete(); // 清除  session中的 pet value
            // ...
        }
    }
}
</code></pre>
<h2 id="sessionattribute"><a class="header" href="#sessionattribute"><code>@SessionAttribute</code></a></h2>
<p>如果您需要访问    全局管理（例如，在控制器外部（例如，通过过滤器））管理  且可能存在或不存在的预先存在的会话属性，则可以在方法参数上使用@SessionAttribute批注，如以下示例所示：</p>
<pre><code class="language-java">@RequestMapping("/")
public String handle(@SessionAttribute User user) { 
    // ...
}
</code></pre>
<p>Using a <code>@SessionAttribute</code> annotation.</p>
<p>For use cases that require adding or removing session attributes, consider injecting <code>org.springframework.web.context.request.WebRequest</code> or <code>javax.servlet.http.HttpSession</code> into the controller method.</p>
<p>对于需要添加或删除会话属性的用例，请考虑将org.springframework.web.context.request.WebRequest或javax.servlet.http.HttpSession注入到控制器方法中。</p>
<p>为了将模型属性作为控制器工作流的一部分临时存储在会话中，请考虑使用 <code>@SessionAttributes</code> as described in <a href="https://docs.spring.io/spring-framework/docs/current/reference/html/web.html#mvc-ann-sessionattributes"><code>@SessionAttributes</code></a>.</p>
<h2 id="requestattribute"><a class="header" href="#requestattribute"><code>@RequestAttribute</code></a></h2>
<p>Similar to <code>@SessionAttribute</code>, you can use the <code>@RequestAttribute</code> annotations to access pre-existing request attributes created earlier (for example, by a Servlet <code>Filter</code> or <code>HandlerInterceptor</code>):</p>
<p>与<code>@ SessionAttribute</code>类似，您可以使用@RequestAttribute 注解 来访问先前创建的请求属性（例如，由Servlet<code>Filter</code>或<code>HandlerInterceptor</code>创建）：</p>
<pre><code class="language-java">@GetMapping("/")
public String handle(@RequestAttribute Client client) { 
    // ...
}
</code></pre>
<h2 id="redirect-attributes"><a class="header" href="#redirect-attributes">Redirect Attributes.</a></h2>
<p>默认情况下，所有模型属性均被视为在重定向URL中作为URI模板变量公开。在其余属性中，那些属于原始类型或原始类型的集合或数组的属性会自动附加为查询参数。</p>
<p>如果专门为重定向准备了模型实例，将原始类型属性作为查询参数附加可能是理想的结果。
但是，在带注解的控制器中，模型可以包含为渲染目的添加的其他属性（例如，下拉字段值）。
为了避免此类属性出现在URL中，@RequestMapping方法可以声明类型为RedirectAttributes的参数，并使用它来指定确切的属性以供RedirectView使用。
如果该方法确实重定向，则使用<code>RedirectAttributes</code>的内容。
否则，将使用模型的内容。</p>
<p>“RequestMappingHandlerAdapter”提供了一个名为“ ignoreDefaultModelOnRedirect”的标志，您可以使用该标志指示如果控制器方法重定向，则绝不要使用默认“ Model”的内容。相反，控制器方法应声明一个类型为RedirectAttributes的属性，或者如果没有声明，则不应将任何属性传递给RedirectView。
MVC命名空间和MVC Java配置都将此标志设置为“ false”，以保持向后兼容性。
但是，对于新应用程序，我们建议将其设置为“ true”。</p>
<p>请注意，展开重定向URL时，当前请求中的URI模板变量会自动变为可用，并且您无需通过“模型”或“ RedirectAttributes”显式添加它们。</p>
<pre><code class="language-java">@PostMapping("/files/{path}")
public String upload(...) {
    // ...
    return "redirect:files/{path}";
}
</code></pre>
<p>将数据传递到重定向目标的另一种方法是使用闪存属性。与其他重定向属性不同，Flash属性保存在HTTP会话中（因此不会出现在URL中）。 See <a href="https://docs.spring.io/spring-framework/docs/current/reference/html/web.html#mvc-flash-attributes">Flash Attributes</a> for more information.</p>
<h2 id="flash-attributes"><a class="header" href="#flash-attributes">Flash Attributes</a></h2>
<p>Flash属性为一个请求 提供了 向另一种请求传递属性的 存储方式。重定向时最常需要此操作，例如Post-Redirect-Get模式。 Flash属性在重定向之前（通常在会话中）被临时保存，以便在重定向之后可供请求使用，并立即被删除。</p>
<p>Spring MVC有两个主要抽象来支持Flash属性。 FlashMap用于保存Flash属性，而FlashMapManager用于存储，检索和管理FlashMap实例。</p>
<p>Flash属性支持始终处于“打开”状态，无需显式启用。</p>
<p>在每个请求上，都有一个“输入”“ FlashMap”，其属性是从前一个请求（如果有）传递过来的；“输出”“ FlashMap”，其属性是为后续请求保存的。</p>
<p>可以通过RequestContextUtils中的静态方法从Spring MVC中的任何位置访问这两个FlashMap实例。</p>
<p>带注释的控制器通常不需要直接与FlashMap一起使用。
相反，@ RequestMapping方法可以接受RedirectAttributes类型的参数，并使用它为重定向方案添加Flash属性。
通过“ RedirectAttributes”添加的Flash属性会自动传播到“输出” FlashMap。
同样，重定向后，来自“输入”“ FlashMap”的属性会自动添加到提供目标URL的控制器的“模型”中</p>
<p><strong>Matching requests to flash attributes</strong></p>
<p>Flash属性的概念存在于许多其他Web框架中，并已证明有时会遇到并发问题。
这是因为根据定义，闪存属性将存储到下一个请求。
但是，“下一个”请求可能不是预期的接收者，而是另一个异步请求（例如，轮询或资源请求），在这种情况下，过早删除闪存属性。</p>
<p>为了减少此类问题的可能性，“ RedirectView”会自动使用目标重定向URL的路径和查询参数对“ FlashMap”实例进行“标记”。
反过来，默认的FlashMapManager在查找“输入” FlashMap时会将信息与传入请求匹配。</p>
<p>这不能完全消除并发问题的可能性，但是可以通过重定向URL中已经可用的信息大大减少并发问题。
因此，我们建议您主要将Flash属性用于重定向方案。</p>
<h2 id="multipart"><a class="header" href="#multipart">Multipart</a></h2>
<pre><code class="language-java">@Controller
public class FileUploadController {

    @PostMapping("/form")
    public String handleFormUpload(@RequestParam("name") String name,
            @RequestParam("file") MultipartFile file) {

        if (!file.isEmpty()) {
            byte[] bytes = file.getBytes();
            // store the bytes somewhere
            return "redirect:uploadSuccess";
        }
        return "redirect:uploadFailure";
    }
}
</code></pre>
<p>将参数类型声明为List 允许解析相同参数名称的多个文件。
如果将@RequestParam批注声明为Map 或MultiValueMap ，但未在批注中指定参数名称，则将使用每个给定参数名称的多部分文件填充该映射。</p>
<blockquote>
<p>使用Servlet 3.0多部分解析时，您还可以将Javax.servlet.http.Part声明为方法参数或集合值类型，而不是Spring的MultipartFile。</p>
</blockquote>
<p>您还可以将多部件内容用作数据绑定到  <a href="https://docs.spring.io/spring-framework/docs/current/reference/html/web.html#mvc-ann-modelattrib-method-args">command object</a>. 的一部分，例如表单字段，</p>
<pre><code class="language-java">class MyForm {

    private String name;

    private MultipartFile file;

    // ...
}

@Controller
public class FileUploadController {

    @PostMapping("/form")
    public String handleFormUpload(MyForm form, BindingResult errors) {
        if (!form.getFile().isEmpty()) {
            byte[] bytes = form.getFile().getBytes();
            // store the bytes somewhere
            return "redirect:uploadSuccess";
        }
        return "redirect:uploadFailure";
    }
}
</code></pre>
<p>在RESTful服务方案中，也可以从非浏览器客户端提交多部分请求。 以下示例显示了带有JSON的文件：</p>
<pre><code class="language-java">POST /someUrl
Content-Type: multipart/mixed

--edt7Tfrdusa7r3lNQc79vXuhIIMlatb7PQg7Vp
Content-Disposition: form-data; name="meta-data"
Content-Type: application/json; charset=UTF-8
Content-Transfer-Encoding: 8bit

{
    "name": "value"
}
--edt7Tfrdusa7r3lNQc79vXuhIIMlatb7PQg7Vp
Content-Disposition: form-data; name="file-data"; filename="file.properties"
Content-Type: text/xml
Content-Transfer-Encoding: 8bit
... File Data ...
</code></pre>
<p>您可以使用@RequestParam作为字符串访问“元数据”部分，但您可能希望将其从JSON反序列化（类似于“ @RequestBody”）。
在使用  <a href="https://docs.spring.io/spring-framework/docs/current/reference/html/integration.html#rest-message-conversion">HttpMessageConverter</a> 将其转换后，使用@RequestPart注解来访问多部件</p>
<pre><code class="language-java">@PostMapping("/")
public String handle(@RequestPart("meta-data") MetaData metadata,
        @RequestPart("file-data") MultipartFile file) {
    // ...
}
</code></pre>
<p>您可以将@RequestPart与javax.validation.Valid结合使用，也可以使用Spring的@Validated注释，这两种注释都会导致应用标准Bean验证。
默认情况下，验证错误会导致“ MethodArgumentNotValidException”，并将其转换为400（BAD_REQUEST）响应。
或者，您可以通过<code>Errors</code>或<code>BindingResult</code>参数在控制器内本地处理验证错误，如以下示例所示：</p>
<pre><code class="language-javascript">@PostMapping("/")
public String handle(@Valid @RequestPart("meta-data") MetaData metadata,
        BindingResult result) {
    // ...
}
</code></pre>
<h2 id="requestbody"><a class="header" href="#requestbody"><code>@RequestBody</code></a></h2>
<p>您可以使用@RequestBody 注解 使请求正文通过HttpMessageConverter读取并反序列化为Object。 以下示例使用@RequestBody参数：</p>
<pre><code class="language-java">@PostMapping("/accounts")
public void handle(@RequestBody Account account) {
    // ...
}

</code></pre>
<p>You can use the <a href="https://docs.spring.io/spring-framework/docs/current/reference/html/web.html#mvc-config-message-converters">Message Converters</a> option of the <a href="https://docs.spring.io/spring-framework/docs/current/reference/html/web.html#mvc-config">MVC Config</a> to configure or customize message conversion.</p>
<p>您可以结合使用@RequestBody和Javax.validation.Valid或Spring的@Validated注释，这两种注释都会导致应用标准Bean验证。
默认情况下，验证错误会导致“ MethodArgumentNotValidException”，并将其转换为400（BAD_REQUEST）响应。
或者，您可以通过<code>Errors</code>或<code>BindingResult</code>参数在控制器内本地处理验证错误，如以下示例所示：</p>
<pre><code class="language-java">@PostMapping("/accounts")
public void handle(@Valid @RequestBody Account account, BindingResult result) {
    // ...
}
</code></pre>
<h2 id="httpentity"><a class="header" href="#httpentity">HttpEntity</a></h2>
<p>HttpEntity或多或少与使用@RequestBody相同，但它基于公开请求标头和正文的容器对象。以下清单显示了一个示例：</p>
<pre><code class="language-java">@PostMapping("/accounts")
public void handle(HttpEntity&lt;Account&gt; entity) {
    // ...
}
</code></pre>
<h2 id="responsebody"><a class="header" href="#responsebody"><code>@ResponseBody</code></a></h2>
<p>您可以在方法上使用@ResponseBody批注，以通过HttpMessageConverter将返回序列化为响应主体。
以下清单显示了一个示例：</p>
<pre><code class="language-java">@GetMapping("/accounts/{id}")
@ResponseBody
public Account handle() {
    // ...
}
</code></pre>
<p><code>@ResponseBody</code> is also supported at the class level, in which case it is inherited by all controller methods. This is the effect of <code>@RestController</code>, which is nothing more than a meta-annotation marked with <code>@Controller</code> and <code>@ResponseBody</code>.</p>
<p>在类级别还支持@ResponseBody，在这种情况下，它由所有控制器方法继承。这就是@RestController的效果，它只不过是带有@Controller和@ResponseBody标记的元注释。</p>
<p>@ResponseBody与 响应式类型一起使用 See <a href="https://docs.spring.io/spring-framework/docs/current/reference/html/web.html#mvc-ann-async">Asynchronous Requests</a> and <a href="https://docs.spring.io/spring-framework/docs/current/reference/html/web.html#mvc-ann-async-reactive-types">Reactive Types</a> for more details.</p>
<p>You can use the <a href="https://docs.spring.io/spring-framework/docs/current/reference/html/web.html#mvc-config-message-converters">Message Converters</a> option of the <a href="https://docs.spring.io/spring-framework/docs/current/reference/html/web.html#mvc-config">MVC Config</a> to configure or customize message conversion.</p>
<p>You can combine <code>@ResponseBody</code> methods with JSON serialization views. See <a href="https://docs.spring.io/spring-framework/docs/current/reference/html/web.html#mvc-ann-jackson">Jackson JSON</a> for details.</p>
<h2 id="responseentity"><a class="header" href="#responseentity">ResponseEntity</a></h2>
<p><code>ResponseEntity</code> is like <a href="https://docs.spring.io/spring-framework/docs/current/reference/html/web.html#mvc-ann-responsebody"><code>@ResponseBody</code></a> but with status and headers. For example:</p>
<pre><code class="language-java">@GetMapping("/something")
public ResponseEntity&lt;String&gt; handle() {
    String body = ... ;
    String etag = ... ;
    return ResponseEntity.ok().eTag(etag).build(body);
}
</code></pre>
<p>Spring MVC supports using a single value <a href="https://docs.spring.io/spring-framework/docs/current/reference/html/web.html#mvc-ann-async-reactive-types">reactive type</a> to produce the <code>ResponseEntity</code> asynchronously, and/or single and multi-value reactive types for the body.</p>
<h2 id="jackson-json"><a class="header" href="#jackson-json">Jackson JSON</a></h2>
<p>Spring offers support for the Jackson JSON library.</p>
<p>Spring MVC为Jackson的序列化视图提供了内置支持，该视图仅可呈现Object中所有字段的一部分。
要将其与@ResponseBody或ResponseEntity控制器方法一起使用，可以使用Jackson的@JsonView批注来激活序列化视图类，如以下示例所示：</p>
<pre><code class="language-java">@RestController
public class UserController {

    @GetMapping("/user")
    @JsonView(User.WithoutPasswordView.class)
    public User getUser() {
        return new User("eric", "7!jd#h23");
    }
}

public class User {

    public interface WithoutPasswordView {};
    public interface WithPasswordView extends WithoutPasswordView {};

    private String username;
    private String password;

    public User() {
    }

    public User(String username, String password) {
        this.username = username;
        this.password = password;
    }

    @JsonView(WithoutPasswordView.class)
    public String getUsername() {
        return this.username;
    }

    @JsonView(WithPasswordView.class)
    public String getPassword() {
        return this.password;
    }
}
</code></pre>
<p>@JsonView允许一组视图类，但是每个控制器方法只能指定一个。
如果需要激活多个视图，则可以使用组合接口</p>
<p>如果要以编程方式执行上述操作，而不是声明@JsonView批注，请使用MappingJacksonValue包装返回值，并使用其提供序列化视图：</p>
<pre><code class="language-java">@RestController
public class UserController {

    @GetMapping("/user")
    public MappingJacksonValue getUser() {
        User user = new User("eric", "7!jd#h23");
        MappingJacksonValue value = new MappingJacksonValue(user);
        value.setSerializationView(User.WithoutPasswordView.class);
        return value;
    }
}
</code></pre>
<p>对于依赖视图解析 的控制器，可以将序列化视图类添加到模型中，如以下示例所示</p>
<pre><code class="language-java">@Controller
public class UserController extends AbstractController {

    @GetMapping("/user")
    public String getUser(Model model) {
        model.addAttribute("user", new User("eric", "7!jd#h23"));
        model.addAttribute(JsonView.class.getName(), User.WithoutPasswordView.class);
        return "userView";
    }
}
</code></pre>
<h1 id="model"><a class="header" href="#model">Model</a></h1>
<p>您可以使用<code>@ ModelAttribute</code>注解：</p>
<ul>
<li>注解在@RequestMapping方法中的方法参数中 ，  从模型创建或访问“对象”，然后通过“ WebDataBinder”将其绑定到请求。</li>
<li>作为@Controller或@ControllerAdvice类中的方法级 注解，可在任何@RequestMapping方法调用之前帮助初始化模型。</li>
<li>在@RequestMapping方法上   标记其返回值的是模型属性</li>
</ul>
<p>This section discusses <code>@ModelAttribute</code> methods的第二项 控制器可以具有任意数量的@ModelAttribute方法，所有这些方法均在同一控制器中的@RequestMapping方法之前被调用,也可以通过@ControllerAdvice在控制器之间共享@ModelAttribute方法。See the section on <a href="https://docs.spring.io/spring-framework/docs/current/reference/html/web.html#mvc-ann-controller-advice">Controller Advice</a> for more details.</p>
<pre><code class="language-java">@ModelAttribute
public void populateModel(@RequestParam String number, Model model) {
    model.addAttribute(accountRepository.findAccount(number));
    // add more ...
}
</code></pre>
<p>The following example adds only one attribute:</p>
<pre><code class="language-java">@ModelAttribute
public Account addAccount(@RequestParam String number) {
    return accountRepository.findAccount(number);
}
</code></pre>
<p>如果未明确指定名称，则根据“对象”类型选择默认名称，如约定的javadoc中所述。 您始终可以使用重载的addAttribute方法或通过@ModelAttribute上的name属性（用于返回值）来分配显式名称。</p>
<p>您也可以将@ModelAttribute用作@RequestMapping方法上的方法级注释，在这种情况下，@ RequestMapping方法的返回值将解释为模型属性。
通常不需要这样做，因为它是HTML控制器的默认行为，除非返回值是一个String，否则它将被解释为视图名称。
@ModelAttribute还可以自定义模型属性名称，如以下示例所示：</p>
<pre><code class="language-java">@GetMapping("/accounts/{id}")
@ModelAttribute("myAccount")
public Account handle() {
    // ...
    return account;
}
</code></pre>
<h1 id="databinder"><a class="header" href="#databinder"><code>DataBinder</code></a></h1>
<p>@Controller或@ControllerAdvice类   可以具有用于初始化WebDataBinder实例的@InitBinder方法，而这些方法又可以：</p>
<ul>
<li>将请求参数（即表单或查询数据）绑定到模型对象。</li>
<li>将基于字符串的请求值（例如请求参数，路径变量，标头，Cookie等）转换为控制器方法参数的目标类型。</li>
<li>呈现HTML表单时，将模型对象的值格式化为String值。</li>
</ul>
<p>@InitBinder方法可以注册特定于控制器的java.beans.PropertyEditor或Spring Converter和Formatter组件。
此外，您可以使用MVC配置在全局共享的FormattingConversionService中注册Converter和Formatter类型。</p>
<p>@InitBinder方法支持与@RequestMapping方法相同的许多参数，除了@ModelAttribute（命令对象）参数。
通常，它们使用WebDataBinder参数（用于注册）和 返回 void
以下清单显示了一个示例：</p>
<p>另外，当通过共享的FormattingConversionService使用基于Formatter的设置时，可以重新使用相同的方法并注册特定于控制器的Formatter实现，如以下示例所示：</p>
<pre><code class="language-java">@Controller
public class FormController {

    @InitBinder 
    protected void initBinder(WebDataBinder binder) {
        binder.addCustomFormatter(new DateFormatter("yyyy-MM-dd"));
    }

    // ...
}
</code></pre>
<h1 id="exceptions"><a class="header" href="#exceptions">Exceptions</a></h1>
<p>@Controller和@ControllerAdvice类可以具有@ExceptionHandler方法来处理控制器方法的异常，如以下示例所示：</p>
<pre><code class="language-java">@Controller
public class SimpleController {

    // ...

    @ExceptionHandler
    public ResponseEntity&lt;String&gt; handle(IOException ex) {
        // ...
    }
}
</code></pre>
<ul>
<li>该异常可能与正在传播的顶级异常（例如，直接IOException被抛出）匹配，</li>
<li>也可能与包装器异常内的嵌套原因（例如，包装在IllegalStateException中的IOException）相匹配。</li>
<li>从5.3开始，这可以在任意  原因异常 级别上匹配，而以前只考虑了直接原因。</li>
</ul>
<p>对于匹配的异常类型，如前面的示例所示，最好将目标异常声明为方法参数。当多个异常方法匹配时，根源异常匹配通常比 原因异常 匹配更可取。
更具体地说，ExceptionDepthComparator用于根据从引发的异常类型开始的深度对异常进行排序。</p>
<p>另外，注释声明可以缩小异常类型以使其匹配，如以下示例所示：</p>
<pre><code class="language-java">@ExceptionHandler({FileSystemException.class, RemoteException.class})
public ResponseEntity&lt;String&gt; handle(IOException ex) {
    // ...
}
</code></pre>
<p>您甚至可以使用带有非常<strong>通用的参数签名</strong>的<strong>特定异常类型的列表</strong>，如以下示例所示：</p>
<pre><code class="language-java">@ExceptionHandler({FileSystemException.class, RemoteException.class})
public ResponseEntity&lt;String&gt; handle(Exception ex) {
    // ...
}
</code></pre>
<p><strong>root and cause exception matching</strong></p>
<p>在前面显示的IOException变体中，通常使用实际的FileSystemException或RemoteException实例作为参数来调用该方法，因为这两个实例均从IOException扩展。但是，如果任何此类匹配异常都在本身是IOException的包装器异常中传播，则传入的异常实例就是该包装器异常。</p>
<p>仅当将它们作为顶级异常抛出时，传入的异常才是实际的FileSystemException或RemoteException实例。</p>
<p>我们通常建议您在参数签名中尽可能具体，以减少根类型和原因异常类型之间不匹配的可能性。
考虑将多重匹配方法分解为单独的@ExceptionHandler方法，每个方法均通过其签名匹配单个特定的异常类型。</p>
<p>最后但并非最不重要的一点是，@ExceptionHandler方法实现可以选择通过以原始形式重新抛出异常来退出处理给定异常实例。
在仅对根级别匹配或无法静态确定的特定上下文中的匹配感兴趣的情况下，这很有用。
重新抛出的异常会在其余的解决方案链中传播，就像给定的@ExceptionHandler方法最初不会匹配一样。</p>
<p>Spring MVC中对@ExceptionHandler方法的支持建立在DispatcherServlet级别HandlerExceptionResolver机制上。</p>
<h2 id="method-arguments"><a class="header" href="#method-arguments">Method Arguments</a></h2>
<p><code>@ExceptionHandler</code> 方法支持 以下参数</p>
<div class="table-wrapper"><table><thead><tr><th style="text-align: left">Method argument</th><th style="text-align: left">Description</th></tr></thead><tbody>
<tr><td style="text-align: left">Exception type</td><td style="text-align: left">For access to the raised exception.</td></tr>
<tr><td style="text-align: left"><code>HandlerMethod</code></td><td style="text-align: left">For access to the controller method that raised the exception.</td></tr>
<tr><td style="text-align: left"><code>WebRequest</code>, <code>NativeWebRequest</code></td><td style="text-align: left">Generic access to request parameters and request and session attributes without direct use of the Servlet API.</td></tr>
<tr><td style="text-align: left"><code>javax.servlet.ServletRequest</code>, <code>javax.servlet.ServletResponse</code></td><td style="text-align: left">Choose any specific request or response type (for example, <code>ServletRequest</code> or <code>HttpServletRequest</code> or Spring’s <code>MultipartRequest</code> or <code>MultipartHttpServletRequest</code>).</td></tr>
<tr><td style="text-align: left"><code>javax.servlet.http.HttpSession</code></td><td style="text-align: left">Enforces the presence of a session. As a consequence, such an argument is never <code>null</code>. Note that session access is not thread-safe. Consider setting the <code>RequestMappingHandlerAdapter</code> instance’s <code>synchronizeOnSession</code> flag to <code>true</code> if multiple requests are allowed to access a session concurrently.</td></tr>
<tr><td style="text-align: left"><code>java.security.Principal</code></td><td style="text-align: left">Currently authenticated user — possibly a specific <code>Principal</code> implementation class if known.</td></tr>
<tr><td style="text-align: left"><code>HttpMethod</code></td><td style="text-align: left">The HTTP method of the request.</td></tr>
<tr><td style="text-align: left"><code>java.util.Locale</code></td><td style="text-align: left">The current request locale, determined by the most specific <code>LocaleResolver</code> available — in effect, the configured <code>LocaleResolver</code> or <code>LocaleContextResolver</code>.</td></tr>
<tr><td style="text-align: left"><code>java.util.TimeZone</code>, <code>java.time.ZoneId</code></td><td style="text-align: left">The time zone associated with the current request, as determined by a <code>LocaleContextResolver</code>.</td></tr>
<tr><td style="text-align: left"><code>java.io.OutputStream</code>, <code>java.io.Writer</code></td><td style="text-align: left">For access to the raw response body, as exposed by the Servlet API.</td></tr>
<tr><td style="text-align: left"><code>java.util.Map</code>, <code>org.springframework.ui.Model</code>, <code>org.springframework.ui.ModelMap</code></td><td style="text-align: left">For access to the model for an error response. Always empty.</td></tr>
<tr><td style="text-align: left"><code>RedirectAttributes</code></td><td style="text-align: left">Specify attributes to use in case of a redirect — (that is to be appended to the query string) and flash attributes to be stored temporarily until the request after the redirect. See <a href="https://docs.spring.io/spring-framework/docs/current/reference/html/web.html#mvc-redirecting-passing-data">Redirect Attributes</a> and <a href="https://docs.spring.io/spring-framework/docs/current/reference/html/web.html#mvc-flash-attributes">Flash Attributes</a>.</td></tr>
<tr><td style="text-align: left"><code>@SessionAttribute</code></td><td style="text-align: left">For access to any session attribute, in contrast to model attributes stored in the session as a result of a class-level <code>@SessionAttributes</code> declaration. See <a href="https://docs.spring.io/spring-framework/docs/current/reference/html/web.html#mvc-ann-sessionattribute"><code>@SessionAttribute</code></a> for more details.</td></tr>
<tr><td style="text-align: left"><code>@RequestAttribute</code></td><td style="text-align: left">For access to request attributes. See <a href="https://docs.spring.io/spring-framework/docs/current/reference/html/web.html#mvc-ann-requestattrib"><code>@RequestAttribute</code></a> for more details.</td></tr>
</tbody></table>
</div>
<p><strong>返回值</strong></p>
<div class="table-wrapper"><table><thead><tr><th style="text-align: left">Return value</th><th style="text-align: left">Description</th></tr></thead><tbody>
<tr><td style="text-align: left"><code>@ResponseBody</code></td><td style="text-align: left">The return value is converted through <code>HttpMessageConverter</code> instances and written to the response. See <a href="https://docs.spring.io/spring-framework/docs/current/reference/html/web.html#mvc-ann-responsebody"><code>@ResponseBody</code></a>.</td></tr>
<tr><td style="text-align: left"><code>HttpEntity&lt;B&gt;</code>, <code>ResponseEntity&lt;B&gt;</code></td><td style="text-align: left">The return value specifies that the full response (including the HTTP headers and the body) be converted through <code>HttpMessageConverter</code> instances and written to the response. See <a href="https://docs.spring.io/spring-framework/docs/current/reference/html/web.html#mvc-ann-responseentity">ResponseEntity</a>.</td></tr>
<tr><td style="text-align: left"><code>String</code></td><td style="text-align: left">A view name to be resolved with <code>ViewResolver</code> implementations and used together with the implicit model — determined through command objects and <code>@ModelAttribute</code> methods. The handler method can also programmatically enrich the model by declaring a <code>Model</code> argument (described earlier).</td></tr>
<tr><td style="text-align: left"><code>View</code></td><td style="text-align: left">A <code>View</code> instance to use for rendering together with the implicit model — determined through command objects and <code>@ModelAttribute</code> methods. The handler method may also programmatically enrich the model by declaring a <code>Model</code> argument (descried earlier).</td></tr>
<tr><td style="text-align: left"><code>java.util.Map</code>, <code>org.springframework.ui.Model</code></td><td style="text-align: left">Attributes to be added to the implicit model with the view name implicitly determined through a <code>RequestToViewNameTranslator</code>.</td></tr>
<tr><td style="text-align: left"><code>@ModelAttribute</code></td><td style="text-align: left">An attribute to be added to the model with the view name implicitly determined through a <code>RequestToViewNameTranslator</code>.Note that <code>@ModelAttribute</code> is optional. See “Any other return value” at the end of this table.</td></tr>
<tr><td style="text-align: left"><code>ModelAndView</code> object</td><td style="text-align: left">The view and model attributes to use and, optionally, a response status.</td></tr>
<tr><td style="text-align: left"><code>void</code></td><td style="text-align: left">A method with a <code>void</code> return type (or <code>null</code> return value) is considered to have fully handled the response if it also has a <code>ServletResponse</code> an <code>OutputStream</code> argument, or a <code>@ResponseStatus</code> annotation. The same is also true if the controller has made a positive <code>ETag</code> or <code>lastModified</code> timestamp check (see <a href="https://docs.spring.io/spring-framework/docs/current/reference/html/web.html#mvc-caching-etag-lastmodified">Controllers</a> for details).If none of the above is true, a <code>void</code> return type can also indicate “no response body” for REST controllers or default view name selection for HTML controllers.</td></tr>
<tr><td style="text-align: left">Any other return value</td><td style="text-align: left">If a return value is not matched to any of the above and is not a simple type (as determined by <a href="https://docs.spring.io/spring-framework/docs/5.3.3/javadoc-api/org/springframework/beans/BeanUtils.html#isSimpleProperty-java.lang.Class-">BeanUtils#isSimpleProperty</a>), by default, it is treated as a model attribute to be added to the model. If it is a simple type, it remains unresolved.</td></tr>
</tbody></table>
</div>
<h2 id="rest-api-exceptions"><a class="header" href="#rest-api-exceptions">REST API exceptions</a></h2>
<p>REST服务的常见要求是在响应正文中包含错误详细信息。
Spring框架不会自动执行此操作，因为响应主体中错误详细信息的表示是特定于应用程序的。
但是，@ RestController可以将@ExceptionHandler方法与ResponseEntity返回值一起使用，以设置响应的状态和主体。
也可以在@ControllerAdvice类中声明此类方法，以将其全局应用。</p>
<p>在响应主体中实现具有错误详细信息的全局异常处理的应用程序应考虑扩展ResponseEntityExceptionHandler，它提供了Spring MVC引发的异常的处理并提供了自定义响应主体的钩子。
要使用此功能，请创建ResponseEntityExceptionHandler的子类，并使用@ControllerAdvice对其进行注释，重写必需的方法，并将其声明为Spring bean。</p>
<h1 id="controller-advice"><a class="header" href="#controller-advice">Controller Advice</a></h1>
<p>通常，@ ExceptionHandler，@ InitBinder和@ModelAttribute方法在声明它们的@Controller类（或类层次结构）中应用。
如果要使<strong>此类方法更全局地应用</strong>（跨控制器），则可以在带有@ControllerAdvice或@RestControllerAdvice注释的类中声明它们。</p>
<ul>
<li>启动时，@RequestMapping和@ExceptionHandler方法的基础结构类将检测使用  @ControllerAdvice注释的Spring bean，然后在运行时应用其方法。
全局@ExceptionHandler方法（来自@ControllerAdvice）在本地方法（来自@Controller）之后应用。</li>
<li>相比之下，全局@ModelAttribute和@InitBinder方法在本地方法之前应用。</li>
</ul>
<p>默认情况下，@ ControllerAdvice方法适用于每个请求（即所有控制器），但是您可以通过使用批注上的属性将其范围缩小到控制器的子集，如以下示例所示：</p>
<pre><code class="language-java">// Target all Controllers annotated with @RestController 所有RestController
@ControllerAdvice(annotations = RestController.class)
public class ExampleAdvice1 {}

// Target all Controllers within specific packages 特定 controller类
@ControllerAdvice("org.example.controllers")
public class ExampleAdvice2 {}

// Target all Controllers assignable to specific classes  抽象基类
@ControllerAdvice(assignableTypes = {ControllerInterface.class, AbstractController.class})
public class ExampleAdvice3 {}
</code></pre>
<p>前面示例中的选择器在运行时进行评估，如果广泛使用，可能会对性能产生负面影响。
有关更多详细信息，请参见@ControllerAdvice javadoc。</p>
<script src="/note-service/java/infisearch_assets/search-ui.chinese.bundle.js" type="text/javascript" charset="utf-8"></script>
<script src="/note-service/java/infisearch_assets/mark.min.js" type="text/javascript" charset="utf-8"></script>
<script>
const base_url = '/note-service/java/';
const mode = 'target';
infisearch.init({
  searcherOptions: {
    url: base_url + 'infisearch_output/',
  },
  uiOptions: {
    mode,
    dropdownAlignment: 'bottom-start',
    target: document.getElementById('infisearch-mdbook-target'),
    fsButtonPlaceholder: 'Search',
    sourceFilesUrl: base_url,
    resultsRenderOpts: {
      searchedTermsParam: 'search',
    },
    multiSelectFilters: [
      { fieldName: 'partTitle', displayName: 'Section', defaultOptName: 'None' },
    ],
  },
});

document.getElementById('infi-search').addEventListener('keydown', (ev) => {
  if (['ArrowLeft', 'ArrowRight'].includes(ev.key)) {
    ev.stopPropagation(); // used in global listener to change pages
    return;
  }
});

if (window.location.search) {
  // Adapted from the original searcher.js for mdbook
  // https://github.com/rust-lang/mdBook/blob/master/src/theme/searcher/searcher.js
  const target = document.getElementById('content');
  const marker = new Mark(target);

  function doSearchOrMarkFromUrl() {
    // Check current URL for search request
    var url = new URL(window.location.href);
    var urlParams = new URLSearchParams(url.search);

    if (urlParams.has('search')) {
      var words = JSON.parse(decodeURIComponent(urlParams.get('search')));
      marker.mark(words);

      var markers = document.querySelectorAll('mark');
      function hide() {
        for (var i = 0; i < markers.length; i++) {
          markers[i].classList.add('fade-out');
          window.setTimeout(function () { marker.unmark(); }, 300);
        }
      }
      for (var i = 0; i < markers.length; i++) {
        markers[i].addEventListener('click', hide);
      }
    }
  }
  doSearchOrMarkFromUrl();
}
</script>
<p><span data-infisearch-part-title="未分类"></span></p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../11.spring_SpringWebMvc/内置四种filters.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="../21.单元测试_JUNIT5/README.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../11.spring_SpringWebMvc/内置四种filters.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="../21.单元测试_JUNIT5/README.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>



        <script src="../clipboard.min.js"></script>
        <script src="../highlight.js"></script>
        <script src="../book.js"></script>

        <!-- Custom JS scripts -->


    </div>
    </body>
</html>
