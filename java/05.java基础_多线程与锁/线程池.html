<!DOCTYPE HTML>
<html lang="zh_CN" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>线程池.md - JAVA笔记库</title>


        <!-- Custom HTML head -->

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="../favicon.svg">
        <link rel="shortcut icon" href="../favicon.png">
        <link rel="stylesheet" href="../css/variables.css">
        <link rel="stylesheet" href="../css/general.css">
        <link rel="stylesheet" href="../css/chrome.css">

        <!-- Fonts -->
        <link rel="stylesheet" href="../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" id="highlight-css" href="../highlight.css">
        <link rel="stylesheet" id="tomorrow-night-css" href="../tomorrow-night.css">
        <link rel="stylesheet" id="ayu-highlight-css" href="../ayu-highlight.css">

        <!-- Custom theme stylesheets -->

        <!-- MathJax -->
        <script async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>

        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "../";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="../toc.js"></script>
    </head>
    <body>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="../toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                    </div>

                    <h1 class="menu-title">JAVA笔记库</h1>

                    <div class="right-buttons">

                    </div>
                </div>


                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <link rel="stylesheet" href="/note-service/java/infisearch_assets/search-ui-light.css">
<style>.light .infi-root,
.rust .infi-root,
.coal .infi-root,
.navy .infi-root,
.ayu .infi-root {
    --infi-shadow: none;
    --infi-border: 3px solid var(--table-header-bg);
    --infi-bg: var(--bg);
    --infi-triangle-bg: var(--table-header-bg);
    --infi-item-box-shadow: 0 1px 5px rgba(196, 192, 187, 0.8);
    --infi-title-fg: var(--fg);
    --infi-title-hover-fg: var(--fg);
    --infi-title-hover-bg: var(--table-header-bg);
    --infi-title-border-bottom-hover: 2px solid var(--table-header-bg);
    --infi-heading-fg: var(--fg);
    --infi-heading-hover-fg: var(--fg);
    --infi-body-fg: var(--fg);
    --infi-body-hover-fg: var(--fg);
    --infi-sub-bg: var(--bg);
    --infi-highlight: var(--search-mark-bg);
    --infi-highlight-bg: none;
    --infi-header-fg: var(--fg);
    --infi-checkbox-bg: #f8f8f8;
    --infi-checkbox-checked-bg: #fff;
    --infi-checkbox-border: #414141;
    --infi-filter-header-active: var(--infi-title-bg);
    --infi-error-fg: var(--fg);
    --infi-fine-print-fg: var(--fg);
    --infi-loading-bg: var(--fg);
    --infi-loading-secondary-bg: var(--fg);
    --infi-load-more-fg: var(--infi-title-fg);
    --infi-load-more-bg: var(--infi-title-bg);
    --infi-load-more-hover-fg: var(--infi-title-hover-fg);
    --infi-load-more-hover-bg: var(--infi-title-hover-bg);
    --infi-scrollbar-bg: none;
    --infi-scrollbar-thumb-bg: var(--sidebar-non-existant);
    --infi-fs-button-input-fg: var(--searchbar-shadow-color);
    --infi-fs-border: 3px solid var(--sidebar-bg);
    --infi-fs-box-shadow: none;
    --infi-fs-header-bg: var(--sidebar-bg);
    --infi-fs-header-box-shadow: none;
    --infi-tip-table-header-border: var(--table-border-color);
    --infi-tip-table-border: transparent;
    --infi-tip-table-alternate: var(--table-alternate-bg);
    --infi-tip-bg: var(--sidebar-bg);
    --infi-tip-fg: var(--sidebar-fg);
    --infi-tip-code-fg: var(--inline-code-color);
    --infi-tip-code-bg: transparent;
    --infi-tip-icon-bg: rgb(230, 230, 230);
    --infi-tip-icon-fg: rgb(80, 80, 80);
}

.light .infi-root {
    --infi-fs-header-close-fg: var(--searchresults-header-fg);
    --infi-fs-header-close-hover-fg: var(--fg);
}

.ayu .infi-root,
.rust .infi-root,
.coal .infi-root,
.navy .infi-root {
    --infi-fs-header-close-fg: var(--sidebar-fg);
    --infi-fs-header-close-hover-fg: white;
}

.ayu .infi-root,
.rust .infi-root {
    --infi-tip-code-fg: var(--search-mark-bg) !important;
    --infi-tip-icon-bg: rgb(200, 200, 200);
    --infi-tip-icon-fg: rgb(50, 50, 50);
}

.light .infi-root .infi-list-item.focus,
.rust .infi-root .infi-list-item.focus,
.coal .infi-root .infi-list-item.focus,
.navy .infi-root .infi-list-item.focus,
.ayu .infi-root .infi-list-item.focus {
    outline: 2px solid grey;
}

.light .infi-root,
.coal .infi-root,
.navy .infi-root,
.ayu .infi-root {
    --infi-title-bg: var(--theme-hover);
    --infi-sub-hover-bg: var(--table-alternate-bg);
    --infi-title-border-bottom: 2px solid var(--theme-hover);
}

.light .infi-root {
    --infi-highlight: #82a6c4;
    --infi-sub-hover-bg: #ebebeb;
}

.rust .infi-root {
    --infi-highlight: #bc8e6a;

    --infi-tip-table-alternate: var(--sidebar-bg);
    --infi-title-bg: var(--table-header-bg);
    --infi-title-border-bottom: 2px solid var(--table-header-bg);

    --infi-sub-hover-bg: #c6bbb1;
    --infi-title-bg: #bbada1;
    --infi-title-border-bottom: 2px solid #bbada1;
    --infi-title-hover-fg: #000;
    --infi-title-hover-bg: #a19488;
    --infi-title-border-bottom-hover: 2px solid #a19488;
    --infi-body-hover-fg: #1e1e1e;
    --infi-heading-hover-fg: #1e1e1e;
}

.coal .infi-root {
    --infi-highlight: #496c8a;
    --infi-sub-hover-bg: #272a2b;
}

.infi-theme .infi-root .infi-tip-item code,
.rust .infi-root .infi-tip-item code {
    color: var(--infi-tip-code-fg) !important;;
}

.coal .infi-root,
.navy .infi-root,
.ayu .infi-root {
    --infi-item-box-shadow: 0 1px 5px rgb(50, 50, 50);
    --infi-fs-input-fg: var(--fg);
    --infi-fs-input-focus-border: 2px solid #4f95cc;
    --infi-fs-input-focus-box-shadow: 0 0 5px -1px #63baff;
    --infi-key-fg: #fff;
    --infi-key-bg: #7d7d7d;
    --infi-checkbox-bg: #313233;
    --infi-checkbox-checked-bg: #424243;
    --infi-checkbox-border: #525354;
}

.rust .infi-root {
    --infi-fs-input-fg: var(--sidebar-fg);
    --infi-fs-input-bg: #29201d;
    --infi-fs-input-border: 2px solid #584d4a;
    --infi-fs-input-focus-border: 2px solid #4f95cc;
    --infi-fs-input-focus-box-shadow: 0 0 5px -1px #63baff;
}

.coal .infi-root {
    --infi-fs-input-bg: #1d1f21;
    --infi-fs-input-border: 2px solid #3e4144;
}

.navy .infi-root {
    --infi-fs-input-bg: #1e222f;
    --infi-fs-input-border: 2px solid #3d4252;
    --infi-sub-hover-bg: #242734;
}

.ayu .infi-root {
    --infi-fs-input-fg: var(--fg);
    --infi-fs-input-bg: #2b3035;
    --infi-fs-input-border: 2px solid #43474c;
    --infi-fs-input-focus-border: 2px solid #4f95cc;
    --infi-fs-input-focus-box-shadow: 0 0 5px -1px #63baff;
    --infi-sub-hover-bg: #282e35;
}

#infi-search {
    width: 100%;
    border-radius: 3px;
    box-sizing: border-box;
    padding: 10px 16px;
    border: 1px solid var(--searchbar-border-color);
    background: var(--searchbar-bg);
    color: var(--searchbar-fg);
}

#infi-search:focus:not(.infi-button-input) {
    box-shadow: 0 0 3px var(--searchbar-shadow-color);
}

#infi-search.infi-button-input {
    width: 100px;
}

#infi-search.infi-button-input::placeholder {
    position: relative;
    left: 14px;
}

#infi-search.infi-button-input:hover {
    transition: 0.3s ease-out;
    background: var(--infi-fs-button-input-bg) !important;
    outline: 2px solid var(--infi-fs-button-input-bg);
}

#infi-search.infi-button-input:hover::placeholder {
    color: var(--infi-fs-button-input-fg) !important;
}

@media print {
    #infi-search {
        display: none;
    }
}

#infisearch-mdbook-target {
    position: relative;
}

/*
 * For this plugin, don't show the controls until there is a query.
 */
#infisearch-mdbook-target.infi-empty-input > * {
    display: none;
}

.infi-root:not(.infi-fs-root) {
    display: block;
}

.light .infi-root .infi-title::after,
.rust .infi-root .infi-title::after,
.coal .infi-root .infi-title::after,
.navy .infi-root .infi-title::after,
.ayu .infi-root .infi-title::after {
    content: none;
    display: none;
}

.infi-header {
    padding-bottom: 9px;
}

.infi-load-more {
    padding: 7px 15px;
}
</style>
<p><input
    type="search"
    id="infi-search"
    placeholder="Search this book ..."
/></p>
<p><span style="font-weight: 600;"><!--preload weight 600--></span></p>
<div id="infisearch-mdbook-target"></div>
<h1 id="线程运行时间"><a class="header" href="#线程运行时间">线程运行时间</a></h1>
<p>一个服务器完成一项任务所需时间为：T1 创建线程时间，T2 在线程中执行任务的时间，T3 销毁线程时间如果 T1+T3 远大于 T2 则可以采用线程池，以提高服务器性能</p>
<h1 id="线程池技术"><a class="header" href="#线程池技术">线程池技术</a></h1>
<blockquote>
<p>一个线程池包括以下四个基本组成部分</p>
</blockquote>
<ul>
<li><strong>线程池管理器</strong> 用于创建线程，回收线程，销毁线程，添加任务</li>
<li><strong>工作线程</strong> 线程池中线程，在没有任务时，处于等待状态，可以循环执行任务</li>
<li><strong>任务接口</strong> 每个任务必须实现的接口，以供工作线程 任务的执行。它主要规定了任务的入口，任务执行完成后的收尾工作，任务的执行状态等</li>
<li><strong>任务队列</strong> 存放没有处理的任务。提供缓冲机制</li>
</ul>
<h1 id="threadpoolexecutor"><a class="header" href="#threadpoolexecutor">ThreadPoolExecutor</a></h1>
<blockquote>
<p>java中的  <em>ThreadPoolExecutor</em> 正是线程池的一种实现</p>
</blockquote>
<h2 id="初始化状态"><a class="header" href="#初始化状态">初始化状态</a></h2>
<p><strong>可指定</strong></p>
<ul>
<li><em>java.util.concurrent.BlockingQueue#workQueue</em> 任务缓存队列</li>
<li><em>corePoolSize</em> 常驻线程大小</li>
<li><em>maximumPoolSize</em> 最大线程大小</li>
<li><em>keepAliveTime</em>  线程存活时间，表示线程没有任务执行时最多保持多久时间会终止。默认情况下，只有当线程池中的线程数大于corePoolSize时，   keepAliveTime才会起作用，直到线程池中的线程数不大于corePoolSize：即当线程池中的线程数大于corePoolSize时，如果一个线程空闲的时间达到keepAliveTime，则会终止，直到线程池中的线程数不超过corePoolSize；但是如果调用了**allowCoreThreadTimeOut(boolean)**方法，在线程池中的线程数不大于corePoolSize时，keepAliveTime参数也会起作用，直到线程池中的线程数为0</li>
<li><em>ThreadFactory</em> 线程工厂 ，默认 <em>java.util.concurrent.Executors.DefaultThreadFactory</em></li>
<li><em>RejectedExecutionHandler</em>  任务队列满了之后的策略，默认 <em>java.util.concurrent.ThreadPoolExecutor.AbortPolicy</em></li>
<li><em>AccessControlContext</em> 访问控制上下文</li>
</ul>
<p><strong>自动初始化</strong></p>
<ul>
<li><em>ctl</em> <em>private final AtomicInteger ctl = new AtomicInteger(ctlOf(RUNNING, 0));</em></li>
<li><em>java.util.concurrent.locks.ReentrantLock#mainLock</em>  可重入锁</li>
<li><em>java.util.concurrent.ThreadPoolExecutor#workers</em>  工作线程的抽象</li>
<li><em>java.util.concurrent.ThreadPoolExecutor#termination</em> terminal锁</li>
<li><em>java.util.concurrent.ThreadPoolExecutor#largestPoolSize</em> 历史最大的线程数</li>
<li><em>java.util.concurrent.ThreadPoolExecutor#completedTaskCount</em> 用来记录已经执行完毕的任务个数</li>
</ul>
<h2 id="提交任务或执行任务"><a class="header" href="#提交任务或执行任务">提交任务或执行任务</a></h2>
<pre><code class="language-java">        int c = ctl.get();
        if (workerCountOf(c) &lt; corePoolSize) { //1.当前工作线程 小于 核心线程数，新增工作线程
                return;
            c = ctl.get();
        }
		//2.工作线程新增失败，（可能是由于其他线程新增了常驻线程，并达到了阈值），则将任务放到缓存队列中
        if (isRunning(c) &amp;&amp; workQueue.offer(command)) { 
            int recheck = ctl.get();	//2.1新增完之后，二次检查下，当前线程池 的状态，如果已经停止了，则回退操作，并拒绝
            if (! isRunning(recheck) &amp;&amp; remove(command))
                reject(command);
            else if (workerCountOf(recheck) == 0) //2.2如果工作线程个数为0，则添加一个工作线程
                addWorker(null, false);
        }
        else if (!addWorker(command, false))//3.如果线程队列满了，或者线程池已经关闭了，则拒绝
            reject(command);
</code></pre>
<h2 id="新增工作线程"><a class="header" href="#新增工作线程"><strong>新增工作线程</strong></a></h2>
<pre><code class="language-java">        retry:
        for (;;) {
            int c = ctl.get();
            int rs = runStateOf(c);
            // Check if queue empty only if necessary. 1.当线程池已经结束，而且 线程池不能满足以下条件 （正处于SHUTDOWN状态，且workQueue不为空，且给定的 firstTask）
            if (rs &gt;= SHUTDOWN &amp;&amp;
                ! (rs == SHUTDOWN &amp;&amp;
                   firstTask == null &amp;&amp;
                   ! workQueue.isEmpty()))
                return false;

            for (;;) {
                int wc = workerCountOf(c);
                //工作线程超过指定容量
                if (wc &gt;= CAPACITY ||
                    wc &gt;= (core ? corePoolSize : maximumPoolSize))
                    return false;
                //没有超过则 对 ctl中的 workCount 自增
                //自增成功，则退出，
                if (compareAndIncrementWorkerCount(c))
                    break retry;
                //自增失败，刷新 ctl
                c = ctl.get();  // Re-read ctl
                //如果 运行状态变了，则返回顶层循环，否则继续本层循环
                if (runStateOf(c) != rs)
                    continue retry;
                // else CAS failed due to workerCount change; retry inner loop
            }
        }

		//自增成功，真正处理 worker
        boolean workerStarted = false;
        boolean workerAdded = false;
        Worker w = null;
        try {
            w = new Worker(firstTask);
            final Thread t = w.thread;
            if (t != null) {
                final ReentrantLock mainLock = this.mainLock;
                mainLock.lock();
                try {
                    //以锁访问 ctl的值
                    // Recheck while holding lock.
                    // Back out on ThreadFactory failure or if
                    // shut down before lock acquired.
                    int rs = runStateOf(ctl.get());

                    //正在运行，或者 关闭中
                    if (rs &lt; SHUTDOWN ||
                        (rs == SHUTDOWN &amp;&amp; firstTask == null)) {
                        if (t.isAlive()) // precheck that t is startable 线程不是可启动的 报异常
                            throw new IllegalThreadStateException();
                        workers.add(w);
                        int s = workers.size();
                        //更新 历史 poolSize
                        if (s &gt; largestPoolSize)
                            largestPoolSize = s;
                        workerAdded = true;
                    }
                } finally {
                    mainLock.unlock();
                }
                //启动线程
                if (workerAdded) {
                    t.start();
                    workerStarted = true;
                }
            }
        } finally {
            if (! workerStarted)
                addWorkerFailed(w);
        }
        return workerStarted;
</code></pre>
<h2 id="判断线程池状态"><a class="header" href="#判断线程池状态">判断线程池状态</a></h2>
<pre><code class="language-java">//不处于运行状态
public boolean isShutdown() {
        return ! isRunning(ctl.get());
}
//是否运行
private static boolean isRunning(int c) {
        return c &lt; SHUTDOWN;
}
//完全terminated
public boolean isTerminated() {
        return runStateAtLeast(ctl.get(), TERMINATED);
}
private static boolean runStateAtLeast(int c, int s) {
        return c &gt;= s;
}
//正在结束中，没有彻底结束
public boolean isTerminating() {
        int c = ctl.get();
        return ! isRunning(c) &amp;&amp; runStateLessThan(c, TERMINATED);
}
private static boolean runStateLessThan(int c, int s) {
        return c &lt; s;
}
</code></pre>
<h2 id="运行线程"><a class="header" href="#运行线程">运行线程</a></h2>
<blockquote>
<p>java.util.concurrent.ThreadPoolExecutor.Worker</p>
</blockquote>
<h3 id="运行"><a class="header" href="#运行">运行</a></h3>
<pre><code class="language-java">    final void runWorker(Worker w) {
        //获取当前线程
        Thread wt = Thread.currentThread();
        Runnable task = w.firstTask;
        w.firstTask = null;
        w.unlock(); // allow interrupts
        boolean completedAbruptly = true;
        try {
            //先取firstTask,如果为空，则从缓存队列来取
            //当线程池 已经关闭，或者工作线程超时 时返回null
            while (task != null || (task = getTask()) != null) {
                //上锁
                w.lock();
                // If pool is stopping, ensure thread is interrupted;
                // if not, ensure thread is not interrupted.  This
                // requires a recheck in second case to deal with
                // shutdownNow race while clearing interrupt
                // 如果线程池正停止，
                // 如果没有停止，已经被中断过，并二次检查是否状态是否为STOP
                if (
                     (
					runStateAtLeast(ctl.get(), STOP) ||
                      (
                         Thread.interrupted() &amp;&amp; runStateAtLeast(ctl.get(), STOP)
                      )
                     )
                    &amp;&amp;
                    !wt.isInterrupted())
                    wt.interrupt();
                try {
                    beforeExecute(wt, task);
                    Throwable thrown = null;
                    try {
                        task.run(); //执行任务
                    } catch (RuntimeException x) {
                        thrown = x; throw x;
                    } catch (Error x) {
                        thrown = x; throw x;
                    } catch (Throwable x) {
                        thrown = x; throw new Error(x);
                    } finally {
                        afterExecute(task, thrown);
                    }
                } finally {
                    task = null;
                    w.completedTasks++;
                    w.unlock();
                }
            }
            completedAbruptly = false;
        } finally {
            ///当线程池 已经关闭，或者工作线程超时 时清理 工作线程
            processWorkerExit(w, completedAbruptly);
        }
    }
</code></pre>
<h3 id="取task"><a class="header" href="#取task">取Task</a></h3>
<ul>
<li>调用 <strong>shutdown()</strong> 线程池 状态变为 <em>SHUTDOWN</em>，此时当线程池没有其他任务时 工作线程退出</li>
<li>调用  <strong>shutdownNow()</strong> 时，状态设置为 <strong>STOP</strong>，不会处理队列其他的任务，强行返回 <strong>NULL</strong></li>
</ul>
<pre><code class="language-java">private Runnable getTask() {
    boolean timedOut = false; // Did the last poll() time out?

    for (;;) {
        int c = ctl.get();
        int rs = runStateOf(c);

        // Check if queue empty only if necessary. 线程池正在关闭 ，1.当为STOP 强行返回NULL，2.当工作线程为空了则强行返回NULL
        if (rs &gt;= SHUTDOWN &amp;&amp; (rs &gt;= STOP || workQueue.isEmpty())) {
            decrementWorkerCount();
            return null;
        }

        int wc = workerCountOf(c);

        // Are workers subject to culling? 判断 是否超时，1.手动设置 allowCoreThreadTimeOut 2.当工作线程大于常驻线程则需要超时
        boolean timed = allowCoreThreadTimeOut || wc &gt; corePoolSize;
		//超过最大工作线程数，或者超时，
        //工作线程数 大于1，或者 任务队列为空
        if ((wc &gt; maximumPoolSize || (timed &amp;&amp; timedOut))
            &amp;&amp; (wc &gt; 1 || workQueue.isEmpty())) {
            if (compareAndDecrementWorkerCount(c))
                return null;
            continue;
        }

        try {
            Runnable r = timed ?
                workQueue.poll(keepAliveTime, TimeUnit.NANOSECONDS) :
                workQueue.take();
            if (r != null)
                return r;
            timedOut = true;
        } catch (InterruptedException retry) {
            timedOut = false;
        }
    }
}
</code></pre>
<h3 id="回收工作线程"><a class="header" href="#回收工作线程">回收工作线程</a></h3>
<blockquote>
<p>processWorkerExit</p>
</blockquote>
<pre><code class="language-java">    private void processWorkerExit(Worker w, boolean completedAbruptly) {
        if (completedAbruptly) // If abrupt, then workerCount wasn't adjusted
            decrementWorkerCount();

        final ReentrantLock mainLock = this.mainLock;
        mainLock.lock();
        try {
            completedTaskCount += w.completedTasks;
            workers.remove(w);
        } finally {
            mainLock.unlock();
        }

        tryTerminate();

        int c = ctl.get();
        if (runStateLessThan(c, STOP)) {
            if (!completedAbruptly) {
                int min = allowCoreThreadTimeOut ? 0 : corePoolSize;
                if (min == 0 &amp;&amp; ! workQueue.isEmpty())
                    min = 1;
                if (workerCountOf(c) &gt;= min)
                    return; // replacement not needed
            }
            addWorker(null, false);
        }
    }

</code></pre>
<h2 id="关闭线程池"><a class="header" href="#关闭线程池">关闭线程池</a></h2>
<h3 id="关闭线程池-1"><a class="header" href="#关闭线程池-1">关闭线程池</a></h3>
<pre><code class="language-java">    public void shutdown() {
        final ReentrantLock mainLock = this.mainLock;
        mainLock.lock(); //上锁
        try {
            checkShutdownAccess(); //检查权限校验
            advanceRunState(SHUTDOWN); //设置线程池 ctl 为 SHUTDOWN
            interruptIdleWorkers(); //中断空闲线程
            onShutdown(); // hook for ScheduledThreadPoolExecutor，中断后回调
        } finally {
            mainLock.unlock(); //释放锁
        }
        tryTerminate();//中断线程
    }
</code></pre>
<h3 id="立即关闭线程池"><a class="header" href="#立即关闭线程池">立即关闭线程池</a></h3>
<pre><code class="language-java">    public List&lt;Runnable&gt; shutdownNow() {
        List&lt;Runnable&gt; tasks;
        final ReentrantLock mainLock = this.mainLock;
        mainLock.lock();
        try {
            checkShutdownAccess(); //检查权限校验
            advanceRunState(STOP); //设置线程池 ctl 为 CTL
            interruptWorkers(); //中断工作中线程
            tasks = drainQueue(); //获取工作线程工作结果
        } finally {
            mainLock.unlock();
        }
        tryTerminate();	//中断线程
        return tasks;
    }
</code></pre>
<h3 id="尝试关闭线程池"><a class="header" href="#尝试关闭线程池">尝试关闭线程池</a></h3>
<p>线程池 有以下四种状态</p>
<ul>
<li>运行中</li>
<li><em>SHUTDOWN</em> 等待所有任务完成后停止</li>
<li>STOP  强行停止</li>
<li>TINYTERMINTATOR 与 TERMINATED 停止状态</li>
</ul>
<p>当 状态 为 STOP 强行停止  或者  SHUTDOWN 且任务都 已经运行完毕时，才尝试 进一步停止 线程池</p>
<pre><code class="language-java">final void tryTerminate() {
        for (;;) {
            int c = ctl.get();
            //1.正在运行
            //2.已经在关闭完成
            //3.正在关闭，且队列不为空 则退出
            if (isRunning(c) ||
                runStateAtLeast(c, TIDYING) ||
                (runStateOf(c) == SHUTDOWN &amp;&amp; ! workQueue.isEmpty()))
                return;
            //工作线程不为0，中断空闲线程
            if (workerCountOf(c) != 0) { // Eligible to terminate
                interruptIdleWorkers(ONLY_ONE);
                return;
            }

            final ReentrantLock mainLock = this.mainLock;
            mainLock.lock();
            try {
                //已经位于关闭状态，且工作线程池为空，任务队列为空，则设置为 TIDYING,调用 termined()回调，设置为彻底关闭 TERMINATED,条件锁唤醒
                if (ctl.compareAndSet(c, ctlOf(TIDYING, 0))) {
                    try {
                        terminated();
                    } finally {
                        ctl.set(ctlOf(TERMINATED, 0));
                        termination.signalAll();
                    }
                    return;
                }
            } finally {
                mainLock.unlock();
            }
            // else retry on failed CAS
        }
    }
</code></pre>
<h2 id="设置线程池ctl"><a class="header" href="#设置线程池ctl">设置线程池ctl</a></h2>
<pre><code class="language-java">   private void advanceRunState(int targetState) {
        for (;;) {
            int c = ctl.get();
            //如果已经 处于 TERMINAL了，则退出
            //没有位于 TERMINAl，通过CAS设置
            //设置失败则，继续设置
            if (runStateAtLeast(c, targetState) ||
                ctl.compareAndSet(c, ctlOf(targetState, workerCountOf(c))))
                break;
        }
    }
</code></pre>
<h2 id="中断线程"><a class="header" href="#中断线程">中断线程</a></h2>
<pre><code class="language-java">    private void interruptIdleWorkers(boolean onlyOne) {
        final ReentrantLock mainLock = this.mainLock;
        mainLock.lock();
        try {
            for (Worker w : workers) {
                Thread t = w.thread;
                if (!t.isInterrupted() &amp;&amp; w.tryLock()) {
                    try {
                        t.interrupt();
                    } catch (SecurityException ignore) {
                    } finally {
                        w.unlock();
                    }
                }
                if (onlyOne)
                    break;
            }
        } finally {
            mainLock.unlock();
        }
    }
</code></pre>
<h2 id="线程池缓冲区"><a class="header" href="#线程池缓冲区">线程池缓冲区</a></h2>
<p><strong>workQueue</strong>：一个阻塞队列，用来存储等待执行的任务，这个参数的选择会对线程池的运行过程产生重大影响，一般来说，这里的阻塞队列有以下几种选择：</p>
<ul>
<li>直接提交的队列
<ol>
<li>新任务提交给线程池时,如果线程数量&lt;<code>maximumPoolSize</code>,则直接创建,否则拒绝</li>
<li><code>SynchronousQueue</code></li>
</ol>
</li>
<li>有界任务队列
<ol>
<li><code>ArrayBlockingQueue</code></li>
<li>若已有线程数量 小于 corePoolSize ,则创建新的线程,直接运行</li>
<li>若大于 corePoolSize ,则加入等待队列</li>
<li>若等待队列已满,且当前线程数量小于<code>maximumPoolSize</code>则新建线程</li>
<li>若当前线程数量已等于<code>maximumPoolSize</code>,则执行拒绝策略</li>
</ol>
</li>
<li>无界任务队列
<ol>
<li><code>LinkedBlockingQueue</code></li>
<li>若已有线程数量 小于 corePoolSize ,则创建新的线程,直接运行</li>
<li>若大于 corePoolSize ,则加入等待队列</li>
<li>无界队列会一直增长 直到内存耗尽</li>
</ol>
</li>
<li>优先任务队列:特殊的无界队列
<ol>
<li><code>PriorityBlockingQueue</code>:</li>
</ol>
</li>
</ul>
<h2 id="线程池状态"><a class="header" href="#线程池状态"><strong>线程池状态</strong></a></h2>
<pre><code class="language-java">private static final int RUNNING = -1 &lt;&lt; COUNT_BITS;
private static final int SHUTDOWN = 0 &lt;&lt; COUNT_BITS;
private static final int STOP = 1 &lt;&lt; COUNT_BITS;
private static final int TIDYING = 2 &lt;&lt; COUNT_BITS;
private static final int TERMINATED = 3 &lt;&lt; COUNT_BITS;
</code></pre>
<ul>
<li>SHUTDOWN 与STOP 状态 是平级状态，SHUTDOWN是等待所有任务全部完成后退出，STOP是强行停止所有任务并停止</li>
</ul>
<h2 id="拒绝策略"><a class="header" href="#拒绝策略">拒绝策略</a></h2>
<p>内置四种拒绝策略</p>
<ol>
<li><code>AbortPolicy</code>: 直接抛出异常</li>
<li><code>CallerRunsPolicy</code>:直接在调用者线程中运行当前被丢弃的任务</li>
<li><code>DiscardOldestPolicy</code>:丢弃最老的请求,也就是即将被执行的,并尝试再次提交当前任务</li>
<li><code>DiscardPolicy</code>:丢弃该任务</li>
</ol>
<h2 id="扩展线程池"><a class="header" href="#扩展线程池">扩展线程池</a></h2>
<ol>
<li><code>ThreadPoolExecutor</code> 可扩展线程池</li>
<li>code</li>
</ol>
<pre><code class="language-java">package com.weisanju;

import java.util.concurrent.ArrayBlockingQueue;
import java.util.concurrent.ThreadPoolExecutor;
import java.util.concurrent.TimeUnit;

public class ThreadPoolTest {
    public static void main(String[] args) {
        ThreadPoolExecutor executor = new ThreadPoolExecutor(5, 10, 100, TimeUnit.MILLISECONDS, new ArrayBlockingQueue&lt;&gt;(20)) {
            protected void beforeExecute(Thread t, Runnable r) {
                System.out.println("线程" + t.getName() + "开始运行");
            }
            protected void afterExecute(Runnable r, Throwable t) {
                System.out.println( r.toString()+ "结束运行");
            }

            protected void terminated() {
                System.out.println("线程池退出");
            }
        };
        executor.execute(()-&gt;{
            System.out.println("helloWorld");
        });
        executor.shutdown();
    }
}

</code></pre>
<h1 id="executors-创建的线程池"><a class="header" href="#executors-创建的线程池">Executors 创建的线程池</a></h1>
<pre><code class="language-java">public static ExecutorService newFixedThreadPool(int nThreads){
    return new ThreadPoolExecutor(nThreads,nThreads,0L,TimeUnit.MILLISECONDS,new LinkedBlockingQueue&lt;Runnable&gt;());
}
</code></pre>
<ul>
<li>它是一种固定大小的线程池；</li>
<li>corePoolSize和maximunPoolSize都为用户设定的线程数量nThreads；</li>
<li>keepAliveTime为0，意味着一旦有多余的空闲线程，就会被立即停止掉；但这里keepAliveTime无效；</li>
<li>阻塞队列采用了LinkedBlockingQueue，它是一个无界队列；</li>
<li>由于阻塞队列是一个无界队列，因此永远不可能拒绝任务；</li>
<li>由于采用了无界队列，实际线程数量将永远维持在nThreads，因此maximumPoolSize和keepAliveTime将无效。</li>
</ul>
<pre><code class="language-java">public static ExecutorService newCachedThreadPool(){
    return new ThreadPoolExecutor(0,Integer.MAX_VALUE,60L,TimeUnit.MILLISECONDS,new SynchronousQueue&lt;Runnable&gt;());
}
</code></pre>
<ul>
<li>它是一个可以无限扩大的线程池；</li>
<li>它比较适合处理执行时间比较小的任务；</li>
<li>corePoolSize为0，maximumPoolSize为无限大，意味着线程数量可以无限大；</li>
<li>keepAliveTime为60S，意味着线程空闲时间超过60S就会被杀死；</li>
<li>采用SynchronousQueue装等待的任务，这个阻塞队列没有存储空间，这意味着只要有请求到来，就必须要找到一条工作线程处理他，如果当前没有空闲的线程，那么就会再创建一条新的线程。</li>
</ul>
<pre><code class="language-java">public static ExecutorService newSingleThreadExecutor(){
    return new ThreadPoolExecutor(1,1,0L,TimeUnit.MILLISECONDS,new LinkedBlockingQueue&lt;Runnable&gt;());
}
</code></pre>
<ul>
<li>它只会创建一条工作线程处理任务；</li>
<li>采用的阻塞队列为LinkedBlockingQueue；</li>
</ul>
<h1 id="线程池监控"><a class="header" href="#线程池监控">线程池监控</a></h1>
<ol>
<li><code>long getTaskCount()</code>，获取已经执行或正在执行的任务数</li>
<li><code>long getCompletedTaskCount()</code>，获取已经执行的任务数</li>
<li><code>int getLargestPoolSize()</code>，获取线程池曾经创建过的最大线程数，根据这个参数，我们可以知道线程池是否满过</li>
<li><code>int getPoolSize()</code>，获取线程池线程数</li>
<li><code>int getActiveCount()</code>，获取活跃线程数（正在执行任务的线程数）</li>
</ol>
<p>其次，<code>ThreadPoolExecutor</code>留给我们自行处理的方法有3个，它在<code>ThreadPoolExecutor</code>中为空实现（也就是什么都不做）。</p>
<ol>
<li><code>protected void beforeExecute(Thread t, Runnable r)</code> // 任务执行前被调用</li>
<li><code>protected void afterExecute(Runnable r, Throwable t)</code> // 任务执行后被调用</li>
<li><code>protected void terminated()</code> // 线程池结束后被调用</li>
</ol>
<h1 id="线程池动态扩容"><a class="header" href="#线程池动态扩容">线程池动态扩容</a></h1>
<p>ThreadPoolExecutor提供了动态调整线程池容量大小的方法：setCorePoolSize()和setMaximumPoolSize()，</p>
<ul>
<li>setCorePoolSize：设置核心池大小</li>
<li>setMaximumPoolSize：设置线程池最大能创建的线程数目大小</li>
</ul>
<p>　　当上述参数从小变大时，ThreadPoolExecutor进行线程赋值，还可能立即创建新的线程来执行任务。</p>
<h1 id="线程池中的线程初始化"><a class="header" href="#线程池中的线程初始化">线程池中的线程初始化</a></h1>
<ul>
<li>prestartCoreThread()：初始化一个核心线程；</li>
<li>prestartAllCoreThreads()：初始化所有核心线程</li>
</ul>
<h1 id="java线程池的调优"><a class="header" href="#java线程池的调优">java线程池的调优</a></h1>
<ul>
<li>先从以下几个角度分析任务的特性：</li>
</ul>
<ol>
<li><strong>任务的性质：</strong> <code>CPU 密集型任务</code>、<code>IO 密集型任务</code>和<code>混合型任务</code>。</li>
<li><strong>任务的优先级：</strong> 高、中、低。</li>
<li><strong>任务的执行时间：</strong> 长、中、短。</li>
<li><strong>任务的依赖性：</strong> <code>是否依赖其他系统资源</code>，如<code>数据库连接</code>。</li>
</ol>
<ul>
<li><strong>任务性质不同的任务可以用不同规模的线程池分开处理。</strong> 可以通过 <code>Runtime.getRuntime().availableProcessors()</code> 方法获得当前设备的 CPU 个数。</li>
</ul>
<ol>
<li><strong>CPU 密集型任务</strong>配置<code>尽可能小的线程</code>，如配置 N c p u + 1 N_{cpu}+1<em>N<strong>c</strong>p**u</em>+1 个线程的线程池。</li>
<li><strong>IO 密集型任务</strong>则由于线程并不是一直在执行任务，则<code>配置尽可能多的线程</code>，如2 ∗ N c p u 2*N_{cpu}2∗<em>N<strong>c</strong>p**u</em>。</li>
<li><strong>混合型任务</strong>，如果可以拆分，则<code>将其拆分成一个 CPU 密集型任务和一个 IO 密集型任务</code>。只要这<code>两个任务执行的时间相差不是太大</code>，那么<code>分解后执行的吞吐率要高于串行执行的吞吐率</code>；如果这两个任务执行时间相差太大，则没必要进行分解。</li>
</ol>
<ul>
<li><strong>优先级不同的任务</strong>可以使用优先级队列 <code>PriorityBlockingQueue</code> 来处理，它可以让优先级高的任务先得到执行。但是，如果<code>一直有高优先级的任务加入到阻塞队列中</code>，那么<code>低优先级的任务可能永远不能执行</code>。</li>
<li><strong>执行时间不同的任务</strong>可以交给<code>不同规模的线程池</code>来处理，或者<code>也可以使用优先级队列</code>，让<code>执行时间短的任务先执行</code>。</li>
<li><strong>依赖数据库连接池的任务</strong>，因为线程提交 SQL 后需要等待数据库返回结果，<code>线程数应该设置得较大</code>，这样才能更好的利用 CPU。</li>
<li><strong>建议使用有界队列</strong>，有界队列能<code>增加系统的稳定性和预警能力</code>。可以根据需要设大一点，比如几千。<code>使用无界队列</code>，线程池的队列就会越来越大，<strong>有可能会撑满内存，导致整个系统不可用</strong>。</li>
</ul>
<h1 id="scheduledthreadpool"><a class="header" href="#scheduledthreadpool">ScheduledThreadPool</a></h1>
<ul>
<li>它接收SchduledFutureTask类型的任务，有两种提交任务的方式：</li>
</ul>
<ol>
<li>scheduledAtFixedRate</li>
<li>scheduledWithFixedDelay</li>
</ol>
<ul>
<li>SchduledFutureTask接收的参数：</li>
</ul>
<ol>
<li>time：任务开始的时间</li>
<li>sequenceNumber：任务的序号</li>
<li>period：任务执行的时间间隔</li>
</ol>
<ul>
<li>它采用DelayQueue存储等待的任务</li>
<li>DelayQueue内部封装了一个PriorityQueue，它会根据time的先后时间排序，若time相同则根据sequenceNumber排序；</li>
<li>DelayQueue也是一个无界队列；</li>
<li>工作线程的执行过程：</li>
<li>工作线程会从DelayQueue取已经到期的任务去执行；</li>
<li>执行结束后重新设置任务的到期时间，再次放回DelayQueue</li>
</ul>
<script src="/note-service/java/infisearch_assets/search-ui.chinese.bundle.js" type="text/javascript" charset="utf-8"></script>
<script src="/note-service/java/infisearch_assets/mark.min.js" type="text/javascript" charset="utf-8"></script>
<script>
const base_url = '/note-service/java/';
const mode = 'target';
infisearch.init({
  searcherOptions: {
    url: base_url + 'infisearch_output/',
  },
  uiOptions: {
    mode,
    dropdownAlignment: 'bottom-start',
    target: document.getElementById('infisearch-mdbook-target'),
    fsButtonPlaceholder: 'Search',
    sourceFilesUrl: base_url,
    resultsRenderOpts: {
      searchedTermsParam: 'search',
    },
    multiSelectFilters: [
      { fieldName: 'partTitle', displayName: 'Section', defaultOptName: 'None' },
    ],
  },
});

document.getElementById('infi-search').addEventListener('keydown', (ev) => {
  if (['ArrowLeft', 'ArrowRight'].includes(ev.key)) {
    ev.stopPropagation(); // used in global listener to change pages
    return;
  }
});

if (window.location.search) {
  // Adapted from the original searcher.js for mdbook
  // https://github.com/rust-lang/mdBook/blob/master/src/theme/searcher/searcher.js
  const target = document.getElementById('content');
  const marker = new Mark(target);

  function doSearchOrMarkFromUrl() {
    // Check current URL for search request
    var url = new URL(window.location.href);
    var urlParams = new URLSearchParams(url.search);

    if (urlParams.has('search')) {
      var words = JSON.parse(decodeURIComponent(urlParams.get('search')));
      marker.mark(words);

      var markers = document.querySelectorAll('mark');
      function hide() {
        for (var i = 0; i < markers.length; i++) {
          markers[i].classList.add('fade-out');
          window.setTimeout(function () { marker.unmark(); }, 300);
        }
      }
      for (var i = 0; i < markers.length; i++) {
        markers[i].addEventListener('click', hide);
      }
    }
  }
  doSearchOrMarkFromUrl();
}
</script>
<p><span data-infisearch-part-title="未分类"></span></p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../05.java基础_多线程与锁/线程操作.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../05.java基础_多线程与锁/线程操作.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>



        <script src="../clipboard.min.js"></script>
        <script src="../highlight.js"></script>
        <script src="../book.js"></script>

        <!-- Custom JS scripts -->


    </div>
    </body>
</html>
