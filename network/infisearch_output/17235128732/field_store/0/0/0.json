[[["_relative_fp","DNS&DHCP.html"],["title","DNS&DHCP.md - 计算机网络"],["body","\n    \n        \n        \n\n        \n        \n\n        \n        \n\n        \n\n        \n        \n\n        \n\n        \n        \n\n        \n\n            \n                                \n                \n                    \n                        "],["body","\n                            \n                        "],["body","\n                        "],["body","\n                            \n                        "],["body","\n                        \n                            "],["body","Light"],["body","\n                            "],["body","Rust"],["body","\n                            "],["body","Coal"],["body","\n                            "],["body","Navy"],["body","\n                            "],["body","Ayu"],["body","\n                        \n                    \n\n                    "],["heading","计算机网络"],["body","\n\n                    \n\n                    \n                \n\n\n                \n                \n\n                \n                    "],["body","\n                        \n\n"],["body","\n"],["body","\n\n"],["headingLink","dns配置"],["heading","DNS配置"],["body","\n"],["headingLink","etchosts"],["heading","/etc/hosts"],["body","\n"],["body","在Linux系统，主机配置文件为/etc/hosts，这是主机名的静态查找表。这个文件是简单的文本文件，用于保存主机名称和IP之间对应关系。\n其格式为一个 IP 地址占用一行， 每一个主机关联一个IP地址（各个域之间用空格或制表字符分开）。格式如下：\n127.0.0.1 localhost [aliases...]"],["body","\n"],["headingLink","etchosts文件的作用"],["heading","/etc/hosts文件的作用"],["body","\n\n"],["body","\n"],["body","包含本地网络上的信息主机信息表"],["body","\n"],["body","\n"],["body","\n"],["body","DNS 输入：使用主机表作为 DNS 服务主机数据库的输入，或 者使用主机表作为备用配置。"],["body","\n"],["body","\n"],["body","\n"],["body","加快域名解析，节省网络流量\nhosts 文件在主机上配置具有加快域名解析的作用， 对于经常访问的网站和主机，我们可以在 hosts 文件中配置域名和 IP 的对应关系。由于有 了映射关系，当我们访问域名时，可以直接从 hosts 文件中解析得出，而不用访问网络上 的域名服务器，不用消耗网络流量。"],["body","\n"],["body","\n"],["body","\n"],["body","屏蔽网站（域名重定向）\n屏蔽广告网站，有很多网站带有广告，但广告和网站 本身域名不同，因此如果能屏蔽一些众所周知的广告网站域名，这样我们利用 hosts 把这 些广告的网站的域名映射到本机 IP 或非法目的 IP，这样就不会看到这些广告图片了,也不 会浪费网络流量。"],["body","\n"],["body","\n"],["body","\n"],["body","防止 DNS 污染和 DNS 劫持"],["body","\n\n"],["body","DNS 劫持就是攻破了 DNS 服务器防护，从而获得 域名解析记录的控制权，进而修改域名解析的结果。这将导致对原始域名的访问转到另外 的 IP 地址。"],["body","\n"],["body","DNS 污染是因为 DNS 查询没有任何认证机制，而且 DNS 查询通常采用的 UDP 是无 连接不可靠的协议，因此 DNS 的查询非常容易被篡改：通过对 UDP 端口 53 上的 DNS 查 询报文进行分析，一旦发现与关键词相匹配的请求则立即伪装成目标域名的解析服务器给 查询者返回虚假结果。"],["body","\n"],["body","如果我们已知服务器的 IP 地址，就可以在 hosts 文件中设置正确的 IP 地址，从而避 免 DNS 劫持和污染。"],["body","\n\n"],["body","\n\n"],["headingLink","广域网上的dns"],["heading","广域网上的DNS"],["body","\n\n"],["body","在因特网中，主机地址非常庞大，并且主 机的IP地址经常改变，因此使用域名系统 DNS 代替主机系统。"],["body","\n"],["body","DNS 可以被视为一种用于 TCP/IP 应用程序的分布式数据库，它提供主机名字和 IP 地址间的相互转换"],["body","\n"],["body","这里提到的分布式是指在因特网上的单个站点不能拥有所有的信息"],["body","\n"],["body","每个站点（如大学中的系、校园、公司或公司的部门）保留它自己的信息数据库，并运行一 个服务器程序供因特网上的其他系统查询。"],["body","\n\n"],["headingLink","域名结构"],["heading","域名结构"],["body","\n\n"],["body","未命名跟节点\n\n"],["body","net"],["body","\n\n\n"],["body","bjbook\n\n"],["body","www"],["body","\n\n"],["body","\n\n\n"],["body","com"],["body","\n\n\n"],["body","cctv"],["body","\n\n\n"],["body","gov"],["body","\n"],["body","org"],["body","\n"],["body","openwrt\nwww\ndev\nwiki"],["body","\n"],["body","ietf"],["body","\n"],["body","cn、sg、us"],["body","\n\n"],["body","\n\n\n"],["body","其最顶端有一个未命名的根节点，然后其下分为几个基本类别名称（称 为顶层域名），例如 com、org、net 和 gov 等 3字符域名，还有 cn、sg、jp 和 us 等两个字 符国家地区域名。"],["body","\n"],["body","每个节点有一个至多 63 个字符长的标识，域名总长度则不能超过 253 个字符。"],["body","\n"],["body","命名标识中不区分大写和小写。"],["body","\n"],["body","命名树上任何一个节点的域名就是将从该节点到 最高层的域名串连起来，中间使用一个点“.”分隔这些节点。例如，一个完整的域名为 www.bjbook.net。"],["body","\n"],["body","域名树中的每个节点必须有一个唯一的名称，但域名树中的不同层级节 点可使用相同的标识，只要在不同的父节点下即可。"],["body","\n\n"],["headingLink","dns报文格式"],["heading","DNS报文格式"],["body","\n\n"],["body","DNS默认使用TCP和UDP端口53。CS模型。DNS的请求和应答封装在UDP报文中。"],["body","\n"],["body","\n\n"],["body","| 会话标识                          | flags                    |\n| 问题数目(2字节)                   | 回答资源记录数(2字节)        |\n| 授权资源记录数(2字节)             | 额外资源记录数(2字节)         |\n|                   问题（可变长度）              |\n|            回答资源记录（可变长度）            |\n|           授权资源记录 （可变长度）          |\n|           附加信息资源 （可变长度）           |"],["body","\n"],["headingLink","会话标识"],["heading","会话标识"],["body","\n"],["body","报文头部的会话标识字段由客户端生成随机值填充并由服务器原样 返回。客户端通过该字段来匹配请求和响应。"],["body","\n"],["headingLink","flags"],["heading","flags"],["body","\n"],["body","flags部分非常复杂\n- 如果是请求一般为0x0100。\n- 如果为响应，通常有两种情况：\n- 0x8182表示服务器失败；\n- 0x8180表示服务器 成功响应。"],["body","\n"],["body","问题数目、回答资源记录数、授权资源记录数目、额外资源记录数目\n对于查询报文，问题数目通常是1，而其他3项则均为0。对于应答报文，问题数目还是1，回答数至少是1。"],["body","\n"],["headingLink","问题"],["heading","问题"],["body","\n\n"],["body","\n"],["body","问题部分中每个问题的格式由3部分顺序组成："],["body","\n\n"],["body","查询内容"],["body","\n"],["body","类型（Type）"],["body","\n"],["body","类（Class）。 类型和类均为固定的两个字节长度。"],["body","\n\n"],["body","\n"],["body","\n"],["body","查询内容长度不定，它是一个或多个标识符的序列。每个标识符以首字节的计数值来 说明随后字符串的字节长度，每个名字的最后字节为 0 表示结束。计数字节的值必须是 0～ 63 的数字，因为标识符的最大长度为 63。高位字节为二进制 11000000 时，用于压缩格式，指向 报文的查询字符串位置，字符串位置是从 DNS 报文头部开始计算的。"],["body","\n"],["body","\n\n"],["headingLink","回答资源记录授权资源记录附加信息资源记录"],["heading","回答资源记录、授权资源记录、附加信息资源记录"],["body","\n\n"],["body","DNS 报文中最后 3 个字段分别为回答字段、授权字段和附加信息字段，均采用资源记录（Resource Record，RR）格式"],["body","\n"],["body","资源记录格式内容顺序包含   域名、类型、类、生存时间、数据长度和数据6部分。\n\n"],["body","Name:域名是记录中资源数据对应的名字"],["body","\n"],["body","Type: 与问题域内容格式相同"],["body","\n"],["body","Class: 与问题域内容格式相同"],["body","\n"],["body","TimeToLive: 生存时间字段占4个字节，是客户程序保留该资源记录的 秒数"],["body","\n"],["body","DataLength: 数据长度字段占2个字节，指明资源数据的长度"],["body","\n"],["body","Address: 数据字段占4个字节，指明资源数据的内容。数据部分的格式依赖于类型字段的值"],["body","\n\n"],["body","\n\n"],["headingLink","域名解析过程"],["heading","域名解析过程"],["body","\n"],["body","client ->\n/etc/hosts ->\n/etc/resolv.conf\n-> DNS服务器1、DNS服务器2"],["body","\n"],["headingLink","etcresolvconf配置文件"],["heading","/etc/resolv.conf配置文件"],["body","\n"],["body","常见的配置如下:"],["body","\n\n"],["body","\n"],["body","nameserver: 域名服务器地址。最多可以设置 3 个名字服务器，每一行一个\n将按照列表顺序查询。若第一个域名服务器查询超 时，再顺序查询下面的域名服务器，直到所有的域名服务器都尝试一遍。如果没有域名服务器地址或者这个配置文件不存在，则默认使用本机（127.0.0.1）作为名字服务器 地址"],["body","\n"],["body","\n"],["body","\n"],["body","domain\n可以使用相对于本地域名的短名来查询。如果域名没有配置，则返回主机名。\n如果域名中不包含点。则认为是短域名。会附加此域名后缀"],["body","\n"],["body","\n"],["body","\n"],["body","search\n定义短域名时的附加列表。\n假设search参数设置为\"example.com, company.com\"，系统会按照顺序在这两个域名后面依次进行搜索。首先，系统会尝试解析\"webserver.example.com\"，如果找到了对应的IP地址，就会进行通信。如果没有找到，系统会继续尝试解析\"webserver.company.com\"。如果还是没有找到，最终会返回一个域名解析失败的错误。通过这种方式，search参数可以方便地进行域名搜索，省去了每次都要完整输入域名的麻烦。这对于在局域网或企业内部使用的内部域名解析非常有用。"],["body","\n"],["body","\n\n"],["headingLink","dhcp简介"],["heading","DHCP简介"],["body","\n\n"],["body","在 TCP/IP 网络上，每台主机在访问网络及其资源之前，都必须进行基本的网络信息 配置，包含 IP 地址、子网掩码、默认网关和 DNS 等"],["body","\n"],["body","在大型网络中，如果每台终端主 机的地址都由不同的使用者来分配，那么就很容易出现地址相同的情况"],["body","\n"],["body","对于经常移动 的终端，重新配置可能需要很长时间，并且容易出错，如果 IP 配置错误将会导致不能访问网络。因此需要一种机制来简化主机 IP 地址的配置。动态主机配置协议 DHCP 应运而生。"],["body","\n"],["body","采用 DHCP 的好处在于减少了网络管理员和用户的负担。这将可以减少手工配置 IP 地址导致的地址冲突，以及网关地址或 DNS 地址错误导致的不能访问网络等问题。"],["body","\n\n"],["headingLink","dhcp原理"],["heading","DHCP原理"],["body","\n\n"],["body","DHCP 服务器拥有一个 IP 地址池，当任何启用 DHCP 的客户机连接到网络时，可 从服务器那里租借一个 IP 地址，不再使用的 IP 地址自动回收到地址池中，供再次分配 使用。"],["body","\n"],["body","DHCP 保证同一时刻的任何 IP 地址只能分给一个客户机使用。当 DHCP 客户机重新 启动时，应配置为相同的 IP 地址。在 DHCP 服务器重启的情况下，也应当给每一个客户机分配相同的 IP 地址，并且和手动分配的 IP 地址共存。这要求 DHCP 服务器对已分配的 地址进行保存，并且在客户端不使用时进行回收。"],["body","\n"],["body","DHCP 是一种动态地向网络终端提供配置参数的协议。在终端提出申请之后，DHCP 服务器可以向终端提供 IP 地址及子网掩码、网关和 DNS 服务器地址等参数。"],["body","\n"],["body","DHCP 协议基于 UDP 协议，客户端的端口号是68，服务器的端口号是67。"],["body","\n\n"],["headingLink","dhcp报文"],["heading","DHCP报文"],["body","\n\n"],["body","DHCP的请求和应答封装在UDP报文中。"],["body","\n"],["body","IP层在请求 IP 地址时采用链路层广播，链路层广播地址为FF:FF:FF:FF:FF:FF"],["body","\n"],["body","网络层目的IP使用广播地址255.255.255.255，源地址采用 0.0.0.0，这是因为请求时自身没有 IP 地址，并且不知道服务器的 IP 地址。"],["body","\n\n"],["headingLink","dhcp工作流程"],["heading","DHCP工作流程"],["body","\n\n"],["body","DHCP 通常由客户端发起广播请求，服务器收到请求后在配置文件中查询，如果符合 要求则向客户端提供服务。\n\n"],["body","客户端在以太网上广播“DHCP Discover”报文来发现 DHCP 服务器。"],["body","\n"],["body","IP 为 10.0.2.2 的服务器收到广播请求后，向客户端回应请求，发出单播“DHCP Offer”报文，并且目的 IP 为 10.0.2.15。"],["body","\n"],["body","客户端再次以广播形式发出“DHCP Request”报文。这是因为客户端可能收到多个服务器“DHCP Offer”报文，客户端会根据报文的内容来选择一个给予响应，采用广播 形式可以让多个服务器均可收到。"],["body","\n"],["body","当服务器收到“DHCP Request”报文后，服务器在将客户端的 MAC 地址同分配的IP地址绑定后，将IP信息（IP、掩码、网关地址和 DNS 等）发送给客户机。"],["body","\n"],["body","客户机收到“DHCP ACK”报文后，将 IP 信息设置到主机系统上。这时 IP 设置 就完成了，客户机就可使用 IP 来访问网络了。"],["body","\n\n"],["body","\n\n\n\n\n                    "],["body","\n\n                    \n                \n            \n\n            \n\n        \n\n\n\n\n        \n\n\n\n        \n        \n        \n\n        \n\n\n    \n    \n\n"]],[["_relative_fp","ipsec-l2tpd.html"],["title","ipsec-l2tpd.md - 计算机网络"],["body","\n    \n        \n        \n\n        \n        \n\n        \n        \n\n        \n\n        \n        \n\n        \n\n        \n        \n\n        \n\n            \n                                \n                \n                    \n                        "],["body","\n                            \n                        "],["body","\n                        "],["body","\n                            \n                        "],["body","\n                        \n                            "],["body","Light"],["body","\n                            "],["body","Rust"],["body","\n                            "],["body","Coal"],["body","\n                            "],["body","Navy"],["body","\n                            "],["body","Ayu"],["body","\n                        \n                    \n\n                    "],["heading","计算机网络"],["body","\n\n                    \n\n                    \n                \n\n\n                \n                \n\n                \n                    "],["body","\n                        \n\n"],["body","\n"],["body","\n\n"],["body","https://github.com/daisreaux/L2TP-VPN/blob/master/docs/clients-zh.md#%E4%BD%BF%E7%94%A8%E5%91%BD%E4%BB%A4%E8%A1%8C%E9%85%8D%E7%BD%AE-linux-vpn-%E5%AE%A2%E6%88%B7%E7%AB%AF"],["body","\n\n\n\n                    "],["body","\n\n                    \n                \n            \n\n            \n\n        \n\n\n\n\n        \n\n\n\n        \n        \n        \n\n        \n\n\n    \n    \n\n"]],[["_relative_fp","systemd&rsolved.html"],["title","systemd&rsolved.md - 计算机网络"],["body","\n    \n        \n        \n\n        \n        \n\n        \n        \n\n        \n\n        \n        \n\n        \n\n        \n        \n\n        \n\n            \n                                \n                \n                    \n                        "],["body","\n                            \n                        "],["body","\n                        "],["body","\n                            \n                        "],["body","\n                        \n                            "],["body","Light"],["body","\n                            "],["body","Rust"],["body","\n                            "],["body","Coal"],["body","\n                            "],["body","Navy"],["body","\n                            "],["body","Ayu"],["body","\n                        \n                    \n\n                    "],["heading","计算机网络"],["body","\n\n                    \n\n                    \n                \n\n\n                \n                \n\n                \n                    "],["body","\n                        \n\n"],["body","\n"],["body","\n\n"],["headingLink","systemd-resolvedservice"],["heading","systemd-resolved.service"],["body","\n"],["body","systemd-resolved 为本地应用程序提供了网络名字解析服务。 它不但提供了传统的 DNS/DNSSEC 解析与本地缓存功能，还提供了 LLMNR 与 MulticastDNS 的解析(resolver)与应答(responder)的功能。 本地应用程序可以通过三种方式提交网络名字解析请求："],["body","\n"],["headingLink","关闭systemd-resolved"],["heading","关闭systemd-resolved"],["body","\n"],["body","sudo systemctl disable systemd-resolved\nsudo systemctl stop systemd-resolved\n"],["body","\n"],["body","先停用systemd-resolved, 并取消开机自动启动"],["body","\n"],["body","接下来修改NetworkManager配置，让它能自动获取dns"],["body","\n"],["body","编辑文件/etc/NetworkManager/NetworkManager.conf"],["body","\n"],["body","增加一行"],["body","\n"],["body","dns=default\n"],["body","\n"],["body","加完之后配置文件大概这样"],["body","\n"],["body","[main]\nplugins=ifupdown,keyfile\ndns=default\n[ifupdown]\nmanaged=false\n[device]\nwifi.scan-rand-mac-address=no\n"],["body","\n"],["body","接下来删除/etc/resolv.conf"],["body","\n"],["body","sudo unlink /etc/resolv.conf\nsudo touch /etc/resolv.conf\n"],["body","\n"],["body","然后重启NetworkManager"],["body","\n"],["body","sudo systemctl restart NetworkManager\n"],["body","\n"],["body","重启之后，再看看/etc/resolv.conf是不是有了新的dns"],["body","\n"],["body","cat /etc/resolv.conf\n"],["body","\n"],["body","也可以看看你的NetworkManager的状态"],["body","\n"],["body","sudo systemctl status NetworkManager\n"],["body","\n\n\n\n                    "],["body","\n\n                    \n                \n            \n\n            \n\n        \n\n\n\n\n        \n\n\n\n        \n        \n        \n\n        \n\n\n    \n    \n\n"]],[["_relative_fp","index.html"],["title","DNS&DHCP.md - 计算机网络"],["body","\n    \n        \n        \n\n        \n        \n\n        \n        \n\n        \n\n        \n        \n\n        \n\n        \n        \n\n        \n\n            \n                                \n                \n                    \n                        "],["body","\n                            \n                        "],["body","\n                        "],["body","\n                            \n                        "],["body","\n                        \n                            "],["body","Light"],["body","\n                            "],["body","Rust"],["body","\n                            "],["body","Coal"],["body","\n                            "],["body","Navy"],["body","\n                            "],["body","Ayu"],["body","\n                        \n                    \n\n                    "],["heading","计算机网络"],["body","\n\n                    \n\n                    \n                \n\n\n                \n                \n\n                \n                    "],["body","\n                        \n\n"],["body","\n"],["body","\n\n"],["headingLink","dns配置"],["heading","DNS配置"],["body","\n"],["headingLink","etchosts"],["heading","/etc/hosts"],["body","\n"],["body","在Linux系统，主机配置文件为/etc/hosts，这是主机名的静态查找表。这个文件是简单的文本文件，用于保存主机名称和IP之间对应关系。\n其格式为一个 IP 地址占用一行， 每一个主机关联一个IP地址（各个域之间用空格或制表字符分开）。格式如下：\n127.0.0.1 localhost [aliases...]"],["body","\n"],["headingLink","etchosts文件的作用"],["heading","/etc/hosts文件的作用"],["body","\n\n"],["body","\n"],["body","包含本地网络上的信息主机信息表"],["body","\n"],["body","\n"],["body","\n"],["body","DNS 输入：使用主机表作为 DNS 服务主机数据库的输入，或 者使用主机表作为备用配置。"],["body","\n"],["body","\n"],["body","\n"],["body","加快域名解析，节省网络流量\nhosts 文件在主机上配置具有加快域名解析的作用， 对于经常访问的网站和主机，我们可以在 hosts 文件中配置域名和 IP 的对应关系。由于有 了映射关系，当我们访问域名时，可以直接从 hosts 文件中解析得出，而不用访问网络上 的域名服务器，不用消耗网络流量。"],["body","\n"],["body","\n"],["body","\n"],["body","屏蔽网站（域名重定向）\n屏蔽广告网站，有很多网站带有广告，但广告和网站 本身域名不同，因此如果能屏蔽一些众所周知的广告网站域名，这样我们利用 hosts 把这 些广告的网站的域名映射到本机 IP 或非法目的 IP，这样就不会看到这些广告图片了,也不 会浪费网络流量。"],["body","\n"],["body","\n"],["body","\n"],["body","防止 DNS 污染和 DNS 劫持"],["body","\n\n"],["body","DNS 劫持就是攻破了 DNS 服务器防护，从而获得 域名解析记录的控制权，进而修改域名解析的结果。这将导致对原始域名的访问转到另外 的 IP 地址。"],["body","\n"],["body","DNS 污染是因为 DNS 查询没有任何认证机制，而且 DNS 查询通常采用的 UDP 是无 连接不可靠的协议，因此 DNS 的查询非常容易被篡改：通过对 UDP 端口 53 上的 DNS 查 询报文进行分析，一旦发现与关键词相匹配的请求则立即伪装成目标域名的解析服务器给 查询者返回虚假结果。"],["body","\n"],["body","如果我们已知服务器的 IP 地址，就可以在 hosts 文件中设置正确的 IP 地址，从而避 免 DNS 劫持和污染。"],["body","\n\n"],["body","\n\n"],["headingLink","广域网上的dns"],["heading","广域网上的DNS"],["body","\n\n"],["body","在因特网中，主机地址非常庞大，并且主 机的IP地址经常改变，因此使用域名系统 DNS 代替主机系统。"],["body","\n"],["body","DNS 可以被视为一种用于 TCP/IP 应用程序的分布式数据库，它提供主机名字和 IP 地址间的相互转换"],["body","\n"],["body","这里提到的分布式是指在因特网上的单个站点不能拥有所有的信息"],["body","\n"],["body","每个站点（如大学中的系、校园、公司或公司的部门）保留它自己的信息数据库，并运行一 个服务器程序供因特网上的其他系统查询。"],["body","\n\n"],["headingLink","域名结构"],["heading","域名结构"],["body","\n\n"],["body","未命名跟节点\n\n"],["body","net"],["body","\n\n\n"],["body","bjbook\n\n"],["body","www"],["body","\n\n"],["body","\n\n\n"],["body","com"],["body","\n\n\n"],["body","cctv"],["body","\n\n\n"],["body","gov"],["body","\n"],["body","org"],["body","\n"],["body","openwrt\nwww\ndev\nwiki"],["body","\n"],["body","ietf"],["body","\n"],["body","cn、sg、us"],["body","\n\n"],["body","\n\n\n"],["body","其最顶端有一个未命名的根节点，然后其下分为几个基本类别名称（称 为顶层域名），例如 com、org、net 和 gov 等 3字符域名，还有 cn、sg、jp 和 us 等两个字 符国家地区域名。"],["body","\n"],["body","每个节点有一个至多 63 个字符长的标识，域名总长度则不能超过 253 个字符。"],["body","\n"],["body","命名标识中不区分大写和小写。"],["body","\n"],["body","命名树上任何一个节点的域名就是将从该节点到 最高层的域名串连起来，中间使用一个点“.”分隔这些节点。例如，一个完整的域名为 www.bjbook.net。"],["body","\n"],["body","域名树中的每个节点必须有一个唯一的名称，但域名树中的不同层级节 点可使用相同的标识，只要在不同的父节点下即可。"],["body","\n\n"],["headingLink","dns报文格式"],["heading","DNS报文格式"],["body","\n\n"],["body","DNS默认使用TCP和UDP端口53。CS模型。DNS的请求和应答封装在UDP报文中。"],["body","\n"],["body","\n\n"],["body","| 会话标识                          | flags                    |\n| 问题数目(2字节)                   | 回答资源记录数(2字节)        |\n| 授权资源记录数(2字节)             | 额外资源记录数(2字节)         |\n|                   问题（可变长度）              |\n|            回答资源记录（可变长度）            |\n|           授权资源记录 （可变长度）          |\n|           附加信息资源 （可变长度）           |"],["body","\n"],["headingLink","会话标识"],["heading","会话标识"],["body","\n"],["body","报文头部的会话标识字段由客户端生成随机值填充并由服务器原样 返回。客户端通过该字段来匹配请求和响应。"],["body","\n"],["headingLink","flags"],["heading","flags"],["body","\n"],["body","flags部分非常复杂\n- 如果是请求一般为0x0100。\n- 如果为响应，通常有两种情况：\n- 0x8182表示服务器失败；\n- 0x8180表示服务器 成功响应。"],["body","\n"],["body","问题数目、回答资源记录数、授权资源记录数目、额外资源记录数目\n对于查询报文，问题数目通常是1，而其他3项则均为0。对于应答报文，问题数目还是1，回答数至少是1。"],["body","\n"],["headingLink","问题"],["heading","问题"],["body","\n\n"],["body","\n"],["body","问题部分中每个问题的格式由3部分顺序组成："],["body","\n\n"],["body","查询内容"],["body","\n"],["body","类型（Type）"],["body","\n"],["body","类（Class）。 类型和类均为固定的两个字节长度。"],["body","\n\n"],["body","\n"],["body","\n"],["body","查询内容长度不定，它是一个或多个标识符的序列。每个标识符以首字节的计数值来 说明随后字符串的字节长度，每个名字的最后字节为 0 表示结束。计数字节的值必须是 0～ 63 的数字，因为标识符的最大长度为 63。高位字节为二进制 11000000 时，用于压缩格式，指向 报文的查询字符串位置，字符串位置是从 DNS 报文头部开始计算的。"],["body","\n"],["body","\n\n"],["headingLink","回答资源记录授权资源记录附加信息资源记录"],["heading","回答资源记录、授权资源记录、附加信息资源记录"],["body","\n\n"],["body","DNS 报文中最后 3 个字段分别为回答字段、授权字段和附加信息字段，均采用资源记录（Resource Record，RR）格式"],["body","\n"],["body","资源记录格式内容顺序包含   域名、类型、类、生存时间、数据长度和数据6部分。\n\n"],["body","Name:域名是记录中资源数据对应的名字"],["body","\n"],["body","Type: 与问题域内容格式相同"],["body","\n"],["body","Class: 与问题域内容格式相同"],["body","\n"],["body","TimeToLive: 生存时间字段占4个字节，是客户程序保留该资源记录的 秒数"],["body","\n"],["body","DataLength: 数据长度字段占2个字节，指明资源数据的长度"],["body","\n"],["body","Address: 数据字段占4个字节，指明资源数据的内容。数据部分的格式依赖于类型字段的值"],["body","\n\n"],["body","\n\n"],["headingLink","域名解析过程"],["heading","域名解析过程"],["body","\n"],["body","client ->\n/etc/hosts ->\n/etc/resolv.conf\n-> DNS服务器1、DNS服务器2"],["body","\n"],["headingLink","etcresolvconf配置文件"],["heading","/etc/resolv.conf配置文件"],["body","\n"],["body","常见的配置如下:"],["body","\n\n"],["body","\n"],["body","nameserver: 域名服务器地址。最多可以设置 3 个名字服务器，每一行一个\n将按照列表顺序查询。若第一个域名服务器查询超 时，再顺序查询下面的域名服务器，直到所有的域名服务器都尝试一遍。如果没有域名服务器地址或者这个配置文件不存在，则默认使用本机（127.0.0.1）作为名字服务器 地址"],["body","\n"],["body","\n"],["body","\n"],["body","domain\n可以使用相对于本地域名的短名来查询。如果域名没有配置，则返回主机名。\n如果域名中不包含点。则认为是短域名。会附加此域名后缀"],["body","\n"],["body","\n"],["body","\n"],["body","search\n定义短域名时的附加列表。\n假设search参数设置为\"example.com, company.com\"，系统会按照顺序在这两个域名后面依次进行搜索。首先，系统会尝试解析\"webserver.example.com\"，如果找到了对应的IP地址，就会进行通信。如果没有找到，系统会继续尝试解析\"webserver.company.com\"。如果还是没有找到，最终会返回一个域名解析失败的错误。通过这种方式，search参数可以方便地进行域名搜索，省去了每次都要完整输入域名的麻烦。这对于在局域网或企业内部使用的内部域名解析非常有用。"],["body","\n"],["body","\n\n"],["headingLink","dhcp简介"],["heading","DHCP简介"],["body","\n\n"],["body","在 TCP/IP 网络上，每台主机在访问网络及其资源之前，都必须进行基本的网络信息 配置，包含 IP 地址、子网掩码、默认网关和 DNS 等"],["body","\n"],["body","在大型网络中，如果每台终端主 机的地址都由不同的使用者来分配，那么就很容易出现地址相同的情况"],["body","\n"],["body","对于经常移动 的终端，重新配置可能需要很长时间，并且容易出错，如果 IP 配置错误将会导致不能访问网络。因此需要一种机制来简化主机 IP 地址的配置。动态主机配置协议 DHCP 应运而生。"],["body","\n"],["body","采用 DHCP 的好处在于减少了网络管理员和用户的负担。这将可以减少手工配置 IP 地址导致的地址冲突，以及网关地址或 DNS 地址错误导致的不能访问网络等问题。"],["body","\n\n"],["headingLink","dhcp原理"],["heading","DHCP原理"],["body","\n\n"],["body","DHCP 服务器拥有一个 IP 地址池，当任何启用 DHCP 的客户机连接到网络时，可 从服务器那里租借一个 IP 地址，不再使用的 IP 地址自动回收到地址池中，供再次分配 使用。"],["body","\n"],["body","DHCP 保证同一时刻的任何 IP 地址只能分给一个客户机使用。当 DHCP 客户机重新 启动时，应配置为相同的 IP 地址。在 DHCP 服务器重启的情况下，也应当给每一个客户机分配相同的 IP 地址，并且和手动分配的 IP 地址共存。这要求 DHCP 服务器对已分配的 地址进行保存，并且在客户端不使用时进行回收。"],["body","\n"],["body","DHCP 是一种动态地向网络终端提供配置参数的协议。在终端提出申请之后，DHCP 服务器可以向终端提供 IP 地址及子网掩码、网关和 DNS 服务器地址等参数。"],["body","\n"],["body","DHCP 协议基于 UDP 协议，客户端的端口号是68，服务器的端口号是67。"],["body","\n\n"],["headingLink","dhcp报文"],["heading","DHCP报文"],["body","\n\n"],["body","DHCP的请求和应答封装在UDP报文中。"],["body","\n"],["body","IP层在请求 IP 地址时采用链路层广播，链路层广播地址为FF:FF:FF:FF:FF:FF"],["body","\n"],["body","网络层目的IP使用广播地址255.255.255.255，源地址采用 0.0.0.0，这是因为请求时自身没有 IP 地址，并且不知道服务器的 IP 地址。"],["body","\n\n"],["headingLink","dhcp工作流程"],["heading","DHCP工作流程"],["body","\n\n"],["body","DHCP 通常由客户端发起广播请求，服务器收到请求后在配置文件中查询，如果符合 要求则向客户端提供服务。\n\n"],["body","客户端在以太网上广播“DHCP Discover”报文来发现 DHCP 服务器。"],["body","\n"],["body","IP 为 10.0.2.2 的服务器收到广播请求后，向客户端回应请求，发出单播“DHCP Offer”报文，并且目的 IP 为 10.0.2.15。"],["body","\n"],["body","客户端再次以广播形式发出“DHCP Request”报文。这是因为客户端可能收到多个服务器“DHCP Offer”报文，客户端会根据报文的内容来选择一个给予响应，采用广播 形式可以让多个服务器均可收到。"],["body","\n"],["body","当服务器收到“DHCP Request”报文后，服务器在将客户端的 MAC 地址同分配的IP地址绑定后，将IP信息（IP、掩码、网关地址和 DNS 等）发送给客户机。"],["body","\n"],["body","客户机收到“DHCP ACK”报文后，将 IP 信息设置到主机系统上。这时 IP 设置 就完成了，客户机就可使用 IP 来访问网络了。"],["body","\n\n"],["body","\n\n\n\n\n                    "],["body","\n\n                    \n                \n            \n\n            \n\n        \n\n\n\n\n        \n\n\n\n        \n        \n        \n\n        \n\n\n    \n    \n\n"]],[["_relative_fp","Socks5协议.html"],["title","Socks5协议.md - 计算机网络"],["body","\n    \n        \n        \n\n        \n        \n\n        \n        \n\n        \n\n        \n        \n\n        \n\n        \n        \n\n        \n\n            \n                                \n                \n                    \n                        "],["body","\n                            \n                        "],["body","\n                        "],["body","\n                            \n                        "],["body","\n                        \n                            "],["body","Light"],["body","\n                            "],["body","Rust"],["body","\n                            "],["body","Coal"],["body","\n                            "],["body","Navy"],["body","\n                            "],["body","Ayu"],["body","\n                        \n                    \n\n                    "],["heading","计算机网络"],["body","\n\n                    \n\n                    \n                \n\n\n                \n                \n\n                \n                    "],["body","\n                        \n\n"],["body","\n"],["body","\n\n"],["headingLink","socks"],["heading","SOCKS"],["body","\n"],["body","SOCKS是一种网络传输协议，名字取做 Socket Security，主要用于客户端与外网服务器之间通讯的中间传递。"],["body","\n"],["body","这个协议最初由David Koblas开发，而后由NEC的Ying-Da Lee将其扩展到SOCKS4。最新协议是SOCKS5，与前一版本相比，增加支持UDP、验证，以及IPv6。"],["body","\n"],["body","根据OSI模型，SOCKS是会话层的协议，位于表示层与传输层之间。"],["body","\n"],["body","SOCKS协议不提供加密。"],["body","\n"],["headingLink","与http代理的对比"],["heading","与HTTP代理的对比"],["body","\n"],["body","SOCKS工作在比HTTP代理更低的层次：SOCKS使用握手协议来通知代理软件其客户端试图进行的SOCKS连接，然后尽可能透明地进行操作，而常规代理可能会解释和重写报头（例如，使用另一种底层协议，例如FTP；然而，HTTP代理只是将HTTP请求转发到所需的HTTP服务器）。虽然HTTP代理有不同的使用模式，HTTP CONNECT方法允许转发TCP连接；然而，SOCKS代理还可以转发UDP流量（仅SOCKS5），而HTTP代理不能。HTTP代理通常更了解HTTP协议，执行更高层次的过滤（虽然通常只用于GET和POST方法，而不用于CONNECT方法）。"],["body","\n"],["headingLink","版本分支"],["heading","版本分支"],["body","\n"],["headingLink","socks-4字节单位"],["heading","SOCKS 4（字节单位）"],["body","\n"],["headingLink","连接请求包"],["heading","连接请求包"],["body","\n"],["body","VN"],["body","CD"],["body","DSTPORT"],["body","DSTIP"],["body","USERID"],["body","NULL"],["body","\n"],["body","1"],["body","1"],["body","2"],["body","4"],["body","variable"],["body","1"],["body","\n\n\n\n"],["body","VN是SOCK版本，4；"],["body","\n"],["body","CD是SOCK的命令码，1表示CONNECT请求，2表示BIND请求；"],["body","\n"],["body","DSTPORT表示目的主机的端口；"],["body","\n"],["body","DSTIP指目的主机IP"],["body","\n"],["body","NULL是0"],["body","\n\n"],["headingLink","服务器响应包"],["heading","服务器响应包"],["body","\n"],["body","代理服务器而后发送回应包（以字节为单位）："],["body","\n"],["body","VN"],["body","CD"],["body","DSTPORT"],["body","DSTIP"],["body","\n"],["body","1"],["body","1"],["body","2"],["body","4"],["body","\n\n\n\n"],["body","VN是回应码的版本，应该是0；"],["body","\n"],["body","CD是代理服务器答复，有几种可能：\n\n"],["body","90，请求得到允许；"],["body","\n"],["body","91，请求被拒绝或失败；"],["body","\n"],["body","92，由于SOCKS服务器无法连接到客户端的identd（一个验证身份的进程），请求被拒绝；"],["body","\n"],["body","93，由于客户端程序与identd报告的用户身份不同，连接被拒绝。"],["body","\n\n"],["body","\n"],["body","DSTPORT与DSTIP与请求包中的内容相同，但被忽略。"],["body","\n\n"],["body","如果请求被拒绝，SOCKS服务器马上与客户端断开连接；如果请求被允许，代理服务器就充当客户端与目的主机之间进行双向传递，对客户端而言，就如同直接在与目的主机相连。"],["body","\n"],["headingLink","socks4a"],["heading","SOCKS4a"],["body","\n"],["body","SOCKS 4A是SOCKS 4协议的简单扩展，允许客户端对无法解析域名的目的主机进行访问。"],["body","\n"],["body","客户端对DSTIP的头三个字节设定为NULL，最后一个字节为非零；对应的IP地址就是0.0.0.x，其中x是非零，这当然不可能是目的主机的地址，这样即使客户端可以解析域名，对此也不会发生冲突。USERID以紧跟的NULL字节作结尾，客户端必须发送目的主机的域名，并以另一个NULL字节作结尾。CONNECT和BIND请求的时候，都要按照这种格式（以字节为单位）"],["body","\n"],["body","VN"],["body","CD"],["body","DSTPORT"],["body","DSTIP 0.0.0.x"],["body","USERID"],["body","NULL"],["body","HOSTNAME"],["body","NULL"],["body","\n"],["body","1"],["body","1"],["body","2"],["body","4"],["body","variable"],["body","1"],["body","variable"],["body","1"],["body","\n\n\n"],["body","使用4a协议的服务器必须检查请求包里的DSTIP字段，如果表示地址0.0.0.x，x是非零结尾，那么服务器就得读取客户端所发包中的域名字段，然后服务器就得解析这个域名，可以的话，对目的主机进行连接。"],["body","\n"],["headingLink","socks5"],["heading","SOCKS5"],["body","\n"],["headingLink","发送支持的认证列表"],["heading","发送支持的认证列表"],["body","\n"],["body","SOCKS5比SOCKS4a多了验证、IPv6、UDP支持。建立与SOCKS5服务器的TCP连接后客户端需要先发送请求来确认协议版本及认证方式，格式为（以字节为单位）："],["body","\n"],["body","VER"],["body","NMETHODS"],["body","METHODS"],["body","\n"],["body","1"],["body","1"],["body","1-255"],["body","\n\n\n\n"],["body","\n"],["body","VER是SOCKS版本，这里应该是0x05；"],["body","\n"],["body","\n"],["body","\n"],["body","NMETHODS是METHODS部分的长度；"],["body","\n"],["body","\n"],["body","\n"],["body","METHODS是客户端支持的认证方式列表，每个方法占1字节。当前的定义是："],["body","\n\n"],["body","\n"],["body","0x00 不需要认证"],["body","\n"],["body","\n"],["body","\n"],["body","0x01 GSSAPI"],["body","\n"],["body","\n"],["body","\n"],["body","0x02 用户名、密码认证"],["body","\n"],["body","\n"],["body","\n"],["body","0x03 - 0x7F由"],["body","\n"],["body","IANA"],["body","\n"],["body","分配（保留）"],["body","\n\n"],["body","0x03: 握手挑战认证协议"],["body","\n"],["body","0x04: 未分派"],["body","\n"],["body","0x05: 响应挑战认证方法"],["body","\n"],["body","0x06: 传输层安全"],["body","\n"],["body","0x07: NDS认证"],["body","\n"],["body","0x08: 多认证框架"],["body","\n"],["body","0x09: JSON参数块"],["body","\n"],["body","0x0A–0x7F: 未分派"],["body","\n\n"],["body","\n"],["body","\n"],["body","0x80 - 0xFE为私人方法保留"],["body","\n"],["body","\n"],["body","\n"],["body","0xFF 无可接受的方法"],["body","\n"],["body","\n\n"],["body","\n\n"],["headingLink","通知使用的认证方法"],["heading","通知使用的认证方法"],["body","\n"],["body","服务器从客户端提供的方法中选择一个并通过以下消息通知客户端（以字节为单位）："],["body","\n"],["body","VER"],["body","METHOD"],["body","\n"],["body","1"],["body","1"],["body","\n\n\n\n"],["body","VER是SOCKS版本，这里应该是0x05；"],["body","\n"],["body","METHOD是服务端选中的方法。如果返回0xFF表示没有一个认证方法被选中，客户端需要关闭连接。"],["body","\n\n"],["headingLink","发送请求"],["heading","发送请求"],["body","\n\n"],["body","\n"],["body","之后客户端和服务端根据选定的认证方式执行对应的认证。"],["body","\n\n"],["body","认证结束后客户端就可以发送请求信息。如果认证方法有特殊封装要求，请求必须按照方法所定义的方式进行封装。"],["body","\n\n"],["body","\n"],["body","\n"],["body","SOCKS5请求格式（以字节为单位）："],["body","\n"],["body","\n"],["body","VER"],["body","CMD"],["body","RSV"],["body","ATYP"],["body","DST.ADDR"],["body","DST.PORT"],["body","\n"],["body","1"],["body","1"],["body","0x00"],["body","1"],["body","动态"],["body","2"],["body","\n\n\n\n"],["body","VER是SOCKS版本，这里应该是0x05；"],["body","\n"],["body","CMD是SOCK的命令码\n\n"],["body","0x01表示CONNECT请求"],["body","\n"],["body","0x02表示BIND请求"],["body","\n"],["body","0x03表示UDP转发"],["body","\n\n"],["body","\n"],["body","RSV 0x00，保留"],["body","\n"],["body","ATYP DST.ADDR类型\n\n"],["body","0x01 IPv4地址，DST.ADDR部分4字节长度"],["body","\n"],["body","0x03 域名，DST.ADDR部分第一个字节为域名长度，DST.ADDR剩余的内容为域名，没有\\0结尾。"],["body","\n"],["body","0x04 IPv6地址，16个字节长度。"],["body","\n\n"],["body","\n"],["body","DST.ADDR 目的地址"],["body","\n"],["body","DST.PORT 网络字节序表示的目的端口"],["body","\n\n"],["body","\n\n"],["headingLink","响应"],["heading","响应"],["body","\n\n"],["body","\n"],["body","服务器按以下格式回应客户端的请求（以字节为单位）："],["body","\n"],["body","\n"],["body","VER"],["body","REP"],["body","RSV"],["body","ATYP"],["body","BND.ADDR"],["body","BND.PORT"],["body","\n"],["body","1"],["body","1"],["body","0x00"],["body","1"],["body","动态"],["body","2"],["body","\n\n\n\n"],["body","VER是SOCKS版本，这里应该是0x05；"],["body","\n"],["body","REP应答字段\n\n"],["body","0x00表示成功"],["body","\n"],["body","0x01普通SOCKS服务器连接失败"],["body","\n"],["body","0x02现有规则不允许连接"],["body","\n"],["body","0x03网络不可达"],["body","\n"],["body","0x04主机不可达"],["body","\n"],["body","0x05连接被拒"],["body","\n"],["body","0x06 TTL超时"],["body","\n"],["body","0x07不支持的命令"],["body","\n"],["body","0x08不支持的地址类型"],["body","\n"],["body","0x09 - 0xFF未定义"],["body","\n\n"],["body","\n"],["body","RSV 0x00，保留"],["body","\n"],["body","ATYP BND.ADDR类型\n\n"],["body","0x01 IPv4地址，DST.ADDR部分4字节长度"],["body","\n"],["body","0x03域名，DST.ADDR部分第一个字节为域名长度，DST.ADDR剩余的内容为域名，没有\\0结尾。"],["body","\n"],["body","0x04 IPv6地址，16个字节长度。"],["body","\n\n"],["body","\n"],["body","BND.ADDR 服务器绑定的地址"],["body","\n"],["body","BND.PORT 网络字节序表示的服务器绑定的端口"],["body","\n\n"],["body","\n\n"],["headingLink","密码认证方式"],["heading","密码认证方式"],["body","\n"],["body","在客户端、服务端协商使用用户名密码认证后，客户端发出用户名密码，格式为（以字节为单位）："],["body","\n"],["body","鉴定协议版本"],["body","用户名长度"],["body","用户名"],["body","密码长度"],["body","密码"],["body","\n"],["body","1"],["body","1"],["body","动态"],["body","1"],["body","动态"],["body","\n\n\n"],["body","鉴定协议版本目前为 0x01 。"],["body","\n"],["body","服务器鉴定后发出如下回应："],["body","\n"],["body","鉴定协议版本"],["body","鉴定状态"],["body","\n"],["body","1"],["body","1"],["body","\n\n\n"],["body","其中鉴定状态 0x00 表示成功，0x01 表示失败。"],["body","\n\n\n\n                    "],["body","\n\n                    \n                \n            \n\n            \n\n        \n\n\n\n\n        \n\n\n\n        \n        \n        \n\n        \n\n\n    \n    \n\n"]],[["_relative_fp","xl2tpd配置详解.html"],["title","xl2tpd配置详解.md - 计算机网络"],["body","\n    \n        \n        \n\n        \n        \n\n        \n        \n\n        \n\n        \n        \n\n        \n\n        \n        \n\n        \n\n            \n                                \n                \n                    \n                        "],["body","\n                            \n                        "],["body","\n                        "],["body","\n                            \n                        "],["body","\n                        \n                            "],["body","Light"],["body","\n                            "],["body","Rust"],["body","\n                            "],["body","Coal"],["body","\n                            "],["body","Navy"],["body","\n                            "],["body","Ayu"],["body","\n                        \n                    \n\n                    "],["heading","计算机网络"],["body","\n\n                    \n\n                    \n                \n\n\n                \n                \n\n                \n                    "],["body","\n                        \n\n"],["body","\n"],["body","\n\n"],["headingLink","简介"],["heading","简介"],["body","\n"],["body","xl2tpd的配置文件xl2tpd.conf一共有3种区块类型:"],["body","\n\n"],["body","global 全局配置章节"],["body","\n"],["body","lns LNS(L2TP Network Server网络服务器)配置章节，作为服务器时"],["body","\n"],["body","lac LAC(L2TP Access Concentrator接入汇聚点)配置章节，作为客户端时"],["body","\n\n"],["body","[section_type section_name]\nattribute1_key = attribute1_value\nattribute2_key = attribute2_value\n;this is a comments line\n"],["body","\n"],["body","章节类型为上面提到的global，lns， lac，章节可以取一个名字，在章节下面有由key = value组成的参数。值可以是字符，数字，boolean值，其中boolean值用yes,no表示。也可以用范围，例如192.168.0.1-192.168.0.20表示这个范围的IP。更多细节可以通过阅读源码里面的file.c文件了解。"],["body","\n"],["body","如果章节名指定为default，则这个章节下面的参数会应用到所有同类型的章节。"],["body","\n"],["headingLink","global-section"],["heading","GLOBAL SECTION"],["body","\n\n"],["body","\n"],["body","auth file"],["body","\n"],["body","指定身份验证文件，此文件用于l2tp隧道的身份验证。默认为/etc/xl2tpd/l2tp-secrets"],["body","\n"],["body","\n"],["body","\n"],["body","listen-addr"],["body","\n"],["body","守护进程监听的拥有此IP的网络接口。默认监听INADDR_ANY (0.0.0.0)，即所有网络接口。"],["body","\n"],["body","\n"],["body","\n"],["body","ipsec saref"],["body","\n"],["body","使用IPsec安全关联跟踪"],["body","\n"],["body","\n"],["body","\n"],["body","saref refinfo"],["body","\n"],["body","\n"],["body","\n"],["body","port"],["body","\n"],["body","UDP监听端口，默认1701。"],["body","\n"],["body","\n"],["body","\n"],["body","access control"],["body","\n"],["body","boolean值，如果设置为yes,xl2tpd进程只接受下面区块 里面peers adresses指定的连接。默认为no。"],["body","\n"],["body","\n"],["body","\n"],["body","debug avp"],["body","\n"],["body","是否开启L2TP AVP调试信息。AVP（Attribute-Value Pair)是一种用于在 L2TP 控制消息中传递信息的格式。"],["body","\n"],["body","\n"],["body","\n"],["body","debug network"],["body","\n"],["body","是否开启网络调试信息。"],["body","\n"],["body","\n"],["body","\n"],["body","debug packet"],["body","\n"],["body","是否开启打印L2TP数据包的调试信息。"],["body","\n"],["body","\n"],["body","\n"],["body","debug state"],["body","\n"],["body","是否打开FSM调试信息。（FSM有限状态机，指L2TP状态装换过程)"],["body","\n"],["body","\n"],["body","\n"],["body","debug tunnel"],["body","\n"],["body","是否开启隧道调试信息"],["body","\n"],["body","\n"],["body","\n"],["body","max retries"],["body","\n"],["body","指定隧道关闭前重试次数。如果当前没建立隧道，则停止重发。默认值为5。"],["body","\n"],["body","\n\n"],["headingLink","lns-section"],["heading","LNS SECTION"],["body","\n\n"],["body","\n"],["body","exclusive"],["body","\n"],["body","如果设置为yes，表示两端仅允许建立一条控制隧道。LNS这端可以和多个host建立隧道，但是对同一个host仅允许建立一个。"],["body","\n"],["body","\n"],["body","\n"],["body","(no) ip range"],["body","\n"],["body","指定LNS分配给LAC的端分配的ip地址范围，可以指定多个范围。如果以no开头表示非的意思，即不分配指定范围的ip。IP范围的格式为IP-IP(例如:1.1.1.1 - 1.1.1.10)。注意，至少分配一个IP范围，或者设置下面的参数assign ip为no 。"],["body","\n"],["body","\n"],["body","\n"],["body","assign ip"],["body","\n"],["body","是否让xl2tpd来分配ip。如果你想用其他方式来分配ip，例如ppp如果支持RADIUS AAA。"],["body","\n"],["body","\n"],["body","\n"],["body","(no) lac"],["body","\n"],["body","指定允许作为LNS连接xl2tpd的LAC的ip地址。格式与ip range选项相同。"],["body","\n"],["body","\n"],["body","\n"],["body","hidden bit"],["body","\n"],["body","开启L2TP的AVP hiding特性，AVP（Attribute-Value Pair)是一种用于在 L2TP 控制消息中传递信息的格式。"],["body","\n"],["body","\n"],["body","\n"],["body","local ip"],["body","\n"],["body","指定xl2tpd自己这端使用的ip地址"],["body","\n"],["body","\n"],["body","\n"],["body","length bit"],["body","\n"],["body","是否在l2tp包的payload里面加入长度字段。"],["body","\n"],["body","\n"],["body","\n"],["body","(refuse | require) chap"],["body","\n"],["body","是否拒绝或者启用对端ppp的CHAP身份验证方式"],["body","\n"],["body","\n"],["body","\n"],["body","(refuse | require) pap"],["body","\n"],["body","是否拒绝或者启用对端ppp的PAP身份验证方式"],["body","\n"],["body","\n"],["body","\n"],["body","(refuse | require) authentication"],["body","\n"],["body","是否需要对端开启身份验证"],["body","\n"],["body","\n"],["body","\n"],["body","unix authentication"],["body","\n"],["body","是否使用/etc/passwd作为对端ppp验证方式"],["body","\n"],["body","\n"],["body","\n"],["body","hostname"],["body","\n"],["body","xl2tpd协商时，上报的hostname。如果不指定，默认使用系统hostname"],["body","\n"],["body","\n"],["body","\n"],["body","ppp debug"],["body","\n"],["body","开启pppd的debug信息"],["body","\n"],["body","\n"],["body","\n"],["body","pass peer"],["body","\n"],["body","将对端IP地址传递给pppd作为ipparam.默认开启"],["body","\n"],["body","\n"],["body","\n"],["body","pppoptfile"],["body","\n"],["body","指定给pppd使用的配置文件路径"],["body","\n"],["body","\n"],["body","\n"],["body","call rws"],["body","\n"],["body","废弃选项，不解释。"],["body","\n"],["body","\n"],["body","\n"],["body","tunnel rws"],["body","\n"],["body","定义控制通道的窗口大小。窗口大小定义为未确认数据包的数量，而不是字节数。"],["body","\n"],["body","\n"],["body","\n"],["body","flow bits"],["body","\n"],["body","如果设置为yes，则在通信中将包含序列号。在会话中使用序列号的功能目前已被停用并且不起作用。"],["body","\n"],["body","\n"],["body","\n"],["body","challenge"],["body","\n"],["body","如果设置为yes，使用挑战认证方式进行认证"],["body","\n"],["body","\n"],["body","\n"],["body","rx bps"],["body","\n"],["body","设置最大接收带宽"],["body","\n"],["body","\n"],["body","\n"],["body","tx bps"],["body","\n"],["body","设置最大发送带宽"],["body","\n"],["body","\n\n"],["headingLink","lac-section"],["heading","LAC SECTION"],["body","\n"],["body","下列选项是LAC特定的选项。上面LNS章节结束的大多数选项都可以用于LAC，特别是l2tp协议微调选项或者认证/ppp相关的选项。"],["body","\n\n"],["body","\n"],["body","lns"],["body","\n"],["body","设置LNS的域名或者IP，LAC这端会用这个去连接LNS"],["body","\n"],["body","\n"],["body","\n"],["body","autodial"],["body","\n"],["body","是否开机自动拨号"],["body","\n"],["body","\n"],["body","\n"],["body","redial"],["body","\n"],["body","是否重拨，例如发现断连，自动重拨"],["body","\n"],["body","\n"],["body","\n"],["body","redial timeout"],["body","\n"],["body","重拨超时时间，单位秒。默认30秒。"],["body","\n"],["body","\n"],["body","\n"],["body","max redials"],["body","\n"],["body","重拨最大尝试次数。"],["body","\n"],["body","\n\n\n"],["body","\n"],["body","local ip"],["body","\n"],["body","本地IP"],["body","\n"],["body","\n\n\n\n\n                    "],["body","\n\n                    \n                \n            \n\n            \n\n        \n\n\n\n\n        \n\n\n\n        \n        \n        \n\n        \n\n\n    \n    \n\n"]],[["_relative_fp","tcpdump.html"],["title","tcpdump.md - 计算机网络"],["body","\n    \n        \n        \n\n        \n        \n\n        \n        \n\n        \n\n        \n        \n\n        \n\n        \n        \n\n        \n\n            \n                                \n                \n                    \n                        "],["body","\n                            \n                        "],["body","\n                        "],["body","\n                            \n                        "],["body","\n                        \n                            "],["body","Light"],["body","\n                            "],["body","Rust"],["body","\n                            "],["body","Coal"],["body","\n                            "],["body","Navy"],["body","\n                            "],["body","Ayu"],["body","\n                        \n                    \n\n                    "],["heading","计算机网络"],["body","\n\n                    \n\n                    \n                \n\n\n                \n                \n\n                \n                    "],["body","\n                        \n\n"],["body","\n"],["body","\n\n"],["headingLink","命令格式"],["heading","命令格式"],["body","\n"],["body","tcpdump [选项] [表达式]\n"],["body","\n"],["headingLink","选项"],["heading","选项"],["body","\n"],["headingLink","指定监听的网络接口"],["heading","指定监听的网络接口"],["body","\n"],["body","tcpdump -i eth0\n"],["body","\n"],["headingLink","不进行主机名解析直接显示ip地址"],["heading","不进行主机名解析，直接显示IP地址。"],["body","\n"],["body","tcpdump -n\n\n"],["body","\n"],["headingLink","不进行主机名和端口号解析"],["heading","不进行主机名和端口号解析。"],["body","\n"],["body","tcpdump -nn\n\n"],["body","\n"],["headingLink","-v--vv--vvv增加详细输出的级别"],["heading","-v, -vv, -vvv：增加详细输出的级别。"],["body","\n"],["body","tcpdump -vv\n\n"],["body","\n"],["headingLink","-c-count捕获指定数量的数据包后停止"],["heading","-c count：捕获指定数量的数据包后停止。"],["body","\n"],["body","tcpdump -c 10\n\n"],["body","\n"],["headingLink","-w-file将捕获的数据包写入文件"],["heading","-w file：将捕获的数据包写入文件。"],["body","\n"],["body","tcpdump -w capture.pcap\n\n"],["body","\n"],["headingLink","-r-file从文件中读取数据包进行分析"],["heading","-r file：从文件中读取数据包进行分析。"],["body","\n"],["body","tcpdump -r capture.pcap\n\n"],["body","\n"],["headingLink","-s-snaplen指定捕获的每个数据包的最大长度"],["heading","-s snaplen：指定捕获的每个数据包的最大长度。"],["body","\n"],["body","tcpdump -s 0\n\n\n-s 0 表示捕获整个数据包。\n\n"],["body","\n"],["body","-A：以ASCII格式显示数据包的内容。"],["body","\n"],["body","tcpdump -A\n\n"],["body","\n"],["body","-X：以十六进制和ASCII格式显示数据包的内容。"],["body","\n"],["body","tcpdump -X\n\n"],["body","\n"],["headingLink","表达式"],["heading","表达式"],["body","\n"],["headingLink","主机捕获特定主机的流量"],["heading","主机：捕获特定主机的流量。"],["body","\n"],["body","tcpdump host 192.168.1.1\n\n"],["body","\n"],["headingLink","网络捕获特定网络的流量"],["heading","网络：捕获特定网络的流量。"],["body","\n"],["body","tcpdump net 192.168.1.0/24\n\n"],["body","\n"],["headingLink","端口捕获特定端口的流量"],["heading","端口：捕获特定端口的流量。"],["body","\n"],["body","tcpdump port 80\n\n"],["body","\n"],["headingLink","协议捕获特定协议的流量如tcpudpicmp"],["heading","协议：捕获特定协议的流量（如TCP、UDP、ICMP）。"],["body","\n"],["body","tcpdump tcp\ntcpdump udp\ntcpdump icmp\n"],["body","\n"],["headingLink","源地址和目标地址捕获特定源或目标地址的流量"],["heading","源地址和目标地址：捕获特定源或目标地址的流量。"],["body","\n"],["body","tcpdump src 192.168.1.1\ntcpdump dst 192.168.1.1\n"],["body","\n"],["headingLink","布尔表达式"],["heading","布尔表达式"],["body","\n"],["headingLink","且"],["heading","且"],["body","\n"],["body","tcpdump src 192.168.1.1 and dst port 80\n"],["body","\n"],["headingLink","或"],["heading","或"],["body","\n"],["body","tcpdump src 192.168.1.1 or src 10.0.0.1\n\n"],["body","\n"],["headingLink","非"],["heading","非"],["body","\n"],["body","tcpdump not port 22\n\n"],["body","\n\n\n\n                    "],["body","\n\n                    \n                \n            \n\n            \n\n        \n\n\n\n\n        \n\n\n\n        \n        \n        \n\n        \n\n\n    \n    \n\n"]],[["_relative_fp","dns-searchdomain.html"],["title","dns-searchdomain.md - 计算机网络"],["body","\n    \n        \n        \n\n        \n        \n\n        \n        \n\n        \n\n        \n        \n\n        \n\n        \n        \n\n        \n\n            \n                                \n                \n                    \n                        "],["body","\n                            \n                        "],["body","\n                        "],["body","\n                            \n                        "],["body","\n                        \n                            "],["body","Light"],["body","\n                            "],["body","Rust"],["body","\n                            "],["body","Coal"],["body","\n                            "],["body","Navy"],["body","\n                            "],["body","Ayu"],["body","\n                        \n                    \n\n                    "],["heading","计算机网络"],["body","\n\n                    \n\n                    \n                \n\n\n                \n                \n\n                \n                    "],["body","\n                        \n\n"],["body","\n"],["body","\n\n"],["headingLink","search-domain简介"],["heading","Search Domain简介"],["body","\n"],["body","Search Domain是一项用于简化DNS解析的配置，其用途一般如下"],["body","\n"],["headingLink","简化域名输入"],["heading","简化域名输入"],["body","\n"],["body","当用户在浏览器中输入主机名而不是完全限定域名(FQDN: Fully qualified domain name)时，Search Domain可以帮助自动补全域名。"],["body","\n"],["body","例如，搜索域设置为public1.114dns.com，请求的域名为example时，系统会将其补全为example.public1.114dns.com。\n"],["body","\n"],["headingLink","dns记录类型"],["heading","DNS记录类型"],["body","\n"],["headingLink","a"],["heading","A"],["body","\n"],["body","将域名指向一个IPV4地址"],["body","\n"],["headingLink","cname"],["heading","CNAME"],["body","\n"],["body","将域名指向另外一个域名"],["body","\n"],["headingLink","aaaa"],["heading","AAAA"],["body","\n"],["body","将域名指向另一个IPV6地址"],["body","\n"],["headingLink","ns"],["heading","NS"],["body","\n"],["body","将子域名指定其他DNS服务器解析"],["body","\n"],["headingLink","mx"],["heading","MX"],["body","\n"],["body","将域名指向邮件服务器地址"],["body","\n"],["headingLink","srv"],["heading","SRV"],["body","\n"],["body","记录提供特定的服务的服务器"],["body","\n"],["headingLink","txt"],["heading","TXT"],["body","\n"],["body","文本长度限制512，通常做SPF记录"],["body","\n"],["headingLink","caa"],["heading","CAA"],["body","\n"],["body","CA证书颁发机构授权校验"],["body","\n"],["headingLink","显性url"],["heading","显性URL"],["body","\n"],["body","将域名重定向到另外一个地址"],["body","\n"],["headingLink","隐形url"],["heading","隐形URL"],["body","\n"],["body","与显性类似，但是会隐藏真实目的地址"],["body","\n\n\n\n                    "],["body","\n\n                    \n                \n            \n\n            \n\n        \n\n\n\n\n        \n\n\n\n        \n        \n        \n\n        \n\n\n    \n    \n\n"]],[["_relative_fp","路由器映射后公网能正常访问但局域网无法通过公网IP访问.html"],["title","路由器映射后公网能正常访问但局域网无法通过公网IP访问.md - 计算机网络"],["body","\n    \n        \n        \n\n        \n        \n\n        \n        \n\n        \n\n        \n        \n\n        \n\n        \n        \n\n        \n\n            \n                                \n                \n                    \n                        "],["body","\n                            \n                        "],["body","\n                        "],["body","\n                            \n                        "],["body","\n                        \n                            "],["body","Light"],["body","\n                            "],["body","Rust"],["body","\n                            "],["body","Coal"],["body","\n                            "],["body","Navy"],["body","\n                            "],["body","Ayu"],["body","\n                        \n                    \n\n                    "],["heading","计算机网络"],["body","\n\n                    \n\n                    \n                \n\n\n                \n                \n\n                \n                    "],["body","\n                        \n\n"],["body","\n"],["body","\n\n"],["headingLink","路由器映射后公网能正常访问但局域网无法通过公网ip访问"],["heading","路由器映射后公网能正常访问但局域网无法通过公网IP访问"],["body","\n"],["body","前段时间在公司的路由器上配置把公网IP映射到局域网中的一台电脑，映射为web服务器，在公司外面可以使用公网IP正常访问web服务，但公司内部使用公网IP确无法访问web服务。最开始以为是路由器配置问题，多次排查配置，没有发现问题；然后想到会不会是本机路由表的问题，尝试设置一些静态路由，问题依然没有解决；最后终于在网上找到类似的问题，原因是路由器硬件的问题，路由器不支持数据回流造成。"],["body","\n"],["body","关于“数据回流”介绍，在网上看到一篇很好的文章以下转帖。原文地址：http://www.5mwl.com/thread-17384-1-1.html"],["body","\n"],["body","回流是什么？最简单的一个实例：\n网吧内网一台主机192.168.0.2建了个WEB服务站点端口80，然后在网关(其内网地址是192.168.0.1、公网地址为218.4.218.4)上映射80端口到192.168.0.2的80端口，这样INTERNET上就能以http://218.4.218.4:80的地址访问到192.168.0.2的WEB站点了。然后出现了个问题，在同网吧的另一台电脑192.168.0.3上，键入http://218.4.218.4:80，却无法访问该WEB站点。就这个现象，我们就称之为“不支持回流”了，这里指的是网关上的映射方式不支持回流，所以说“回流”一说，是针对映射方式而言的。"],["body","\n"],["body","现在我们来看常规情况下，是为什么会发生这种情况的"],["body","\n"],["body","过程如下：\n192.168.0.3要请求访问218.4.218.4的80端口，根据它掌握的路由表，它本身是不知道电脑218.4.218.4在哪里的，所以把将这个数据包发送给它的默认路由，即电脑192.168.0.1。注意：这个数据包的源地址是192.168.0.3、源端口假设是1025、目标地址是218.4.218.4、目标端口是80、SYN标志位为1、这是建立TCP连接的第一次握手。如果“把目标地址为218.4.218.4的数据包发给了192.168.0.1”你听起来觉得有点矛盾，那么我解释一下：其实这个数据包的目标IP地址是218.4.218.4，目标MAC地址却是192.168.0.1的电脑192.168.0.1接收到了这份数据包(因为它的身份是路由器，所以允许接收和转发目标地址不是自已、MAC地址却是自已接口 MAC地址的数据包)，它分析这个数据包的目标地址，发现这个数据包是需要中转到电脑192.168.0.2:80去的，于是它把这个数据包转发给了电脑 192.168.0.2:80。注意：这个数据包的源地址是192.168.0.3、源端口是1025、目标地址为192.168.0.2、目标端口为80、SYN标志位为1。我们要注意这个数据包在转发后发生了变化了，即目标地址变了。电脑192.168.0.2顺利接到了数据包，它马上作出回应，发送一个数据包给电脑192.168.0.3。注意：这个数据包的源地址是192.168.0.2、源端口是80、目标地址192.168.0.3、目标端口为1025、SYN标志位为1、ACK标志位为1、这是建立TCP连接的第二次握手。电脑192.168.0.3顺利接到了数据包，然而它发现这是一个来自192.168.0.2:80的回应，因为ACK标志位值为1摆在那里呢。它想不起来什么时候给192.168.0.2:80这个目标对象发送过SYN请求，它认为这是一个错误的数据包，于是决定把这个数据包丢弃。然后继续等待 218.4.218.4:80的回应，一直等到超时。而电脑192.168.0.2这边，它等192.168.0.3:1025的第三次握手请求包发送过来，以便建立一个TCP的连接。同样也没有结果，一直等到超时。三次握手在规定的时间内没有完成，访问宣布流产了。"],["body","\n"],["body","那么怎么样才能正常访问呢？也就是说怎么样形成“回流”呢？\n玄机在于电脑192.168.0.1把第一次握手的那个数据包在转发时，不仅要修改目标地址和端口，也要修改源地址和端口，我们来看一下情况会有什么不同：电脑192.168.0.1接收到了这份数据包(因为它的身份是路由器，所以允许接收和转发目标IP地址不是自已、MAC地址却是自已接口MAC地址的数据包)，它分析这个数据包的目标地址，发现这个数据包是需要中转到电脑192.168.0.2:80去的，于是它把这个数据包通过自已的5201端口转发给了电脑192.168.0.2:80，并在内存里面记录下来了，192.168.0.1:5201已定位给了192.168.0.3:1025。注意：这个数据包的源地址是192.168.0.1、源端口是5201、目标地址为192.168.0.2、目标端口为80、SYN标志位为1。电脑192.168.0.2顺利接到了数据包，它马上作出回应，发送一个数据包给电脑192.168.0.1。注意：这个数据包的源地址是192.168.0.2、源端口是80、目标地址192.168.0.1、目标端口为5201、SYN标志位为1、ACK标志位为1、这是建立TCP连接的第二次握手。电脑192.168.0.1顺利接到了数据包，检查内存记录发现，这个数据包真正的收货人是192.168.0.3:1025，于是它把这个数据包转发给192.168.0.3。注意：这个数据包的的源地址是218.4.218.4、源端口为80、目标地址为192.168.0.3、目标端口为1025。我们要注意这个数据包在转发后发生变化了，即源地址变了。这很重要！为什么会变，因为在它心目当中，192.168.0.2:80早已定位给了218.4.218.4:80，映射规则使然。电脑192.168.0.3顺利接到了数据包，发现期待已久的218.4.218.4:80终于有了回音，它兴奋不已的发出第三次的握手请求。注意：这个数据包的源地址是192.168.0.3、源端口是1025、目标地址是218.4.218.4、目标端口是80、ACK标志位为1、这是建立TCP连接的第三次握手。跟前面的数据包一样，这个数据包会从192.168.0.1那里中转给192.168.0.2以后192.168.0.2:80和192.168.0.3:1025之间来往通信的数据包，全部由192.168.0.1负责中转，“回流”构成了"],["body","\n\n\n\n                    "],["body","\n\n                    \n                \n            \n\n            \n\n        \n\n\n\n\n        \n\n\n\n        \n        \n        \n\n        \n\n\n    \n    \n\n"]],[["_relative_fp","v2rayN代理.html"],["title","v2rayN代理.md - 计算机网络"],["body","\n    \n        \n        \n\n        \n        \n\n        \n        \n\n        \n\n        \n        \n\n        \n\n        \n        \n\n        \n\n            \n                                \n                \n                    \n                        "],["body","\n                            \n                        "],["body","\n                        "],["body","\n                            \n                        "],["body","\n                        \n                            "],["body","Light"],["body","\n                            "],["body","Rust"],["body","\n                            "],["body","Coal"],["body","\n                            "],["body","Navy"],["body","\n                            "],["body","Ayu"],["body","\n                        \n                    \n\n                    "],["heading","计算机网络"],["body","\n\n                    \n\n                    \n                \n\n\n                \n                \n\n                \n                    "],["body","\n                        \n\n"],["body","\n"],["body","\n\n"],["body","GITHUB"],["body","\n"],["headingLink","geo文件"],["heading","Geo文件"],["body","\n"],["body","Geo文件即路由规则文件：\n\n\"geosite.dat\"：提供一个预定义好的 「全球域名」 列表;  \n\n\"geoip.dat\" ：提供一个预定义好的 「全球 ip-地区」 列表.\n"],["body","\n"],["body",".dat文件里面有无数个分类，比如,中国的域名和IP都在 geosite:cn 和 geoip:cn*\n\ngfwlist的网址(也就是经典的PAC)在 geosite:gfw | [点击跳转](https://youtu.be/jjpBvUYotDc)\n\n广告域名在 geosite:category-ads-all\n国外域名在 geosite:geolocation-!cn\n本地IP在 geoip:private里;\n还有一千多种分类细分，比如 geosite:steam geosite:google 等，\n"],["body","\n"],["body","路由规则输入的格式"],["body","\n"],["body","domian:jamesdailylife.com\n"],["body","\n"],["body","相关域名和IP分类名的解释"],["body","\n"],["body","category-ads：包含了常见的广告域名。\ncategory-ads-all：包含了常见的广告域名，以及广告提供商的域名。\ncn：相当于 geolocation-cn 和 tld-cn 的合集。\napple：包含了 Apple 旗下绝大部分域名。\ngoogle：包含了 Google 旗下绝大部分域名。\nmicrosoft：包含了 Microsoft 旗下绝大部分域名。\nfacebook：包含了 Facebook 旗下绝大部分域名。\ntwitter：包含了 Twitter 旗下绝大部分域名。\ntelegram：包含了 Telegram 旗下绝大部分域名。\ngeolocation-cn：包含了常见的大陆站点域名。\ngeolocation-!cn：包含了常见的非大陆站点域名，同时包含了 tld-!cn。\ntld-cn：包含了 CNNIC 管理的用于中国大陆的顶级域名，如以 .cn、.中国 结尾的域名。\ntld-!cn：包含了非中国大陆使用的顶级域名，如以 .hk（香港）、.tw（台湾）、.jp（日本）、.sg（新加坡）、.us（美国）.ca（加拿大）等结尾的域名。\n\ncategory-games： 包含了 steam、ea、blizzard、epicgames 和 nintendo 等常见的游戏厂商。\n更多域名类别，请查看 data 目录 。\n"],["body","\n"],["body","OutBoundTag"],["body","\n\n"],["body","proxy: 代理"],["body","\n"],["body","direct：直连"],["body","\n"],["body","block: 阻止"],["body","\n\n"],["headingLink","越靠前的规则优先级越高"],["heading","越靠前的规则，优先级越高"],["body","\n"],["body","路由规则集范本"],["body","\n"],["body","白名单范例：https://raw.githubusercontent.com/2dust/v2rayCustomRoutingList/master/custom_routing_rules_whitelist"],["body","\n"],["body","黑名单范例：https://raw.githubusercontent.com/2dust/v2rayCustomRoutingList/master/custom_routing_rules_blacklist"],["body","\n"],["body","参考链接-1"],["body","\n"],["body","官方文档"],["body","\n\n\n\n                    "],["body","\n\n                    \n                \n            \n\n            \n\n        \n\n\n\n\n        \n\n\n\n        \n        \n        \n\n        \n\n\n    \n    \n\n"]],[["_relative_fp","SSH代理.html"],["title","SSH代理.md - 计算机网络"],["body","\n    \n        \n        \n\n        \n        \n\n        \n        \n\n        \n\n        \n        \n\n        \n\n        \n        \n\n        \n\n            \n                                \n                \n                    \n                        "],["body","\n                            \n                        "],["body","\n                        "],["body","\n                            \n                        "],["body","\n                        \n                            "],["body","Light"],["body","\n                            "],["body","Rust"],["body","\n                            "],["body","Coal"],["body","\n                            "],["body","Navy"],["body","\n                            "],["body","Ayu"],["body","\n                        \n                    \n\n                    "],["heading","计算机网络"],["body","\n\n                    \n\n                    \n                \n\n\n                \n                \n\n                \n                    "],["body","\n                        \n\n"],["body","\n"],["body","\n\n"],["headingLink","ssh代理"],["heading","SSH代理"],["body","\n"],["headingLink","常用选项"],["heading","常用选项"],["body","\n"],["body","1 | -C 压缩传输，加快传输速度\n2 | -f 在后台对用户名密码进行认证\n3 | -N 仅仅只用来转发，不用再弹回一个新的shell -n 后台运行\n4 | -q 安静模式，不要显示任何debug信息\n5 | -l 指定ssh登录名\n6 | -g 允许远程主机连接到本地用于转发的端口\n7 | -L 进行本地端口转发\n8 | -R 进行远程端口转发\n9 | -D 动态转发，即socks代理\n10 | -T 禁止分配伪终端\n11 | -p 指定远程ssh服务端口"],["body","\n"],["body","A -> B -> C"],["body","\n"],["headingLink","本地端口代理"],["heading","本地端口代理"],["body","\n"],["body","\n"],["body","将本地主机A的端口8888 由远程主机B 转发到目标主机C的IP地址和端口上。\nssh -L 8888:target-host:target-port proxy-host-user@proxy-host -p proxy-host-port"],["body","\n"],["body","\n"],["headingLink","f后台运行-q安静模式-n不执行远程命令"],["heading","f:后台运行 q:安静模式 N:不执行远程命令"],["body","\n"],["body","ssh -fqN -L 8888:192.168.3.11:80 weisanju@weisanju.dynv6.net -p 65533\nssh -fqN -L 8888:192.168.3.24:5230 weisanju@weisanju.dynv6.net -p 65533"],["body","\n"],["headingLink","远程端口代理"],["heading","远程端口代理"],["body","\n\n"],["body","在代理主机 proxy-host 上开启一个 access-port 端口 监听。"],["body","\n"],["body","并且代理主机将该端口的数据转发到目标主机 target-host 的 target-port 端口上。"],["body","\n"],["body","执行此命令的方是跳板机或者被代理主机：这条命令可以在被代理的主机上执行、也可以在代理的主机上执行"],["body","\n"],["body","注意：代理主机上的sshd_config需要开启 gatewayports yes 表示开启的端口监听在所有网卡上"],["body","\n\n"],["body","ssh -R <proxy-host-access-port>:target-host:target-port proxy-host-user@proxy-host -p proxy-host-port\n"],["body","\n"],["headingLink","动态端口代理"],["heading","动态端口代理"],["body","\n"],["body","可以理解为：在执行命令的地方 启动一个 socks5代理。将数据转发到代理主机上，由代理主机转发到目标主机上。"],["body","\n"],["body","ssh -D <local-port> proxy-host-user@proxy-host -p proxy-host-port\n"],["body","\n"],["headingLink","ssh自动重连"],["heading","SSH自动重连"],["body","\n"],["body","autossh -M 0 -fqN -L 8888:192.168.3.24:5230 weisanju@weisanju.dynv6.net -p 65533\nautossh -M 0 -fqN -L 8889:192.168.3.2:80 weisanju@weisanju.dynv6.net -p 65533\n\nautossh -M 0 -fqN -L 8889:192.168.3.1:80 weisanju@weisanju.dynv6.net -p 65533\n\n"],["body","\n"],["body","其中，-M 0表示关闭autossh的监控端口，-f表示在后台运行，-N表示不执行远程命令，只建立SSH连接，-L表示本地端口转发，<本地端口>\n是你要监听的本地端口，<目标主机>和<目标端口>是你要访问的目标主机和端口，<SSH用户名>和<SSH服务器地址>是你的SSH登录信息。"],["body","\n"],["headingLink","ssh配置自定义主机"],["heading","SSH配置自定义主机"],["body","\n"],["body","Host <自定义主机名>\nHostName <主机IP或域名>\nPort <端口号>\nUser <用户名>"],["body","\n"],["headingLink","proxycommand"],["heading","ProxyCommand"],["body","\n"],["body","ProxyCommand：用来指定连接到服务器的命令. 其可以是任何的命令,只要能从其标准输入读入数据,然后写出到标准输出即可.\n这条命令需要连接到sshd服务器上."],["body","\n"],["body","ssh -W命令\n-W host:port：将client过来的标准输入和输出forward到host和port指定的地方. 可以看到,这个选项直接就可以搭配上ProxyCommand的需求."],["body","\n"],["headingLink","单层跳板机"],["heading","单层跳板机"],["body","\n"],["body","Host 跳板机\n    HostName <主机IP或域名>\n    Port <端口号>\n    User <用户名>\n    IdentityFile <私钥路径>\n    StrictHostKeyChecking no\n    UserKnownHostsFile /dev/null\n\nHost <自定义主机名>\n    HostName <主机IP或域名>\n    Port <端口号>\n    User <用户名>\n    ProxyCommand ssh -q -x -W %h:%p <跳板机>\n"],["body","\n"],["headingLink","多层跳板机"],["heading","多层跳板机"],["body","\n"],["body","Host 跳板机1\n    HostName <主机IP或域名>\n    Port <端口号>\n    User <用户名>\n    IdentityFile <私钥路径>\n    StrictHostKeyChecking no\n    UserKnownHostsFile /dev/null\n\nHost 跳板机2\n    HostName <主机IP或域名>\n    Port <端口号>\n    User <用户名>\n    ProxyCommand ssh -q -x -W %h:%p <跳板机1>\n    \nHost <目标机>\n    HostName <主机IP或域名>\n    Port <端口号>\n    User <用户名>\n    ProxyCommand ssh -q -x -W %h:%p <跳板机2>\n"],["body","\n\n\n\n                    "],["body","\n\n                    \n                \n            \n\n            \n\n        \n\n\n\n\n        \n\n\n\n        \n        \n        \n\n        \n\n\n    \n    \n\n"]],[["_relative_fp","strongSwan.html"],["title","strongSwan.md - 计算机网络"],["body","\n    \n        \n        \n\n        \n        \n\n        \n        \n\n        \n\n        \n        \n\n        \n\n        \n        \n\n        \n\n            \n                                \n                \n                    \n                        "],["body","\n                            \n                        "],["body","\n                        "],["body","\n                            \n                        "],["body","\n                        \n                            "],["body","Light"],["body","\n                            "],["body","Rust"],["body","\n                            "],["body","Coal"],["body","\n                            "],["body","Navy"],["body","\n                            "],["body","Ayu"],["body","\n                        \n                    \n\n                    "],["heading","计算机网络"],["body","\n\n                    \n\n                    \n                \n\n\n                \n                \n\n                \n                    "],["body","\n                        \n\n"],["body","\n"],["body","\n\n"],["headingLink","strongswan简介"],["heading","strongSwan简介"],["body","\n"],["headingLink","securing-a-network"],["heading","Securing a Network"],["body","\n"],["body","strongSwan是一个完整的 IPsec 解决方案，为服务器和客户端提供加密和身份验证。strongSwan可用于保护与远程网络的通信，就如同本地通信一样"],["body","\n"],["headingLink","gateway"],["heading","Gateway"],["body","\n"],["body","网关通常是你的防火墙。同时也会承担小网络中的 DHCP DNS"],["body","\n"],["headingLink","remote-access--roadwarrior-clients"],["heading","Remote Access / Roadwarrior Clients"],["body","\n"],["body","“Roadwarriors” 在 VPN 和网络安全领域中是一个术语，通常指的是需要从不同地点、通过公共网络（如互联网）连接到公司内部网络的远程用户。这些用户可能是在家办公的员工、经常出差的人员，或者其他需要远程访问公司资源的用户。"],["body","\n"],["body","在 StrongSwan 的文档中 roadwarriors 这个术语具体指的是那些使用 IPsec VPN 客户端，从任何地方（不固定位置）连接到公司 VPN 网关的用户。为这些用户配置 VPN 可以确保他们的连接安全、数据加密，从而保护公司网络和信息的安全。"],["body","\n"],["headingLink","remote-hosts--host-to-host"],["heading","Remote Hosts / Host-to-Host"],["body","\n"],["body","This can be a remote web server or a backup system. This is illustrated in the image by host **winnetou** and either of the gateways **moon** and **sun**. The connection between the two hosts can usually be initiated by either one of them."],["body","\n"],["body","这可以是远程web服务器或备份系统"],["body","\n"],["headingLink","remote-sites--site-to-site"],["heading","Remote Sites / Site-to-Site"],["body","\n"],["body","位于不同位置的两个或更多子网中的主机应该能够相互访问。且能够加密通信"],["body","\n"],["headingLink","ike-and-ipsec-basics"],["heading","IKE and IPsec Basics"],["body","\n"],["body","strongSwan is basically a keying daemon that uses the Internet Key Exchange Version 2 (IKEv2) protocol to establish Security Associations (SAs) and negotiate Security Policies (SPs) between two peers. For legacy applications IKEv1 is still supported, although we strongly discourage from using IKEv1 due to stability and some security reasons (it is now officially deprecated)."],["body","\n"],["body","IKE provides strong authentication of both peers and derives unique cryptographically-strong session keys. Such an IKE session is often denoted IKE_SA in our documentation. Besides authentication and key material IKE also provides the means to exchange configuration information (e.g. virtual IP addresses) and to negotiate IPsec SAs, which are often called CHILD_SAs. IPsec SAs define which network traffic is to be secured and how it has to be encrypted and authenticated."],["body","\n"],["body","A CHILD_SA consists of two components:"],["body","\n\n"],["body","The actual IPsec SAs (two of them are established, one in each direction) describing the algorithms and keys used to encrypt and authenticate the traffic."],["body","\n"],["body","The policies (there are at least two) that define which network traffic shall use that SA."],["body","\n\n"],["body","The policies work both ways, i.e. only traffic matching an inbound policy will be allowed after decryption. Policies are derived from the traffic selectors (TS) negotiated via IKE when establishing a CHILD_SA. Unprotected traffic that the kernel receives and for which there is no matching inbound IPsec policy will be dropped. This is a security feature."],["body","\n"],["body","The actual IPsec traffic is not handled by strongSwan but will be relegated to the network and IPsec stack of the operating system kernel. strongSwan installs the negotiated IPsec SAs and SPs into the kernel by using a platform-dependent kernel interface."],["body","\n"],["body","The mentioned distinction between policies and SAs often leads to misconceptions. For instance, referring to the image above, if host **moon** has a site-to-site tunnel to host **sun** (connecting the two networks **10.1.0.0/16** and **10.2.0.0/24**) and host **carol** has a roadwarrior connection to host **sun** (from which **carol** received a virtual IP address of **10.3.0.10**). Then **carol** won’t be able to automatically communicate with **alice**, even if forwarding is enabled on **sun**. This is because there is no IPsec policy allowing traffic between **carol** (**10.3.0.10**) and **alice** (**10.1.0.10**). An additional SA between **moon** and **sun** connecting the virtual subnet **10.3.0.0/24** with **10.1.0.0/16** would be a possible solution to this issue."],["body","\n"],["body","Generally, IPsec processing and routing are not directly related. IPsec is often just bumped into the network stack and matching traffic is processed transparently (policy-based). So any routes to the remote TS will technically work for packets to get forwarded and processed by IPsec. However, source address selection can be a problem when traffic is sent from the VPN host itself. If the local TS don’t include its \"public\" address, traffic would not get processed if the source address is e.g. selected based on the default route. This is particularly true if virtual IP addresses are used. So to ensure that an address from a local TS is selected as source, the strongSwan **charon** IKE daemon, by default, installs specific routes to the remote TS for most CHILD_SAs (excluded are e.g. those that use transport mode or TS with specific ports/protocol)."],["body","\n"],["body","An alternative approach is route-based IPsec that uses interfaces and explicit routes to control what packets are going to be processed by IPsec tunnels (traffic routed that way still has to match the negotiated policies)."],["body","\n"],["body","strongSwan 基本上是一个密钥守护进程，使用 Internet 密钥交换版本 2 (IKEv2) 协议来建立安全关联 (SAs： Security Associations ) 并协商两个对等体之间的安全策略 (SPs： Security Policies)。对于传统应用，IKEv1 仍然受支持，尽管由于稳定性和某些安全原因（现已正式弃用），我们强烈不建议使用 IKEv1。"],["body","\n"],["body","IKE 提供对两个对等体的强认证并生成唯一的、加密强度高的会话密钥。在我们的文档中，这样的 IKE 会话通常被称为 IKE_SA。除了认证和密钥材料，IKE 还提供了交换配置信息（例如虚拟 IP 地址）和协商 IPsec SAs 的手段，后者通常被称为 CHILD_SAs。IPsec SAs 定义了哪些网络流量需要被保护以及如何加密和认证这些流量。"],["body","\n"],["body","一个 CHILD_SA 由两个组件组成："],["body","\n\n"],["body","实际的 IPsec SAs（每个方向建立两个），描述用于加密和认证流量的算法和密钥。"],["body","\n"],["body","定义哪些网络流量将使用该 SA 的策略（至少有两个）。"],["body","\n\n"],["body","这些策略是双向工作的，即只有匹配入站策略的流量在解密后才会被允许通过。策略是从在建立 CHILD_SA 时通过 IKE 协商的流量选择器（TS： traffic selectors (）派生的。内核接收到的没有匹配的入站 IPsec 策略的未保护流量将被丢弃。这是一个安全特性。"],["body","\n"],["body","实际的 IPsec 流量 不是由 strongSwan 处理的，而是由操作系统内核的网络和 IPsec 堆栈处理的。strongSwan 通过使用平台相关的内核接口将协商的 IPsec SAs 和 SPs 安装到内核中。"],["body","\n"],["body","提到的策略和 SAs 之间的区别常常导致误解。"],["body","\n"],["body","\n"],["body","例如，参考上图，如果主机 **moon** 有一个到主机 **sun** 的站点到站点隧道（连接两个网络 **10.1.0.0/16** 和 **10.2.0.0/24**），并且主机 **carol** 有一个到主机 **sun** 的 roadwarrior 连接（从 **sun** 处获得虚拟 IP 地址 **10.3.0.10**）。那么，即使在 **sun** 上启用了转发，**carol** 也无法自动与 **alice** 通信。这是因为没有允许 **carol**（**10.3.0.10**）和 **alice**（**10.1.0.10**）之间流量的 IPsec 策略。在 **moon** 和 **sun** 之间建立一个额外的 SA，连接虚拟子网 **10.3.0.0/24** 和 **10.1.0.0/16**，可能是解决这个问题的一个方法。"],["body","\n"],["body","一般来说，IPsec 处理和路由不是直接相关的。IPsec 通常只是被集成到网络堆栈中，匹配的流量被透明地处理（基于策略）。因此，任何到远程 TS 的路由在技术上都可以工作，使数据包得以转发和被 IPsec 处理。然而，当流量从 VPN 主机自身发送时，源地址选择可能会成为问题。如果本地 TS 不包括其“公共”地址，那么当基于默认路由选择源地址时，流量将不会被处理。这在使用虚拟 IP 地址时尤为真实。因此，为确保选择本地 TS 的地址作为源，strongSwan **charon** IKE 守护进程默认情况下会为大多数 CHILD_SAs（不包括使用传输模式或具有特定端口/协议的 TS）安装特定的远程 TS 路由。"],["body","\n"],["body","一种替代方法是 基于路由 的 IPsec，它使用接口和显式路由来控制将通过 IPsec 隧道处理哪些数据包（这种方式路由的流量仍必须匹配协商的策略）。"],["body","\n"],["headingLink","authentication-basics"],["heading","Authentication Basics"],["body","\n"],["body","为了确保建立 IKE_SA 的对等方确实是它所声称的那样，必须对其进行认证。"],["body","\n"],["body","strongSwan 提供了几种方法来实现这一点："],["body","\n"],["headingLink","公钥认证"],["heading","公钥认证"],["body","\n"],["body","使用 RSA、ECDSA 或 EdDSA X.509 证书来验证对等方的真实性。"],["body","\n"],["body","证书可以是自签名的（这种情况下必须安装在所有对等方上）或由公共证书颁发机构（CA）签名的。后者大大简化了部署和配置，因为网关只需要 CA 证书来认证所有提供由该 CA 签名的有效证书的对等方。"],["body","\n"],["body","可以使用证书撤销列表（CRLs）或在线证书状态协议（OCSP）来验证证书的有效性。"],["body","\n"],["body","为了安全存储私钥，可以通过 pkcs11 插件使用智能卡。"],["body","\n"],["body","为了防止中间人攻击，对等方声称的身份必须通过证书确认，无论是通过 subjectDn 还是 subjectAltName 扩展。"],["body","\n"],["headingLink","预共享密钥认证psk"],["heading","预共享密钥认证（PSK）"],["body","\n"],["body","预共享密钥是一种易于部署的选项，但它需要强大的秘密才能确保安全。"],["body","\n"],["body","如果 PSK 为许多用户所知（这在 IKEv1 XAuth with PSK 中经常发生），任何知道该秘密的用户都可以冒充网关。因此，这种方法不推荐用于大规模部署。"],["body","\n"],["headingLink","可扩展认证协议eap"],["heading","可扩展认证协议（EAP）"],["body","\n"],["body","这涵盖了几种可能的认证方法，有些基于用户名/密码认证（EAP-MD5、EAP-MSCHAPv2、EAP-GTC）或 X.509 证书（EAP-TLS）。有些甚至可以隧道其他 EAP 方法（EAP-TTLS、EAP-PEAP）。"],["body","\n"],["body","用户的实际认证可以通过 eap-radius 插件委托给 RADIUS 服务器。"],["body","\n"],["body","EAP 认证只能与 IKEv2 一起使用，并且对于某些方法，使用 xauth-eap 插件可以与 IKEv1 一起使用。"],["body","\n"],["headingLink","扩展认证xauth"],["heading","扩展认证（XAuth）"],["body","\n"],["body","XAuth 在 IKEv1 中提供了一个灵活的认证框架。它主要用于基于用户名/密码的认证。它通常作为基于 X.509 证书或 PSK 的相互认证后的第二种认证方法使用。然而，使用 IKEv1 混合认证，可以通过证书认证网关，并仅使用 XAuth 认证客户端。"],["body","\n"],["body","使用 IKEv2，可以进行多轮认证（RFC 4739），例如，首先使用 X.509 证书认证机器，然后使用基于用户名/密码的认证方案（例如 EAP-MSCHAPv2）认证用户。还可以使用不对称认证，例如在第一轮认证中通过证书认证网关，通过基于用户名/密码的 EAP 方法认证客户端。请注意，并非所有 IKEv2 实现都支持 RFC 4739 扩展。"],["body","\n"],["body","我们的网站提供了数十个配置示例，涵盖了这些和其他认证选项。"],["body","\n"],["headingLink","configuration-files"],["heading","Configuration Files"],["body","\n"],["body","The recommended way of configuring strongSwan is via the powerful **vici** control interface and the **swanctl** command line tool. The **swanctl.conf** configuration file used by **swanctl** is stored together with certificates and corresponding private keys in the **swanctl** directory."],["body","\n"],["body","Global strongSwan settings as well as plugin-specific configurations are defined in **strongswan.conf**."],["body","\n"],["body","Alternatively, the legacy **stroke** control interface and the **ipsec** command line tool can be used with the deprecated **ipsec.conf** and **ipsec.secrets** configuration files."],["body","\n"],["headingLink","other-configuration-sources"],["heading","Other Configuration Sources"],["body","\n"],["body","The configuration may also be loaded from an SQL database or can be provided by custom plugins. Using the **charon-nm** daemon variant, the NetworkManager can be used to manage VPN connections."],["body","\n"],["headingLink","invocation-and-maintenance"],["heading","Invocation and Maintenance"],["body","\n"],["body","在现代发行版中，strongSwan 通常使用 swanctl 命令进行管理，而 IKE charon 守护进程由 systemd 控制。在传统安装中，strongSwan 由 ipsec 命令控制，其中 ipsec start 将启动 starter 守护进程，进而启动并配置密钥管理的 charon 守护进程。"],["body","\n"],["body","在 swanctl.conf 中定义的 IKE 连接和 CHILD SAs 可以通过三种不同的方式启动："],["body","\n"],["headingLink","基于流量"],["heading","基于流量"],["body","\n"],["body","如果使用 start_action = trap，则会为配置的流量（通过 local_ts/remote_ts 定义）安装 IPsec trap 策略，匹配这些策略的流量将触发获取事件，导致守护进程建立所需的 IKE/IPsec SAs。这也用于 passthrough/drop IPsec 策略，让特定流量绕过其他策略/SAs 或完全丢弃它。"],["body","\n"],["headingLink","启动时"],["heading","启动时"],["body","\n"],["body","配置了 start_action = start 的 CHILD SAs 会在守护进程启动时自动建立。当它们由于某种原因下线时，不会自动重启。需要指定其他配置设置（dpd_action 和/或 close_action）以自动重启它们，但即便如此，该设置也不完美，可能会导致数据包泄漏。建议使用 trap 策略，并阅读 SecurityRecommendations 以解决任何问题。"],["body","\n"],["headingLink","手动"],["heading","手动"],["body","\n"],["body","没有使用 start_action 的连接必须通过 swanctl --initiate 手动建立，或者被动地作为响应者等待对等方/roadwarrior 连接。根据配置，也可以使用 swanctl --install 手动安装这些连接的策略，就像 start_action = trap 在启动时所做的那样。"],["body","\n"],["body","在建立 SA 后，可以使用 swanctl --terminate 来拆除 IKE_SA 或单个 CHILD_SAs。"],["body","\n"],["body","每当 swanctl.conf 文件或 swanctl 目录中的凭证发生更改时，可以使用不同的 swanctl --load-.. 命令重新加载这些更改。已经建立的连接不受这些命令的影响（除非使用了 start_action = start）。如果需要更新配置，必须重新启动 SAs 或守护进程。"],["body","\n"],["body","使用不同的 swanctl --list-.. 命令可以提供有关已加载或缓存的证书、支持的算法和已加载插件的信息。"],["body","\n"],["headingLink","logging-and-monitoring"],["heading","Logging and Monitoring"],["body","\n"],["body","如果遇到问题，提高日志级别可能有助于理解具体出了什么问题。不同的日志选项在单独的文档或 strongswan.conf 手册页中有所描述。调试问题的推荐日志设置可以在这里找到。"],["body","\n"],["body","每当遇到类似 received … error notify 的日志消息，其中占位符 … 例如 NO_PROPOSAL_CHOSEN 或 TS_UNACCEPTABLE 时，应查阅远程对等方的日志，以找出最初生成该错误通知的原因。"],["body","\n"],["body","swanctl --list-.. 命令将提供有关已建立和配置连接的信息。"],["body","\n"],["body","在 Linux 上，iproute2 包提供了 ip xfrm state 和 ip xfrm policy 命令，可以请求有关内核中安装的 IPsec SAs 和策略的详细信息。添加 -s 选项将显示广泛的统计信息，例如传输或无效数据包的数量。在其他平台上，ipsec-tools 包中的 setkey 命令提供类似的信息。"],["body","\n"],["body","tcpdump 和 wireshark 也常常对调试问题有用。"],["body","\n"],["body","在使用 ping 测试连接时，确保选择一个包含在本地流量选择器中的源 IP 地址（使用 -I 选项）（也请参阅下面的站点到站点配置）。"],["body","\n"],["headingLink","pki"],["heading","PKI"],["body","\n"],["body","要使用基于证书的认证，您需要创建自签名证书或建立一个完整的公钥基础设施（PKI），包括证书颁发机构（CA）、可选的中间 CA 和终端实体证书，以及证书吊销列表（CRL）或其他方法（如 OCSP）来验证证书的有效性。"],["body","\n"],["body","生成证书的最简单方法之一是使用 **pki** 工具。由于建立整个 PKI 可能相当复杂，我们提供了一些 简单的说明 以帮助您入门。"],["body","\n"],["body","OpenSSL 也是生成证书的广泛替代方案，还有一些基于 GUI 的 CA 管理工具。微软的 Active Directory Certificate Services（AD CS）也可以用于大规模 PKI。"],["body","\n"],["headingLink","证书要求"],["heading","证书要求"],["body","\n\n"],["body","\n"],["body","生成的终端实体证书需要认证相应的远程 IKE ID 以使对等认证成功。"],["body","\n"],["body","\n"],["body","\n"],["body","为了使用一个或多个证书（也可以使用属性证书）对另一个 strongSwan 实例进行认证，证书必须认证主机发送的 IKE ID。"],["body","\n"],["body","如果 Alice 试图以 Alice（她自己）的身份对 Bob 进行认证，那么 Alice 的证书必须包含至少一个正确类型（FQDN）和值为 Alice 的 **subjectAltName**（SAN）字段，或者 **subjectDistinguishedName**（DN），而不是 **commonName**（CN），必须为 Alice！"],["body","\n"],["body","换句话说，您可以使用完整的 **DN** 或任何 **SAN** 字段（假设类型正确）作为 IKE ID。有关详细信息，请参阅 关于证书的注释。"],["body","\n"],["body","\n"],["body","\n"],["body","此外，证书必须被 Bob 信任，要么 Bob 事先知道该证书有效，要么该证书由 Bob 信任的证书颁发机构（CA）颁发。"],["body","\n"],["body","\n"],["body","\n"],["body","为了认证成功，另一个对等方必须拥有从根证书（根 CA）到终端实体证书（主机或用户证书）的完整 X.509 证书信任链，包括所有中间证书（中间 CA）。这可以通过向远程主机发送任何中间证书或远程主机已在本地安装这些证书来完成。"],["body","\n"],["body","\n\n"],["body","第三方 IKE 实现的基于证书认证的要求在 Microsoft Windows 和 Apple iOS/macOS 的单独文档中有所说明。"],["body","\n"],["headingLink","关于证书的注释"],["heading","关于证书的注释"],["body","\n"],["body","作为 X.509 信任链顶端的根 CA 证书总是自签名的，因此可以被任何人伪造，**永远不要**将其发送到另一个主机。任何对等方必须以可信的方式在本地安装根 CA 证书，且绝不接受通过网络接收到的任何根 CA 证书。"],["body","\n"],["body","仅在以下任一设置为真时，本地证书才会发送到另一台主机："],["body","\n\n"],["body","本地主机在其使用的连接定义中设置了 **connections.<conn>.send_cert = always**。"],["body","\n"],["body","远程对等方通过发送 CERTREQ 负载向本地对等方请求由可信 CA 颁发的证书，该负载指示从本地主机的证书到其根 CA 证书路径中的一个 CA。"],["body","\n\n"],["headingLink","routing"],["heading","Routing"],["body","\n"],["body","在 Linux 上，strongSwan 默认将路由安装到路由表 220，因此需要内核支持基于策略的路由。"],["body","\n"],["body","您可以使 charon 守护进程将路由安装到任何您喜欢的表中，或者完全禁用它们。为此，可以在 strongswan.conf 中使用 charon.install_routes、charon.routing_table 和 charon.routing_table_prio 设置。当在两个子网之间建立隧道时，charon 会尝试在隧道的本地子网中找到本地 IP。这样的 IP 必须配置为 global 作用域以便查找。如果找到有效的 IP，charon 会安装一个路由，指向远程子网，其中源 IP 设置为找到的 IP。这会导致如下的路由："],["body","\n"],["body","css\n复制代码\n10.1.0.0/24 via 10.2.0.1 src 10.2.0.2\n"],["body","\n"],["body","在这个例子中，本地 IP 将是 10.2.0.2。远程子网将是 10.1.0.0/24。这是为了使发送到远程子网的数据包使用正确的源 IP。因此，IPsec 策略将匹配，从本地机器到远程子网的流量将通过 IPsec 进行保护。"],["body","\n"],["body","为了避免与这些路由发生冲突（特别是如果使用虚拟 IP 地址），kernel-netlink 插件会手动解析主机的路由表，以确定发送 IKE 数据包时的合适源地址。在具有（非常）大量路由的主机上，这非常低效。在这种情况下，建议在 strongswan.conf 中设置 charon.plugins.kernel-netlink.fwmark，因为它允许使用更有效的源地址查找。"],["body","\n"],["body","为了检测连接变化，strongSwan 解析内核在安装或删除路由时发送的事件，因此，当运行在通过动态路由接收大量路由的系统上时，可能会导致高 CPU 负载。可以通过在 strongswan.conf 中设置 charon.process_route = no 来禁用连接变化检测。"],["body","\n"],["body","如果使用 IPv6，请确保在必要时绕过邻居发现协议（NDP）流量。当隧道传输流量时，可能会遇到 MSS/MTU 问题。请参阅转发和分割隧道的详细信息。"],["body","\n"],["headingLink","remote-access-configurations远程访问配置"],["heading","Remote Access Configurations（远程访问配置）"],["body","\n"],["body","在本节中，我们将展示一些常见远程访问使用案例的示例配置。在这些所谓的“roadwarrior”场景中，移动客户端能够连接到一个远程网络。由于这些客户端很可能从未知的IP地址连接，网关将使用 remote_addrs = %any 来字面上接受来自任何地方的连接。为了简化返回给客户端的流量路由（ routing traffic back ），并且由于 roadwarriors 通常位于一个或多个NAT设备之后，使用 virtual IP 地址是必要的。"],["body","\n"],["body","虚拟IP地址可以来自一个独立的子网，或者实际上可以通过使用 **farp** 插件（以及可选的e **dhcp** 插件）来自网关后面的子网。"],["body","\n"],["body","需要考虑的另一个问题是，“roadwarriors”是否会将所有的流量发送到网关，或者使用分离隧道（ split-tunneling,），即只通过隧道发送特定目的地的流量。有关这一点的更详细解释可以在“转发和分离隧道”  Forwarding and Split-Tunneling. 中找到。该文档还解释了如何将流量转发 forwarded 给网关后面的主机。"],["body","\n"],["headingLink","ikev2-configurations"],["heading","IKEv2 Configurations"],["body","\n"],["body","The three strongSwan gateway configurations shown for the Windows clients may be used for all IKEv2 clients:"],["body","\n\n"],["body","Certificate-based Authentication"],["body","\n"],["body","Certificate-based EAP-TLS Authentication"],["body","\n"],["body","Password-based EAP Authentication"],["body","\n\n"],["body","In all three use cases the gateway is authenticated by a certificate while the clients either authenticate themselves based on certificates (1, 2) or on username/password schemes (3). The generic EAP use case (3) incorporates the EAP-TLS use case (2), so that only two configurations (1, 3) must be implemented in parallel on a strongSwan VPN gateway to leave it up to the VPN clients to select any of the three authentication methods above."],["body","\n"],["body","With the **eap-radius** plugin, user authentication may be delegated to a RADIUS server (e.g. an existing Active Directory DC)."],["body","\n"],["body","Both the strongSwan VPN Client for Android and NetworkManager may be used with any of the strongSwan VPN gateway configurations. Alternatively the **charon-cmd** command line IKEv2 client provides a simple means to establish roadwarrior connections."],["body","\n"],["body","Our app for macOS supports IKEv2 and simple EAP authentication. With iOS 8 and macOS 10.10 Apple introduced support for IKEv2 in their clients. A GUI to configure such connections is currently not provided, so it’s necessary to write (or generate) custom configuration profiles."],["body","\n"],["headingLink","ikev2-配置"],["heading","IKEv2 配置"],["body","\n"],["body","为Windows客户端显示的三种strongSwan网关配置可用于所有IKEv2客户端："],["body","\n\n"],["body","基于证书的认证"],["body","\n"],["body","基于证书的EAP-TLS认证"],["body","\n"],["body","基于密码的EAP认证"],["body","\n\n"],["body","在这三种使用案例中，网关通过证书进行认证，而客户端则通过证书（1，2）或用户名/密码方案（3）进行认证。通用的EAP使用案例（3）包含了EAP-TLS使用案例（2），因此只需在strongSwan VPN网关上并行实现两种配置（1，3），便可让VPN客户端自行选择上述三种认证方法中的任何一种。"],["body","\n"],["body","通过**eap-radius**插件，可以将用户认证委托给RADIUS服务器（例如现有的Active Directory DC）。"],["body","\n"],["body","strongSwan VPN客户端for Android和NetworkManager均可与任何strongSwan VPN网关配置一起使用。或者，**charon-cmd**命令行IKEv2客户端提供了一种简单的方法来建立移动用户连接。"],["body","\n"],["body","我们为macOS提供的应用程序支持IKEv2和简单EAP认证。在iOS 8 和 macOS 10.10中，Apple引入了对其客户端的IKEv2支持。然而，目前并未提供配置此类连接的GUI，因此需要编写（或生成）自定义配置文件。"],["body","\n"],["headingLink","site-to-site-configurations-站点到站点配置"],["heading","Site-to-Site Configurations （站点到站点配置）"],["body","\n"],["body","我们提供以下站点到站点配置示例。"],["body","\n"],["body","与远程访问情况相比，最重要的区别在于发起方不会请求虚拟IP地址，而是使用local_ts来隧道传输一个或多个本地子网的流量。使用IKEv2时，可以将多个子网（CIDR表示法）添加到local_ts/remote_ts中，并用逗号分隔。如果使用IKEv1，需要为每个本地和远程子网组合添加一个独立的children.<child>子部分，因为只有local_ts/remote_ts中的第一个子网会被使用。"],["body","\n"],["body","一个经常让IPsec新手困惑的问题是，从任一网关测试网对网场景时，通常需要特意选择使用的源地址（例如，用ping -I），因为任一网关的外部IP可能未被包含在隧道子网中。如果这是您需要的，可以将外部IP添加到local_ts/remote_ts的子网列表中，或者添加一个特定的主机对主机配置。"],["body","\n"],["headingLink","host-to-host-configurations主机到主机配置"],["heading","Host-to-Host Configurations（主机到主机配置）"],["body","\n"],["body","主机到主机连接设置非常简单。基本上，您只需将remote_addrs设置为对等方的主机名或IP地址，并配置所需的认证方式。既不需要显式设置local_ts，也不需要显式设置remote_ts流量选择器。"],["body","\n"],["body","同样，我们的网站提供了一些实用的主机到主机配置示例。"],["body","\n"],["headingLink","roadwarriors由来"],["heading","Roadwarriors由来"],["body","\n"],["body","“Roadwarriors” 这个术语来源于一个比喻，形象地描述了那些经常在路上工作、需要远程连接公司网络的用户。这个比喻源自电影《疯狂的麦克斯》（Mad Max）中的角色，他们在一个后末日世界中不断迁徙、争夺资源和生存，被称为“道路战士”。尽管这种情景与办公室员工的工作环境相去甚远，但它形象地描述了这些员工的流动性和灵活性。"],["body","\n\n\n\n                    "],["body","\n\n                    \n                \n            \n\n            \n\n        \n\n\n\n\n        \n\n\n\n        \n        \n        \n\n        \n\n\n    \n    \n\n"]]]