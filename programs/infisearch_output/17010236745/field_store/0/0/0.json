[[["_relative_fp","3.rust/rust指针.html"],["title","rust指针 - 各项编程语言"],["body","\n    \n        \n        \n\n        \n        \n\n        \n        \n\n        \n        \n\n        \n\n        \n\n            \n                                \n                \n                    \n                        "],["body","\n                            \n                        "],["body","\n                        "],["body","\n                            \n                        "],["body","\n                        \n                            "],["body","Light"],["body","\n                            "],["body","Rust"],["body","\n                            "],["body","Coal"],["body","\n                            "],["body","Navy"],["body","\n                            "],["body","Ayu"],["body","\n                        \n                    \n\n                    "],["heading","各项编程语言"],["body","\n\n                    \n\n                    \n                \n\n\n                \n                \n\n                \n                    "],["body","\n                        \n\n"],["body","\n"],["body","\n\n"],["headingLink","智能指针简介"],["heading","智能指针简介"],["body","\n\n"],["body","\n"],["body","指针 （pointer）是一个包含内存地址的变量"],["body","\n"],["body","\n"],["body","\n"],["body","这个地址 \"引用\"，或  “指向”（points at）一些其他数据"],["body","\n"],["body","\n"],["body","\n"],["body","Rust 中最常见的指针是 引用（reference）引用以 & 符号为标志并借用了他们所指向的值"],["body","\n"],["body","\n"],["body","\n"],["body","除了引用数据没有任何其他特殊功能。它们也没有任何额外开销，所以应用得最多。"],["body","\n"],["body","\n"],["body","\n"],["body","智能指针（smart pointers）是一类数据结构，他们的表现类似指针，但是拥有额外的元数据和功能"],["body","\n"],["body","\n"],["body","\n"],["body","智能指针的概念并不为 Rust 所独有；其起源于 C++ 并存在于其他语言中"],["body","\n"],["body","\n"],["body","\n"],["body","Rust 标准库中不同的智能指针提供了多于引用的额外功能"],["body","\n"],["body","\n"],["body","\n"],["body","在 Rust 中，普通引用和智能指针的一个额外的区别是  引用是一类只借用数据的指针,智能指针 拥有 他们指向的数据。"],["body","\n"],["body","\n"],["body","\n"],["body","实际上本书中已经出现过一些智能指针，比如第八章的 String 和 Vec<T>，虽然当时我们并不这么称呼它们。这些类型都属于智能指针因为它们拥有一些数据并允许你修改它们"],["body","\n"],["body","\n"],["body","\n"],["body","它们也带有元数据（比如他们的容量）和额外的功能或保证（String 的数据总是有效的 UTF-8 编码）。"],["body","\n"],["body","\n"],["body","\n"],["body","智能指针通常使用结构体实现。智能指针区别于常规结构体的显著特性在于其实现了 Deref 和 Drop trait"],["body","\n"],["body","\n"],["body","\n"],["body","Deref trait 允许智能指针结构体实例表现的像引用一样，这样就可以编写既用于引用、又用于智能指针的代码"],["body","\n"],["body","\n"],["body","\n"],["body","Drop trait 允许我们自定义当智能指针离开作用域时运行的代码。本章会讨论这些 trait 以及为什么对于智能指针来说他们很重要。"],["body","\n"],["body","\n"],["body","\n"],["body","常见的智能指针"],["body","\n"],["body","\n\n\n"],["body","Box<T>，用于在堆上分配值"],["body","\n"],["body","Rc<T>，一个引用计数类型，其数据可以有多个所有者"],["body","\n"],["body","Ref<T> 和 RefMut<T>，通过 RefCell<T> 访问。（ RefCell<T> 是一个在运行时而不是在编译时执行借用规则的类型）。"],["body","\n\n\n"],["body","另外我们会涉及 内部可变性（interior mutability）模式，这是不可变类型暴露出改变其内部值的 API"],["body","\n"],["body","引用循环（reference cycles）会如何泄漏内存，以及如何避免。"],["body","\n\n"],["headingLink","最简单的智能指针boxt"],["heading","最简单的智能指针：Box<T>"],["body","\n"],["headingLink","简介"],["heading","简介"],["body","\n\n"],["body","\n"],["body","最简单直接的智能指针是 box，其类型是 Box<T>"],["body","\n"],["body","\n"],["body","\n"],["body","box 允许你将一个值放在堆上而不是栈上。"],["body","\n"],["body","\n"],["body","\n"],["body","留在栈上的则是指向堆数据的指针"],["body","\n"],["body","\n\n"],["body","除了数据被储存在堆上而不是栈上之外，box 没有性能损失。不过也没有很多额外的功能。它们多用于如下场景："],["body","\n\n"],["body","\n"],["body","当有一个在编译时未知大小的类型，而又想要在需要确切大小的上下文中使用这个类型值的时候"],["body","\n"],["body","box 允许创建递归类型"],["body","\n"],["body","\n"],["body","\n"],["body","当有大量数据并希望在确保数据不被拷贝的情况下转移所有权的时候"],["body","\n"],["body","转移大量数据的所有权可能会花费很长的时间，因为数据在栈上进行了拷贝。为了改善这种情况下的性能，可以通过 box 将这些数据储存在堆上。接着，只有少量的指针数据在栈上被拷贝"],["body","\n"],["body","\n"],["body","\n"],["body","当希望拥有一个值并只关心它的类型是否实现了特定 trait 而不是其具体类型的时候"],["body","\n"],["body","trait 对象（trait object）"],["body","\n"],["body","\n\n"],["headingLink","box-允许创建递归类型"],["heading","Box 允许创建递归类型"],["body","\n"],["headingLink","简介-1"],["heading","简介"],["body","\n\n"],["body","\n"],["body","Rust 需要在编译时知道类型占用多少空间。一种无法在编译时知道大小的类型是 递归类型（recursive type）"],["body","\n"],["body","\n"],["body","\n"],["body","其值的一部分可以是相同类型的另一个值。这种值的嵌套理论上可以无限的进行下去，"],["body","\n"],["body","\n"],["body","\n"],["body","所以 Rust 不知道递归类型需要多少空间。"],["body","\n"],["body","\n"],["body","\n"],["body","不过 box 有一个已知的大小，所以通过在循环类型定义中插入 box，就可以创建递归类型了。"],["body","\n"],["body","\n\n"],["body","enum List {\n    Cons(i32, List),\n    Nil,\n}\n\nuse crate::List::{Cons, Nil};\nfn main() {\n    let list = Cons(1, Cons(2, Cons(3, Nil)));\n}"],["body","\n"],["headingLink","计算非递归类型的大小"],["heading","计算非递归类型的大小"],["body","\n"],["body","#![allow(unused)]\n\nfn main() {\nenum Message {\n    Quit,\n    Move { x: i32, y: i32 },\n    Write(String),\n    ChangeColor(i32, i32, i32),\n}\n}"],["body","\n"],["body","当 Rust 需要知道要为 Message 值分配多少空间时，它可以检查每一个成员并发现 Message::Quit 并不需要任何空间，Message::Move 需要足够储存两个 i32 值的空间，依此类推。因此，Message 值所需的空间等于储存其最大成员的空间大小。"],["body","\n"],["headingLink","使用-boxt给递归类型一个已知的大小"],["heading","使用 Box<T>给递归类型一个已知的大小"],["body","\n"],["body","enum List {\n    Cons(i32, Box<List>),\n    Nil,\n}\n\nuse crate::List::{Cons, Nil};\n\nfn main() {\n    let list = Cons(1,\n        Box::new(Cons(2,\n            Box::new(Cons(3,\n                Box::new(Nil))))));\n}"],["body","\n"],["headingLink","通过-deref-trait-将智能指针当作常规引用处理"],["heading","通过 Deref trait 将智能指针当作常规引用处理"],["body","\n"],["body","\n"],["body","实现 Deref trait 允许我们重载 解引用运算符（dereference operator）*（与乘法运算符或通配符相区别）"],["body","\n"],["body","\n"],["body","\n"],["body","通过这种方式实现 Deref trait 的智能指针可以被当作常规引用来对待，"],["body","\n"],["body","\n\n"],["body","让我们首先看看解引用运算符如何处理常规引用"],["body","\n"],["body","接着尝试定义我们自己的类似 Box<T> 的类型并看看为何解引用运算符不能像引用一样工作"],["body","\n"],["body","我们会探索如何实现 Deref trait 使得智能指针以类似引用的方式工作变为可能"],["body","\n"],["body","最后，我们会讨论 Rust 的 Deref 强制转换（deref coercions）功能以及它是如何处理引用或智能指针的"],["body","\n\n"],["body","我们将要构建的 MyBox<T> 类型与真正的 Box<T> 有一个很大的区别"],["body","\n\n"],["body","我们的版本不会在堆上储存数据"],["body","\n"],["body","这个例子重点关注 Deref，所以其数据实际存放在何处，相比其类似指针的行为来说不算重要。"],["body","\n\n"],["headingLink","通过解引用运算符追踪指针的值"],["heading","通过解引用运算符追踪指针的值"],["body","\n"],["body","\n"],["body","常规引用是一个指针类型，一种理解指针的方式是将其看成指向储存在其他某处值的箭头"],["body","\n"],["body","\n"],["body","fn main() {\n    let x = 5;\n    let y = &x;\n\n    assert_eq!(5, x);\n    assert_eq!(5, *y);\n}"],["body","\n"],["body","不能 将 5 与 y比较 因为 y是 引用类型（指针类型）"],["body","\n"],["body","6 |   assert_eq!(5, y);\n\n |   ^^^^^^^^^^^^^^^^^ no implementation for `{integer} == &{integer}`\n"],["body","\n"],["headingLink","像引用一样使用-boxt"],["heading","像引用一样使用 Box<T>"],["body","\n"],["body","fn main() {\n    let x = 5;\n    let y = Box::new(x);\n\n    assert_eq!(5, x);\n    assert_eq!(5, *y);\n}"],["body","\n"],["headingLink","自定义智能指针"],["heading","自定义智能指针"],["body","\n"],["body","#![allow(unused)]\n\nfn main() {\nuse std::ops::Deref;\n\n\nimpl<T> Deref for MyBox<T> {\n    type Target = T;\n\n    fn deref(&self) -> &T {\n        //返回内部数据的引用\n        &self.0\n    }\n}\n\n//等价于\n*(y.deref()) \n//等价于\n*(&T)\n//等价于\nT\n}"],["body","\n\n"],["body","\n"],["body","deref方法返回值的引用，以及 *(y.deref()) 括号外边的普通解引用仍为必须的原因在于所有权。"],["body","\n"],["body","\n"],["body","\n"],["body","如果 deref 方法直接返回值而不是值的引用，其值（的所有权）将被移出 self"],["body","\n"],["body","\n"],["body","\n"],["body","在这里以及大部分使用解引用运算符的情况下我们并不希望获取 MyBox<T> 内部值的所有权"],["body","\n"],["body","\n"],["body","\n"],["body","每次当我们在代码中使用 * 时， * 运算符都被替换成了先调用 deref 方法再接着使用 * 解引用的操作，且只会发生一次，不会对 * 操作符无限递归替换"],["body","\n"],["body","\n"],["body","\n"],["body","解引用出上面 i32 类型的值就停止了"],["body","\n"],["body","\n\n"],["headingLink","函数和方法的隐式-deref-强制转换"],["heading","函数和方法的隐式 Deref 强制转换"],["body","\n"],["body","\n"],["body","Deref 强制转换（deref coercions）是 Rust 在函数或方法传参上的一种便利"],["body","\n"],["body","\n\n"],["body","\n"],["body","其将实现了 Deref 的类型的引用  转换为原始类型"],["body","\n"],["body","\n"],["body","\n"],["body","通过 Deref 所能够转换的类型的引用"],["body","\n"],["body","\n"],["body","\n"],["body","当这种特定类型的引用作为实参传递给和形参类型不同的函数或方法时，Deref 强制转换将自动发生，这时会有一系列的 deref 方法被调用，把我们提供的类型转换成了参数所需的类型。"],["body","\n"],["body","\n\n"],["body","Deref 强制转换的加入使得 Rust 程序员编写函数和方法调用时无需增加过多显式使用 & 和 * 的引用和解引用。这个功能也使得我们可以编写更多同时作用于引用或智能指针的代码。"],["body","\n"],["headingLink","example"],["heading","example"],["body","\n"],["body","\n"],["body","对于 str的解引用"],["body","\n"],["body","\n"],["body","mod smart_box;\nuse smart_box::MyBox;\nfn main() {\n    let my_box = MyBox::new(1);\n    let my_box1 = MyBox::new(String::from(\"xjq\"));\n    //普通手动解引用\n\t\t//*mybox1 为 String\n    \t//**mybox1 为 str\n    \t//&**mybox1 为 &str\n    print_str(&**my_box1);\n    \n    //自动强制解引用\n    print_str(&my_box1);\n}\n\nfn print_str(str: &str){\n    print!(\"{}\",str);\n}\nlet my_box1 = MyBox::new(String::from(\"xjq\"));\n\nprint_str(&**my_box1);"],["body","\n\n"],["body","Rust 可以通过 deref 调用将 &MyBox<String> 变为 &String"],["body","\n"],["body","Rust 再次调用 deref 将 &String 变为 &str"],["body","\n\n"],["body","fn main() {\n    let m = MyBox::new(String::from(\"Rust\"));\n    hello(&(*m)[..]);\n}"],["body","\n"],["headingLink","deref-强制转换如何与可变性交互"],["heading","Deref 强制转换如何与可变性交互"],["body","\n\n"],["body","\n"],["body","类似于如何使用 Deref trait 重载不可变引用的 * 运算符"],["body","\n"],["body","\n"],["body","\n"],["body","Rust 提供了 DerefMut trait 用于重载可变引用的 * 运算符。"],["body","\n"],["body","\n\n"],["body","Rust 在发现类型和 trait 实现满足三种情况时会进行 Deref 强制转换："],["body","\n\n"],["body","当 T: Deref<Target=U> 时从 &T 到 &U。"],["body","\n"],["body","当 T: DerefMut<Target=U> 时从 &mut T 到 &mut U。"],["body","\n"],["body","当 T: Deref<Target=U> 时从 &mut T 到 &U。"],["body","\n\n"],["body","将一个可变引用转换为不可变引用永远也不会打破借用规则。"],["body","\n"],["headingLink","使用-drop-trait-运行清理代码"],["heading","使用 Drop Trait 运行清理代码"],["body","\n\n"],["body","\n"],["body","对于智能指针模式来说第二个重要的 trait 是 Drop"],["body","\n"],["body","\n"],["body","\n"],["body","其允许我们在值要离开作用域时执行一些代码"],["body","\n"],["body","\n"],["body","\n"],["body","可以为任何类型提供 Drop trait 的实现"],["body","\n"],["body","\n"],["body","\n"],["body","同时所指定的代码被用于释放类似于文件或网络连接的资源"],["body","\n"],["body","\n\n"],["body","我们在智能指针上下文中讨论 Drop 是因为其功能几乎总是用于实现智能指针"],["body","\n\n"],["body","Drop trait 包含在 prelude 中"],["body","\n"],["body","drop 函数体是放置任何当类型实例离开作用域时期望运行的逻辑的地方"],["body","\n\n"],["headingLink","通过-stdmemdrop-提早丢弃值"],["heading","通过 std::mem::drop 提早丢弃值"],["body","\n\n"],["body","整个 Drop trait 存在的意义在于其是自动处理的"],["body","\n"],["body","你可能希望强制运行 drop 方法来释放锁以便作用域中的其他代码可以获取锁"],["body","\n"],["body","Rust 并不允许我们主动调用 Drop trait 的 drop 方法；"],["body","\n"],["body","当我们希望在作用域结束之前就强制释放变量的话，我们应该使用的是由标准库提供的 std::mem::drop。"],["body","\n"],["body","Rust 中的 drop 函数就是这么一个析构函数。"],["body","\n"],["body","因为不能禁用当值离开作用域时自动插入的 drop，并且不能显式调用 drop，如果我们需要强制提早清理值，可以使用 std::mem::drop 函数。"],["body","\n"],["body","std::mem::drop 函数不同于 Drop trait 中的 drop 方法。可以通过传递希望提早强制丢弃的值作为参数"],["body","\n\n"],["headingLink","rct-引用计数智能指针"],["heading","Rc<T> 引用计数智能指针"],["body","\n\n"],["body","\n"],["body","大部分情况下所有权是非常明确的:可以准确地知道哪个变量拥有某个值"],["body","\n"],["body","\n"],["body","\n"],["body","有些情况单个值可能会有多个所有者,例如图数据结构"],["body","\n"],["body","\n"],["body","\n"],["body","为了启用多所有权，Rust 有一个叫做 Rc<T> 的类型。其名称为 引用计数（reference counting）的缩写"],["body","\n"],["body","\n"],["body","\n"],["body","引用计数意味着记录一个值引用的数量来知晓这个值是否仍在被使用。如果某个值有零个引用，就代表没有任何有效引用并可以被清理。"],["body","\n"],["body","\n"],["body","\n"],["body","Rc<T> 用于当我们希望在堆上分配一些内存供程序的多个部分读取，而且无法在编译时确定程序的哪一部分会最后结束使用它的时候"],["body","\n"],["body","\n"],["body","\n"],["body","如果确实知道哪部分是最后一个结束使用的话，就可以令其成为数据的所有者，正常的所有权规则就可以在编译时生效。"],["body","\n"],["body","\n\n"],["body","\n"],["body","注意 Rc<T> 只能用于单线程场景"],["body","\n"],["body","\n"],["headingLink","使用-rct-共享数据"],["heading","使用 Rc<T> 共享数据"],["body","\n\n"],["body","\n"],["body","不必像调用 Rc::clone 增加引用计数那样调用一个函数来减少计数；"],["body","\n"],["body","\n"],["body","\n"],["body","Drop trait 的实现当 Rc<T> 值离开作用域时自动减少引用计数。"],["body","\n"],["body","\n"],["body","\n"],["body","使用 Rc<T> 允许一个值有多个所有者，引用计数则确保只要任何所有者依然存在其值也保持有效。"],["body","\n"],["body","\n"],["body","\n"],["body","通过不可变引用， Rc<T> 允许在程序的多个部分之间只读地共享数据。如果 Rc<T> 也允许多个可变引用,则会违反第四章讨论的借用规则之一：相同位置的多个可变借用可能造成数据竞争和不一致"],["body","\n"],["body","\n\n"],["headingLink","refcellt-和内部可变性模式"],["heading","RefCell<T> 和内部可变性模式"],["body","\n\n"],["body","\n"],["body","内部可变性（Interior mutability）是 Rust 中的一个设计模式"],["body","\n"],["body","\n"],["body","\n"],["body","它允许你即使在有不可变引用时也可以改变数据，这通常是借用规则所不允许的"],["body","\n"],["body","\n"],["body","\n"],["body","为了改变数据，该模式在数据结构中使用 unsafe 代码来模糊 Rust 通常的可变性和借用规则"],["body","\n"],["body","\n"],["body","\n"],["body","我们还未讲到不安全代码；第十九章会学习它们"],["body","\n"],["body","\n"],["body","\n"],["body","当可以确保代码在运行时会遵守借用规则，即使编译器不能保证的情况，可以选择使用那些运用内部可变性模式的类型"],["body","\n"],["body","\n"],["body","\n"],["body","所涉及的 unsafe 代码将被封装进安全的 API 中，而外部类型仍然是不可变的。"],["body","\n"],["body","\n\n"],["headingLink","通过-refcellt-在运行时检查借用规则"],["heading","通过 RefCell<T> 在运行时检查借用规则"],["body","\n"],["body","如下为选择 Box<T>，Rc<T> 或 RefCell<T> 的理由："],["body","\n\n"],["body","Rc<T> 允许相同数据有多个所有者；Box<T> 和 RefCell<T> 有单一所有者。"],["body","\n"],["body","Box<T> 允许在编译时执行不可变或可变借用检查；Rc<T>仅允许在编译时执行不可变借用检查；RefCell<T> 允许在运行时执行不可变或可变借用检查。"],["body","\n"],["body","因为 RefCell<T> 允许在运行时执行可变借用检查，所以我们可以在即便 RefCell<T> 自身是不可变的情况下修改其内部的值。"],["body","\n\n"],["body","在不可变值内部改变值就是 内部可变性 模式。让我们看看何时内部可变性是有用的，并讨论这是如何成为可能的。"],["body","\n"],["headingLink","内部可变性不可变值的可变借用"],["heading","内部可变性：不可变值的可变借用"],["body","\n"],["body","#![allow(unused)]\nfn main() {\nlet vec1 = vec![1, 2, 3];\nlet cell = RefCell::new(vec1);\n\n{\n    let mut ref_mut1 = cell.borrow_mut();\n    ref_mut1.push(4);\n    println!(\"{:?}\", ref_mut1);\n}\nlet mut ref_mut2= cell.borrow_mut();\n}"],["body","\n"],["headingLink","refcellt-在运行时记录借用"],["heading","RefCell<T> 在运行时记录借用"],["body","\n\n"],["body","当创建不可变和可变引用时，我们分别使用 & 和 &mut 语法。对于 RefCell<T> 来说，则是 borrow 和 borrow_mut 方法，这属于 RefCell<T> 安全 API 的一部分"],["body","\n"],["body","borrow 方法返回 Ref<T> 类型的智能指针，borrow_mut 方法返回 RefMut 类型的智能指针"],["body","\n"],["body","这两个类型都实现了 Deref，所以可以当作常规引用对待。"],["body","\n"],["body","RefCell<T> 记录当前有多少个活动的 Ref<T> 和 RefMut<T> 智能指针"],["body","\n"],["body","每次调用 borrow，RefCell<T> 将活动的不可变借用计数加一，当 Ref<T> 值离开作用域时，不可变借用计数减一，就像编译时借用规则一样"],["body","\n"],["body","RefCell<T> 在任何时候只允许有多个不可变借用或一个可变借用。"],["body","\n"],["body","如果我们尝试违反这些规则，相比引用时的编译时错误，RefCell<T> 的实现会在运行时出现 panic"],["body","\n\n"],["headingLink","结合-rct-和-refcellt-来拥有多个可变数据所有者"],["heading","结合 Rc<T> 和 RefCell<T> 来拥有多个可变数据所有者"],["body","\n\n"],["body","RefCell<T> 的一个常见用法是与 Rc<T> 结合"],["body","\n"],["body","Rc<T> 允许对相同数据有多个所有者，不过只能提供数据的不可变访问"],["body","\n"],["body","如果有一个储存了 RefCell<T> 的 Rc<T> 的话，就可以得到有多个所有者 并且 可以修改的值了！"],["body","\n\n"],["body","#![allow(unused)]\nfn main() {\npub fn test_ref_rc(){\n    let vec1 = vec![1, 2, 3];\n    let cell = RefCell::new(vec1);\n    let rc = Rc::new(cell);\n    let rc1 = rc.clone();\n    let rc2 = rc.clone();\n    rc1.borrow_mut().push(4);\n    rc2.borrow_mut().push(5);\n\n    println!(\"{:?}\",rc);\n}\n}"],["body","\n"],["headingLink","引用循环与内存泄漏"],["heading","引用循环与内存泄漏"],["body","\n\n"],["body","Rust 的内存安全性保证使其难以意外地制造永远也不会被清理的内存（被称为 内存泄漏（memory leak））"],["body","\n"],["body","但并不是不可能。与在编译时拒绝数据竞争不同， Rust 并不保证完全地避免内存泄漏，这意味着内存泄漏在 Rust 被认为是内存安全的"],["body","\n"],["body","这一点可以通过 Rc<T> 和 RefCell<T> 看出：创建引用循环的可能性是存在的。这会造成内存泄漏，因为每一项的引用计数永远也到不了 0，其值也永远不会被丢弃。"],["body","\n\n"],["headingLink","制造引用循环"],["heading","制造引用循环"],["body","\n"],["body","\n"],["body","创建一个引用循环：两个 List 值互相指向彼此"],["body","\n"],["body","\n"],["body","fn main() {}\nuse std::rc::Rc;\nuse std::cell::RefCell;\nuse crate::List::{Cons, Nil};\n\n#[derive(Debug)]\nenum List {\n    Cons(i32, RefCell<Rc<List>>),\n    Nil,\n}\n\nimpl List {\n    fn tail(&self) -> Option<&RefCell<Rc<List>>> {\n        match self {\n            Cons(_, item) => Some(item),\n            Nil => None,\n        }\n    }\n}\n\npub fn test_recursive(){\n    let a =  Rc::new( Cons(1, RefCell::new(Rc::new(Nil))) ) ;\n    println!(\"a initial rc count = {}\", Rc::strong_count(&a));\n    println!(\"a next item = {:?}\", a.tail());\n\n\n    let b = Rc::new( Cons(2,RefCell::new(a.clone())) );\n    println!(\"a rc count after b creation = {}\", Rc::strong_count(&a));\n    println!(\"b initial rc count = {}\", Rc::strong_count(&b));\n    println!(\"b next item = {:?}\", b.tail());\n\n\n\n\n    match  a.tail() {\n        None => {}\n        Some(item) => {\n            *item.borrow_mut() = b.clone();\n        }\n    }\n\n    println!(\"b rc count after changing a = {}\", Rc::strong_count(&b));\n    println!(\"a rc count after changing a = {}\", Rc::strong_count(&a));\n}"],["body","\n"],["headingLink","weakref的使用"],["heading","WeakRef的使用"],["body","\n"],["body","#![allow(unused)]\nfn main() {\nuse std::rc::{Rc, Weak};\nuse std::cell::RefCell;\n#[derive(Debug)]\nstruct Node {\n    value: i32,\n    child: RefCell<Vec<Rc<Node>>>,\n    parent: RefCell<Weak<Node>>,\n}\n\nimpl Node {\n    fn new(value: i32, child: Vec<Rc<Node>>) -> Rc<Node> {\n        Rc::new(Node {\n            value,\n            child: RefCell::new(vec![]),\n            parent: RefCell::new(Weak::new()),\n        }\n        )\n    }\n}\n\npub fn test_weak_ref() {\n    //创建节点1\n    let node1 = Node::new(1, vec![]);\n\n    println!(\"node1 parent = {:?}\", node1.parent.borrow().upgrade());\n\n\n    {\n        //创建节点2\n        let node2 = Node::new(2, vec![node1.clone()]);\n\n        println!(\"strong_count:{:?},weak_count:{:?}\",Rc::strong_count(&node2),Rc::weak_count(&node2));\n\n        //将parent赋值为node2\n        *node1.parent.borrow_mut() = Rc::downgrade(&node2);\n\n        println!(\"strong_count:{:?},weak_count:{:?}\",Rc::strong_count(&node2),Rc::weak_count(&node2));\n\n        println!(\"node1 parent = {:?}\", node1.parent.borrow().upgrade());\n    }\n\n    println!(\"node1 parent = {:?}\", node1.parent.borrow().upgrade());\n}\n}"],["body","\n\n\n\n"],["body","\n\n                    "],["body","\n\n                    \n                \n            \n\n            \n\n        \n\n\n\n\n        \n\n\n\n        \n        \n        \n\n        \n\n\n    \n    \n"]],[["_relative_fp","3.rust/模式匹配.html"],["title","模式匹配 - 各项编程语言"],["body","\n    \n        \n        \n\n        \n        \n\n        \n        \n\n        \n        \n\n        \n\n        \n\n            \n                                \n                \n                    \n                        "],["body","\n                            \n                        "],["body","\n                        "],["body","\n                            \n                        "],["body","\n                        \n                            "],["body","Light"],["body","\n                            "],["body","Rust"],["body","\n                            "],["body","Coal"],["body","\n                            "],["body","Navy"],["body","\n                            "],["body","Ayu"],["body","\n                        \n                    \n\n                    "],["heading","各项编程语言"],["body","\n\n                    \n\n                    \n                \n\n\n                \n                \n\n                \n                    "],["body","\n                        \n\n"],["body","\n"],["body","\n\n"],["headingLink","模式由如下一些内容组合而成"],["heading","模式由如下一些内容组合而成"],["body","\n\n"],["body","字面值"],["body","\n"],["body","解构的数组、枚举、结构体或者元组"],["body","\n"],["body","变量"],["body","\n"],["body","通配符"],["body","\n"],["body","占位符"],["body","\n\n"],["headingLink","模式匹配使用场景"],["heading","模式匹配使用场景"],["body","\n"],["headingLink","match-分支"],["heading","match 分支"],["body","\n"],["body","#![allow(unused)]\nfn main() {\nmatch VALUE {\n    PATTERN => EXPRESSION,\n    PATTERN => EXPRESSION,\n    PATTERN => EXPRESSION,\n}\n}"],["body","\n"],["headingLink","if-let-条件表达式"],["heading","if let 条件表达式"],["body","\n"],["body","\n"],["body","编写等同于只关心一个情况的 match 语句简写的"],["body","\n"],["body","\n\n"],["body","\n"],["body","也可以组合并匹配 if let、else if 和 else if let 表达式。"],["body","\n"],["body","\n"],["body","\n"],["body","这相比 match 表达式一次只能将一个值与模式比较提供了更多灵活性；"],["body","\n"],["body","\n"],["body","\n"],["body","一系列 if let、else if、else if let 分支并不要求其条件相互关联"],["body","\n"],["body","\n\n"],["headingLink","while-let-条件循环"],["heading","while let 条件循环"],["body","\n\n"],["body","示例一 : 定义一个 枚举集合 ,循环打印"],["body","\n\n"],["headingLink","for循环"],["heading","for循环"],["body","\n"],["body","#![allow(unused)]\nfn main() {\nfor (index, value) in v.iter().enumerate() {\n    println!(\"{} is at index {}\", value, index);\n}\n\nfor pattern in v.iter(){\n\tstatement\n}\n}"],["body","\n"],["headingLink","let-语句"],["heading","let 语句"],["body","\n"],["body","let PATTERN = EXPRESSION;\n\nlet (x, y) = (1, 2, 3);\n"],["body","\n"],["headingLink","函数参数"],["heading","函数参数"],["body","\n"],["body","fn print_coordinates(&(x, y): &(i32, i32)) {\n    println!(\"Current location: ({}, {})\", x, y);\n}\n\nfn main() {\n    let point = (3, 5);\n    print_coordinates(&point);\n}"],["body","\n"],["headingLink","可反驳性与非反驳性"],["heading","可反驳性与非反驳性"],["body","\n\n"],["body","let 语句和 for 循环只能接受不可反驳的模式"],["body","\n"],["body","if let和while let 只接受 可反驳模式"],["body","\n\n"],["headingLink","变量覆盖"],["heading","变量覆盖"],["body","\n"],["body","match 会开始一个新作用域，match 表达式中作为模式的一部分声明的变量会覆盖 match 结构之外的同名变量"],["body","\n"],["body","fn main() {\n    let x = Some(5);\n    let y = 10;\n\n    match x {\n        Some(50) => println!(\"Got 50\"),\n        Some(y) => println!(\"Matched, y = {:?}\", y),\n        _ => println!(\"Default case, x = {:?}\", x),\n    }\n\n    println!(\"at the end: x = {:?}, y = {:?}\", x, y);\n}"],["body","\n"],["headingLink","多模式"],["heading","多模式"],["body","\n"],["body","#![allow(unused)]\n\nfn main() {\nlet x = 1;\n\nmatch x {\n    1 | 2 => println!(\"one or two\"),\n    3 => println!(\"three\"),\n    _ => println!(\"anything\"),\n}\n}"],["body","\n"],["headingLink","范围匹配"],["heading","范围匹配"],["body","\n"],["body","\n"],["body","只允许数字和char"],["body","\n"],["body","\n"],["body","#![allow(unused)]\n\nfn main() {\nlet x = 5;\n\nmatch x {\n    1..=5 => println!(\"one through five\"),\n    _ => println!(\"something else\"),\n}\n}"],["body","\n"],["headingLink","匹配结构体"],["heading","匹配结构体"],["body","\n"],["body","struct Point {\n    x: i32,\n    y: i32,\n}\n\nfn main() {\n    let p = Point { x: 0, y: 7 };\n\n    let Point { x: a, y: b } = p;\n    assert_eq!(0, a);\n    assert_eq!(7, b);\n}"],["body","\n"],["headingLink","匹配枚举"],["heading","匹配枚举"],["body","\n"],["body","enum Message {\n    Quit,\n    Move { x: i32, y: i32 },\n    Write(String),\n    ChangeColor(i32, i32, i32),\n}\n\nfn main() {\n    let msg = Message::ChangeColor(0, 160, 255);\n\n    match msg {\n        Message::Quit => {\n            println!(\"The Quit variant has no data to destructure.\")\n        }\n        Message::Move { x, y } => {\n            println!(\n                \"Move in the x direction {} and in the y direction {}\",\n                x,\n                y\n            );\n        }\n        Message::Write(text) => println!(\"Text message: {}\", text),\n        Message::ChangeColor(r, g, b) => {\n            println!(\n                \"Change the color to red {}, green {}, and blue {}\",\n                r,\n                g,\n                b\n            )\n        }\n    }\n}"],["body","\n"],["headingLink","嵌套匹配"],["heading","嵌套匹配"],["body","\n"],["body","\n#![allow(unused)]\nfn main() {\nstruct Point {\n    x: i32,\n    y: i32,\n}\n\nlet ((feet, inches), Point {x, y}) = ((3, 10), Point { x: 3, y: -10 });\n}\n"],["body","\n"],["headingLink","忽略模式"],["heading","忽略模式"],["body","\n"],["body","//忽略函数参数\nfn foo(_: i32, y: i32) {\n    println!(\"This code only uses the y parameter: {}\", y);\n}\n\nfn main() {\n    foo(3, 4);\n}\n"],["body","\n"],["body","嵌套忽略"],["body","\n"],["body","\n#![allow(unused)]\nfn main() {\nlet mut setting_value = Some(5);\nlet new_setting_value = Some(10);\n\nmatch (setting_value, new_setting_value) {\n    (Some(_), Some(_)) => {\n        println!(\"Can't overwrite an existing customized value\");\n    }\n    _ => {\n        setting_value = new_setting_value;\n    }\n}\n\nprintln!(\"setting is {:?}\", setting_value);\n}\n\n#![allow(unused)]\nfn main() {\nlet mut setting_value = Some(5);\nlet new_setting_value = Some(10);\n\nmatch (setting_value, new_setting_value) {\n    (Some(_), Some(_)) => {\n        println!(\"Can't overwrite an existing customized value\");\n    }\n    _ => {\n        setting_value = new_setting_value;\n    }\n}\n\nprintln!(\"setting is {:?}\", setting_value);\n}\n"],["body","\n"],["body","忽略元组多个部分"],["body","\n"],["body","#![allow(unused)]\nfn main() {\nlet numbers = (2, 4, 8, 16, 32);\n\nmatch numbers {\n    (first, _, third, _, fifth) => {\n        println!(\"Some numbers: {}, {}, {}\", first, third, fifth)\n    },\n}\n}"],["body","\n"],["body","_下划线开头的变量,可以避免编译器警告"],["body","\n"],["body","fn main() {\n    let _x = 5;\n    let y = 10;\n}"],["body","\n"],["body","用 .. 忽略剩余值"],["body","\n"],["body","#![allow(unused)]\nfn main() {\nstruct Point {\n    x: i32,\n    y: i32,\n    z: i32,\n}\n\nlet origin = Point { x: 0, y: 0, z: 0 };\n\nmatch origin {\n    Point { x, .. } => println!(\"x is {}\", x),\n}\n}"],["body","\n"],["headingLink","匹配守卫"],["heading","匹配守卫"],["body","\n"],["headingLink","条件匹配"],["heading","条件匹配"],["body","\n"],["body","#![allow(unused)]\nfn main() {\nlet num = Some(4);\n\nmatch num {\n    Some(x) if x < 5 => println!(\"less than five: {}\", x),\n    Some(x) => println!(\"{}\", x),\n    None => (),\n}\n}"],["body","\n"],["headingLink","范围匹配-1"],["heading","范围匹配"],["body","\n"],["body","#![allow(unused)]\nfn main() {\nmatch msg {\n    Message::Hello { id: id_variable @ 3..=7 } => {\n        println!(\"Found an id in range: {}\", id_variable)\n    },\n    Message::Hello { id: 10..=12 } => {\n        println!(\"Found an id in another range\")\n    },\n    Message::Hello { id } => {\n        println!(\"Found some other id: {}\", id)\n    },\n}\n}"],["body","\n\n\n\n"],["body","\n\n                    "],["body","\n\n                    \n                \n            \n\n            \n\n        \n\n\n\n\n        \n\n\n\n        \n        \n        \n\n        \n\n\n    \n    \n"]],[["_relative_fp","3.rust/rfcs/0911-const-fn.html"],["title","0911-const-fn - 各项编程语言"],["body","\n    \n        \n        \n\n        \n        \n\n        \n        \n\n        \n        \n\n        \n\n        \n\n            \n                                \n                \n                    \n                        "],["body","\n                            \n                        "],["body","\n                        "],["body","\n                            \n                        "],["body","\n                        \n                            "],["body","Light"],["body","\n                            "],["body","Rust"],["body","\n                            "],["body","Coal"],["body","\n                            "],["body","Navy"],["body","\n                            "],["body","Ayu"],["body","\n                        \n                    \n\n                    "],["heading","各项编程语言"],["body","\n\n                    \n\n                    \n                \n\n\n                \n                \n\n                \n                    "],["body","\n                        \n\n"],["body","\n"],["body","\n\n"],["headingLink","summary"],["heading","Summary"],["body","\n"],["body","允许将一般函数和 继承过来的函数 标记为 const,使它们能够在常量上下文中调用，并带有常量参数"],["body","\n"],["headingLink","motivation"],["heading","Motivation"],["body","\n"],["body","#![allow(unused)]\n\nfn main() {\n#[lang=\"unsafe_cell\"]\nstruct UnsafeCell<T> { pub value: T }\nstruct AtomicUsize { v: UnsafeCell<usize> }\nconst ATOMIC_USIZE_INIT: AtomicUsize = AtomicUsize {\n    v: UnsafeCell { value: 0 }\n};\n\n}"],["body","\n\n"],["body","为了能在 const 字段中 直接初始化结构体，上述例子只能 将 字段 设置为 pub"],["body","\n"],["body","有了const函数后，可以避免上述的情况"],["body","\n\n"],["body","#![allow(unused)]\nfn main() {\npub mod unsafe_cell {\n    pub struct UnsafeCell<T> {  value: T }\n    pub struct AtomicUsize {  v: UnsafeCell<usize> }\n    pub const  fn new(a:usize)->AtomicUsize{\n        AtomicUsize {\n            v:UnsafeCell{\n                value:a\n            }\n        }\n    }\n}\nuse unsafe_cell::*;\nconst ATOMIC_USIZE_INIT: AtomicUsize = unsafe_cell::new(0);\n}"],["body","\n"],["headingLink","detailed-design"],["heading","Detailed design"],["body","\n\n"],["body","函数和继承方法可以标记为 const："],["body","\n"],["body","只允许 简单的 参数 按值传递"],["body","\n"],["body","const 函数体会当做 一个 const 代码块"],["body","\n\n"],["body","#![allow(unused)]\nfn main() {\nconst FOO: Foo = {\n    // Currently, only item \"statements\" are allowed here.\n    stmts;\n    // The function's arguments and constant expressions can be freely combined.\n    expr\n}\n}"],["body","\n"],["headingLink","const规则"],["heading","const规则"],["body","\n\n"],["body","当前支持的 expr是"],["body","\n\n"],["headingLink","expr"],["heading","expr"],["body","\n\n"],["body","基础类型字面量"],["body","\n"],["body","ADTS（tuples、arrays、structs、enum variants"],["body","\n"],["body","基础类型的一元操作、二元操作。unary/binary "],["body","\n"],["body","强制转换、字段访问、索引"],["body","\n"],["body","无捕获闭包"],["body","\n"],["body","引用和块（只 item statmts,和 tail expression）"],["body","\n\n"],["headingLink","no-side-effects"],["heading","no side-effects"],["body","\n\n"],["body","赋值语句"],["body","\n"],["body","non-const function  调用"],["body","\n"],["body","inline assembly)"],["body","\n\n"],["headingLink","structenum-values-not-allowded-for-copy-trait"],["heading","struct/enum values not allowded for copy trait"],["body","\n"],["body","struct/enum values are not allowed if their type implements Drop, but this is not transitive, allowing the (perfectly harmless) creation of, e.g. None::<Vec<T>> (as an aside, this rule could be used to allow [x; N] even for non-Copy types of x, but that is out of the scope of this RFC)"],["body","\n"],["headingLink","references-are-truly-immutable"],["heading","references are truly immutable,"],["body","\n\n"],["body","no value with interior mutability can be placed behind a reference,"],["body","\n"],["body","mutable references can only be created from zero-sized values (e.g. &mut || {}) -  this allows a reference to be represented just by its value, with no guarantees for the actual address in memory"],["body","\n\n"],["headingLink","raw-pointer"],["heading","raw pointer"],["body","\n\n"],["body","raw pointers can only be created from an integer, a reference or another raw pointer"],["body","\n"],["body","cannot be dereferenced or cast back to an integer, which means any constant raw pointer can be represented by either a constant integer or references"],["body","\n\n"],["headingLink","loops"],["heading","loops"],["body","\n\n"],["body","as a result of not having any side-effects, loops would only affect termination, which has no practical value, thus remaining unimplemented"],["body","\n\n"],["headingLink","conditional-control-flow"],["heading","conditional control flow"],["body","\n\n"],["body","although more useful than loops, conditional control flow (if/else and match) also remains unimplemented and only match would pose a challenge"],["body","\n\n"],["headingLink","immutable-let-bindings"],["heading","immutable let bindings"],["body","\n\n"],["body","immutable let bindings in blocks have the same status and implementation difficulty as if/else and they both suffer from a lack of demand (blocks were originally introduced to const/static for scoping items used only in the initializer of a global)."],["body","\n\n"],["headingLink","可以从任何常量表达式调用-const-函数和方法"],["heading","可以从任何常量表达式调用 const 函数和方法："],["body","\n"],["body","#![allow(unused)]\n\nfn main() {\n// Standalone example.\nstruct Point { x: i32, y: i32 }\n\nimpl Point {\n    const fn new(x: i32, y: i32) -> Point {\n        Point { x: x, y: y }\n    }\n\n    const fn add(self, other: Point) -> Point {\n        Point::new(self.x + other.x, self.y + other.y)\n    }\n}\n\nconst ORIGIN: Point = Point::new(0, 0);\n\nconst fn sum_test(xs: [Point; 3]) -> Point {\n    xs[0].add(xs[1]).add(xs[2])\n}\n\nconst A: Point = Point::new(1, 0);\nconst B: Point = Point::new(0, 1);\nconst C: Point = A.add(B);\nconst D: Point = sum_test([A, B, C]);\n\n// Assuming the Foo::new methods used here are const.\nstatic FLAG: AtomicBool = AtomicBool::new(true);\nstatic COUNTDOWN: AtomicUsize = AtomicUsize::new(10);\n#[thread_local]\nstatic TLS_COUNTER: Cell<u32> = Cell::new(1);\n\n}"],["body","\n"],["body","Type parameters and their bounds are not restricted, though trait methods cannot be called, as they are never const in this design. Accessing trait methods can still be useful - for example, they can be turned into function pointers:"],["body","\n"],["body","#![allow(unused)]\nfn main() {\nconst fn arithmetic_ops<T: Int>() -> [fn(T, T) -> T; 4] {\n    [Add::add, Sub::sub, Mul::mul, Div::div]\n}\n}"],["body","\n"],["body","const functions can also be unsafe, allowing construction of types that require invariants to be maintained (e.g. std::ptr::Unique requires a non-null pointer)"],["body","\n"],["body","#![allow(unused)]\nfn main() {\nstruct OptionalInt(u32);\nimpl OptionalInt {\n    /// Value must be non-zero\n    const unsafe fn new(val: u32) -> OptionalInt {\n        OptionalInt(val)\n    }\n}\n}"],["body","\n\n\n\n"],["body","\n\n                    "],["body","\n\n                    \n                \n            \n\n            \n\n        \n\n\n\n\n        \n\n\n\n        \n        \n        \n\n        \n\n\n    \n    \n"]],[["_relative_fp","3.rust/rfcs/0195_associated-items.html"],["title","0195_associated-items - 各项编程语言"],["body","\n    \n        \n        \n\n        \n        \n\n        \n        \n\n        \n        \n\n        \n\n        \n\n            \n                                \n                \n                    \n                        "],["body","\n                            \n                        "],["body","\n                        "],["body","\n                            \n                        "],["body","\n                        \n                            "],["body","Light"],["body","\n                            "],["body","Rust"],["body","\n                            "],["body","Coal"],["body","\n                            "],["body","Navy"],["body","\n                            "],["body","Ayu"],["body","\n                        \n                    \n\n                    "],["heading","各项编程语言"],["body","\n\n                    \n\n                    \n                \n\n\n                \n                \n\n                \n                    "],["body","\n                        \n\n"],["body","\n"],["body","\n\n\n"],["body","Start Date: 2014-08-04"],["body","\n"],["body","RFC PR #: rust-lang/rfcs#195"],["body","\n"],["body","Rust Issue #: rust-lang/rust#17307"],["body","\n\n"],["headingLink","summary"],["heading","Summary"],["body","\n"],["body","该RFC使用关联项扩展特性，从而实现泛型编程 更方便、可扩展和强大，特别的，traits将包含一系列方法"],["body","\n\n"],["body","Associated functions (already present as \"static\" functions)"],["body","\n"],["body","Associated consts"],["body","\n"],["body","Associated types"],["body","\n"],["body","Associated lifetimes"],["body","\n\n"],["body","这个RFC还为 multidispatch traits 提供了一种机制，其中根据不同类型选择不同的 trait实现。"],["body","\n"],["body","注意:在 RFC 246引入const和静态项之间的区别之前，这个RFC已经被接受了。该文本已经被 更新，以 澄清：关联常量而不是静态，并提供了对关联常量初始实现的限制 的摘要，除了这个修改之外，没有其他的新语法 影响这个提案的修改"],["body","\n"],["headingLink","motivation"],["heading","Motivation"],["body","\n"],["body","\n"],["body","动机"],["body","\n"],["body","\n"],["body","关联项发挥作用的一个典型例子是数据结构，比如 图，至少包含三种类型:节点、边和图本身。"],["body","\n"],["body","在今天的《Rust》中，为了将 graph 设计为 通用的trait，你必须采用 与图关联的其他类型作为 参数"],["body","\n"],["body","#![allow(unused)]\nfn main() {\ntrait Graph<N, E> {\n    fn has_edge(&self, &N, &N) -> bool;\n    ...\n}\n}"],["body","\n"],["body","把节点和边类型当做参数这令人困惑，因为任何 具体的图类型他们的边跟节点的类型都是确定的、唯一的"],["body","\n"],["body","同时，这也带来了不遍，因为使用 泛型的 图的代码 也同样被迫 参数化，即使不是所有的类型都是相关的"],["body","\n"],["body","#![allow(unused)]\nfn main() {\n//使用N、E参数化了,所以G必须也是参数化的\nfn distance<N, E, G: Graph<N, E>>(graph: &G, start: &N, end: &N) -> uint { ... }\n}"],["body","\n"],["body","使用关联的类型，图trait 可以明确表明  节点和 边类型由impl决定:"],["body","\n"],["body","#![allow(unused)]\nfn main() {\ntrait Graph {\n    type N;\n    type E;\n    fn has_edge(&self, &N, &N) -> bool;\n}\n}"],["body","\n"],["body","客户端可以 直接使用关联类型 表示 图类型"],["body","\n"],["body","#![allow(unused)]\nfn main() {\nfn distance<G: Graph>(graph: &G, start: &G::N, end: &G::N) -> uint { ... }\n}"],["body","\n"],["body","下面的小节扩展了 关联类型 的上述好处"],["body","\n"],["headingLink","associated-types-engineering-benefits-for-generics"],["heading","Associated types: engineering benefits for generics"],["body","\n"],["body","\n"],["body","泛型的工程好处"],["body","\n"],["body","\n"],["body","关联类型提供了几个工程上的好处"],["body","\n\n"],["body","\n"],["body","Readability and scalability:可读性和可伸缩性"],["body","\n"],["body","关联类型可以一次性抽象整个类型族，而不需要分别命名它们"],["body","\n"],["body","这提高了 泛型代码的可读性 (就像上面的 distance 函数). "],["body","\n"],["body","它还 使泛型更具“可伸缩性”:traits可以合并其他相关的特性 类型不会给不关心这些的客户带来额外的负担"],["body","\n"],["body","相比之下，在今天的Rust中，将额外的通用参数添加到 Trait经常感觉像是一个非常“重量级”的举动。"],["body","\n"],["body","\n"],["body","\n"],["body","Ease of refactor ing/evolution：易于重构"],["body","\n"],["body","因为trait的用户不必单独参数化它 相关的类型，可以添加新的关联类型而不破坏所有 现有的客户端代码。"],["body","\n"],["body","相反，在今天的Rust中，关联类型只能通过给 一个trait 添加更多的类型参数，这会破坏所有使用到这个trait的代码。"],["body","\n"],["body","\n\n"],["headingLink","clearer-trait-matching"],["heading","Clearer trait matching"],["body","\n"],["body","\n"],["body","清晰的trait匹配"],["body","\n"],["body","\n"],["body","traits的类型参数 要么是 输入、输出"],["body","\n\n"],["body","\n"],["body","Inputs. “input”类型参数用于确定使用哪个类型的实现"],["body","\n"],["body","\n"],["body","\n"],["body","Outputs. \"output\" 类型参数 在选择实现时没有作用。"],["body","\n"],["body","\n\n"],["body","输入和输出类型在类型推理和   trait 一致性规则 中起着重要作用，这后面会有更详细的描述"],["body","\n"],["body","在目前绝大多数的库中，唯一的输入类型是' Self ' 类型实现trait，所有其他特征类型参数都是输出"],["body","\n"],["body","例如，trait  Iterator<A> 接受元素的类型形参' A ' 但这种类型总是由具体的“Self”决定的 类型(e.g. Items<u8>) ，A类型通常是输出类型"],["body","\n"],["body","Additional input type parameters are useful for cases like binary operators,\nwhere you may want the impl to depend on the types of both\narguments. For example, you might want a trait"],["body","\n"],["body","#![allow(unused)]\nfn main() {\ntrait Add<Rhs, Sum> {\n    fn add(&self, rhs: &Rhs) -> Sum;\n}\n}"],["body","\n"],["body","将' Self '和' Rhs '类型视为输入，将' Sum '类型视为输出 (因为它是由参数类型唯一决定的)。这将允许 ' impl ' s取决于' Rhs '类型，即使' Self '类型是相同的:"],["body","\n"],["body","#![allow(unused)]\nfn main() {\nimpl Add<int, int> for int { ... }\nimpl Add<Complex, Complex> for int { ... }\n}"],["body","\n"],["body","今天的Rust没有明确区分输入类型和输出类型 参数特征。如果你试图提供上面的两个impl，你 会收到如下错误"],["body","\n"],["body","error: conflicting implementations for trait `Add`\n"],["body","\n"],["body","这个RFC通过"],["body","\n\n"],["body","将所有trait类型参数视为输入类型，并且"],["body","\n"],["body","提供关联类型，即输出类型"],["body","\n\n"],["body","在这个设计中，“Add”trait将会像下面这样写和实现:"],["body","\n"],["body","#![allow(unused)]\nfn main() {\n// Self and Rhs are *inputs*\ntrait Add<Rhs> {\n    type Sum; // Sum is an *output*\n    fn add(&self, &Rhs) -> Sum;\n}\n\nimpl Add<int> for int {\n    type Sum = int;\n    fn add(&self, rhs: &int) -> int { ... }\n}\n\nimpl Add<Complex> for int {\n    type Sum = Complex;\n    fn add(&self, rhs: &Complex) -> Complex { ... }\n}\n}"],["body","\n"],["body","通过这种方法，一个trait声明像trait Add<Rhs>{…} 定义了一个“家族”特征，每个“Rhs”选择一类家族"],["body","\n"],["headingLink","expressiveness"],["heading","Expressiveness"],["body","\n"],["body","\n"],["body","善于表现；表情丰富"],["body","\n"],["body","\n"],["body","今天的rust  已经可以表达 Associated types、lifetimes、functions，尽管这样做很笨拙(如上所述)。"],["body","\n"],["body","但associated _consts_不能表达。"],["body","\n"],["body","例如，今天的Rust包含了各种数字traits，包括 ' Float '，当前必须将常量公开为静态函数:"],["body","\n"],["body","#![allow(unused)]\nfn main() {\ntrait Float {\n    fn nan() -> Self;\n    fn infinity() -> Self;\n    fn neg_infinity() -> Self;\n    fn neg_zero() -> Self;\n    fn pi() -> Self;\n    fn two_pi() -> Self;\n    ...\n} \n}"],["body","\n"],["body","因为这些函数不能用在常量表达式中，"],["body","\n"],["body","float类型的模块 同样导出了一组单独的常量作为 const,而没有使用 traits"],["body","\n"],["body","相关的常量将允许常量直接存在于特征上:"],["body","\n"],["body","#![allow(unused)]\nfn main() {\ntrait Float {\n    const NAN: Self;\n    const INFINITY: Self;\n    const NEG_INFINITY: Self;\n    const NEG_ZERO: Self;\n    const PI: Self;\n    const TWO_PI: Self;\n    ...\n}\n}"],["body","\n"],["headingLink","why-now"],["heading","Why now?"],["body","\n"],["body","撇开上述动机不谈，添加 associated types 的原因可能并不明显, 现在(即1.0之前)很重要。主要有两个原因。"],["body","\n"],["body","首先，这里展示的设计是“不”向后兼容的，因为它 为了trait实现匹配的目的，将trait类型参数重新解释为输入 匹配"],["body","\n"],["body","输入/输出的区别对一致性规则、类型推断和解析都有区别，这些都将在后面的 RFC。"],["body","\n"],["body","当然，也有可能给出一个不太理想的设计 关联类型可以稍后添加，而不需要更改 已有的特征类型参数解析"],["body","\n"],["body","例如，类型参数可以是显式的 标记为输入，否则假定为输出。这将是 不幸的是，因为关联的类型也是输出"],["body","\n"],["body","这会使语言 具有两种指定traits的输出类型的方法"],["body","\n"],["body","但第二个原因是库的稳定过程:"],["body","\n\n"],["body","\n"],["body","由于trait类型参数的大多数现有用途都是作为输出，它们实际上应该是关联类型。对这些api做出承诺：他们目前面临的风险是，将库置于一个这样的设计中：关联类型 添加后 即原有代码就会被抛弃。这种风险可能会 可以通过不同的向后兼容的 相关项设计来缓解，但是 以牺牲语言本身为代价。"],["body","\n"],["body","\n"],["body","\n"],["body","二元运算符的特征(例如。' Add ')应该是multidispatch"],["body","\n"],["body","\n"],["body","\n"],["body","It does not seem possible to stabilize them now in a way that will support moving to multidispatch later."],["body","\n"],["body","\n"],["body","\n"],["body","当前的库中还存在一些棘手的问题,"],["body","\n\n"],["body","such as the _equivmethods accumulating in HashMap, 这可以通过关联类型来解决"],["body","\n"],["body","(请参阅下面的“Defaults”以获得关于这个特定示例的更多信息。) 额外的 示例包括：错误传播的 trait、类型转换的 trait"],["body","\n\n"],["body","\n\n"],["headingLink","detailed-design"],["heading","Detailed design"],["body","\n"],["body","\n"],["body","详细设计"],["body","\n"],["body","\n"],["headingLink","trait-headers"],["heading","Trait headers"],["body","\n"],["body","Trait头是根据以下语法写的"],["body","\n"],["body","TRAIT_HEADER =\n  'trait' IDENT [ '<' INPUT_PARAMS '>' ] [ ':' BOUNDS ] [ WHERE_CLAUSE ]\n\nINPUT_PARAMS = INPUT_TY { ',' INPUT_TY }* [ ',' ]\nINPUT_PARAM  = IDENT [ ':' BOUNDS ]\n\nBOUNDS = BOUND { '+' BOUND }* [ '+' ]\nBOUND  = IDENT [ '<' ARGS '>' ]\n\nARGS   = INPUT_ARGS\n       | OUTPUT_CONSTRAINTS\n       | INPUT_ARGS ',' OUTPUT_CONSTRAINTS\n\nINPUT_ARGS = TYPE { ',' TYPE }*\n\nOUTPUT_CONSTRAINTS = OUTPUT_CONSTRAINT { ',' OUTPUT_CONSTRAINT }*\nOUTPUT_CONSTRAINT  = IDENT '=' TYPE\n"],["body","\n"],["body","注意：WHERE_CLAUSE and BOUND 的语法 在下面的 \"Constraining associated types\" 节中详细解释"],["body","\n"],["body","一个trait的所有类型参数都被认为是输入，可以用来选择 一个“impl”;"],["body","\n"],["body","从概念上讲，每个不同实例的类型 都会产生一个 截然不同的trait。更多细节在\"The input/output type\ndistinction\"一节中给出 区别”。"],["body","\n"],["headingLink","trait-bodies-defining-associated-items"],["heading","Trait bodies: defining associated items"],["body","\n"],["body","Trait bodies扩展成包含 三种新事物："],["body","\n"],["body","consts, types and lifetimes:"],["body","\n"],["body","TRAIT = TRAIT_HEADER '{' TRAIT_ITEM* '}'\nTRAIT_ITEM =\n  ... <existing productions>\n  | 'const' IDENT ':' TYPE [ '=' CONST_EXP ] ';'\n  | 'type' IDENT [ ':' BOUNDS ] [ WHERE_CLAUSE ] [ '=' TYPE ] ';'\n  | 'lifetime' LIFETIME_IDENT ';'\n"],["body","\n"],["body","Traits已经支持 关联函数，就是之前 称作：“static”的函数"],["body","\n"],["body","关联类型上的 BOUNDS and WHERE_CLAUSE  是对 trait的挑选、假设"],["body","\n"],["body","#![allow(unused)]\nfn main() {\ntrait Graph {\n    type N: Show + Hash;\n    type E: Show + Hash;\n    ...\n}\n\nimpl Graph for MyGraph {\n    // Both MyNode and MyEdge must implement Show and Hash\n    type N = MyNode;\n    type E = MyEdge;\n    ...\n}\n\nfn print_nodes<G: Graph>(g: &G) {\n    // here, can assume G::N implements Show\n    ...\n}\n}"],["body","\n"],["headingLink","namespacingshadowing-for-associated-types"],["heading","Namespacing/shadowing for associated types"],["body","\n"],["body","\n"],["body","关联类型的命名空间/遮蔽"],["body","\n"],["body","\n"],["body","关联类型可以与作用域中现有类型具有相同的名称，除trait的类型参数之外:"],["body","\n"],["body","#![allow(unused)]\nfn main() {\nstruct Foo { ... }\n\ntrait Bar<Input> {\n    type Foo; // this is allowed\n    fn into_foo(self) -> Foo; // this refers to the trait's Foo\n\n    type Input; // this is NOT allowed\n}\n}"],["body","\n"],["body","By not allowing name clashes between input and output types,\nkeep open the possibility of later allowing syntax like:"],["body","\n"],["body","通过不允许输入和输出类型之间的名称冲突， 保留以后允许 如下语法的可能性"],["body","\n"],["body","#![allow(unused)]\nfn main() {\nBar<Input=u8, Foo=uint>\n}"],["body","\n"],["body","where both input and output parameters are constrained by name. And anyway,\nthere is no use for clashing input/output names."],["body","\n"],["body","其中输入和输出参数都由名称约束。无论如何, 输入/输出名称冲突是没有用的。"],["body","\n"],["body","在名字冲突的情况下，如上面的' Foo '，由于某种原因 如果trait需要引用 外部 Foo，它总是可以通过使用' type 别名来做到这一点 在 trait 之外。"],["body","\n"],["headingLink","defaults"],["heading","Defaults"],["body","\n"],["body","注意，关联的常量和类型都允许默认值，就像trait一样 方法和函数可以提供默认值。"],["body","\n"],["body","作为一种代码重用机制和一种扩展方法，默认值都是有用的 "],["body","\n"],["body","然而，关联类型的默认值提出了一个有趣的问题：默认方法可以采用默认类型吗"],["body","\n"],["body","#![allow(unused)]\nfn main() {\ntrait ContainerKey : Clone + Hash + Eq {\n    type Query: Hash = Self;\n    fn compare(&self, other: &Query) -> bool { self == other }\n    fn query_to_key(q: &Query) -> Self { q.clone() };\n}\n\nimpl ContainerKey for String {\n    type Query = str;\n    fn compare(&self, other: &str) -> bool {\n        self.as_slice() == other\n    }\n    fn query_to_key(q: &str) -> String {\n        q.into_string()\n    }\n}\n\nimpl<K,V> HashMap<K,V> where K: ContainerKey {\n    fn find(&self, q: &K::Query) -> &V { ... }\n}\n}"],["body","\n"],["body","在这个例子中，' ContainerKey ' trait被用来关联一个' Query ' '类型 (用于查找)具有拥有的键类型"],["body","\n"],["body","这解决了 HashMap中棘手的问题:使用 &str索引，而不是 &String索引"],["body","\n"],["body","#![allow(unused)]\nfn main() {\n// H: HashMap<String, SomeType>\nH.find(\"some literal\")\n}"],["body","\n"],["body","而不是写作："],["body","\n"],["body","#![allow(unused)]\nfn main() {\nH.find(&\"some literal\".to_string())`\n}"],["body","\n"],["body","当前的解决方案包括使用' _equiv '方法复制API表面 使用了一些微妙的“Equiv”特征，但也使用了关联类型方法 使得提供一个覆盖相同用例的简单、单一的API变得容易。"],["body","\n"],["body","' ContainerKey '的默认值只是假设拥有键和查找键 类型是相同的"],["body","\n"],["body","但是默认方法必须假定默认值 关联类型，才能正常工作。"],["body","\n"],["body","不可用 覆盖 Query类型、而保留默认方法。"],["body","\n"],["body","我们用一种非常简单的方法来处理这个问题:"],["body","\n\n"],["body","如果一个trait 覆盖了任何默认的关联类型，它们也必须覆盖 覆盖所有默认函数和方法。"],["body","\n"],["body","否则，trait实现者可以有选择地覆盖单个默认值 方法/函数，就像今天一样。"],["body","\n\n"],["headingLink","trait-implementations"],["heading","Trait implementations"],["body","\n"],["body","triat实现语法"],["body","\n"],["body","IMPL_ITEM =\n  ... <existing productions>\n  | 'const' IDENT ':' TYPE '=' CONST_EXP ';'\n  | 'type' IDENT' '=' 'TYPE' ';'\n  | 'lifetime' LIFETIME_IDENT '=' LIFETIME_REFERENCE ';'\n"],["body","\n"],["body","类中的任何“type”实现必须满足所有边界和where子句"],["body","\n"],["headingLink","referencing-associated-items"],["heading","Referencing associated items"],["body","\n"],["body","\n"],["body","引用关联项"],["body","\n"],["body","\n"],["body","关联项是通过路径引用的"],["body","\n"],["body","表达式路径语法为 作为[UFCS]的一部分更新(https://github.com/rust-lang/rfcs/pull/132)，"],["body","\n"],["body","但 容纳相关的类型和生命周期，我们需要更新类型路径 语法。"],["body","\n"],["body","完整的语法如下:"],["body","\n"],["body","EXP_PATH\n  = EXP_ID_SEGMENT { '::' EXP_ID_SEGMENT }*\n  | TYPE_SEGMENT { '::' EXP_ID_SEGMENT }+\n  | IMPL_SEGMENT { '::' EXP_ID_SEGMENT }+\nEXP_ID_SEGMENT   = ID [ '::' '<' TYPE { ',' TYPE }* '>' ]\n\nTY_PATH\n  = TY_ID_SEGMENT { '::' TY_ID_SEGMENT }*\n  | TYPE_SEGMENT { '::' TY_ID_SEGMENT }*\n  | IMPL_SEGMENT { '::' TY_ID_SEGMENT }+\n\nTYPE_SEGMENT = '<' TYPE '>'\nIMPL_SEGMENT = '<' TYPE 'as' TRAIT_REFERENCE '>'\nTRAIT_REFERENCE = ID [ '<' TYPE { ',' TYPE * '>' ]\n"],["body","\n"],["body","下面是一些示例路径，以及它们可能引用的内容"],["body","\n"],["body","#![allow(unused)]\nfn main() {\n// Expression paths ///////////////////////////////////////////////////////////////\n\na::b::c         // reference to a function `c` in module `a::b`\na::<T1, T2>     // the function `a` instantiated with type arguments `T1`, `T2`\nVec::<T>::new   // reference to the function `new` associated with `Vec<T>`\n<Vec<T> as SomeTrait>::some_fn\n                // reference to the function `some_fn` associated with `SomeTrait`,\n                //   as implemented by `Vec<T>`\nT::size_of      // the function `size_of` associated with the type or trait `T`\n<T>::size_of    // the function `size_of` associated with `T` _viewed as a type_\n<T as SizeOf>::size_of\n                // the function `size_of` associated with `T`'s impl of `SizeOf`\n\n// Type paths /////////////////////////////////////////////////////////////////////\n\na::b::C         // reference to a type `C` in module `a::b`\nA<T1, T2>       // type A instantiated with type arguments `T1`, `T2`\nVec<T>::Iter    // reference to the type `Iter` associated with `Vec<T>\n<Vec<T> as SomeTrait>::SomeType\n                // reference to the type `SomeType` associated with `SomeTrait`,\n                //   as implemented by `Vec<T>`\n}"],["body","\n"],["headingLink","ways-to-reference-items"],["heading","Ways to reference items"],["body","\n"],["body","接下来，我们将详细介绍每种路径的含义。  为了便于讨论，我们假设已经定义了一个trait类似于"],["body","\n"],["body","#![allow(unused)]\nfn main() {\ntrait Container {\n    type E;\n    fn empty() -> Self;\n    fn insert(&mut self, E);\n    fn contains(&self, &E) -> bool where E: PartialEq;\n    ...\n}\n\nimpl<T> Container for Vec<T> {\n    type E = T;\n    fn empty() -> Vec<T> { Vec::new() }\n    ...\n}\n}"],["body","\n"],["headingLink","via-an-id_segment-prefix"],["heading","Via an ID_SEGMENT prefix"],["body","\n"],["body","\n"],["body","通过ID_SEGEMENT 前缀 访问"],["body","\n"],["body","\n"],["headingLink","当前缀解析为类型时"],["heading","当前缀解析为类型时"],["body","\n"],["body","获取关联项的最常见方法是通过  带有特征限制类型参数 :"],["body","\n"],["body","#![allow(unused)]\nfn main() {\nfn pick<C: Container>(c: &C) -> Option<&C::E> { ... }\n\nfn mk_with_two<C>() -> C where C: Container, C::E = uint {\n    let mut cont = C::empty();  // reference to associated function\n    cont.insert(0);\n    cont.insert(1);\n    cont\n}\n}"],["body","\n"],["body","要使这些引用有效，必须知道类型参数才能实现 相关的特征:"],["body","\n"],["body","#![allow(unused)]\nfn main() {\n// Knowledge via bounds\nfn pick<C: Container>(c: &C) -> Option<&C::E> { ... }\n\n// ... or equivalently,  where clause\nfn pick<C>(c: &C) -> Option<&C::E> where C: Container { ... }\n\n// Knowledge via ambient constraints\nstruct TwoContainers<C1: Container, C2: Container>(C1, C2);\nimpl<C1: Container, C2: Container> TwoContainers<C1, C2> {\n    fn pick_one(&self) -> Option<&C1::E> { ... }\n    fn pick_other(&self) -> Option<&C2::E> { ... }\n}\n}"],["body","\n"],["body","请注意' Vec<T>::E '和' Vec::<T>::empty '也是有效的类型和函数"],["body","\n"],["body","对于像' C::E '或' Vec<T>::E '这样的情况，路径以' ID_SEGMENT '开头，前缀本身解析为_type: ' C '和' Vec<T> '都是类型。在 一般情况下，路径PREFIX::REST_OF_PATH，其中PREFIX解析为类型是 等价于使用' TYPE_SEGMENT 前缀 <PREFIX>::REST_OF_PATH 。因此,对于 下面的例子都是等价的:"],["body","\n"],["body","#![allow(unused)]\nfn main() {\nfn pick<C: Container>(c: &C) -> Option<&C::E> { ... }\nfn pick<C: Container>(c: &C) -> Option<&<C>::E> { ... }\nfn pick<C: Container>(c: &C) -> Option<&<<C>::E>> { ... }\n}"],["body","\n"],["body","TYPE_SEGMENT前缀的行为将在下一小节中描述。"],["body","\n"],["headingLink","当前缀解析为trait时"],["heading","当前缀解析为trait时"],["body","\n"],["body","ID_SEGMENT 前缀可以解析为trait' 其行为不同于 ' TYPE_SEGMENT '的类型"],["body","\n"],["body","如下:"],["body","\n"],["body","#![allow(unused)]\nfn main() {\n// a reference Container::insert is roughly equivalent to:\nfn trait_insert<C: Container>(c: &C, e: C::E);\n\n// a reference <Container>::insert is roughly equivalent to:\nfn object_insert<E>(c: &Container<E=E>, e: E);\n}"],["body","\n"],["body","trait前缀"],["body","\n\n"],["body","\n"],["body","A path PREFIX::REST resolves to the item/path REST defined within\nTrait, while treating the type implementing the trait as a type parameter."],["body","\n"],["body","\n"],["body","\n"],["body","A path <PREFIX>::REST treats PREFIX as a (DST-style) type, and is\nhence usable only with trait objects. See the\nUFCS RFC for more detail."],["body","\n"],["body","\n\n"],["body","请注意，像' Container::E '这样的路径虽然在语法上是有效的，但将失败 ，因为没有办法告诉使用哪个“impl”。 Container::empty '的函数大致相当于:"],["body","\n"],["body","#![allow(unused)]\nfn main() {\nfn trait_empty<C: Container>() -> C;\n}"],["body","\n"],["headingLink","via-a-type_segment-prefix"],["heading","Via a TYPE_SEGMENT prefix"],["body","\n"],["body","\n"],["body","The following text is slightly changed from the\nUFCS RFC."],["body","\n"],["body","\n"],["body","当路径以' TYPE_SEGMENT '开头时，它是一个类型相对路径"],["body","\n"],["body","如果这已经是一个全部路径，则解析到指定的 类型。如果路径继续(例如，' <int>::size_of ')，那么下一个段是 使用以下过程进行解析。"],["body","\n"],["body","该过程旨在模拟 方法查找，因此对方法查找的任何更改也可能会更改 此查找算法。"],["body","\n"],["body","Given a path <T>::m::...:"],["body","\n\n"],["body","Search for members of inherent impls defined on T (if any) with\nthe name m. If any are found, the path resolves to that item."],["body","\n"],["body","Otherwise, let IN_SCOPE_TRAITS be the set of traits that are in\nscope and which contain a member named m:\n\n"],["body","Let IMPLEMENTED_TRAITS be those traits from IN_SCOPE_TRAITS\nfor which an implementation exists that (may) apply to T.\n\n"],["body","There can be ambiguity in the case that T contains type inference\nvariables."],["body","\n\n"],["body","\n"],["body","If IMPLEMENTED_TRAITS is not a singleton set, report an ambiguity\nerror. Otherwise, let TRAIT be the member of IMPLEMENTED_TRAITS."],["body","\n"],["body","If TRAIT is ambiguously implemented for T, report an\nambiguity error and request further type information."],["body","\n"],["body","Otherwise, rewrite the path to <T as Trait>::m::... and\ncontinue."],["body","\n\n"],["body","\n\n"],["headingLink","via-a-impl_segment-prefix"],["heading","Via a IMPL_SEGMENT prefix"],["body","\n"],["body","\n"],["body","The following text is somewhat different from the\nUFCS RFC."],["body","\n"],["body","\n"],["body","When a path begins with an IMPL_SEGMENT, it is a reference to an item defined\nfrom a trait. Note that such paths must always have a follow-on member m (that\nis, <T as Trait> is not a complete path, but <T as Trait>::m is)."],["body","\n"],["body","To resolve the path, first search for an applicable implementation of Trait\nfor T. If no implementation can be found -- or the result is ambiguous -- then\nreport an error.  Note that when T is a type parameter, a bound T: Trait\nguarantees that there is such an implementation, but does not count for\nambiguity purposes."],["body","\n"],["body","Otherwise, resolve the path to the member of the trait with the substitution\nSelf => T and continue."],["body","\n"],["body","This apparently straightforward algorithm has some subtle consequences, as\nillustrated by the following example:"],["body","\n"],["body","#![allow(unused)]\nfn main() {\ntrait Foo {\n    type T;\n    fn as_T(&self) -> &T;\n}\n\n// A blanket impl for any Show type T\nimpl<T: Show> Foo for T {\n    type T = T;\n    fn as_T(&self) -> &T { self }\n}\n\nfn bounded<U: Foo>(u: U) where U::T: Show {\n    // Here, we just constrain the associated type directly\n    println!(\"{}\", u.as_T())\n}\n\nfn blanket<U: Show>(u: U) {\n    // the blanket impl applies to U, so we know that `U: Foo` and\n    // <U as Foo>::T = U (and, of course, U: Show)\n    println!(\"{}\", u.as_T())\n}\n\nfn not_allowed<U: Foo>(u: U) {\n    // this will not compile, since <U as Trait>::T is not known to\n    // implement Show\n    println!(\"{}\", u.as_T())\n}\n}"],["body","\n"],["body","This example includes three generic functions that make use of an associated\ntype; the first two will typecheck, while the third will not."],["body","\n\n"],["body","\n"],["body","The first case, bounded, places a Show constraint directly on the\notherwise-abstract associated type U::T. Hence, it is allowed to assume that\nU::T: Show, even though it does not know the concrete implementation of\nFoo for U."],["body","\n"],["body","\n"],["body","\n"],["body","The second case, blanket, places a Show constraint on the type U, which\nmeans that the blanket impl of Foo applies even though we do not know the\nconcrete type that U will be. That fact means, moreover, that we can\ncompute exactly what the associated type U::T will be, and know that it will\nsatisfy Show. Coherence guarantees that that the blanket impl is the only\none that could apply to U. (See the section \"Impl specialization\" under\n\"Unresolved questions\" for a deeper discussion of this point.)"],["body","\n"],["body","\n"],["body","\n"],["body","The third case assumes only that U: Foo, and therefore nothing is known\nabout the associated type U::T. In particular, the function cannot assume\nthat U::T: Show."],["body","\n"],["body","\n\n"],["body","The resolution rules also interact with instantiation of type parameters in an\nintuitive way. For example:"],["body","\n"],["body","#![allow(unused)]\nfn main() {\ntrait Graph {\n    type N;\n    type E;\n    ...\n}\n\nimpl Graph for MyGraph {\n    type N = MyNode;\n    type E = MyEdge;\n    ...\n}\n\nfn pick_node<G: Graph>(t: &G) -> &G::N {\n    // the type G::N is abstract here\n    ...\n}\n\nlet G = MyGraph::new();\n...\npick_node(G) // has type: <MyGraph as Graph>::N = MyNode\n}"],["body","\n"],["body","Assuming there are no blanket implementations of Graph, the pick_node\nfunction knows nothing about the associated type G::N. However, a client of\npick_node that instantiates it with a particular concrete graph type will also\nknow the concrete type of the value returned from the function -- here, MyNode."],["body","\n"],["headingLink","scoping-of-trait-and-impl-items"],["heading","Scoping of trait and impl items"],["body","\n"],["body","Associated types are frequently referred to in the signatures of a trait's\nmethods and associated functions, and it is natural and convenient to refer to\nthem directly."],["body","\n"],["body","In other words, writing this:"],["body","\n"],["body","#![allow(unused)]\nfn main() {\ntrait Graph {\n    type N;\n    type E;\n    fn has_edge(&self, &N, &N) -> bool;\n    ...\n}\n}"],["body","\n"],["body","is more appealing than writing this:"],["body","\n"],["body","#![allow(unused)]\nfn main() {\ntrait Graph {\n    type N;\n    type E;\n    fn has_edge(&self, &Self::N, &Self::N) -> bool;\n    ...\n}\n}"],["body","\n"],["body","This RFC proposes to treat both trait and impl bodies (both\ninherent and for traits) the same way we treat mod bodies: all\nitems being defined are in scope. In particular, methods are in scope\nas UFCS-style functions:"],["body","\n"],["body","#![allow(unused)]\nfn main() {\ntrait Foo {\n    type AssocType;\n    lifetime 'assoc_lifetime;\n    const ASSOC_CONST: uint;\n    fn assoc_fn() -> Self;\n\n    // Note: 'assoc_lifetime and AssocType in scope:\n    fn method(&self, Self) -> &'assoc_lifetime AssocType;\n\n    fn default_method(&self) -> uint {\n        // method in scope UFCS-style, assoc_fn in scope\n        let _ = method(self, assoc_fn());\n        ASSOC_CONST // in scope\n    }\n}\n\n// Same scoping rules for impls, including inherent impls:\nstruct Bar;\nimpl Bar {\n    fn foo(&self) { ... }\n    fn bar(&self) {\n        foo(self); // foo in scope UFCS-style\n        ...\n    }\n}\n}"],["body","\n"],["body","Items from super traits are not in scope, however. See\nthe discussion on super traits below for more detail."],["body","\n"],["body","These scope rules provide good ergonomics for associated types in\nparticular, and a consistent scope model for language constructs that\ncan contain items (like traits, impls, and modules). In the long run,\nwe should also explore imports for trait items, i.e. use Trait::some_method, but that is out of scope for this RFC."],["body","\n"],["body","Note that, according to this proposal, associated types/lifetimes are not in\nscope for the optional where clause on the trait header. For example:"],["body","\n"],["body","#![allow(unused)]\nfn main() {\ntrait Foo<Input>\n    // type parameters in scope, but associated types are not:\n    where Bar<Input, Self::Output>: Encodable {\n\n    type Output;\n    ...\n}\n}"],["body","\n"],["body","This setup seems more intuitive than allowing the trait header to refer directly\nto items defined within the trait body."],["body","\n"],["body","It's also worth noting that trait-level where clauses are never needed for\nconstraining associated types anyway, because associated types also have where\nclauses. Thus, the above example could (and should) instead be written as\nfollows:"],["body","\n"],["body","#![allow(unused)]\nfn main() {\ntrait Foo<Input> {\n    type Output where Bar<Input, Output>: Encodable;\n    ...\n}\n}"],["body","\n"],["headingLink","constraining-associated-types"],["heading","Constraining associated types"],["body","\n"],["body","Associated types are not treated as parameters to a trait, but in some cases a\nfunction will want to constrain associated types in some way. For example, as\nexplained in the Motivation section, the Iterator trait should treat the\nelement type as an output:"],["body","\n"],["body","#![allow(unused)]\nfn main() {\ntrait Iterator {\n    type A;\n    fn next(&mut self) -> Option<A>;\n    ...\n}\n}"],["body","\n"],["body","For code that works with iterators generically, there is no need to constrain\nthis type:"],["body","\n"],["body","#![allow(unused)]\nfn main() {\nfn collect_into_vec<I: Iterator>(iter: I) -> Vec<I::A> { ... }\n}"],["body","\n"],["body","But other code may have requirements for the element type:"],["body","\n\n"],["body","That it implements some traits (bounds)."],["body","\n"],["body","That it unifies with a particular type."],["body","\n\n"],["body","These requirements can be imposed via where clauses:"],["body","\n"],["body","#![allow(unused)]\nfn main() {\nfn print_iter<I>(iter: I) where I: Iterator, I::A: Show { ... }\nfn sum_uints<I>(iter: I) where I: Iterator, I::A = uint { ... }\n}"],["body","\n"],["body","In addition, there is a shorthand for equality constraints:"],["body","\n"],["body","#![allow(unused)]\nfn main() {\nfn sum_uints<I: Iterator<A = uint>>(iter: I) { ... }\n}"],["body","\n"],["body","In general, a trait like:"],["body","\n"],["body","#![allow(unused)]\nfn main() {\ntrait Foo<Input1, Input2> {\n    type Output1;\n    type Output2;\n    lifetime 'a;\n    const C: bool;\n    ...\n}\n}"],["body","\n"],["body","can be written in a bound like:"],["body","\n"],["body","T: Foo<I1, I2>\nT: Foo<I1, I2, Output1 = O1>\nT: Foo<I1, I2, Output2 = O2>\nT: Foo<I1, I2, Output1 = O1, Output2 = O2>\nT: Foo<I1, I2, Output1 = O1, 'a = 'b, Output2 = O2>\nT: Foo<I1, I2, Output1 = O1, 'a = 'b, C = true, Output2 = O2>\n"],["body","\n"],["body","The output constraints must come after all input arguments, but can appear in\nany order."],["body","\n"],["body","Note that output constraints are allowed when referencing a trait in a type or\na bound, but not in an IMPL_SEGMENT path:"],["body","\n\n"],["body","As a type: fn foo(obj: Box<Iterator<A = uint>> is allowed."],["body","\n"],["body","In a bound: fn foo<I: Iterator<A = uint>>(iter: I) is allowed."],["body","\n"],["body","In an IMPL_SEGMENT: <I as Iterator<A = uint>>::next is not allowed."],["body","\n\n"],["body","The reason not to allow output constraints in IMPL_SEGMENT is that such paths\nare references to a trait implementation that has already been determined -- it\ndoes not make sense to apply additional constraints to the implementation when\nreferencing it."],["body","\n"],["body","Output constraints are a handy shorthand when using trait bounds, but they are a\nnecessity for trait objects, which we discuss next."],["body","\n"],["headingLink","trait-objects"],["heading","Trait objects"],["body","\n"],["body","When using trait objects, the Self type is \"erased\", so different types\nimplementing the trait can be used under the same trait object type:"],["body","\n"],["body","#![allow(unused)]\nfn main() {\nimpl Show for Foo { ... }\nimpl Show for Bar { ... }\n\nfn make_vec() -> Vec<Box<Show>> {\n    let f = Foo { ... };\n    let b = Bar { ... };\n    let mut v = Vec::new();\n    v.push(box f as Box<Show>);\n    v.push(box b as Box<Show>);\n    v\n}\n}"],["body","\n"],["body","One consequence of erasing Self is that methods using the Self type as\narguments or return values cannot be used on trait objects, since their types\nwould differ for different choices of Self."],["body","\n"],["body","In the model presented in this RFC, traits have additional input parameters\nbeyond Self, as well as associated types that may vary depending on all of the\ninput parameters. This raises the question: which of these types, if any, are\nerased in trait objects?"],["body","\n"],["body","The approach we take here is the simplest and most conservative: when using a\ntrait as a type (i.e., as a trait object), all input and output types must\nbe provided as part of the type. In other words, only the Self type is\nerased, and all other types are specified statically in the trait object type."],["body","\n"],["body","Consider again the following example:"],["body","\n"],["body","#![allow(unused)]\nfn main() {\ntrait Foo<Input1, Input2> {\n    type Output1;\n    type Output2;\n    lifetime 'a;\n    const C: bool;\n    ...\n}\n}"],["body","\n"],["body","Unlike the case for static trait bounds, which do not have to specify any of the\nassociated types, lifetimes, or consts, (but do have to specify the input types),\ntrait object types must specify all of the types:"],["body","\n"],["body","#![allow(unused)]\nfn main() {\nfn consume_foo<T: Foo<I1, I2>>(t: T) // this is valid\nfn consume_obj(t: Box<Foo<I1, I2>>)  // this is NOT valid\n\n// but this IS valid:\nfn consume_obj(t: Box<Foo<I1, I2, Output1 = O2, Output2 = O2, 'a = 'static, C = true>>)\n}"],["body","\n"],["body","With this design, it is clear that none of the non-Self types are erased as\npart of trait objects. But it leaves wiggle room to relax this restriction\nlater on: trait object types that are not allowed under this design can be given\nmeaning in some later design."],["body","\n"],["headingLink","inherent-associated-items"],["heading","Inherent associated items"],["body","\n"],["body","All associated items are also allowed in inherent impls, so a definition like\nthe following is allowed:"],["body","\n"],["body","#![allow(unused)]\nfn main() {\nstruct MyGraph { ... }\nstruct MyNode { ... }\nstruct MyEdge { ... }\n\nimpl MyGraph {\n    type N = MyNode;\n    type E = MyEdge;\n\n    // Note: associated types in scope, just as with trait bodies\n    fn has_edge(&self, &N, &N) -> bool {\n        ...\n    }\n\n    ...\n}\n}"],["body","\n"],["body","Inherent associated items are referenced similarly to trait associated items:"],["body","\n"],["body","#![allow(unused)]\nfn main() {\nfn distance(g: &MyGraph, from: &MyGraph::N, to: &MyGraph::N) -> uint { ... }\n}"],["body","\n"],["body","Note, however, that output constraints do not make sense for inherent outputs:"],["body","\n"],["body","#![allow(unused)]\nfn main() {\n// This is *not* a legal type:\nMyGraph<N = SomeNodeType>\n}"],["body","\n"],["headingLink","the-inputoutput-type-distinction"],["heading","The input/output type distinction"],["body","\n"],["body","When designing a trait that references some unknown type, you now have the\noption of taking that type as an input parameter, or specifying it as an output\nassociated type. What are the ramifications of this decision?"],["body","\n"],["headingLink","coherence-implications"],["heading","Coherence implications"],["body","\n"],["body","Input types are used when determining which impl matches, even for the same\nSelf type:"],["body","\n"],["body","#![allow(unused)]\nfn main() {\ntrait Iterable1<A> {\n    type I: Iterator<A>;\n    fn iter(self) -> I;\n}\n\n// These impls have distinct input types, so are allowed\nimpl Iterable1<u8> for Foo { ... }\nimpl Iterable1<char> for Foo { ... }\n\ntrait Iterable2 {\n    type A;\n    type I: Iterator<A>;\n    fn iter(self) -> I;\n}\n\n// These impls apply to a common input (Foo), so are NOT allowed\nimpl Iterable2 for Foo { ... }\nimpl Iterable2 for Foo { ... }\n}"],["body","\n"],["body","More formally, the coherence property is revised as follows:"],["body","\n\n"],["body","Given a trait and values for all its type parameters (inputs, including\nSelf), there is at most one applicable impl."],["body","\n\n"],["body","In the trait reform RFC, coherence\nis guaranteed by maintaining two other key properties, which are revised as\nfollows:"],["body","\n"],["body","Orphan check: Every implementation must meet one of\nthe following conditions:"],["body","\n\n"],["body","\n"],["body","The trait being implemented (if any) must be defined in the current crate."],["body","\n"],["body","\n"],["body","\n"],["body","At least one of the input type parameters (including but not\nnecessarily Self) must meet the following grammar, where C\nis a struct or enum defined within the current crate:"],["body","\n"],["body","T = C\n  | [T]\n  | [T, ..n]\n  | &T\n  | &mut T\n  | ~T\n  | (..., T, ...)\n  | X<..., T, ...> where X is not bivariant with respect to T\n"],["body","\n"],["body","\n\n"],["body","Overlapping instances: No two implementations can be instantiable\nwith the same set of types for the input type parameters."],["body","\n"],["body","See the trait reform RFC for more\ndiscussion of these properties."],["body","\n"],["headingLink","type-inference-implications"],["heading","Type inference implications"],["body","\n"],["body","Finally, output type parameters can be inferred/resolved as soon as there is\na matching impl based on the input type parameters. Because of the\ncoherence property above, there can be at most one."],["body","\n"],["body","On the other hand, even if there is only one applicable impl, type inference\nis not allowed to infer the input type parameters from it. This restriction\nmakes it possible to ensure crate concatenation: adding another crate may add\nimpls for a given trait, and if type inference depended on the absence of such\nimpls, importing a crate could break existing code."],["body","\n"],["body","In practice, these inference benefits can be quite valuable. For example, in the\nAdd trait given at the beginning of this RFC, the Sum output type is\nimmediately known once the input types are known, which can avoid the need for\ntype annotations."],["body","\n"],["headingLink","limitations"],["heading","Limitations"],["body","\n"],["body","The main limitation of associated items as presented here is about associated\ntypes in particular. You might be tempted to write a trait like the following:"],["body","\n"],["body","#![allow(unused)]\nfn main() {\ntrait Iterable {\n    type A;\n    type I: Iterator<&'a A>; // what is the lifetime here?\n    fn iter<'a>(&'a self) -> I;  // and how to connect it to self?\n}\n}"],["body","\n"],["body","The problem is that, when implementing this trait, the return type I of iter\nmust generally depend on the lifetime of self. For example, the corresponding\nmethod in Vec looks like the following:"],["body","\n"],["body","#![allow(unused)]\nfn main() {\nimpl<T> Vec<T> {\n    fn iter(&'a self) -> Items<'a, T> { ... }\n}\n}"],["body","\n"],["body","This means that, given a Vec<T>, there isn't a single type Items<T> for\niteration -- rather, there is a family of types, one for each input lifetime.\nIn other words, the associated type I in the Iterable needs to be\n\"higher-kinded\": not just a single type, but rather a family:"],["body","\n"],["body","#![allow(unused)]\nfn main() {\ntrait Iterable {\n    type A;\n    type I<'a>: Iterator<&'a A>;\n    fn iter<'a>(&self) -> I<'a>;\n}\n}"],["body","\n"],["body","In this case, I is parameterized by a lifetime, but in other cases (like\nmap) an associated type needs to be parameterized by a type."],["body","\n"],["body","In general, such higher-kinded types (HKTs) are a much-requested feature for\nRust, and they would extend the reach of associated types. But the design and\nimplementation of higher-kinded types is, by itself, a significant investment.\nThe point of view of this RFC is that associated items bring the most important\nchanges needed to stabilize our existing traits (and add a few key others),\nwhile HKTs will allow us to define important traits in the future but are not\nnecessary for 1.0."],["body","\n"],["headingLink","encoding-higher-kinded-types"],["heading","Encoding higher-kinded types"],["body","\n"],["body","That said, it's worth pointing out that variants of higher-kinded types can be\nencoded in the system being proposed here."],["body","\n"],["body","For example, the Iterable example above can be written in the following\nsomewhat contorted style:"],["body","\n"],["body","#![allow(unused)]\nfn main() {\ntrait IterableOwned {\n    type A;\n    type I: Iterator<A>;\n    fn iter_owned(self) -> I;\n}\n\ntrait Iterable {\n    fn iter<'a>(&'a self) -> <&'a Self>::I where &'a Self: IterableOwned {\n        IterableOwned::iter_owned(self)\n    }\n}\n}"],["body","\n"],["body","The idea here is to define a trait that takes, as input type/lifetimes\nparameters, the parameters to any HKTs. In this case, the trait is implemented\non the type &'a Self, which includes the lifetime parameter."],["body","\n"],["body","We can in fact generalize this technique to encode arbitrary HKTs:"],["body","\n"],["body","#![allow(unused)]\nfn main() {\n// The kind * -> *\ntrait TypeToType<Input> {\n    type Output;\n}\ntype Apply<Name, Elt> where Name: TypeToType<Elt> = Name::Output;\n\nstruct Vec_;\nstruct DList_;\n\nimpl<T> TypeToType<T> for Vec_ {\n    type Output = Vec<T>;\n}\n\nimpl<T> TypeToType<T> for DList_ {\n    type Output = DList<T>;\n}\n\ntrait Mappable\n{\n    type E;\n    type HKT where Apply<HKT, E> = Self;\n\n    fn map<F>(self, f: E -> F) -> Apply<HKT, F>;\n}\n}"],["body","\n"],["body","While the above demonstrates the versatility of associated types and where\nclauses, it is probably too much of a hack to be viable for use in libstd."],["body","\n"],["headingLink","associated-consts-in-generic-code"],["heading","Associated consts in generic code"],["body","\n"],["body","If the value of an associated const depends on a type parameter (including\nSelf), it cannot be used in a constant expression. This restriction will\nalmost certainly be lifted in the future, but this raises questions outside the\nscope of this RFC."],["body","\n"],["headingLink","staging"],["heading","Staging"],["body","\n"],["body","Associated lifetimes are probably not necessary for the 1.0 timeframe. While we\ncurrently have a few traits that are parameterized by lifetimes, most of these\ncan go away once DST lands."],["body","\n"],["body","On the other hand, associated lifetimes are probably trivial to implement once\nassociated types have been implemented."],["body","\n"],["headingLink","other-interactions"],["heading","Other interactions"],["body","\n"],["headingLink","interaction-with-implied-bounds"],["heading","Interaction with implied bounds"],["body","\n"],["body","As part of the\nimplied bounds\nidea, it may be desirable for this:"],["body","\n"],["body","#![allow(unused)]\nfn main() {\nfn pick_node<G>(g: &G) -> &<G as Graph>::N\n}"],["body","\n"],["body","to be sugar for this:"],["body","\n"],["body","#![allow(unused)]\nfn main() {\nfn pick_node<G: Graph>(g: &G) -> &<G as Graph>::N\n}"],["body","\n"],["body","But this feature can easily be added later, as part of a general implied bounds RFC."],["body","\n"],["headingLink","future-proofing-specialization-of-impls"],["heading","Future-proofing: specialization of impls"],["body","\n"],["body","In the future, we may wish to relax the \"overlapping instances\" rule so that one\ncan provide \"blanket\" trait implementations and then \"specialize\" them for\nparticular types. For example:"],["body","\n"],["body","#![allow(unused)]\nfn main() {\ntrait Sliceable {\n    type Slice;\n    // note: not using &self here to avoid need for HKT\n    fn as_slice(self) -> Slice;\n}\n\nimpl<'a, T> Sliceable for &'a T {\n    type Slice = &'a T;\n    fn as_slice(self) -> &'a T { self }\n}\n\nimpl<'a, T> Sliceable for &'a Vec<T> {\n    type Slice = &'a [T];\n    fn as_slice(self) -> &'a [T] { self.as_slice() }\n}\n}"],["body","\n"],["body","But then there's a difficult question:"],["body","\n"],["body","fn dice<A>(a: &A) -> &A::Slice where &A: Slicable {\n    a // is this allowed?\n}\n"],["body","\n"],["body","Here, the blanket and specialized implementations provide incompatible\nassociated types. When working with the trait generically, what can we assume\nabout the associated type? If we assume it is the blanket one, the type may\nchange during monomorphization (when specialization takes effect)!"],["body","\n"],["body","The RFC does allow generic code to \"see\" associated types provided by blanket\nimplementations, so this is a potential problem."],["body","\n"],["body","Our suggested strategy is the following. If at some later point we wish to add\nspecialization, traits would have to opt in explicitly. For such traits, we\nwould not allow generic code to \"see\" associated types for blanket\nimplementations; instead, output types would only be visible when all input\ntypes were concretely known. This approach is backwards-compatible with the RFC,\nand is probably a good idea in any case."],["body","\n"],["headingLink","alternatives"],["heading","Alternatives"],["body","\n"],["headingLink","multidispatch-through-tuple-types"],["heading","Multidispatch through tuple types"],["body","\n"],["body","This RFC clarifies trait matching by making trait type parameters inputs to\nmatching, and associated types outputs."],["body","\n"],["body","A more radical alternative would be to remove type parameters from traits, and\ninstead support multiple input types through a separate multidispatch mechanism."],["body","\n"],["body","In this design, the Add trait would be written and implemented as follows:"],["body","\n"],["body","#![allow(unused)]\nfn main() {\n// Lhs and Rhs are *inputs*\ntrait Add for (Lhs, Rhs) {\n    type Sum; // Sum is an *output*\n    fn add(&Lhs, &Rhs) -> Sum;\n}\n\nimpl Add for (int, int) {\n    type Sum = int;\n    fn add(left: &int, right: &int) -> int { ... }\n}\n\nimpl Add for (int, Complex) {\n    type Sum = Complex;\n    fn add(left: &int, right: &Complex) -> Complex { ... }\n}\n}"],["body","\n"],["body","The for syntax in the trait definition is used for multidispatch traits, here\nsaying that impls must be for pairs of types which are bound to Lhs and\nRhs respectively. The add function can then be invoked in UFCS style by\nwriting"],["body","\n"],["body","#![allow(unused)]\nfn main() {\nAdd::add(some_int, some_complex)\n}"],["body","\n"],["body","Advantages of the tuple approach:"],["body","\n\n"],["body","\n"],["body","It does not force a distinction between Self and other input types, which in\nsome cases (including binary operators like Add) can be artificial."],["body","\n"],["body","\n"],["body","\n"],["body","Makes it possible to specify input types without specifying the trait:\n<(A, B)>::Sum rather than <A as Add<B>>::Sum."],["body","\n"],["body","\n\n"],["body","Disadvantages of the tuple approach:"],["body","\n\n"],["body","\n"],["body","It's more painful when you do want a method rather than a function."],["body","\n"],["body","\n"],["body","\n"],["body","Requires where clauses when used in bounds: where (A, B): Trait rather\nthan A: Trait<B>."],["body","\n"],["body","\n"],["body","\n"],["body","It gives two ways to write single dispatch: either without for, or using\nfor with a single-element tuple."],["body","\n"],["body","\n"],["body","\n"],["body","There's a somewhat jarring distinction between single/multiple dispatch\ntraits, making the latter feel \"bolted on\"."],["body","\n"],["body","\n"],["body","\n"],["body","The tuple syntax is unusual in acting as a binder of its types, as opposed to\nthe Trait<A, B> syntax."],["body","\n"],["body","\n"],["body","\n"],["body","Relatedly, the generics syntax for traits is immediately understandable (a\nfamily of traits) based on other uses of generics in the language, while the\ntuple notation stands alone."],["body","\n"],["body","\n"],["body","\n"],["body","Less clear story for trait objects (although the fact that Self is the only\nerased input type in this RFC may seem somewhat arbitrary)."],["body","\n"],["body","\n\n"],["body","On balance, the generics-based approach seems like a better fit for the language\ndesign, especially in its interaction with methods and the object system."],["body","\n"],["headingLink","a-backwards-compatible-version"],["heading","A backwards-compatible version"],["body","\n"],["body","Yet another alternative would be to allow trait type parameters to be either\ninputs or outputs, marking the inputs with a keyword in:"],["body","\n"],["body","#![allow(unused)]\nfn main() {\ntrait Add<in Rhs, Sum> {\n    fn add(&Lhs, &Rhs) -> Sum;\n}\n}"],["body","\n"],["body","This would provide a way of adding multidispatch now, and then adding associated\nitems later on without breakage. If, in addition, output types had to come after\nall input types, it might even be possible to migrate output type parameters\nlike Sum above into associated types later."],["body","\n"],["body","This is perhaps a reasonable fallback, but it seems better to introduce a clean\ndesign with both multidispatch and associated items together."],["body","\n"],["headingLink","unresolved-questions"],["heading","Unresolved questions"],["body","\n"],["headingLink","super-traits"],["heading","Super traits"],["body","\n"],["body","This RFC largely ignores super traits."],["body","\n"],["body","Currently, the implementation of super traits treats them identically to a\nwhere clause that bounds Self, and this RFC does not propose to change\nthat. However, a follow-up RFC should clarify that this is the intended\nsemantics for super traits."],["body","\n"],["body","Note that this treatment of super traits is, in particular, consistent with the\nproposed scoping rules, which do not bring items from super traits into scope in\nthe body of a subtrait; they must be accessed via Self::item_name."],["body","\n"],["headingLink","equality-constraints-in-where-clauses"],["heading","Equality constraints in where clauses"],["body","\n"],["body","This RFC allows equality constraints on types for associated types, but does not\npropose a similar feature for where clauses. That will be the subject of a\nfollow-up RFC."],["body","\n"],["headingLink","multiple-trait-object-bounds-for-the-same-trait"],["heading","Multiple trait object bounds for the same trait"],["body","\n"],["body","The design here makes it possible to write bounds or trait objects that mention\nthe same trait, multiple times, with different inputs:"],["body","\n"],["body","#![allow(unused)]\nfn main() {\nfn mulit_add<T: Add<int> + Add<Complex>>(t: T) -> T { ... }\nfn mulit_add_obj(t: Box<Add<int> + Add<Complex>>) -> Box<Add<int> + Add<Complex>> { ... }\n}"],["body","\n"],["body","This seems like a potentially useful feature, and should be unproblematic for\nbounds, but may have implications for vtables that make it problematic for trait\nobjects. Whether or not such trait combinations are allowed will likely depend\non implementation concerns, which are not yet clear."],["body","\n"],["headingLink","generic-associated-consts-in-match-patterns"],["heading","Generic associated consts in match patterns"],["body","\n"],["body","It seems desirable to allow constants that depend on type parameters in match\npatterns, but it's not clear how to do so while still checking exhaustiveness\nand reachability of the match arms. Most likely this requires new forms of\nwhere clause, to constrain associated constant values."],["body","\n"],["body","For now, we simply defer the question."],["body","\n"],["headingLink","generic-associated-consts-in-array-sizes"],["heading","Generic associated consts in array sizes"],["body","\n"],["body","It would be useful to be able to use trait-associated constants in generic code."],["body","\n"],["body","#![allow(unused)]\nfn main() {\n// Shouldn't this be OK?\nconst ALIAS_N: usize = <T>::N;\nlet x: [u8; <T>::N] = [0u8; ALIAS_N];\n// Or...\nlet x: [u8; T::N + 1] = [0u8; T::N + 1];\n}"],["body","\n"],["body","However, this causes some problems. What should we do with the following case in\ntype checking, where we need to prove that a generic is valid for any T?"],["body","\n"],["body","#![allow(unused)]\nfn main() {\nlet x: [u8; T::N + T::N] = [0u8; 2 * T::N];\n}"],["body","\n"],["body","We would like to handle at least some obvious cases (e.g. proving that\nT::N == T::N), but without trying to prove arbitrary statements about\narithmetic. The question of how to do this is deferred."],["body","\n\n\n\n"],["body","\n\n                    "],["body","\n\n                    \n                \n            \n\n            \n\n        \n\n\n\n\n        \n\n\n\n        \n        \n        \n\n        \n\n\n    \n    \n"]],[["_relative_fp","3.rust/Rust库API设计文档规范.html"],["title","Rust库API设计文档规范 - 各项编程语言"],["body","\n    \n        \n        \n\n        \n        \n\n        \n        \n\n        \n        \n\n        \n\n        \n\n            \n                                \n                \n                    \n                        "],["body","\n                            \n                        "],["body","\n                        "],["body","\n                            \n                        "],["body","\n                        \n                            "],["body","Light"],["body","\n                            "],["body","Rust"],["body","\n                            "],["body","Coal"],["body","\n                            "],["body","Navy"],["body","\n                            "],["body","Ayu"],["body","\n                        \n                    \n\n                    "],["heading","各项编程语言"],["body","\n\n                    \n\n                    \n                \n\n\n                \n                \n\n                \n                    "],["body","\n                        \n\n"],["body","\n"],["body","\n\n"],["headingLink","什么是优雅的-api"],["heading","什么是优雅的 API"],["body","\n\n"],["body","\n"],["body","方法名清晰易懂，以让调用了这个 API 的代码易于阅读。"],["body","\n"],["body","\n"],["body","\n"],["body","有规律、可猜测的方法名在使用 API 时也很有用，可以减少阅读文档的需求。"],["body","\n"],["body","\n"],["body","\n"],["body","每个 API 都有至少要有文档和一小段示例代码。"],["body","\n"],["body","\n"],["body","\n"],["body","用户几乎不需要编写样板代码（boilerplate code）来使用这个 API，因为"],["body","\n\n"],["body","它广泛接受各种输入类型（当然类型转换是显式的）"],["body","\n"],["body","并且也有足以应付大部分常用情况的一键 API"],["body","\n\n"],["body","\n"],["body","\n"],["body","充分利用类型来防止逻辑错误，但不会太妨碍使用。"],["body","\n"],["body","\n"],["body","\n"],["body","返回有意义的错误，并且在文档中注明会导致 panic 的情况。"],["body","\n"],["body","\n\n"],["headingLink","技术"],["heading","技术"],["body","\n"],["body","\n"],["body","有一些 Rust RFC 描述了标准库的命名方案。你也应该遵循它们，以让用户能迅速上手使用你的库。"],["body","\n"],["body","\n\n"],["body","\n"],["body","RFC 199 解释说应该使用 mut、move 或 ref 作为后缀，来根据参数的可变性区分方法。"],["body","\n"],["body","\n"],["body","\n"],["body","RFC 344 定义了一些有意思的约定，比如："],["body","\n\n"],["body","如何在方法名称中引用类型名称（如 &mut [T] 变成 mut_slice、*mut T 变成 mut ptr），"],["body","\n"],["body","如何命名返回迭代器的方法，"],["body","\n"],["body","getter 方法应该被命名为 field_name 而 setter 方法应该被命名为 set_field_name，"],["body","\n"],["body","如何命名 trait：“优先选择（及物）动词、名词，然后是形容词；避免语法后缀（如 able）”，而且“如果这个 trait 只有一个主要方法，可以考虑用方法名称来命名 trait 本身”，"],["body","\n\n"],["body","\n"],["body","\n"],["body","RFC 430 描述了一些通用的大小写约定（总结：CamelCase 用于类型级别，snake_case 用于变量级别）。"],["body","\n"],["body","\n"],["body","\n"],["body","RFC 445 希望你为扩展 trait（extension trait）添加 Ext 后缀。"],["body","\n"],["body","\n\n"],["body","除了 RFC 199 和 RFC 344 （见上）规定的以外，还有一些其他的关于如何选择方法名称的约定，目前还没有在 RFC 中提及。这些约定大部分都在旧的 Rust 风格指南和 @llogiq 的文章 Rustic Bits 以及 clippy 的 wrong_self_convention 检测项中提到了。这里总结一下。"],["body","\n"],["body","方法名称"],["body","参数"],["body","备注"],["body","举例"],["body","\n"],["body","new"],["body","无 self，通常 >= 1 1"],["body","构造器，另参见 Default"],["body","Box::new、std::net::Ipv4Addr::new"],["body","\n"],["body","with_..."],["body","无 self，>= 1"],["body","其他构造器"],["body","Vec::with_capacity、regex::Regex::with_size_limit"],["body","\n"],["body","from_..."],["body","1"],["body","参见转换 trait（conversion traits）"],["body","String::from_utf8_lossy"],["body","\n"],["body","as_..."],["body","&self"],["body","无开销的转换，返回数据的一个视图（view）"],["body","str::as_bytes、uuid::Uuid::as_bytes"],["body","\n"],["body","to_..."],["body","&self"],["body","昂贵的转换"],["body","str::to_string、std::path::Path::to_str"],["body","\n"],["body","into_..."],["body","self（消耗）"],["body","可能昂贵的转换，参见 转换 trait（conversion traits）"],["body","std::fs::File::into_raw_fd"],["body","\n"],["body","is_..."],["body","&self（或无）"],["body","期望返回 bool"],["body","slice::is_empty、Result::is_ok、std::path::Path::is_file"],["body","\n"],["body","has_..."],["body","&self （或无）"],["body","期望返回 bool"],["body","regex_syntax::Expr::has_bytes"],["body","\n\n\n"],["headingLink","文档测试"],["heading","文档测试"],["body","\n"],["body","编写带有示例代码的文档可以展示 API 的用法而且还能获得自动测试\n详见第一版 TRPL（The Rust Programming Language）的[文档](详见第一版 TRPL（The Rust Programming Language）的文档一节。)一节。"],["body","\n"],["body","#![allow(unused)]\nfn main() {\n/// 使用魔法操作数字\n///\n/// # 示例\n///\n/// ```rust\n/// assert_eq!(min( 0,   14),    0);\n/// assert_eq!(min( 0, -127), -127);\n/// assert_eq!(min(42,  666),   42);\n/// ```(由于 hexo markdown 渲染辣鸡，此处加点文字避免被渲染为单独代码块）\nfn min(lhs: i32, rhs: i32) -> i32 {\n\tif lhs < rhs { lhs } else { rhs }\n}\n\n}"],["body","\n"],["body","你还可以使用 #![deny(missing_docs)] 来强制保证每个公开 API 都有文档。你可能也会对我的这篇提出了 Rust 文档格式化约定的文章感兴趣。"],["body","\n"],["headingLink","不要在-api-中使用-字符串类型"],["heading","不要在 API 中使用 “字符串类型”"],["body","\n"],["body","\n"],["body","尽量使用枚举"],["body","\n"],["body","\n"],["body","enum Color { Red, Green, Blue, LightGoldenRodYellow }\n\nfn color_me(input: &str, color: Color) { /* ... */ }\n\nfn main() {\n    color_me(\"surprised\", Color::Blue);\n}"],["body","\n"],["headingLink","全是常量的模块"],["heading","全是常量的模块"],["body","\n"],["body","或者，如果你想表达更复杂的值的话，则可以定义一个新的 struct，然后定义一堆公共常量。然后把这些常量放到模块中，用户就可以使用与 enum 类似的语法来访问它们了。"],["body","\n"],["body","pub mod output_options {\n    pub struct OutputOptions { /* ... */ }\n    \n    impl OutputOptions { fn new(/* ... */) -> OutputOptions { /* ... */ } }\n    \n    pub const DEFAULT: OutputOptions = OutputOptions { /* ... */ };\n    pub const SLIM: OutputOptions = OutputOptions { /* ... */ };\n    pub const PRETTY: OutputOptions = OutputOptions { /* ... */ };\n}\n\nfn output(f: &Foo, opts: OutputOptions) { /* ... */ }\n\nfn main() {\n    let foo = Foo::new();\n    \n    output(foo, output_options::PRETTY);\n}"],["body","\n"],["headingLink","使用-fromstr-来解析字符串"],["heading","使用 FromStr 来解析字符串"],["body","\n"],["body","在某些情况下，你的用户确实不得不使用字符串，比如：从环境变量中读取或者读取他们的用户的输入作为参数——也就是说，他们没办法在代码中编写（静态）字符串传递给你的 API（这个也是我们尝试阻止的）。这种情况下就需要使用 FromStr triat 了，它抽象了 “解析字符串到 Rust 数据类型” 的行为。"],["body","\n"],["body","// 选择 A: 你来解析\nfn output_a(f: &Foo, color: &str) -> Result<Bar, ParseError> {\n    // 这里使用解析后的类型遮蔽掉了原来的 `color`\n    let color: Color = try!(color.parse());\n\n    f.to_bar(&color)\n}\n\n// 选择 B: 用户来解析\nfn output_b(f: &Foo, color: &Color) -> Bar {\n    f.to_bar(color)\n}\n\nfn main() {\n    let foo = Foo::new();\n\n    // 选择 A: 你来解析，用户来处理 API 错误\n    output_a(foo, \"Green\").expect(\"Error :(\");\n\n    // 选择 B: 用户传入有效类型，所以不需要处理错误\n    output_b(foo, Color::Green);\n\n    // 选择 B: 用户使用字符串，需要自己解析并处理错误\n    output_b(foo, \"Green\".parse().except(\"Parse error!\"));\n}"],["body","\n"],["headingLink","错误处理"],["heading","错误处理"],["body","\n"],["body","TRPL 中对于错误处理有一章写得很不错。"],["body","\n"],["body","也有一些 crate 可以用来减少编写良好错误类型所需的样板代码，比如 quick-error 和 error-chain。"],["body","\n"],["headingLink","公共类型别名"],["heading","公共类型别名"],["body","\n"],["body","如果你的内部代码常常使用某个参数相同的泛型类型，此时可以使用类型别名。如果你想把这些类型公开给你的用户，你也应该把这些别名同样公开给用户（当然记得文档）。"],["body","\n"],["body","一个常见情况是 E 为固定值的 Result<T, E> 类型。比如 std::io::Result<T> 是 Result<T, std::io::Error> 的别名，std::fmt::Result 是 Result<(), std::fmt::Error> 的别名，serde_json::error::Result<T> 是 Result<T, serde_json::error::Error> 的别名。"],["body","\n"],["headingLink","使用转换-trait"],["heading","使用转换 trait"],["body","\n"],["body","一个良好实践是永远也不要在参数中使用 &String 和 &Vec，取而代之使用 &str 和 &[T]，后者允许传入更多类型。（基本上是所有能 deref 到字符串或切片（slice）的类型）"],["body","\n"],["body","与其使用具体类型作为参数，不如使用拥有严格约束的泛型。这样做的缺点是文档的可读性会降低，因为它充满了大量复杂的泛型约束！"],["body","\n"],["body","std::convert 为提供了一些方便的工具："],["body","\n\n"],["body","AsMut：一个便宜的（低消耗）、可变引用到可变引用的转换。"],["body","\n"],["body","AsRef：一个便宜的，引用到引用的转换。"],["body","\n"],["body","From： 通过转换来构造自身"],["body","\n"],["body","Into：一个消耗会自身的转换，可能会比较昂贵（高开销）。"],["body","\n"],["body","TryFrom：尝试通过转换来构造自身"],["body","\n"],["body","TryInto：尝试消耗自身转的换，可能会比较昂贵。"],["body","\n\n"],["body","你可能也会喜欢这篇关于如何在 Rust 中进行方便地道的转换的文章."],["body","\n"],["headingLink","cow"],["heading","Cow"],["body","\n"],["body","如果你需要处理很多不确定是否需要进行分配（allocate）的东西，你应该使用Cow<'a, B>，它可以让你抽象借用和拥有所有权的数据。"],["body","\n"],["body","fn foo(p: PathBuf)"],["body","fn foo<P: Into>(p: P)"],["body","\n"],["body","用户需要把数据转为 PathBuf"],["body","由库来调用 .into() 进行转换"],["body","\n"],["body","用户进行分配"],["body","看不出：库可能进行分配"],["body","\n"],["body","用户需要关心 PathBuf 是什么、如何创建"],["body","用户可以传递 String 、OsString，或者 PathBuf 都行"],["body","\n\n\n"],["headingLink","intooption_"],["heading","Into<Option<_>>"],["body","\n"],["body","这个 PR 添加了一个 impl<T> From<T> for Option<T>，在 Rust 1.12 中正式实装。寥寥几行代码赋予了你编写可以被直接调用而不需要写一大堆 Some(...) 的 API 的能力。"],["body","\n"],["body","之前"],["body","\n"],["body","// 对于 API 作者来说很容易编写，文档也很易于阅读\nfn foo(lorem: &str, ipsum: Option<i32>, dolor: Option<i32>, sit: Option<i32>) {\n    println!(\"{}\", lorem);\n}\n\nfn main() {\n    foo(\"bar\", None, None, None);               // 看起来有些奇怪\n    foo(\"bar\", Some(42), None, None);           // 还好\n    foo(\"bar\", Some(42), Some(1337), Some(-1)); // 停！太多…… Some 了……\n}"],["body","\n"],["body","现在"],["body","\n"],["body","// 对于 API 作者来说得多打点字\n// （而且遗憾的是，每个参数都需要被单独指定——否则 Rust 只会根据第一个参数推断类型。\n// 这种写法阅读来不是很方便，文档可能也没那么好看）\nfn foo<I, D, S>(lorem: &str, ipsum: I, dolor: D, sit: S) where\n    I: Into<Option<i32>>,\n    D: Into<Option<i32>>,\n    S: Into<Option<i32>>,\n{\n    println!(\"{}\", lorem);\n}\n\nfn main() {\n    foo(\"bar\", None, None, None); // 仍然奇怪\n    foo(\"bar\", 42, None, None);   // 不错\n    foo(\"bar\", 42, 1337, -1);     // Wow，棒棒！请务必这样编写 API！\n}"],["body","\n"],["headingLink","关于可能较长的编译时间的说明"],["heading","关于可能较长的编译时间的说明"],["body","\n"],["body","如果你有："],["body","\n\n"],["body","很多类型参数（比如用于转换 trait）"],["body","\n"],["body","用在一个很复杂/大型的函数上面"],["body","\n"],["body","这个函数用得还很多"],["body","\n\n"],["body","然后 rustc 将会根据不同参数编译这个函数的大量排列组合（泛型函数的单态化），这会导致很长的编译时间。"],["body","\n"],["body","bluss 在 Reddit 上提到可以使用 “去泛型” 技术来规避这个问题：你的（公共）泛型函数只简单地调用另一个（私有）非泛型函数，这样这个私有函数就只会被编译一次。"],["body","\n"],["body","bluss 给的例子是 std::fs::OpenOptions::open 的实现（来自 Rust 1.12 的源码）和 image crate 的 这个PR，它将 open 函数修改成了这个样子："],["body","\n"],["body","#![allow(unused)]\nfn main() {\npub fn open<P>(path: P) -> ImageResult<DynamicImage> where P: AsRef<Path> {\n    // 简单的包装函数，在调用 open_impl 之前去掉泛型\n    open_impl(path.as_ref())\n}\n}"],["body","\n"],["headingLink","惰性"],["heading","惰性"],["body","\n"],["body","尽管 Rust 不能像 Haskell 一样对表达式进行惰性计算，但是你仍然可以使用一些技术来优雅地省略不必要的计算和分配。"],["body","\n"],["headingLink","使用迭代器iterator"],["heading","使用迭代器（Iterator）"],["body","\n"],["body","标准库中最绝妙的构造之一是 Iterator，它是一个 trait，允许类似生成器的值迭代，而你只需要为此实现一个 next 方法2。Rust 的迭代器是惰性的，你需要显式地调用一个消费函数才会开始迭代。只是编写 \"hello\".chars().filter(char::is_white_space) 不会对数据进行任何操作，直到你对它调用像 .collect::() 这样的方法。"],["body","\n"],["headingLink","迭代器作为参数"],["heading","迭代器作为参数"],["body","\n"],["body","使用迭代器作为输入可能会让你的 API 更加难以阅读（T: Iterator<Item=Thingy> vs &[Thingy]），但是可以让用户避免内存分配。"],["body","\n"],["body","不过，事实上，你可能也并不想接受一个宽泛的 Iterator：而是使用 IntoIterator 。这样你就可以得到一个通过调用 .into_iter() 就能轻松转换为迭代器的类型。判断哪些类型实现了 IntoIterator 也很简单——就如文档中所说的："],["body","\n"],["headingLink","类似-iterator-的-trait"],["heading","类似 Iterator 的 trait"],["body","\n"],["body","futures::Stream：如 futures 教程所说，类似 Iterator::next 返回 OptionSelf::Item，Stream::poll 返回一个 OptionSelf::Item 的异步结果（或者返回一个错误）。"],["body","\n"],["headingLink","接受闭包"],["heading","接受闭包"],["body","\n"],["body","如果有一个可能比较昂贵的值（暂称为类型 Value），而且它并不会在所有的分支中都被使用到，这时可以考虑使用一个返回这个值的闭包（Fn() -> Value）。"],["body","\n"],["body","一个实际例子是 Result 中的 unwrap_or 和 unwrap_or_else："],["body","\n"],["body","#![allow(unused)]\nfn main() {\nlet res: Result<i32, &str> = Err(\"oh noes\");\nres.unwrap_or(42); // 立即返回 `42`\n\nlet res: Result<i32, &str> = Err(\"oh noes\");\nres.unwrap_or_else(|msg| msg.len() as i32); // 将会在需要的时候调用闭包计算\n}"],["body","\n"],["headingLink","关于惰性的小技巧"],["heading","关于惰性的小技巧"],["body","\n"],["body","让 Deref 完成所有的工作：为你的类型实现 Deref，让它来完成实际的计算逻辑。这个crate lazy实现了一个能为你完成这件事情的宏（不过需要 unstable 特性）。"],["body","\n"],["headingLink","提升易用性的-trait"],["heading","提升易用性的 trait"],["body","\n"],["body","这里列举了一些你应该试着为你的类型实现的 trait，它们可以让你的类型更加易用："],["body","\n\n"],["body","实现或者派生（derive）“常用” 的 trait 比如 Debug、Hash、PartialEq、PartialOrd、Eq、Ord"],["body","\n"],["body","实现或者派生Default，而不是编写一个不接受任何参数的 new 方法。"],["body","\n"],["body","如果你正在为一个类型实现一个可以将它的数据作为 Iterator 返回的方法，你也应该考虑为这个类型实现IntoIterator。（仅有一种迭代数据的主要方式时，才建议这么做。 另请参见上面有关迭代器的部分。）"],["body","\n"],["body","如果你的自定义数据类型和 std 中的基本类型 T 很相似，请考虑为它实现 Deref<Target=T>，不过请不要滥用——Deref 不是用来模拟继承的！"],["body","\n"],["body","不要编写一个接受字符串作为参数然后返回一个实例的构造方法，请使用FromStr"],["body","\n\n"],["headingLink","为输入参数实现自定义-trait"],["heading","为输入参数实现自定义 trait"],["body","\n"],["body","例：str::find\nstr::find<P: Pattern>(p: P) 接受一个Pattern作为输入，char、str、FnMut(char) -> bool 等类型都实现了这个 trait"],["body","\n"],["body","#![allow(unused)]\nfn main() {\n\"Lorem ipsum\".find('L');\n\"Lorem ipsum\".find(\"ipsum\");\n\"Lorem ipsum\".find(char::is_whitespace);\n}"],["body","\n"],["headingLink","扩展-trait"],["heading","扩展 trait"],["body","\n"],["body","尽量使用标准库中定义的类型和 trait，因为大部分 Rust 程序员都了解它们，它们经过了充分的测试并且有良好的文档。不过，由于 Rust 标准库倾向于提供有语义含义的类型3，这些类型包含的方法可能对你的 API 来说还不够。幸运的是，Rust 的 “孤儿规则（orphan rules）” 赋予了为任何类型实现任何 trait 的能力——前提是类型和 trait 中的任意一个是在当前 crate 中定义的。"],["body","\n"],["headingLink","装饰结果"],["heading","装饰结果"],["body","\n"],["body","如 Florian 在 “Decorating Results” 中写到的，你可以使用这种方法来编写并实现 trait 来为内置类型如 Result 实现自己的方法。举例："],["body","\n"],["body","pub trait GrandResultExt {\n    fn party(self) -> Self;\n}\n\nimpl GrandResultExt for Result<String, Box<Error>> {\n    fn party(self) -> Result<String, Box<Error>> {\n        if self.is_ok() {\n          println!(\"Wooohoo! 🎉\");\n        }\n        self\n    }\n}\n\n// 用户代码\nfn main() {\n    let fortune = library_function()\n        .method_returning_result()\n        .party()\n        .unwrap_or(\"Out of luck.\".to_string());\n}"],["body","\n"],["body","Florian 在 lazers 的真实代码中使用了这样的模式装饰了 BoxFuture（来自 futures crate）以让代码更加可读："],["body","\n"],["body","#![allow(unused)]\nfn main() {\nlet my_database = client\n    .find_database(\"might_not_exist\")\n    .or_create();\n\n}"],["body","\n"],["headingLink","扩展-trait-1"],["heading","扩展 trait"],["body","\n"],["body","到目前为止，我们已经通过定义并实现自己的 trait 扩展了类型上的可用方法。但你还可以定义扩展其他 trait 的 trait（trait MyTrait: BufRead + Debug {}）。最突出的例子是 itertools crate，它为 std 的迭代器添加了一大堆方法。"],["body","\n"],["headingLink","建造者模式"],["heading","建造者模式"],["body","\n"],["body","通过将一堆小方法串联在一起你可以让复杂的 API 更加易于调用。这个和 Session Type 非常搭（稍后会提到）。derive_builder crate 可以用来为自定义的 struct 自动生成（简单的）Builder"],["body","\n"],["body","例： std::fs::OpenOptions"],["body","\n"],["body","#![allow(unused)]\nfn main() {\nuse std::fs::OpenOptions;\nlet file = OpenOptions::new().read(true).write(true).open(\"foo.txt\");\n}"],["body","\n"],["headingLink","session-type"],["heading","Session Type"],["body","\n"],["body","你可以在类型系统中编码一个状态机。"],["body","\n\n"],["body","每个状态都有不同的类型。"],["body","\n"],["body","每个状态类型都实现了不同的方法。"],["body","\n"],["body","一些方法会消耗这个状态类型（获取所有权）并且返回另一个状态类型。"],["body","\n\n"],["body","这个技巧在 Rust 中工作地非常良好，因为你的方法可以将数据移动到新的类型中，并且保证在之后你就无法访问旧状态了。"],["body","\n"],["body","这是一个关于邮寄包裹的小例子："],["body","\n"],["body","#![allow(unused)]\nfn main() {\nlet p: OpenPackage = Package::new();\nlet p: OpenPackage = package.insert([stuff, padding, padding]);\n\nlet p: ClosedPackage = package.seal_up();\n\n// let p: OpenPackage = package.insert([more_stuff]);\n//~^ ERROR: No method named `insert` on `ClosedPackage`\n\nlet p: DeliveryTracking = package.send(address, postage);\n\n}"],["body","\n"],["body","一个很好的实际例子是 /u/ssokolow 在 /r/rust 的这个帖子 中给出的："],["body","\n"],["body","Hyper 使用这个方法来在编译时保证，你不可能做出诸如 “在请求/响应主体已经开始后又来设置 HTTP 头” 这种经常在 PHP 网站上看到的事。（编译器可以捕获这个错误，因为在该状态下的连接上没有 “set header” 方法，并且由于过时引用会失效，所以被引用的一定是正确的状态。）"],["body","\n"],["body","hyper::server 文档中更详细地解释了这是如何实现的。另一个有趣的想法可以在 lazers-replicator crate 中找到：它使用 std::convert::From来在状态中转换。"],["body","\n"],["headingLink","更多信息"],["heading","更多信息："],["body","\n\n"],["body","文章 “Beyond Memory Safety With Types” 描述了这项技术如何被用来实现一个漂亮并且类型安全的 IMAP 协议。"],["body","\n"],["body","论文 “Session types for Rust” (PDF)，作者 Thomas Bracht Laumann Jespersen, Philip Munksgaard, and Ken Friis Larsen (2015). DOI"],["body","\n"],["body","Andrew Hobden 的帖子 “Pretty State Machine Patterns in Rust” 展示了一些在 Rust 的类型系统中实现状态机的方法。"],["body","\n\n"],["headingLink","使用生命周期"],["heading","使用生命周期"],["body","\n"],["body","在静态类型语言中，为你的 API 指定类型和 trait 约束是必不可少的，如前文所说的，它们可以帮助防止逻辑错误。此外，Rust 的类型系统还提供了另一个维度：你还可以描述你的数据的生命周期（并编写生命周期约束）。"],["body","\n"],["body","这可以让你（作为开发者）更轻松地对待借用的数据（而不是使用开销更大的拥有所有权的数据）。尽可能地使用引用在 Rust 中是一个良好实践，因为高性能和 “零分配” 的库也是语言的卖点之一。"],["body","\n"],["body","不过，你应该尽可能为此编写良好的文档，因为理解生命周期和处理引用对于你的库用户来说可能是个挑战，尤其是对于 Rust 新手来说。"],["body","\n"],["body","由于某些原因（可能是比较简短），很多生命周期都被命名为 'a、'b或类似的无意义字符，不过如果你了解引用的生命周期对应的资源的话，你可以找到更好的名称。举例来说，如果你将文件读入到内存并且处理对这块内存的引用，可以将它的生命周期命名为 'file，或者如果你在处理一个 TCP 请求并且解析它的数据，则可以将生命周期命名为 'req。"],["body","\n"],["headingLink","将析构代码放在-drop-中"],["heading","将析构代码放在 drop 中"],["body","\n"],["body","Rust 的所有权规则不仅能用于内存：如果你的数据类型表示着外部资源（比如 TCP 连接），则在超出作用域时，你可以使用 Drop trait 关闭、释放或清理该资源。你可以像在其他语言中使用析构函数（或者 try ... catch ... finally）一样使用它。\n实际的例子有："],["body","\n\n"],["body","引用计数类型 Rc 和 Arc 使用 Drop 来减少引用计数（并且在计数归零的时候释放拥有的数据）。"],["body","\n"],["body","MutexGuard 使用 Drop 来释放它对 Mutex 的锁。"],["body","\n"],["body","diesel crate 用 Drop 来关闭数据库连接（比如 SQLite）。"],["body","\n\n"],["headingLink","案例学习"],["heading","案例学习"],["body","\n"],["body","在 API 设计中使用了一些不错的技巧的 Rust 库："],["body","\n\n"],["body","hyper：Session Type（见上文）"],["body","\n"],["body","diesel：使用拥有复杂的关联类型的 trait 将 SQL 查询编码为类型"],["body","\n"],["body","futures：高度抽象并且拥有良好文档的 crate"],["body","\n\n"],["headingLink","其他设计模式"],["heading","其他设计模式"],["body","\n"],["body","我在这里介绍的是编写接口的设计模式，即面向用户的 API。虽然我认为其中的一些模式只适用于编写库，但许多模式也同样适用于编写通用应用程序的代码。"],["body","\n"],["body","你可以在 Rust Design Patterns 仓库中找到更多信息"],["body","\n"],["body","Update 2017-04-27：这篇文章发布以来，Rust 库团队的 @brson 已经发布了一个相当全面的 Rust API Guidelines 文档，囊括了我的所有建议，并且内容更全面。"],["body","\n4\n"],["body","在其他强类型语言中有一句口号 “making illegal states unrepresentable”。我第一次听说这个是在人们谈论 Haskell 的时候，这也是 F# for fun and profit 的这篇文章的标题，和 Richard Feldman 在 elm-conf 2016 上的这篇演讲。"],["body","\n\n"],["body","本文链接"],["body","\n\n\n\n"],["body","\n\n                    "],["body","\n\n                    \n                \n            \n\n            \n\n        \n\n\n\n\n        \n\n\n\n        \n        \n        \n\n        \n\n\n    \n    \n"]],[["_relative_fp","3.rust/结构体.html"],["title","结构体 - 各项编程语言"],["body","\n    \n        \n        \n\n        \n        \n\n        \n        \n\n        \n        \n\n        \n\n        \n\n            \n                                \n                \n                    \n                        "],["body","\n                            \n                        "],["body","\n                        "],["body","\n                            \n                        "],["body","\n                        \n                            "],["body","Light"],["body","\n                            "],["body","Rust"],["body","\n                            "],["body","Coal"],["body","\n                            "],["body","Navy"],["body","\n                            "],["body","Ayu"],["body","\n                        \n                    \n\n                    "],["heading","各项编程语言"],["body","\n\n                    \n\n                    \n                \n\n\n                \n                \n\n                \n                    "],["body","\n                        \n\n"],["body","\n"],["body","\n\n"],["headingLink","结构体"],["heading","结构体"],["body","\n"],["headingLink","定义"],["heading","定义"],["body","\n"],["body","fn main() {\nstruct User {\n    username: String,\n    email: String,\n    sign_in_count: u64,\n    active: bool,\n}\n}"],["body","\n"],["headingLink","使用"],["heading","使用"],["body","\n"],["body","#![allow(unused)]\nfn main() {\nlet user1 = User {\n    email: String::from(\"someone@example.com\"),\n    username: String::from(\"someusername123\"),\n    active: true,\n    sign_in_count: 1,\n};\n}"],["body","\n"],["headingLink","赋值"],["heading","赋值"],["body","\n"],["body","#![allow(unused)]\nfn main() {\nlet mut user1 = User {\n    email: String::from(\"someone@example.com\"),\n    username: String::from(\"someusername123\"),\n    active: true,\n    sign_in_count: 1,\n};\nuser1.email = String::from(\"anotheremail@example.com\");\n}"],["body","\n"],["headingLink","字段同名时的简化写法"],["heading","字段同名时的简化写法"],["body","\n"],["body","#![allow(unused)]\nfn main() {\nfn build_user(email: String, username: String) -> User {\n    User {\n        email,\n        username,\n        active: true,\n        sign_in_count: 1,\n    }\n}\n}"],["body","\n"],["headingLink","使用结构体更新语法创建示例对象"],["heading","使用结构体更新语法创建示例对象"],["body","\n"],["body","#![allow(unused)]\nfn main() {\nlet user2 = User {\n    email: String::from(\"another@example.com\"),\n    username: String::from(\"anotherusername567\"),\n    active: user1.active,\n    sign_in_count: user1.sign_in_count,\n};\n}"],["body","\n"],["headingLink","使用没有命名的元组结构体创建不同的类型"],["heading","使用没有命名的元组结构体创建不同的类型"],["body","\n"],["body","\n#![allow(unused)]\nfn main() {\nstruct Color(i32, i32, i32);\nstruct Point(i32, i32, i32);\n\nlet black = Color(0, 0, 0);\nlet origin = Point(0, 0, 0);\n}"],["body","\n"],["headingLink","没有任何字段的类单元结构体"],["heading","没有任何字段的类单元结构体"],["body","\n"],["body","我们也可以定义一个没有任何字段的结构体！它们被称为 类单元结构体（unit-like structs）因为它们类似于 ()，即 unit 类型。类单元结构体常常在你想要在某个类型上实现 trait 但不需要在类型中存储数据的时候发挥作用"],["body","\n"],["body","#![allow(unused)]\nfn main() {\n    struct A();\n    let a  =A();\n}"],["body","\n"],["headingLink","结构体的所有权"],["heading","结构体的所有权"],["body","\n\n"],["body","\n"],["body","一般情况  结构体拥有其 子字段的所有权, "],["body","\n"],["body","\n"],["body","\n"],["body","可以使结构体存储被其他对象拥有的数据的引用，不过这么做的话需要用上 生命周期（lifetimes），"],["body","\n"],["body","\n"],["body","\n"],["body","生命周期确保结构体引用的数据有效性跟结构体本身保持一致"],["body","\n"],["body","\n\n"],["headingLink","定义方法"],["heading","定义方法"],["body","\n"],["body","#[derive(Debug)]\nstruct Rectangle {\n    width: u32,\n    height: u32,\n}\nimpl Rectangle {\n    fn area(&self) -> u32 {\n        self.width * self.height\n    }\n}\nfn main() {\n    let rect1 = Rectangle { width: 30, height: 50 };\n    println!(\n        \"The area of the rectangle is {} square pixels.\",\n        rect1.area()\n    );\n}"],["body","\n\n"],["body","在 area 的签名中，使用 &self 来替代 rectangle: &Rectangle"],["body","\n\n"],["headingLink","枚举"],["heading","枚举"],["body","\n"],["headingLink","使用枚举"],["heading","使用枚举"],["body","\n"],["body","定义"],["body","\n"],["body","#![allow(unused)]\nfn main() {\nenum IpAddrKind {\n    V4,\n    V6,\n}\n}"],["body","\n"],["body","取值"],["body","\n"],["body","#![allow(unused)]\nfn main() {\nlet four = IpAddrKind::V4;\nlet six = IpAddrKind::V6;\n}"],["body","\n"],["body","#![allow(unused)]\nfn main() {\nfn route(ip_type: IpAddrKind) { }\nroute(IpAddrKind::V4);\nroute(IpAddrKind::V6);\n}"],["body","\n"],["body","每个成员可以处理不同类型和数量的数据"],["body","\n"],["body","#![allow(unused)]\nfn main() {\nenum IpAddr {\n    V4(u8, u8, u8, u8),\n    V6(String),\n}\n\nlet home = IpAddr::V4(127, 0, 0, 1);\n\nlet loopback = IpAddr::V6(String::from(\"::1\"));\n}"],["body","\n"],["body","示例"],["body","\n"],["body","#![allow(unused)]\nfn main() {\nenum Message {\n    Quit,\n    Move { x: i32, y: i32 }, //匿名结构体\n    Write(String),//string类型\n    ChangeColor(i32, i32, i32), //元组\n}\n}"],["body","\n"],["body","使用 impl 来为结构体定义方法"],["body","\n"],["headingLink","option枚举"],["heading","Option枚举"],["body","\n"],["body","#![allow(unused)]\nfn main() {\nenum Option<T> {\n    Some(T),\n    None,\n}\n}"],["body","\n"],["body","Option<T> 枚举是如此有用以至于它甚至被包含在了 prelude 之中，你不需要将其显式引入作用域"],["body","\n"],["body","#![allow(unused)]\nfn main() {\n//直接使用\nSome()\nNone\nlet y: Option<i8> = Some(5);\n}"],["body","\n"],["headingLink","match控制流运算符"],["heading","Match控制流运算符"],["body","\n\n"],["body","它允许我们将一个值与一系列的模式相比较，并根据相匹配的模式执行相应代码"],["body","\n"],["body","模式可由字面值、变量、通配符和许多其他内容构成"],["body","\n\n"],["body","#![allow(unused)]\nfn main() {\n//match匹配枚举\nenum Coin {\n    Penny,\n    Nickel,\n    Dime,\n    Quarter,\n}\n\nfn value_in_cents(coin: Coin) -> u8 {\n    match coin {\n        Coin::Penny => 1,\n        Coin::Nickel => 5,\n        Coin::Dime => 10,\n        Coin::Quarter => 25,\n    }\n}\n}"],["body","\n"],["body","枚举的变量获取"],["body","\n"],["body","#![allow(unused)]\n\nfn main() {\nfn plus_one(x: Option<i32>) -> Option<i32> {\n    match x {\n        None => None,\n        Some(i) => Some(i + 1),\n    }\n}\n\nlet five = Some(5);\nlet six = plus_one(five);\nlet none = plus_one(None);\n}"],["body","\n"],["body","枚举的匹配时穷尽的 通过指定默认块"],["body","\n"],["body","\n#![allow(unused)]\nfn main() {\nlet some_u8_value = 0u8;\nmatch some_u8_value {\n    1 => println!(\"one\"),\n    3 => println!(\"three\"),\n    5 => println!(\"five\"),\n    7 => println!(\"seven\"),\n    _ => (),\n}\n}"],["body","\n"],["headingLink","if-let-简洁控制流"],["heading","if let 简洁控制流"],["body","\n"],["body","#![allow(unused)]\n\nfn main() {\nlet mut count = 0;\nif let Coin::Quarter(state) = coin {\n    println!(\"State quarter from {:?}!\", state);\n} else {\n    count += 1;\n}\n\nif coin\n}"],["body","\n\n\n\n"],["body","\n\n                    "],["body","\n\n                    \n                \n            \n\n            \n\n        \n\n\n\n\n        \n\n\n\n        \n        \n        \n\n        \n\n\n    \n    \n"]],[["_relative_fp","3.rust/newType模式.html"],["title","newType模式 - 各项编程语言"],["body","\n    \n        \n        \n\n        \n        \n\n        \n        \n\n        \n        \n\n        \n\n        \n\n            \n                                \n                \n                    \n                        "],["body","\n                            \n                        "],["body","\n                        "],["body","\n                            \n                        "],["body","\n                        \n                            "],["body","Light"],["body","\n                            "],["body","Rust"],["body","\n                            "],["body","Coal"],["body","\n                            "],["body","Navy"],["body","\n                            "],["body","Ayu"],["body","\n                        \n                    \n\n                    "],["heading","各项编程语言"],["body","\n\n                    \n\n                    \n                \n\n\n                \n                \n\n                \n                    "],["body","\n                        \n\n"],["body","\n"],["body","\n\n"],["headingLink","为了类型安全和抽象而使用-newtype-模式"],["heading","为了类型安全和抽象而使用 newtype 模式"],["body","\n"],["headingLink","newtype的功能"],["heading","newType的功能"],["body","\n\n"],["body","\n"],["body","使用newType替代 基本类型 可以确保某值不被混淆或者用来表示一个值的单元"],["body","\n"],["body","\n"],["body","\n"],["body","抽象掉一些类型的实现细节"],["body","\n\n"],["body","封装类型可以暴露出与直接使用其内部私有类型时所不同的公有 API，以便限制其功能。"],["body","\n"],["body","newtype 也可以隐藏其内部的泛型类型。"],["body","\n\n"],["body","例如，可以提供一个封装了 HashMap<i32, String> 的 People 类型，用来储存人名以及相应的 ID。使用 People 的代码只需与提供的公有 API 交互即可，比如向 People 集合增加名字字符串的方法，这样这些代码就无需知道在内部我们将一个 i32 ID 赋予了这个名字了。newtype 模式是一种实现第十七章 “封装隐藏了实现细节” 部分所讨论的隐藏实现细节的封装的轻量级方法。"],["body","\n"],["body","\n\n"],["headingLink","类型别名"],["heading","类型别名"],["body","\n"],["headingLink","什么是类型别名"],["heading","什么是类型别名"],["body","\n"],["body","连同 newtype 模式，Rust 还提供了声明 类型别名（type alias）的能力，使用 type 关键字来给予现有类型另一个名字。例如，可以像这样创建 i32 的别名 Kilometers："],["body","\n"],["body","#![allow(unused)]\nfn main() {\ntype Kilometers = i32;\n}"],["body","\n"],["body","这意味着 Kilometers 是 i32 的 同义词（synonym）；不同于示例 19-23 中创建的 Millimeters 和 Meters 类型。Kilometers 不是一个新的、单独的类型。Kilometers 类型的值将被完全当作 i32 类型值来对待："],["body","\n"],["headingLink","类型别名的使用"],["heading","类型别名的使用"],["body","\n"],["body","类型别名的主要用途是减少重复。例如，可能会有这样很长的类型："],["body","\n"],["body","#![allow(unused)]\nfn main() {\nlet f: Box<dyn Fn() + Send + 'static> = Box::new(|| println!(\"hi\"));\n\nfn takes_long_type(f: Box<dyn Fn() + Send + 'static>) {\n    // --snip--\n}\n\nfn returns_long_type() -> Box<dyn Fn() + Send + 'static> {\n    // --snip--\n}\n\n//使用类型别名\ntype Thunk = Box<dyn Fn() + Send + 'static>;\n\nlet f: Thunk = Box::new(|| println!(\"hi\"));\n\nfn takes_long_type(f: Thunk) {\n    // --snip--\n}\n\nfn returns_long_type() -> Thunk {\n    // --snip--\n}\n}"],["body","\n"],["headingLink","泛型化类型别名"],["heading","泛型化类型别名"],["body","\n"],["body","#![allow(unused)]\nfn main() {\ntype Result<T> = std::result::Result<T, std::io::Error>;\n}"],["body","\n"],["headingLink","从不返回的-never-type"],["heading","从不返回的 never type"],["body","\n\n"],["body","\n"],["body","Rust 有一个叫做 ! 的特殊类型。在类型理论术语中，它被称为 empty type，因为它没有值。我们更倾向于称之为 never type。"],["body","\n"],["body","\n"],["body","\n"],["body","从不返回的函数被称为 发散函数（diverging functions）"],["body","\n"],["body","\n\n"],["headingLink","continue返回-"],["heading","Continue返回 !"],["body","\n"],["body","#![allow(unused)]\nfn main() {\nlet guess: u32 = match guess.trim().parse() {\n    Ok(num) => num,\n    Err(_) => continue,\n};\n}"],["body","\n"],["headingLink","panic返回"],["heading","Panic返回!"],["body","\n"],["body","#![allow(unused)]\nfn main() {\nimpl<T> Option<T> {\n    pub fn unwrap(self) -> T {\n        match self {\n            Some(val) => val,\n            None => panic!(\"called `Option::unwrap()` on a `None` value\"),\n        }\n    }\n}\n}"],["body","\n"],["headingLink","loop返回"],["heading","Loop返回!"],["body","\n"],["body","#![allow(unused)]\nfn main() {\nprint!(\"forever \");\n\nloop {\n    print!(\"and ever \");\n}\n}"],["body","\n"],["headingLink","动态大小类型和-sized-trait"],["heading","动态大小类型和 Sized trait"],["body","\n"],["body","因为 Rust 需要知道例如应该为特定类型的值分配多少空间这样的信息其类型系统的一个特定的角落可能令人迷惑：这就是 动态大小类型（dynamically sized types）的概念。这有时被称为 “DST” 或 “unsized types”，这些类型允许我们处理只有在运行时才知道大小的类型。"],["body","\n"],["body","让我们深入研究一个贯穿本书都在使用的动态大小类型的细节：str。没错，不是 &str，而是 str 本身。str 是一个 DST；直到运行时我们都不知道字符串有多长。因为直到运行时都不能知道大其小，也就意味着不能创建 str 类型的变量，也不能获取 str 类型的参数。考虑一下这些代码，他们不能工作："],["body","\n"],["body","#![allow(unused)]\nfn main() {\nlet s1: str = \"Hello there!\";\nlet s2: str = \"How's it going?\";\n}"],["body","\n"],["body","Rust 需要知道应该为特定类型的值分配多少内存，同时所有同一类型的值必须使用相同数量的内存。如果允许编写这样的代码，也就意味着这两个 str 需要占用完全相同大小的空间，不过它们有着不同的长度。这也就是为什么不可能创建一个存放动态大小类型的变量的原因。"],["body","\n"],["body","那么该怎么办呢？你已经知道了这种问题的答案：s1 和 s2 的类型是 &str 而不是 str。如果你回想第四章 “字符串 slice” 部分，slice 数据结储存了开始位置和 slice 的长度。"],["body","\n"],["body","所以虽然 &T 是一个储存了 T 所在的内存位置的单个值，&str 则是 两个 值：str 的地址和其长度。这样，&str 就有了一个在编译时可以知道的大小：它是 usize 长度的两倍。也就是说，我们总是知道 &str 的大小，而无论其引用的字符串是多长。这里是 Rust 中动态大小类型的常规用法：他们有一些额外的元信息来储存动态信息的大小。这引出了动态大小类型的黄金规则：必须将动态大小类型的值置于某种指针之后。"],["body","\n"],["body","可以将 str 与所有类型的指针结合：比如 Box<str> 或 Rc<str>。事实上，之前我们已经见过了，不过是另一个动态大小类型：trait。每一个 trait 都是一个可以通过 trait 名称来引用的动态大小类型。在第十七章 “为使用不同类型的值而设计的 trait 对象” 部分，我们提到了为了将 trait 用于 trait 对象，必须将他们放入指针之后，比如 &dyn Trait 或 Box<dyn Trait>（Rc<dyn Trait> 也可以）。"],["body","\n"],["body","为了处理 DST，Rust 有一个特定的 trait 来决定一个类型的大小是否在编译时可知：这就是 Sized trait。这个 trait 自动为编译器在编译时就知道大小的类型实现。另外，Rust 隐式的为每一个泛型函数增加了 Sized bound。也就是说，对于如下泛型函数定义："],["body","\n"],["body","#![allow(unused)]\nfn main() {\nfn generic<T>(t: T) {\n    // --snip--\n}\n}"],["body","\n"],["body","实际上被当作如下处理："],["body","\n"],["body","#![allow(unused)]\nfn main() {\nfn generic<T: Sized>(t: T) {\n    // --snip--\n}\n}"],["body","\n"],["body","泛型函数默认只能用于在编译时已知大小的类型。然而可以使用如下特殊语法来放宽这个限制："],["body","\n"],["body","#![allow(unused)]\nfn main() {\nfn generic<T: ?Sized>(t: &T) {\n    // --snip--\n}\n}"],["body","\n"],["body","?Sized trait bound 与 Sized 相对；也就是说，它可以读作 “T 可能是也可能不是 Sized 的”。这个语法只能用于 Sized ，而不能用于其他 trait。"],["body","\n"],["body","另外注意我们将 t 参数的类型从 T 变为了 &T：因为其类型可能不是 Sized 的，所以需要将其置于某种指针之后。在这个例子中选择了引用。"],["body","\n"],["body","例如"],["body","\n"],["body","闭包的存储空间是动态的"],["body","\n"],["body","通过指定包装返回闭包"],["body","\n"],["body","#![allow(unused)]\nfn main() {\nfn returns_closure() -> Box<dyn Fn(i32) -> i32> {\n    Box::new(|x| x + 1)\n}\n}"],["body","\n\n\n\n"],["body","\n\n                    "],["body","\n\n                    \n                \n            \n\n            \n\n        \n\n\n\n\n        \n\n\n\n        \n        \n        \n\n        \n\n\n    \n    \n"]],[["_relative_fp","3.rust/依赖管理.html"],["title","依赖管理 - 各项编程语言"],["body","\n    \n        \n        \n\n        \n        \n\n        \n        \n\n        \n        \n\n        \n\n        \n\n            \n                                \n                \n                    \n                        "],["body","\n                            \n                        "],["body","\n                        "],["body","\n                            \n                        "],["body","\n                        \n                            "],["body","Light"],["body","\n                            "],["body","Rust"],["body","\n                            "],["body","Coal"],["body","\n                            "],["body","Navy"],["body","\n                            "],["body","Ayu"],["body","\n                        \n                    \n\n                    "],["heading","各项编程语言"],["body","\n\n                    \n\n                    \n                \n\n\n                \n                \n\n                \n                    "],["body","\n                        \n\n"],["body","\n"],["body","\n\n"],["headingLink","包和箱crate"],["heading","包和箱(crate)"],["body","\n\n"],["body","\n"],["body","crate 是一个二进制项或者库,例如某个第三方包"],["body","\n"],["body","\n"],["body","\n"],["body","crate root 是一个源文件，Rust 编译器以它为起始点,并构成你的 crate 的根模块"],["body","\n"],["body","\n"],["body","\n"],["body","包（package） 是提供一系列功能的一个或者多个 crate,整个项目工程"],["body","\n"],["body","\n"],["body","\n"],["body","一个包会包含有一个 Cargo.toml 文件，阐述如何去构建这些 crate。"],["body","\n"],["body","\n\n"],["headingLink","包规则"],["heading","包规则"],["body","\n\n"],["body","一个包中至多 只能 包含一个库 crate(library crate)；"],["body","\n"],["body","包中可以包含任意多个二进制 crate(binary crate)；"],["body","\n"],["body","包中至少包含一个 crate，无论是库的还是二进制的"],["body","\n\n"],["headingLink","示例"],["heading","示例"],["body","\n"],["body","//Cargo 会给我们的包创建一个 Cargo.toml 文件\ncargo new my-project\n"],["body","\n"],["headingLink","cargo-遵循的一个约定"],["heading","Cargo 遵循的一个约定"],["body","\n\n"],["body","src/main.rs 就是一个与包同名的二进制 crate 的 crate 根"],["body","\n"],["body","如果包目录中包含 src/lib.rs，则包带有与其同名的库 crate，且 src/lib.rs 是 crate 根。"],["body","\n"],["body","crate 根文件将由 Cargo 传递给 rustc 来实际构建库或者二进制项目。"],["body","\n\n"],["body","在此，我们有了一个只包含 src/main.rs 的包，意味着它只含有一个名为 my-project 的二进制 crate。如果一个包同时含有 src/main.rs 和 src/lib.rs，则它有两个 crate：一个库和一个二进制项，且名字都与包相同。通过将文件放在 src/bin 目录下，一个包可以拥有多个二进制 crate：每个 src/bin 下的文件都会被编译成一个独立的二进制 crate。"],["body","\n"],["body","src/main.rs 和 src/lib.rs 叫做 crate 根。之所以这样叫它们是因为这两个文件的内容都分别在 crate 模块结构的根组成了一个名为 crate 的模块，该结构被称为 模块树（module tree）。"],["body","\n"],["body","路径有两种形式："],["body","\n\n"],["body","绝对路径（absolute path）从 crate 根开始，以 crate 名或者字面值 crate 开头。"],["body","\n"],["body","相对路径（relative path）从当前模块开始，以 self、super 或当前模块的标识符开头。"],["body","\n\n"],["headingLink","使用-use-关键字将名称引入作用域"],["heading","使用 use 关键字将名称引入作用域"],["body","\n"],["body","#![allow(unused)]\nfn main() {\nmod front_of_house {\n    pub mod hosting {\n        pub fn add_to_waitlist() {}\n    }\n}\n\nuse front_of_house::hosting;\n\npub fn eat_at_restaurant() {\n    hosting::add_to_waitlist();\n    hosting::add_to_waitlist();\n    hosting::add_to_waitlist();\n}\n}"],["body","\n"],["headingLink","创建惯用的-use-路径"],["heading","创建惯用的 use 路径"],["body","\n"],["body","#![allow(unused)]\nfn main() {\nmod front_of_house {\n    pub mod hosting {\n        pub fn add_to_waitlist() {}\n    }\n}\n\nuse crate::front_of_house::hosting::add_to_waitlist;\n\npub fn eat_at_restaurant() {\n    add_to_waitlist();\n    add_to_waitlist();\n    add_to_waitlist();\n}\n}"],["body","\n"],["headingLink","使用父模块将两个具有相同名称的类型引入同一作用域"],["heading","使用父模块将两个具有相同名称的类型引入同一作用域"],["body","\n"],["body","#![allow(unused)]\nfn main() {\nuse std::fmt::Result;\nuse std::io::Result as IoResult;\n\nfn function1() -> Result {\n    // --snip--\n}\n\nfn function2() -> IoResult<()> {\n    // --snip--\n}\n}"],["body","\n"],["headingLink","使用as重命名"],["heading","使用as重命名"],["body","\n"],["body","\n#![allow(unused)]\nfn main() {\nuse std::fmt::Result;\nuse std::io::Result as IoResult;\n\nfn function1() -> Result {\n    // --snip--\n    Ok(())\n}\n\nfn function2() -> IoResult<()> {\n    // --snip--\n    Ok(())\n}\n}"],["body","\n"],["headingLink","使用-pub-use-重导出名称"],["heading","使用 pub use 重导出名称"],["body","\n"],["body","mod front_of_house {\n    pub mod hosting {\n        pub fn add_to_waitlist() {}\n    }\n}\n\npub use crate::front_of_house::hosting;\n\npub fn eat_at_restaurant() {\n    hosting::add_to_waitlist();\n    hosting::add_to_waitlist();\n    hosting::add_to_waitlist();\n}\nfn main() {}\n"],["body","\n"],["body","使用pub use  可以使得使用该模块的 访问到内部的模块"],["body","\n"],["headingLink","使用外部包"],["heading","使用外部包"],["body","\n"],["body","[dependencies]\nrand = \"0.5.5\"\n\n//使用\nuse rand::Rng;\nfn main() {\n    let secret_number = rand::thread_rng().gen_range(1, 101);\n}"],["body","\n"],["body","标准库"],["body","\n"],["body","\n#![allow(unused)]\nfn main() {\nuse std::collections::HashMap;\n}"],["body","\n"],["headingLink","嵌套路径来消除大量的-use-行"],["heading","嵌套路径来消除大量的 use 行"],["body","\n"],["body","\n#![allow(unused)]\nfn main() {\nuse std::{cmp::Ordering, io};\n// ---snip---\n}\n\n#![allow(unused)]\nfn main() {\nuse std::io;\nuse std::io::Write;\n}\n\n\n#![allow(unused)]\nfn main() {\nuse std::io::{self, Write};\n}"],["body","\n"],["headingLink","通过-glob-运算符将所有的公有定义引入作用域"],["heading","通过 glob 运算符将所有的公有定义引入作用域"],["body","\n"],["body","#![allow(unused)]\nfn main() {\nuse std::collections::*;\n}"],["body","\n"],["headingLink","将模块分割进不同文件"],["heading","将模块分割进不同文件"],["body","\n\n"],["body","每一个crate就是一个根模块。如：exp, lip, lip1, lip2, lip3。"],["body","\n"],["body","独立的一个文件就是一个mod,文件名就是mod名；但是main.rs, lib.rs, mod.rs除外，mod.rs的模块名就是其所在目录的名字； 而main.rs, lib.rs 的目录结构，如：exp/src/main.rs或 lip/src/lib.rs ;两者的mod名分别是exp和lip。"],["body","\n"],["body","文件和文件夹内的mod 及其内部定义的函数默认都是private的，除非pub声明公开。"],["body","\n"],["body","一个文件夹直接包含mod.rs ，如: rust_mod_study/lip2/src/worker/mod.rs ;则 worker就是模块名； 并且mod.rs为此模块的入口文件，此文件夹内的其他子模块都要在mod.rs中 pub mod 模块名，声明后，外部方可看到。"],["body","\n"],["body","如果一个元素是私有的，那么只有本模块内的元素以及它的子模块可以访问。"],["body","\n"],["body","如果一个元素是公开的，那么它上一层的模块就有权访问它。"],["body","\n"],["body","如果存在与文件同名的目录， 则在该目录下定义的模块都是该文件的子模块.（2018 edition有效）如：rust_mod_study/lip3/src/caller.rs ;``rust_mod_study/lip3/src/caller/callerin.rs;"],["body","\n\n"],["body","特别注意，callerin这个mod必须在caller.rs中以pub mod callerin;形式声明，否则外部看不到； 最终模块路径为：lip3::caller::callerin::call();"],["body","\n\n"],["body","rust 2018 edition 不再需要在根模块中使用extern crate xxx;语法导入第三方包。如在文件main.rs , lib.rs中不再需要extern crate xxx语法导入第三方包, 如:rust_mod_study/exp/src/main.rs 中的extern crate xxx可以去掉了。只需在Cargo.toml中配置好， 然后在代码中以模块路径访问即可，如：modx::mody::modz::fnx()； 也可以use一下，缩短路径。"],["body","\n"],["body","rust 如何引用未发布的本地crate, 特别之处在exp/Cargo.toml中， 如："],["body","\n\n"],["body","[package]\nname = \"exp\"\nversion = \"0.1.0\"\nauthors = [\"yujinliang <285779289@qq.com>\"]\nedition = \"2018\"\n\n# See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html\n[dependencies]\nlip = {path= \"../lip\" }\nlip1 = {path= \"../lip1\" }\nlip2 = {path= \"../lip2\" }\nlip3 = {path= \"../lip3\" } \n\n"],["body","\n\n"],["body","\n"],["body","目录结构：Cargo.lock Cargo.toml exp lip lip1 lip2 lip3 target在同一个父目录rust_mod_study中；其中exp/src/main.rs引用lip开头的所有模块。"],["body","\n"],["body","\n"],["body","\n"],["body","配置rust workspace, 在rust_mod_study/Cargo.toml中加入以下配置即可，如：\n```\n[workspace]\nmembers = [\"exp\", \"lip\", \"lip1\", \"lip2\", \"lip3\"]\n```"],["body","\n"],["body","\n"],["body","\n"],["body","在rust_mod_study/exp中给出一个例子用于说明：在同一个crate下各个子mod间的可见性和引用方法"],["body","\n"],["body","\n\n\n"],["body","首先各个子mod都需要在main.rs(属于crate顶级mod)中声明自己， 如： mod producer; mod consumer; mod switcher;等 ，只有这样各个子mod才能看到彼此，才能引用。"],["body","\n"],["body","每一个子mod可以用use crate::xxx形式引用在1.中声明的mod, 如：use crate::producer;等。"],["body","\n"],["body","每一个子mod自身默认都是自私的，除非以pub , pub use等打开为公用。"],["body","\n"],["body","对于pub struct 其field默认仍然是private的，需要pub声明为公用。"],["body","\n\n"],["body","总结： 父mod可以引用其子mod, 但是在父模块中仍然需要声明后方可应用子模块，如：mod 子模块名 ；而每一个子模块，只可以看到在其父模块中声明过的子mod, 但是仍需use crate::子模块名 来引用一下后方可用。\n我是在rust 1.39中做的实验， 时间急促，水平有限，如有谬误，欢迎指正，感谢啦！"],["body","\n\n"],["body","所有的例子代码都在rust_mod_study目录中 `"],["body","\n\n\n\n\n"],["body","\n\n                    "],["body","\n\n                    \n                \n            \n\n            \n\n        \n\n\n\n\n        \n\n\n\n        \n        \n        \n\n        \n\n\n    \n    \n"]],[["_relative_fp","3.rust/宏.html"],["title","宏 - 各项编程语言"],["body","\n    \n        \n        \n\n        \n        \n\n        \n        \n\n        \n        \n\n        \n\n        \n\n            \n                                \n                \n                    \n                        "],["body","\n                            \n                        "],["body","\n                        "],["body","\n                            \n                        "],["body","\n                        \n                            "],["body","Light"],["body","\n                            "],["body","Rust"],["body","\n                            "],["body","Coal"],["body","\n                            "],["body","Navy"],["body","\n                            "],["body","Ayu"],["body","\n                        \n                    \n\n                    "],["heading","各项编程语言"],["body","\n\n                    \n\n                    \n                \n\n\n                \n                \n\n                \n                    "],["body","\n                        \n\n"],["body","\n"],["body","\n\n"],["headingLink","宏"],["heading","宏"],["body","\n"],["body","\n"],["body","宏（Macro）指的是 Rust 中一系列的功能"],["body","\n"],["body","\n"],["headingLink","声明declarative宏"],["heading","声明（Declarative）宏"],["body","\n"],["headingLink","定义宏-macro_rules"],["heading","定义宏 macro_rules!"],["body","\n"],["headingLink","实例"],["heading","实例"],["body","\n"],["body","vec! 实现"],["body","\n"],["body","#![allow(unused)]\n\nfn main() {\n#[macro_export]\nmacro_rules! vec {\n    ( $( $x:expr ),* ) => {\n        {\n            let mut temp_vec = Vec::new();\n            $(\n                temp_vec.push($x);\n            )*\n            temp_vec\n        }\n    };\n}\n}"],["body","\n"],["headingLink","三种-过程procedural宏"],["heading","三种 过程（Procedural）宏"],["body","\n"],["body","自定义派生（derive）"],["body","\n"],["body","类属性"],["body","\n"],["body","类函数"],["body","\n"],["headingLink","宏原理"],["heading","宏原理"],["body","\n"],["headingLink","源分析"],["heading","源分析"],["body","\n"],["headingLink","tokenisation"],["heading","tokenisation"],["body","\n\n"],["body","\n"],["body","编译的第一个阶段就是 词汇化(tokenisation)"],["body","\n"],["body","\n"],["body","\n"],["body","将源代码转换为一系列不可分割的 词语单元"],["body","\n"],["body","\n"],["body","\n"],["body","rust的各种各样的词法单元"],["body","\n\n"],["body","自定义标识符  foo, Bambous, self, we_can_dance, LaCaravane, …"],["body","\n"],["body","整型字面量 : 42, 72u32, 0_______0, …"],["body","\n"],["body","关键字: _, fn, self, match, yield, macro, …"],["body","\n"],["body","申明周期标识符: 'a, 'b, 'a_rare_long_lifetime_name, …"],["body","\n"],["body","字符串字面量: \"\", \"Leicester\", r##\"venezuelan beaver\"##, …"],["body","\n"],["body","符号: [, :, ::, ->, @, <-, …"],["body","\n\n"],["body","\n\n"],["headingLink","parsing"],["heading","parsing"],["body","\n"],["body","下一个阶段是转换 将一系列的 tokens 转换成 AST(Abstract Syntax Tree)"],["body","\n\n"],["body","会在内存中 构建 程序 的语法结构"],["body","\n"],["body","例如 1+2 在内存中的结构如下"],["body","\n"],["body","AST结构 包含了整个程序"],["body","\n\n"],["body","┌─────────┐   ┌─────────┐\n│ BinOp   │ ┌╴│ LitInt  │\n│ op: Add │ │ │ val: 1  │\n│ lhs: ◌  │╶┘ └─────────┘\n│ rhs: ◌  │╶┐ ┌─────────┐\n└─────────┘ └╴│ LitInt  │\n              │ val: 2  │\n              └─────────┘\n"],["body","\n"],["headingLink","token-trees"],["heading","Token trees"],["body","\n\n"],["body","token tree 是介于 tokens 和 AST 之间的一种结构"],["body","\n"],["body","首先,大部分token都是 toeknTree 中的叶子结点 "],["body","\n"],["body","唯一不是叶子结点的 token 是 (...), [...], and {...} 又 称 grouping ,它们是 token tree 的内部 非叶子结点"],["body","\n"],["body","例如"],["body","\n\n"],["body","a + b + (c + d[0]) + e\n"],["body","\n"],["body","would be parsed into the following token trees:"],["body","\n"],["body","«a» «+» «b» «+» «(   )» «+» «e»\n          ╭────────┴──────────╮\n           «c» «+» «d» «[   ]»\n                        ╭─┴─╮\n                         «0»\n"],["body","\n"],["body","Note that this has no relationship to the AST the expression would produce; instead of a single root node, there are nine token trees at the root level. For reference, the AST would be:"],["body","\n"],["body","              ┌─────────┐\n              │ BinOp   │\n              │ op: Add │\n            ┌╴│ lhs: ◌  │\n┌─────────┐ │ │ rhs: ◌  │╶┐ ┌─────────┐\n│ Var     │╶┘ └─────────┘ └╴│ BinOp   │\n│ name: a │                 │ op: Add │\n└─────────┘               ┌╴│ lhs: ◌  │\n              ┌─────────┐ │ │ rhs: ◌  │╶┐ ┌─────────┐\n              │ Var     │╶┘ └─────────┘ └╴│ BinOp   │\n              │ name: b │                 │ op: Add │\n              └─────────┘               ┌╴│ lhs: ◌  │\n                            ┌─────────┐ │ │ rhs: ◌  │╶┐ ┌─────────┐\n                            │ BinOp   │╶┘ └─────────┘ └╴│ Var     │\n                            │ op: Add │                 │ name: e │\n                          ┌╴│ lhs: ◌  │                 └─────────┘\n              ┌─────────┐ │ │ rhs: ◌  │╶┐ ┌─────────┐\n              │ Var     │╶┘ └─────────┘ └╴│ Index   │\n              │ name: c │               ┌╴│ arr: ◌  │\n              └─────────┘   ┌─────────┐ │ │ ind: ◌  │╶┐ ┌─────────┐\n                            │ Var     │╶┘ └─────────┘ └╴│ LitInt  │\n                            │ name: d │                 │ val: 0  │\n                            └─────────┘                 └─────────┘\n"],["body","\n"],["body","tokenTree 与 AST 的差别 要理解"],["body","\n"],["body","写宏时会涉及到这两个结构"],["body","\n"],["body","方括号,括号,花括号 必须要配对"],["body","\n"],["headingLink","ast中的宏"],["heading","AST中的宏"],["body","\n"],["body","宏处理发生在AST构建好之后"],["body","\n"],["body","宏使用语法"],["body","\n\n"],["body","# [ $arg ]; e.g. #[derive(Clone)], #[no_mangle], …"],["body","\n"],["body","# ! [ $arg ]; e.g. #![allow(dead_code)], #![crate_name=\"blang\"], …"],["body","\n"],["body","$name ! $arg; e.g. println!(\"Hi!\"), concat!(\"a\", \"b\"), …"],["body","\n"],["body","$name ! $arg0 $arg1; e.g. macro_rules! dummy { () => {}; }."],["body","\n\n"],["body","头两个是 attribute,目前暂无法定义这两种形式"],["body","\n"],["body","最后一种 只有  macro_rules!宏 是这种形式"],["body","\n"],["body","只考虑第三种"],["body","\n"],["body","bitflags! {\n    flags Color: u8 {\n        const RED    = 0b0001,\n        const GREEN  = 0b0010,\n        const BLUE   = 0b0100,\n        const BRIGHT = 0b1000,\n    }\n}\n\nlazy_static! {\n    static ref FIB_100: u32 = {\n        fn fib(a: u32) -> u32 {\n            match a {\n                0 => 0,\n                1 => 1,\n                a => fib(a-1) + fib(a-2)\n            }\n        }\n\n        fib(100)\n    };\n}\n\nfn main() {\n    let colors = vec![RED, GREEN, BLUE];\n    println!(\"Hello, World!\");\n}\n"],["body","\n"],["body","Although the above invocations may look like they contain various kinds of Rust code, the parser simply sees a collection of meaningless token trees. To make this clearer, we can replace all these syntactic \"black boxes\" with ⬚, leaving us with:"],["body","\n"],["body","bitflags! ⬚\n\nlazy_static! ⬚\n\nfn main() {\n    let colors = vec! ⬚;\n    println! ⬚;\n}\n"],["body","\n"],["body","重点是:"],["body","\n\n"],["body","rust有各种各样的语法扩展, 现在只讨论  macro_rules! 定义的约定"],["body","\n"],["body","$name! $arg 这种形式可能不是 宏, 而是某种形式的语法扩展"],["body","\n"],["body","对 宏的输入 是一个 单一的 非叶子结点的 token tree"],["body","\n\n"],["body","宏只能出现在 明确定义支持的地方"],["body","\n\n"],["body","Patterns , 模式匹配"],["body","\n"],["body","Statements 语句"],["body","\n"],["body","Expressions 表达式"],["body","\n"],["body","Items "],["body","\n"],["body","impl Items"],["body","\n\n"],["headingLink","展开"],["heading","展开"],["body","\n"],["body","遍历AST, 定位 宏 然后展开"],["body","\n"],["body","let eight = 2 * four!();\n"],["body","\n"],["body","We can visualise this partial AST as follows:"],["body","\n"],["body","┌─────────────┐\n│ Let         │\n│ name: eight │   ┌─────────┐\n│ init: ◌     │╶─╴│ BinOp   │\n└─────────────┘   │ op: Mul │\n                ┌╴│ lhs: ◌  │\n     ┌────────┐ │ │ rhs: ◌  │╶┐ ┌────────────┐\n     │ LitInt │╶┘ └─────────┘ └╴│ Macro      │\n     │ val: 2 │                 │ name: four │\n     └────────┘                 │ body: ()   │\n                                └────────────┘\n"],["body","\n"],["body","从上下文得知, 宏展开成一个 表达式"],["body","\n"],["body","┌─────────────┐\n│ Let         │\n│ name: eight │   ┌─────────┐\n│ init: ◌     │╶─╴│ BinOp   │\n└─────────────┘   │ op: Mul │\n                ┌╴│ lhs: ◌  │\n     ┌────────┐ │ │ rhs: ◌  │╶┐ ┌─────────┐\n     │ LitInt │╶┘ └─────────┘ └╴│ BinOp   │\n     │ val: 2 │                 │ op: Add │\n     └────────┘               ┌╴│ lhs: ◌  │\n                   ┌────────┐ │ │ rhs: ◌  │╶┐ ┌────────┐\n                   │ LitInt │╶┘ └─────────┘ └╴│ LitInt │\n                   │ val: 1 │                 │ val: 3 │\n                   └────────┘                 └────────┘\n"],["body","\n"],["body","This can be written out like so:"],["body","\n"],["body","let eight = 2 * (1 + 3);\n"],["body","\n\n"],["body","宏展开会被当成语法 一个 AST的 node"],["body","\n"],["body","宏还可以展开成 宏 , 递归宏 展开是有限度的, 默认最大32 #![recursion_limit=\"…\"]"],["body","\n\n"],["headingLink","macro_rules"],["heading","macro_rules!"],["body","\n"],["headingLink","语法"],["heading","语法"],["body","\n"],["body","macro_rules! 是自身的一个语法扩展, 不是rust的语法"],["body","\n"],["body","macro_rules! $name {\n    $rule0 ;\n    $rule1 ;\n    // …\n    $ruleN ;\n}\n"],["body","\n"],["body","至少有一个rule 最后一个rule 的分号可以省略"],["body","\n"],["body","每一个rule的定义为"],["body","\n"],["body","    ($pattern) => {$expansion}\n"],["body","\n"],["body","pattern周围的 () 和 expression 的 {} 是用来分组的, 可以任意替换使用"],["body","\n"],["headingLink","matching"],["heading","Matching"],["body","\n"],["body","空模式"],["body","\n"],["body","#![allow(unused)]\nfn main() {\nmacro_rules! four {\n    () => {1 + 3};\n}\n//four!(), four![] or four!{} 都行\n}"],["body","\n"],["body","匹配时不会考虑, 分组符号"],["body","\n"],["body","模式同样能包好 字面 tokenTree ,必须精确匹配,通过简单正常编写 token tree 来完成"],["body","\n"],["body","#![allow(unused)]\nfn main() {\n//例如\nmacro_rules! gibberish {\n    (4 fn ['spang \"whammo\"] @_@) => {...};\n}\n}"],["body","\n"],["headingLink","captures"],["heading","Captures"],["body","\n"],["body","捕获标识 用  $self_variable: type"],["body","\n"],["body","type只能是以下几种"],["body","\n\n"],["body","item: an item, like a function, struct, module, etc."],["body","\n"],["body","block: a block (i.e. a block of statements and/or an expression, surrounded by braces)"],["body","\n"],["body","stmt: a statement"],["body","\n"],["body","pat: a pattern"],["body","\n"],["body","expr: an expression"],["body","\n"],["body","ty: a type"],["body","\n"],["body","ident: an identifier"],["body","\n"],["body","path: a path (e.g. foo, ::std::mem::replace, transmute::<_, int>, …)"],["body","\n"],["body","meta: a meta item; the things that go inside #[...] and #![...] attributes"],["body","\n"],["body","tt: a single token tree"],["body","\n\n"],["body","For example, here is a macro which captures its input as an expression:"],["body","\n"],["body","macro_rules! one_expression {\n    ($e:expr) => {...};\n}\n"],["body","\n"],["body","A capture $name:kind can be substituted into the expansion by writing $name. For example:"],["body","\n"],["body","macro_rules! times_five {\n    ($e:expr) => {5 * $e};\n}\n"],["body","\n"],["body","多捕获"],["body","\n"],["body","macro_rules! multiply_add {\n    ($a:expr, $b:expr, $c:expr) => {$a * ($b + $c)};\n}\n"],["body","\n"],["headingLink","repetitions"],["heading","Repetitions"],["body","\n"],["body","重复标识"],["body","\n"],["body","These allow a sequence of tokens to be matched. These have the general form"],["body","\n"],["body","$ ( ... ) sep rep"],["body","\n\n"],["body","$ is a literal dollar token."],["body","\n"],["body","( ... ) is the paren-grouped pattern being repeated."],["body","\n"],["body","sep is an optional separator token. Common examples are ,, and ;."],["body","\n"],["body","rep is   *  或者 +"],["body","\n\n"],["body","macro_rules! vec_strs {\n    (\n        // Start a repetition:\n        $(\n            // Each repeat must contain an expression...\n            $element:expr\n        )\n        // ...separated by commas...\n        ,\n        // ...zero or more times.\n        *\n    ) => {\n        // Enclose the expansion in a block so that we can use\n        // multiple statements.\n        {\n            let mut v = Vec::new();\n\n            // Start a repetition:\n            $(\n                // Each repeat will contain the following statement, with\n                // $element replaced with the corresponding expression.\n                v.push(format!(\"{}\", $element));\n            )*\n\n            v\n        }\n    };\n}\n"],["body","\n"],["headingLink","captures-and-expansion-redux"],["heading","Captures and Expansion Redux"],["body","\n"],["headingLink","第二个规则永远也不会匹配"],["heading","第二个规则永远也不会匹配"],["body","\n"],["body","因为一个ident也是也是一个expr"],["body","\n"],["body","macro_rules! dead_rule {\n    ($e:expr) => { ... };\n    ($i:ident +) => { ... };\n}\n"],["body","\n"],["body","规则匹配的广度"],["body","\n\n"],["body","item: anything."],["body","\n"],["body","block: anything."],["body","\n"],["body","stmt: => , ;"],["body","\n"],["body","pat: => , = if in"],["body","\n"],["body","expr: => , ;"],["body","\n"],["body","ty: , => : = > ; as"],["body","\n"],["body","ident: anything."],["body","\n"],["body","path: , => : = > ; as"],["body","\n"],["body","meta: anything."],["body","\n"],["body","tt: anything."],["body","\n\n"],["body","Additionally, macro_rules! generally forbids a repetition to be followed by another repetition, even if the contents do not conflict."],["body","\n"],["headingLink","捕获之后无法重新被捕获"],["heading","捕获之后无法重新被捕获"],["body","\n"],["body","One aspect of substitution that often surprises people is that substitution is not token-based, despite very much looking like it. Here is a simple demonstration:"],["body","\n"],["body","macro_rules! capture_expr_then_stringify {\n    ($e:expr) => {\n        stringify!($e)\n    };\n}\n\nfn main() {\n    println!(\"{:?}\", stringify!(dummy(2 * (1 + (3)))));\n    println!(\"{:?}\", capture_expr_then_stringify!(dummy(2 * (1 + (3)))));\n}\n"],["body","\n"],["body","Note that stringify! is a built-in syntax extension which simply takes all tokens it is given and concatenates them into one big string."],["body","\n"],["body","The output when run is:"],["body","\n"],["body","\"dummy ( 2 * ( 1 + ( 3 ) ) )\"\n\"dummy(2 * (1 + (3)))\"\n"],["body","\n"],["body","Note that despite having the same input, the output is different. This is because the first invocation is stringifying a sequence of token trees, whereas the second is stringifying an AST expression node."],["body","\n"],["body","To visualise the difference another way, here is what the stringify! macro gets invoked with in the first case:"],["body","\n"],["body","«dummy» «(   )»\n   ╭───────┴───────╮\n    «2» «*» «(   )»\n       ╭───────┴───────╮\n        «1» «+» «(   )»\n                 ╭─┴─╮\n                  «3»\n"],["body","\n"],["body","…and here is what it gets invoked with in the second case:"],["body","\n"],["body","« »\n │ ┌─────────────┐\n └╴│ Call        │\n   │ fn: dummy   │   ┌─────────┐\n   │ args: ◌     │╶─╴│ BinOp   │\n   └─────────────┘   │ op: Mul │\n                   ┌╴│ lhs: ◌  │\n        ┌────────┐ │ │ rhs: ◌  │╶┐ ┌─────────┐\n        │ LitInt │╶┘ └─────────┘ └╴│ BinOp   │\n        │ val: 2 │                 │ op: Add │\n        └────────┘               ┌╴│ lhs: ◌  │\n                      ┌────────┐ │ │ rhs: ◌  │╶┐ ┌────────┐\n                      │ LitInt │╶┘ └─────────┘ └╴│ LitInt │\n                      │ val: 1 │                 │ val: 3 │\n                      └────────┘                 └────────┘\n"],["body","\n"],["body","As you can see, there is exactly one token tree, which contains the AST which was parsed from the input to the capture_expr_then_stringify! invocation. Hence, what you see in the output is not the stringified tokens, it's the stringified AST node."],["body","\n"],["body","This has further implications. Consider the following:"],["body","\n"],["body","macro_rules! capture_then_match_tokens {\n    ($e:expr) => {match_tokens!($e)};\n}\n\nmacro_rules! match_tokens {\n    ($a:tt + $b:tt) => {\"got an addition\"};\n    (($i:ident)) => {\"got an identifier\"};\n    ($($other:tt)*) => {\"got something else\"};\n}\n\nfn main() {\n    println!(\"{}\\n{}\\n{}\\n\",\n        match_tokens!((caravan)),\n        match_tokens!(3 + 6),\n        match_tokens!(5));\n    println!(\"{}\\n{}\\n{}\",\n        capture_then_match_tokens!((caravan)),\n        capture_then_match_tokens!(3 + 6),\n        capture_then_match_tokens!(5));\n}\n"],["body","\n"],["body","The output is:"],["body","\n"],["body","got an identifier\ngot an addition\ngot something else\n\ngot something else\ngot something else\ngot something else\n"],["body","\n"],["body","By parsing the input into an AST node, the substituted result becomes un-destructible; i.e. you cannot examine the contents or match against it ever again."],["body","\n"],["body","Here is another example which can be particularly confusing:"],["body","\n"],["body","macro_rules! capture_then_what_is {\n    (#[$m:meta]) => {what_is!(#[$m])};\n}\n\nmacro_rules! what_is {\n    (#[no_mangle]) => {\"no_mangle attribute\"};\n    (#[inline]) => {\"inline attribute\"};\n    ($($tts:tt)*) => {concat!(\"something else (\", stringify!($($tts)*), \")\")};\n}\n\nfn main() {\n    println!(\n        \"{}\\n{}\\n{}\\n{}\",\n        what_is!(#[no_mangle]),\n        what_is!(#[inline]),\n        capture_then_what_is!(#[no_mangle]),\n        capture_then_what_is!(#[inline]),\n    );\n}\n"],["body","\n"],["body","The output is:"],["body","\n"],["body","no_mangle attribute\ninline attribute\nsomething else (# [ no_mangle ])\nsomething else (# [ inline ])\n"],["body","\n"],["body","The only way to avoid this is to capture using the tt or ident kinds. Once you capture with anything else, the only thing you can do with the result from then on is substitute it directly into the output."],["body","\n\n\n\n"],["body","\n\n                    "],["body","\n\n                    \n                \n            \n\n            \n\n        \n\n\n\n\n        \n\n\n\n        \n        \n        \n\n        \n\n\n    \n    \n"]],[["_relative_fp","3.rust/ConstantsAndVariables.html"],["title","ConstantsAndVariables - 各项编程语言"],["body","\n    \n        \n        \n\n        \n        \n\n        \n        \n\n        \n        \n\n        \n\n        \n\n            \n                                \n                \n                    \n                        "],["body","\n                            \n                        "],["body","\n                        "],["body","\n                            \n                        "],["body","\n                        \n                            "],["body","Light"],["body","\n                            "],["body","Rust"],["body","\n                            "],["body","Coal"],["body","\n                            "],["body","Navy"],["body","\n                            "],["body","Ayu"],["body","\n                        \n                    \n\n                    "],["heading","各项编程语言"],["body","\n\n                    \n\n                    \n                \n\n\n                \n                \n\n                \n                    "],["body","\n                        \n\n"],["body","\n"],["body","\n\n"],["headingLink","constants-vs-variables"],["heading","Constants v/s Variables"],["body","\n\n"],["body","常量使用  const关键字 声明，变量使用 let关键字申明"],["body","\n"],["body","变量得类型是可选的，常量的类型是必选的"],["body","\n"],["body","let关键字申明的变量是默认 不可变的。也可以使用 mut关键字 使之可变，常量始终不可变"],["body","\n"],["body","常量只能通过 constant expression设置。不能通过 函数调用、或者其他运行时 计算表达式"],["body","\n"],["body","常量可以申明在 任何作用域"],["body","\n"],["body","变量可以被重复定义，后定义的变量覆盖前面的定义，常量不可以"],["body","\n\n\n\n\n"],["body","\n\n                    "],["body","\n\n                    \n                \n            \n\n            \n\n        \n\n\n\n\n        \n\n\n\n        \n        \n        \n\n        \n\n\n    \n    \n"]],[["_relative_fp","3.rust/函数式编程.html"],["title","函数式编程 - 各项编程语言"],["body","\n    \n        \n        \n\n        \n        \n\n        \n        \n\n        \n        \n\n        \n\n        \n\n            \n                                \n                \n                    \n                        "],["body","\n                            \n                        "],["body","\n                        "],["body","\n                            \n                        "],["body","\n                        \n                            "],["body","Light"],["body","\n                            "],["body","Rust"],["body","\n                            "],["body","Coal"],["body","\n                            "],["body","Navy"],["body","\n                            "],["body","Ayu"],["body","\n                        \n                    \n\n                    "],["heading","各项编程语言"],["body","\n\n                    \n\n                    \n                \n\n\n                \n                \n\n                \n                    "],["body","\n                        \n\n"],["body","\n"],["body","\n\n"],["headingLink","实例1"],["heading","实例1"],["body","\n"],["body","#![allow(unused)]\nfn main() {\n// 函数式的写法\nlet sum_of_squared_odd_numbers: u32 =\n    (0..).map(|n| n * n)             // 所有自然数取平方\n         .take_while(|&n| n < upper) // 取小于上限的\n         .filter(|&n| is_odd(n))     // 取奇数\n         .fold(0, |sum, i| sum + i); // 最后加起来\nprintln!(\"functional style: {}\", sum_of_squared_odd_numbers);\n}"],["body","\n\n\n\n"],["body","\n\n                    "],["body","\n\n                    \n                \n            \n\n            \n\n        \n\n\n\n\n        \n\n\n\n        \n        \n        \n\n        \n\n\n    \n    \n"]],[["_relative_fp","3.rust/1常见编程概念.html"],["title","1常见编程概念 - 各项编程语言"],["body","\n    \n        \n        \n\n        \n        \n\n        \n        \n\n        \n        \n\n        \n\n        \n\n            \n                                \n                \n                    \n                        "],["body","\n                            \n                        "],["body","\n                        "],["body","\n                            \n                        "],["body","\n                        \n                            "],["body","Light"],["body","\n                            "],["body","Rust"],["body","\n                            "],["body","Coal"],["body","\n                            "],["body","Navy"],["body","\n                            "],["body","Ayu"],["body","\n                        \n                    \n\n                    "],["heading","各项编程语言"],["body","\n\n                    \n\n                    \n                \n\n\n                \n                \n\n                \n                    "],["body","\n                        \n\n"],["body","\n"],["body","\n\n"],["headingLink","变量"],["heading","变量"],["body","\n"],["headingLink","变量语法"],["heading","变量语法"],["body","\n"],["body","#![allow(unused)]\nfn main() {\n// 自动类型推断语法\nlet x = 5;\n\n//完整语法 ,指定数据类型\nlet y: f32 = 3.0; // f32\n}"],["body","\n"],["headingLink","变量与可变性"],["heading","变量与可变性"],["body","\n\n"],["body","在Rust 中 变量默认是不可改变的（immutable）"],["body","\n"],["body","不能对不可变变量 x 二次赋值"],["body","\n"],["body","使用 mut 声明可变变量 let mut x = 5;"],["body","\n\n"],["headingLink","变量和常量"],["heading","变量和常量"],["body","\n\n"],["body","常量是绑定到一个名称的不允许改变的值"],["body","\n"],["body","常量不光默认不能变，它总是不能变。"],["body","\n"],["body","声明常量使用 const 关键字而不是 let，并且 必须 注明值的类型"],["body","\n"],["body","常量只能被设置为常量表达式，而不能是函数调用的结果，或任何其他只能在运行时计算出的值。"],["body","\n"],["body","example: const MAX_POINTS: u32 = 100_000;"],["body","\n\n"],["headingLink","隐藏shadowing"],["heading","隐藏（Shadowing）"],["body","\n\n"],["body","我们可以定义一个与之前变量同名的新变量，而新变量会 隐藏 之前的变量"],["body","\n"],["body","这意味着使用这个变量时会看到第二个值。可以用相同变量名称来隐藏一个变量，以及重复使用 let 关键字来多次隐藏，"],["body","\n"],["body","隐藏使我们不必使用不同的名字"],["body","\n"],["body","example"],["body","\n\n"],["body","fn main() {\n    let x = 5;\n\n    let x = x + 1;\n\n    let x = x * 2;\n\n    println!(\"The value of x is: {}\", x);\n}"],["body","\n"],["headingLink","数据类型"],["heading","数据类型"],["body","\n"],["body","\n"],["body","在 Rust 中，每一个值都属于某一个 数据类型（data type），两类数据类型子集：标量（scalar）和复合（compound）。"],["body","\n"],["body","\n"],["body","Rust 是 静态类型（statically typed）语言"],["body","\n"],["body","也就是说在编译时就必须知道所有变量的类型。根据值及其使用方式，编译器通常可以推断出我们想要用的类型。当多种类型均有可能时"],["body","\n"],["body","必须增加类型注解 let guess: u32 = \"42\".parse().expect(\"Not a number!\");"],["body","\n"],["headingLink","标量类型"],["heading","标量类型"],["body","\n"],["body","Rust 有四种基本的标量类型：整型、浮点型、布尔类型 字符类型"],["body","\n"],["headingLink","整型"],["heading","整型"],["body","\n"],["body","长度"],["body","有符号"],["body","无符号"],["body","\n"],["body","8-bit"],["body","i8"],["body","u8"],["body","\n"],["body","16-bit"],["body","i16"],["body","u16"],["body","\n"],["body","32-bit"],["body","i32"],["body","u32"],["body","\n"],["body","64-bit"],["body","i64"],["body","u64"],["body","\n"],["body","128-bit"],["body","i128"],["body","u128"],["body","\n"],["body","arch"],["body","isize"],["body","usize"],["body","\n\n\n"],["body","isize 和 usize 类型依赖运行程序的计算机架构：64 位架构上它们是 64 位的， 32 位架构上它们是 32 位的。"],["body","\n"],["headingLink","整型字面量"],["heading","整型字面量"],["body","\n"],["body","数字字面值"],["body","例子"],["body","\n"],["body","Decimal (十进制)"],["body","98_222"],["body","\n"],["body","Hex (十六进制)"],["body","0xff"],["body","\n"],["body","Octal (八进制)"],["body","0o77"],["body","\n"],["body","Binary (二进制)"],["body","0b1111_0000"],["body","\n"],["body","Byte (单字节字符)(仅限于u8)"],["body","b'A'"],["body","\n\n\n"],["body","Rust 数字类型默认是 i32：它通常是最快的，甚至在 64 位系统上也是。isize 或 usize 主要作为某些集合的索引。"],["body","\n"],["headingLink","整型溢出"],["heading","整型溢出"],["body","\n"],["body","比方说有一个 u8 ，它可以存放从零到 255 的值。那么当你将其修改为 256 时会发生什么呢？这被称为 “整型溢出”（“integer overflow” ），关于这一行为 Rust 有一些有趣的规则。当在 debug 模式编译时，Rust 检查这类问题并使程序 panic，这个术语被 Rust 用来表明程序因错误而退出。第九章 “panic! 与不可恢复的错误” 部分会详细介绍 panic。"],["body","\n"],["body","在 release 构建中，Rust 不检测溢出，相反会进行一种被称为二进制补码包装（two’s complement wrapping）的操作。简而言之，256 变成 0，257 变成 1，依此类推。依赖整型溢出被认为是一种错误，即便可能出现这种行为。如果你确实需要这种行为，标准库中有一个类型显式提供此功能，Wrapping。"],["body","\n"],["headingLink","浮点"],["heading","浮点"],["body","\n"],["body","两个原生的 浮点数（floating-point numbers）类型，它们是带小数点的数字。Rust 的浮点数类型是 f32 和 f64，分别占 32 位和 64 位。默认类型是 f64，因为在现代 CPU 中，它与 f32 速度几乎一样，不过精度更高。"],["body","\n"],["headingLink","布尔类型"],["heading","布尔类型"],["body","\n"],["body"," let f: bool = false; // 显式指定类型注解\n"],["body","\n"],["headingLink","字符类型"],["heading","字符类型"],["body","\n"],["body","fn main() {\n    let c = 'z';\n    let z = 'ℤ';\n    let heart_eyed_cat = '😻';\n}\n"],["body","\n"],["body","Rust 的 char 类型的大小为四个字节(four bytes)，并代表了一个 Unicode 标量值（Unicode Scalar Value），这意味着它可以比 ASCII 表示更多内容。在 Rust 中，拼音字母（Accented letters），中文、日文、韩文等字符，emoji（绘文字）以及零长度的空白字符都是有效的 char 值。Unicode 标量值包含从 U+0000 到 U+D7FF 和 U+E000 到 U+10FFFF 在内的值。"],["body","\n"],["headingLink","复合类型"],["heading","复合类型"],["body","\n"],["body","\n"],["body","可以将多个值组合成一个类型。Rust 有两个原生的复合类型：元组（tuple）和数组（array）。"],["body","\n"],["body","\n"],["headingLink","元组类型"],["heading","元组类型"],["body","\n\n"],["body","元组长度固定：一旦声明，其长度不会增大或缩小。"],["body","\n"],["body","圆括号中的逗号分隔的值列表来创建一个元组"],["body","\n"],["body","元组中的每一个位置都有一个类型，而且这些不同值的类型也不必是相同的"],["body","\n\n"],["body","元组解构取值"],["body","\n"],["body","#![allow(unused)]\nfn main() {\nlet tup = (500, 6.4, 1);\n\n    let (x, y, z) = tup;\n\n    println!(\"The value of y is: {}\", y);\n}"],["body","\n"],["body",". 号取值"],["body","\n"],["body","#![allow(unused)]\nfn main() {\n// 也可以使用点号（.）后跟值的索引来直接访问它们\n let x: (i32, f64, u8) = (500, 6.4, 1);\n\n    let five_hundred = x.0;\n\n    let six_point_four = x.1;\n\n    let one = x.2;\n}"],["body","\n"],["headingLink","数组类型"],["heading","数组类型"],["body","\n"],["body","\n"],["body","数组中的每个元素的类型必须相同"],["body","\n"],["body","\n"],["body","#![allow(unused)]\nfn main() {\nlet a = [1, 2, 3, 4, 5];\nlet a: [i32; 5] = [1, 2, 3, 4, 5];\n// let a = [elea-value; array-length]\nlet a = [3; 5];\n}"],["body","\n"],["headingLink","函数"],["heading","函数"],["body","\n\n"],["body","main 函数，它是很多程序的入口点"],["body","\n"],["body","fn 关键字，它用来声明新函数"],["body","\n"],["body","Rust 代码中的函数和变量名使用 snake case 规范风格。在 snake case 中，所有字母都是小写并使用下划线分隔单词。这是一个包含函数定义示例的程序："],["body","\n\n"],["headingLink","函数参数"],["heading","函数参数"],["body","\n"],["body","#![allow(unused)]\nfn main() {\nfn another_function(x: i32, y: i32) {\n    println!(\"The value of x is: {}\", x);\n    println!(\"The value of y is: {}\", y);\n}\n}"],["body","\n"],["headingLink","包含语句和表达式的函数体"],["heading","包含语句和表达式的函数体"],["body","\n\n"],["body","\n"],["body","语句不返回值"],["body","\n"],["body","#![allow(unused)]\nfn main() {\n let x = (let y = 6);\n}"],["body","\n"],["body","\n"],["body","\n"],["body","表达式会计算出一些值  并且你将编写的大部分 Rust 代码是由表达式组成的。"],["body","\n\n"],["body","\n"],["body","考虑一个简单的数学运算，比如 5 + 6，这是一个表达式并计算出值 11。"],["body","\n"],["body","\n"],["body","\n"],["body","表达式可以是语句的一部分：在示例 3-1 中，语句 let y = 6; 中的 6 是一个表达式，它计算出的值是 6。"],["body","\n"],["body","\n"],["body","\n"],["body","函数调用是一个表达式。"],["body","\n"],["body","\n"],["body","\n"],["body","宏调用是一个表达式。"],["body","\n"],["body","\n"],["body","\n"],["body","我们用来创建新作用域的大括号（代码块），{}，也是一个表达式，例如："],["body","\n"],["body","#![allow(unused)]\nfn main() {\n let y = {\n        let x = 3;\n        x + 1\n    };\n}"],["body","\n"],["body","\n\n"],["body","\n\n"],["headingLink","函数返回值"],["heading","函数返回值"],["body","\n"],["body","fn five() -> i32 {\n    5\n}\nfn main() {\n    let x = five();\n    println!(\"The value of x is: {}\", x);\n}"],["body","\n"],["body","#![allow(unused)]\nfn main() {\n//x+1 因为加上了分号 从表达式 变成了 语句\nfn plus_one(x: i32) -> i32 {\n    x + 1;\n}\n如果函数没有返回值,则 使用空元组 () 返回\n}"],["body","\n"],["headingLink","控制流"],["heading","控制流"],["body","\n"],["headingLink","if"],["heading","if"],["body","\n"],["body","\n"],["body","表达式 必须 是 bool 值"],["body","\n"],["body","\n"],["body","    if number < 5 {\n        println!(\"condition was true\");\n    } else {\n        println!(\"condition was false\");\n    }\n"],["body","\n"],["headingLink","if同时也是一个表达式"],["heading","if同时也是一个表达式"],["body","\n"],["body","\n"],["body","if 和 else 分支的值类型必须相同"],["body","\n"],["body","\n"],["body","#![allow(unused)]\nfn main() {\nlet number = if condition {\n        5\n    } else {\n        6\n    };\n\n//error_example\n  let condition = true;\n\n    let number = if condition {\n        5\n    } else {\n        \"six\"\n    };\n}"],["body","\n"],["headingLink","循环"],["heading","循环"],["body","\n"],["headingLink","loop"],["heading","Loop"],["body","\n"],["body","#![allow(unused)]\n\nfn main() {\nloop {\n        println!(\"again!\");\n    }\n\n//循环返回,loop也是一个表达式\n let result = loop {\n        counter += 1;\n\n        if counter == 10 {\n            break counter * 2;\n        }\n    };\n\n\n}"],["body","\n"],["headingLink","while"],["heading","while"],["body","\n"],["body","#![allow(unused)]\nfn main() {\n let mut number = 3;\n\n    while number != 0 {\n        println!(\"{}!\", number);\n\n        number = number - 1;\n    }\n}"],["body","\n"],["body","#![allow(unused)]\nfn main() {\n  let a = [10, 20, 30, 40, 50];\n    let mut index = 0;\n\n    while index < 5 {\n        println!(\"the value is: {}\", a[index]);\n\n        index = index + 1;\n    }\n}"],["body","\n"],["headingLink","for迭代"],["heading","For迭代"],["body","\n"],["body","fn main() {\n    let a = [10, 20, 30, 40, 50];\n\n    for element in a.iter() {\n        println!(\"the value is: {}\", element);\n    }\n}"],["body","\n"],["body","反转"],["body","\n"],["body","fn main() {\n    for number in (1..4).rev() {\n        println!(\"{}!\", number);\n    }\n    println!(\"LIFTOFF!!!\");\n}"],["body","\n\n\n\n"],["body","\n\n                    "],["body","\n\n                    \n                \n            \n\n            \n\n        \n\n\n\n\n        \n\n\n\n        \n        \n        \n\n        \n\n\n    \n    \n"]],[["_relative_fp","3.rust/const类型与函数.html"],["title","const类型与函数 - 各项编程语言"],["body","\n    \n        \n        \n\n        \n        \n\n        \n        \n\n        \n        \n\n        \n\n        \n\n            \n                                \n                \n                    \n                        "],["body","\n                            \n                        "],["body","\n                        "],["body","\n                            \n                        "],["body","\n                        \n                            "],["body","Light"],["body","\n                            "],["body","Rust"],["body","\n                            "],["body","Coal"],["body","\n                            "],["body","Navy"],["body","\n                            "],["body","Ayu"],["body","\n                        \n                    \n\n                    "],["heading","各项编程语言"],["body","\n\n                    \n\n                    \n                \n\n\n                \n                \n\n                \n                    "],["body","\n                        \n\n"],["body","\n"],["body","\n\n"],["headingLink","const-typestraits-and-implementations-in-rust"],["heading","const types,traits and implementations in rust"],["body","\n"],["body","Rust 允许以  const 和 const fn 的形式 的有限形式 编译时函数 执行\n"],["body","\n"],["body","虽然最初，const似乎 是一个 合理的简单功能，但它最终提出了大量有趣而复杂得设计问题，\nconst fn  是一种非常受限的函数\n：不允许带trait bound的泛型参数：这是因为需要考虑 const代码与 运行时代码 交互的问题"],["body","\n"],["body","但是很难确定一个满足所有要求，又尽可能简约的设计，"],["body","\n"],["headingLink","proposed-design"],["heading","Proposed design"],["body","\n"],["body","\n"],["body","建议设计"],["body","\n"],["body","\n\n"],["body","最要的概念是如何将 const函数 视为 运行时函数或转换为运行时函数"],["body","\n"],["body","始终能够 在运行时调用 const函数"],["body","\n\n"],["body","#![allow(unused)]\nfn main() {\nconst fn foo<A: T>(A) -> A;\n}"],["body","\n"],["body","这个cost函数将会以如下方式解析"],["body","\n\n"],["body","在编译时调用 foo时，必须有一个 类型为A的const常量，且实现了trait T，且 实现 T for A 必须也是 const的实现"],["body","\n"],["body","在运行时调 foo时，没有特殊要求"],["body","\n\n"],["body","#![allow(unused)]\nfn main() {\nfn bar<A: T>(A) -> A;\n}"],["body","\n\n"],["body","bar不能在编译时调用"],["body","\n"],["body","在运行时调 foo时，没有特殊要求"],["body","\n\n"],["headingLink","const-implementations"],["heading","const implementations"],["body","\n"],["body","\n"],["body","cost实现"],["body","\n"],["body","\n\n"],["body","对于 trait T ，类型A的实现必须要满足：每个函数都必须是 const函数"],["body","\n"],["body","如果视线中有一个不是 const函数，则该实现 不是 const实现"],["body","\n"],["body","如果存在 默认方法，必须也得覆盖，除非默认方法本来就是 const"],["body","\n\n"],["headingLink","const-functions-with-generic-trait-bound-types"],["heading","const functions with generic trait bound types"],["body","\n"],["body","\n"],["body","具有泛型trait绑定类型的 const 函数"],["body","\n"],["body","\n"],["body","#![allow(unused)]\nfn main() {\nconst fn baz<A: T>(A) -> A;\n}"],["body","\n"],["body","只接受 tarit T的 const实现的 类型A"],["body","\n"],["headingLink","explicitly-const-trait-bounds"],["heading","Explicitly-const trait bounds"],["body","\n"],["body","\n"],["body","显示const trait 绑定"],["body","\n"],["body","\n"],["body","#![allow(unused)]\nfn main() {\nfn baz<A: const T>(A) -> A {\n    // We can only call a `T` method of `A`\n    // in a `const` variable declaration\n    // if we know `A` `const`-implements `T`,\n    // so the trait bound must explicitly\n    // be `const`.\n    const X: bool = <A as T>::choice();\n    ...\n}\n}"],["body","\n"],["body","如果 在函数内部 显示调用了 trait的方法。则必须声明为 impl T for A is const "],["body","\n"],["headingLink","const-in-traits"],["heading","const in traits"],["body","\n"],["body","#![allow(unused)]\nfn main() {\n//要求所有实现都必须 const实现 choice\ntrait T {\n    const fn choice() -> bool;\n    ...\n}\nfn baz<A: T>(A) -> A {\n    // Now, `<A: const T>` is not needed, since\n    // `choice` is always const in any implementation\n    // of `T`.\n    const X: bool = <A as T>::choice();\n    ...\n}\n}"],["body","\n"],["headingLink","opting-out-of-const-trait-bounds-with-const"],["heading","Opting out of const trait bounds with ?const"],["body","\n"],["body","\n"],["body","选择性退出 const实现"],["body","\n"],["body","\n"],["body","#![allow(unused)]\nfn main() {\ntrait T {\n    const fn choice() -> bool;\n\n    fn validate(u8) -> bool;\n}\n\nstruct S;\n\nimpl T for S {\n    const fn choice() -> bool {\n        ...\n    }\n\n    fn validate(u8) -> bool {\n        ...\n    }\n}\n\nconst fn bar<A: T>(A) -> A {\n    let x: bool = <A as T>::choice();\n    ...\n}\n}"],["body","\n\n"],["body","如果某个函数 中只使用到了 某个 trait的某个 const函数"],["body","\n"],["body","但是在函数申明时 必须要求 const 实现： trait实现里的所有方法都必须是 const"],["body","\n"],["body","可以通过  显式 const trait bounds 选择退出 来放宽 此要求 ：?const"],["body","\n\n"],["body","#![allow(unused)]\nfn main() {\nconst fn bar_opt_ct<A: ?const T>(A) -> A {\n    let x: bool = <A as T>::choice();\n    ...\n}\n}"],["body","\n\n"],["body","默认的  const fn  需要 const trait bounds ，而对于运行时没有要求"],["body","\n"],["body","以 ?const 为前缀的 trait bounds 不需要 const traits bounds 。在编译时、或者运行时"],["body","\n\n"],["headingLink","removal-of-the-const-keyword"],["heading","Removal of the const keyword"],["body","\n"],["body","由于任何 const 函数都可以在运行时调用，因此它也必须是有效的非 const 函数（在适当的翻译之后）：这就是我们定义的直觉和动机。转换只是修改函数签名，而不更改正文。这种转换非常简单，只需从函数中删除 const 前缀并删除任何 ？const 边界即可。"],["body","\n"],["headingLink","syntactic-sugar-for-const-on-traits-and-impls"],["heading","Syntactic sugar for const on traits and impls"],["body","\n"],["body","\n"],["body","const 语法糖"],["body","\n"],["body","\n"],["body","可以将 trait 申明为 const 或者 将 实现 声明为 trait"],["body","\n"],["body","#![allow(unused)]\nfn main() {\nconst trait V {\n    fn foo(C) -> D;\n    fn bar(E) -> F;\n}\n// ...desugars to...\ntrait V {\n    const fn foo(C) -> D;\n    const fn bar(E) -> F;\n}\n\nstruct P;\n\nconst impl V for P {\n    fn foo(C) -> D;\n    fn bar(E) -> F;\n}\n// ...desugars to...\nimpl V for P {\n    const fn foo(C) -> D;\n    const fn bar(E) -> F;\n}\n\n}"],["body","\n"],["body","参考文章"],["body","\n\n\n\n"],["body","\n\n                    "],["body","\n\n                    \n                \n            \n\n            \n\n        \n\n\n\n\n        \n\n\n\n        \n        \n        \n\n        \n\n\n    \n    \n"]],[["_relative_fp","3.rust/泛型与trait.html"],["title","泛型与trait - 各项编程语言"],["body","\n    \n        \n        \n\n        \n        \n\n        \n        \n\n        \n        \n\n        \n\n        \n\n            \n                                \n                \n                    \n                        "],["body","\n                            \n                        "],["body","\n                        "],["body","\n                            \n                        "],["body","\n                        \n                            "],["body","Light"],["body","\n                            "],["body","Rust"],["body","\n                            "],["body","Coal"],["body","\n                            "],["body","Navy"],["body","\n                            "],["body","Ayu"],["body","\n                        \n                    \n\n                    "],["heading","各项编程语言"],["body","\n\n                    \n\n                    \n                \n\n\n                \n                \n\n                \n                    "],["body","\n                        \n\n"],["body","\n"],["body","\n\n"],["headingLink","泛型的使用"],["heading","泛型的使用"],["body","\n"],["headingLink","函数泛型定义与使用"],["heading","函数泛型定义与使用"],["body","\n"],["body","#![allow(unused)]\nfn main() {\n//定义,写在函数名后面, 使用在函数的任何地方\nfn largest<T>(list: &[T]) -> T {\n    let mut largest = list[0];\n    for &item in list.iter() {\n        if item > largest {\n            largest = item;\n        }\n    }\n    largest\n}\n}"],["body","\n"],["headingLink","结构体泛型定义与使用"],["heading","结构体泛型定义与使用"],["body","\n"],["body","struct Point<T> {\n    x: T,\n    y: T,\n}\n\nfn main() {\n    let wont_work = Point { x: 5, y: 4.0 };\n}"],["body","\n"],["headingLink","枚举定义的泛型"],["heading","枚举定义的泛型"],["body","\n"],["body","#![allow(unused)]\nfn main() {\nenum Option<T> {\n    Some(T),\n    None,\n}\nenum Result<T, E> {\n    Ok(T),\n    Err(E),\n}\n}"],["body","\n"],["headingLink","方法实现中的泛型定义"],["heading","方法实现中的泛型定义"],["body","\n"],["body","#![allow(unused)]\nfn main() {\nstruct Point<T> {\nx: T,\ny: T,\n}\n\n\nimpl Point<f32> {\n    fn distance_from_origin(&self) -> f32 {\n        (self.x.powi(2) + self.y.powi(2)).sqrt()\n    }\n}\n\nimpl<T> Point<T> {\n    fn x(&self) -> &T {\n        &self.x\n    }\n}\n\n//产生新泛型\nstruct Point<T, U> {\n    x: T,\n    y: U,\n}\n\nimpl<T, U> Point<T, U> {\n    fn mixup<V, W>(self, other: Point<V, W>) -> Point<T, W> {\n        Point {\n            x: self.x,\n            y: other.y,\n        }\n    }\n}\n}"],["body","\n"],["headingLink","泛型代码的性能"],["heading","泛型代码的性能"],["body","\n\n"],["body","Rust 实现了泛型，使得使用泛型类型参数的代码相比使用具体类型并没有任何速度上的损失。"],["body","\n"],["body","Rust 通过在编译时进行泛型代码的 单态化（monomorphization）来保证效率。单态化是一个通过填充编译时使用的具体类型，将通用代码转换为特定代码的过程。"],["body","\n"],["body","编译器寻找所有泛型代码被调用的位置并使用泛型代码针对具体类型生成代码。"],["body","\n\n"],["body","让我们看看一个使用标准库中 Option 枚举的例子："],["body","\n"],["body","#![allow(unused)]\nfn main() {\nlet integer = Some(5);\nlet float = Some(5.0);\n}"],["body","\n"],["body","编译器会读取传递给 Option<T> 的值并发现有两种 Option<T>：一个对应 i32 另一个对应 f64"],["body","\n"],["body","为此，它会将泛型定义 Option<T> 展开为 Option_i32 和 Option_f64，接着将泛型定义替换为这两个具体的定义。"],["body","\n"],["headingLink","trait特性"],["heading","Trait(特性)"],["body","\n"],["headingLink","定义"],["heading","定义"],["body","\n\n"],["body","\n"],["body","一个类型的行为由其可供调用的方法构成。"],["body","\n"],["body","\n"],["body","\n"],["body","如果可以对不同类型调用相同的方法的话，这些类型就可以共享相同的行为了。"],["body","\n"],["body","\n"],["body","\n"],["body","trait 定义是一种将方法签名组合起来的方法，目的是定义一个实现某些目的所必需的行为的集合。"],["body","\n"],["body","\n\n"],["body","#![allow(unused)]\nfn main() {\n//trait 体中可以有多个方法\npub trait Summary {\n    fn summarize(&self) -> String;\n}\n}"],["body","\n"],["headingLink","为结构体实现trait"],["heading","为结构体实现Trait"],["body","\n"],["body","#![allow(unused)]\nfn main() {\npub struct NewsArticle {\n    pub headline: String,\n    pub location: String,\n    pub author: String,\n    pub content: String,\n}\n\nimpl Summary for NewsArticle {\n    fn summarize(&self) -> String {\n        format!(\"{}, by {} ({})\", self.headline, self.author, self.location)\n    }\n}\n\npub struct Tweet {\n    pub username: String,\n    pub content: String,\n    pub reply: bool,\n    pub retweet: bool,\n}\n\nimpl Summary for Tweet {\n    fn summarize(&self) -> String {\n        format!(\"{}: {}\", self.username, self.content)\n    }\n}\n}"],["body","\n"],["headingLink","trait-的相干性"],["heading","trait 的相干性"],["body","\n\n"],["body","不能为 外部类型(第三方) 实现 外部 （第三方）trait\n\n"],["body","例如 不能在 aggregator crate 中为 Vec<T> 实现 Display trait"],["body","\n"],["body","因为 Display 和 Vec<T> 都定义于标准库中"],["body","\n"],["body","并不位于 aggregator crate 本地作用域中"],["body","\n"],["body","这个限制是被称为 相干性（coherence） 更具体的说是 孤儿规则（orphan rule）"],["body","\n"],["body","这条规则确保了其他人编写的代码不会破坏你代码"],["body","\n\n"],["body","\n\n"],["headingLink","trait-的默认实现"],["heading","Trait 的默认实现"],["body","\n"],["body","#![allow(unused)]\nfn main() {\npub trait Summary {\n    fn summarize(&self) -> String {\n        String::from(\"(Read more...)\")\n    }\n}\n}"],["body","\n"],["body","默认方法与抽象方法共存"],["body","\n"],["body","#![allow(unused)]\n\nfn main() {\npub trait Summary {\n    fn summarize_author(&self) -> String;\n\n    fn summarize(&self) -> String {\n        format!(\"(Read more from {}...)\", self.summarize_author())\n    }\n}\n}"],["body","\n"],["body","#![allow(unused)]\nfn main() {\ntrait Summary{\n     fn summary(&self) -> String{\n        String::from(\"read more\")\n    }\n}\nimpl Summary for Book{\n\n}\n}"],["body","\n"],["headingLink","trait-作为参数"],["heading","Trait 作为参数"],["body","\n"],["headingLink","traitbound-语法糖"],["heading","TraitBound 语法糖"],["body","\n"],["body","\n"],["body","与 impl Summary 是一样"],["body","\n"],["body","\n"],["body","#![allow(unused)]\nfn main() {\npub fn notify<T: Summary>(item: T) {\n    println!(\"Breaking news! {}\", item.summarize());\n}\n}"],["body","\n"],["body","pub fn notify(item1: impl Summary, item2: impl Summary) {\n与\npub fn notify<T: Summary>(item1: T, item2: T) {\n"],["body","\n"],["body","通过 + 号 指定多个"],["body","\n"],["body","#![allow(unused)]\nfn main() {\npub fn notify(item: impl Summary + Display) {\n与\npub fn notify<T: Summary + Display>(item: T) {\n}"],["body","\n"],["body","通过 where 简化 trait bound"],["body","\n"],["body","#![allow(unused)]\nfn main() {\nfn some_function<T: Display + Clone, U: Clone + Debug>(t: T, u: U) -> i32 {\n与\n\nfn some_function<T, U>(t: T, u: U) -> i32\n    where T: Display + Clone,\n          U: Clone + Debug\n{\n}"],["body","\n"],["headingLink","函数参数"],["heading","函数参数"],["body","\n"],["body","#![allow(unused)]\nfn main() {\npub fn notify(item: impl Summary) {\n    println!(\"Breaking news! {}\", item.summarize());\n}\n}"],["body","\n"],["headingLink","返回类型"],["heading","返回类型"],["body","\n"],["body","#![allow(unused)]\nfn main() {\nfn returns_summarizable() -> impl Summary {\n    Tweet {\n        username: String::from(\"horse_ebooks\"),\n        content: String::from(\"of course, as you probably already know, people\"),\n        reply: false,\n        retweet: false,\n    }\n}\n}"],["body","\n"],["headingLink","使用-trait-bound-有条件地实现方法"],["heading","使用 trait bound 有条件地实现方法"],["body","\n"],["body","\n"],["body","限定泛型的实现 类型"],["body","\n"],["body","\n"],["body","#![allow(unused)]\nfn main() {\nuse std::fmt::Display;\n\nstruct Pair<T> {\n    x: T,\n    y: T,\n}\n\nimpl<T> Pair<T> {\n    fn new(x: T, y: T) -> Self {\n        Self {\n            x,\n            y,\n        }\n    }\n}\n\nimpl<T: Display + PartialOrd> Pair<T> {\n    fn cmp_display(&self) {\n        if self.x >= self.y {\n            println!(\"The largest member is x = {}\", self.x);\n        } else {\n            println!(\"The largest member is y = {}\", self.y);\n        }\n    }\n}\n}"],["body","\n"],["body","例如"],["body","\n"],["body","#![allow(unused)]\nfn main() {\n//标准库为任何实现了 Display trait 的类型实现了 ToString trait。这个 impl 块看起来像这样：\nimpl<T: Display> ToString for T {\n    // --snip--\n}\n//因为标准库有了这些 blanket implementation，我们可以对任何实现了 Display trait 的类型调用由 ToString 定义的 to_string 方法。例如，可以将整型转换为对应的 String 值，因为整型实现了 Display：\n}"],["body","\n"],["headingLink","dyn-trait-trait-对象"],["heading","dyn Trait trait 对象"],["body","\n"],["body","dyn Trait 是使用 trait 对象的新语法，简而言之："],["body","\n\n"],["body","Box<Trait> becomes Box<dyn Trait>"],["body","\n"],["body","&Trait and &mut Trait become &dyn Trait and &mut dyn Trait"],["body","\n\n"],["headingLink","标准库中的-trait"],["heading","标准库中的 Trait"],["body","\n"],["headingLink","debug详细打印"],["heading","Debug详细打印"],["body","\n"],["body","Debug trait 用于开启格式化字符串中的调试格式，其通过在 {} 占位符中增加 :? 表明。"],["body","\n"],["body","需要实现 Debug 的 fmt"],["body","\n"],["body","impl Debug for Address{\n    fn fmt(&self, f: &mut Formatter<'_>) -> Result<(), Error> {\n        write!(f,\"a={}\",self.home)\n    }\n}\n"],["body","\n"],["headingLink","等值比较"],["heading","等值比较"],["body","\n"],["body","相关解释 "],["body","\n"],["headingLink","partitaleq"],["heading","PartitalEq"],["body","\n"],["body","\n"],["body","派生的 PartialEq 实现了 eq 方法。"],["body","\n"],["body","\n\n"],["body","当 PartialEq 在结构体上派生时，只有所有 的字段都相等时两个实例才相等。"],["body","\n"],["body","当在枚举上派生时，每一个成员都和其自身相等，且和其他成员都不相等。"],["body","\n\n"],["headingLink","eq"],["heading","Eq"],["body","\n"],["body","Eq 相比 PartialEq 需要额外满足反身性，即 a == a，对于浮点类型，Rust 只实现了 PartialEq 而不是 Eq，原因就是 NaN != NaN。"],["body","\n"],["headingLink","ord--partialord"],["heading","Ord & PartialOrd"],["body","\n"],["body","类似于 Eq，Ord 指的是 Total Order，需要满足以下三个性质："],["body","\n\n"],["body","反对称性（Antisymmetry）：a <= b 且 a >= b 可推出 a == b"],["body","\n"],["body","传递性（Transitivity）：a <= b 且 b <= c 可推出 a <= c"],["body","\n"],["body","连通性（Connexity）：a <= b 或 a >= b"],["body","\n\n"],["body","而 PartialOrd 无需满足连通性，只满足反对称性和传递性即可。"],["body","\n\n"],["body","反对称性：a < b 则有 !(a > b)，反之亦然"],["body","\n"],["body","传递性：a < b 且 b < c 可推出 a < c，== 和 > 同理"],["body","\n\n"],["headingLink","复制值的-clone-和-copy"],["heading","复制值的 Clone 和 Copy"],["body","\n\n"],["body","可以明确地创建一个值的深拷贝（deep copy），复制过程可能包含任意代码的执行以及堆上数据的复制"],["body","\n"],["body","派生 Clone 实现了 clone 方法，其为整个的类型实现时，在类型的每一部分上调用了 clone 方法。这意味着类型中所有字段或值也必须实现了 Clone，这样才能够派生 Clone 。"],["body","\n\n"],["body","切片转集合时需要clone"],["body","\n"],["body","当在一个切片（slice）上调用 to_vec 方法时，Clone 是必须的。切片并不拥有其所包含实例的类型，但是从 to_vec 中返回的 vector 需要拥有其实例，因此，to_vec 在每个元素上调用 clone。因此，存储在切片中的类型必须实现 Clone。"],["body","\n"],["body","拷贝存储在栈上的数据不需要额外代码"],["body","\n"],["body","Copy trait 允许你通过只拷贝存储在栈上的位来复制值而不需要额外的代码。查阅第四章 “只在栈上的数据：拷贝” 的部分来获取有关 Copy 的更多信息。"],["body","\n"],["headingLink","固定大小的值到值映射的-hash"],["heading","固定大小的值到值映射的 Hash"],["body","\n\n"],["body","\n"],["body","Hash trait 可以实例化一个任意大小的类型，并且能够用哈希（hash）函数将该实例映射到一个固定大小的值上。"],["body","\n"],["body","\n"],["body","\n"],["body","派生 Hash 实现了 hash 方法。hash 方法的派生实现结合了在类型的每部分调用 hash 的结果，这意味着所有的字段或值也必须实现了 Hash，这样才能够派生 Hash。"],["body","\n"],["body","\n\n"],["body","\n"],["body","例如，在 HashMap<K, V> 上存储数据，存放 key 的时候，Hash 是必须的。"],["body","\n"],["body","\n"],["headingLink","默认值的-default"],["heading","默认值的 Default"],["body","\n"],["body","*　Default trait 使你创建一个类型的默认值"],["body","\n"],["body","使用"],["body","\n"],["body","#![allow(unused)]\nfn main() {\npub fn  test_default(){\n    let person = Person {..Default::default()};\n    println!(\"{:?}\",person);\n}\n#[derive(Debug)]\nstruct Person{\n    age:i32,\n    name:String,\n    address:String\n}\n\nimpl Default for Person{\n    fn default() -> Self {\n        Person{\n            age:18,\n            name:\"ssss\".to_owned(),\n            address: \"\".to_owned()\n        }\n    }\n}\n}"],["body","\n"],["headingLink","trait-对象执行动态分发"],["heading","trait 对象执行动态分发"],["body","\n\n"],["body","\n"],["body","当对泛型使用 trait bound 时编译器所进行单态化处理：编译器为每一个被泛型类型参数代替的具体类型生成了非泛型的函数和方法实现。"],["body","\n"],["body","\n"],["body","\n"],["body","单态化所产生的代码进行 静态分发（static dispatch）"],["body","\n"],["body","\n"],["body","\n"],["body","静态分发发生于编译器在编译时就知晓调用了什么方法的时候。这与 动态分发 （dynamic dispatch）相对，这时编译器在编译时无法知晓调用了什么方法。在动态分发的情况下，编译器会生成在运行时确定调用了什么方法的代码。"],["body","\n"],["body","\n\n"],["body","当使用 trait 对象时，Rust 必须使用动态分发"],["body","\n"],["headingLink","trait-对象要求对象安全"],["heading","Trait 对象要求对象安全"],["body","\n"],["body","只有 对象安全（object safe）的 trait 才可以组成 trait 对象"],["body","\n"],["body","如果一个 trait 中所有的方法有如下属性时，则该 trait 是对象安全的："],["body","\n\n"],["body","返回值类型不为 Self"],["body","\n"],["body","方法没有任何泛型类型参数"],["body","\n\n"],["body","一个 trait 的方法不是对象安全的例子是标准库中的 Clone trait。Clone trait 的 clone 方法的参数签名看起来像这样："],["body","\n"],["body","#![allow(unused)]\nfn main() {\npub trait Clone {\n    fn clone(&self) -> Self;\n}\n}"],["body","\n"],["headingLink","高级trait"],["heading","高级Trait"],["body","\n"],["headingLink","trait中的关联类型"],["heading","trait中的关联类型"],["body","\n"],["body","干什么用的?"],["body","\n\n"],["body","提供类似泛型的作用"],["body","\n"],["body","提供迭代的子类型"],["body","\n"],["body","Item 是一个占位类型,在编译时期,会根据具体的实现类去替换"],["body","\n\n"],["body","怎么使用的?"],["body","\n"],["body","定义"],["body","\n"],["body","#![allow(unused)]\n\nfn main() {\npub trait Iterator {\n    type Item;\n\n    fn next(&mut self) -> Option<Self::Item>;\n}\n}"],["body","\n"],["body","使用"],["body","\n"],["body","#![allow(unused)]\nfn main() {\nmpl Iterator for Counter {\n    type Item = u32;\n\n    fn next(&mut self) -> Option<Self::Item> {\n}"],["body","\n"],["headingLink","为什么会要有定义这个而不使用泛型"],["heading","为什么会要有定义这个而不使用泛型?"],["body","\n"],["body","如果使用泛型 的话,每次调用 next方法都得指定泛型具体类型"],["body","\n"],["headingLink","默认类型参数"],["heading","默认类型参数"],["body","\n"],["headingLink","干嘛用的"],["heading","干嘛用的?"],["body","\n\n"],["body","当使用泛型类型参数时，可以为泛型指定一个默认的具体类型。如果默认类型就足够的话，这消除了为具体类型实现 trait 的需要"],["body","\n\n"],["headingLink","如何使用"],["heading","如何使用"],["body","\n"],["body","定义默认类型参数"],["body","\n"],["body","#![allow(unused)]\nfn main() {\n//定义,RHS参数默认使用 实现该Trait 的 类型 \ntrait Add<RHS=Self> {\n    type Output;\n    fn add(self, rhs: RHS) -> Self::Output;\n}\n\n}"],["body","\n"],["body","使用默认类型参数"],["body","\n"],["body","#![allow(unused)]\n\nfn main() {\n#[derive(Debug, PartialEq)]\nstruct Point {\n    x: i32,\n    y: i32,\n}\n\nimpl Add for Point {\n    type Output = Point;\n\n    fn add(self, other: Point) -> Point {\n        Point {\n            x: self.x + other.x,\n            y: self.y + other.y,\n        }\n    }\n}\n}"],["body","\n"],["body","使用自定义类型参数"],["body","\n"],["body","#![allow(unused)]\nfn main() {\nuse std::ops::Add;\n\nstruct Millimeters(u32);\nstruct Meters(u32);\n\nimpl Add<Meters> for Millimeters {\n    type Output = Millimeters;\n\n    fn add(self, other: Meters) -> Millimeters {\n        Millimeters(self.0 + (other.0 * 1000))\n    }\n}\n}"],["body","\n"],["body","为什么要引入这个"],["body","\n\n"],["body","一小部分实现的样板代码是不必要的，这样使用 trait 就更容易了,减少不必要的泛型类型"],["body","\n"],["body","扩展类型而不破坏现有代码。"],["body","\n\n"],["headingLink","完全限定语法"],["heading","完全限定语法"],["body","\n"],["headingLink","干嘛用的-1"],["heading","干嘛用的?"],["body","\n"],["body","#![allow(unused)]\n\nfn main() {\ntrait Pilot {\n    fn fly(&self);\n}\n\ntrait Wizard {\n    fn fly(&self);\n}\n\nstruct Human;\n\nimpl Pilot for Human {\n    fn fly(&self) {\n        println!(\"This is your captain speaking.\");\n    }\n}\n\nimpl Wizard for Human {\n    fn fly(&self) {\n        println!(\"Up!\");\n    }\n}\n\nimpl Human {\n    fn fly(&self) {\n        println!(\"*waving arms furiously*\");\n    }\n}\n}"],["body","\n\n"],["body","当一个类上实现了多个方法,编译器默认调用 使用 impl Type 中的方法"],["body","\n"],["body","使用 完全限定语法可以调用 其他 Trait的方法"],["body","\n\n"],["headingLink","如何使用-1"],["heading","如何使用?"],["body","\n"],["body","全语法"],["body","\n"],["body","<Type as Trait>::function(receiver_if_method, next_arg, ...);"],["body","\n"],["body","使用(类型定义见上)"],["body","\n"],["body","fn main() {\n    let person = Human;\n    Pilot::fly(&person);\n    Wizard::fly(&person);\n    person.fly();\n}"],["body","\n"],["body","使用2"],["body","\n"],["body","fn main() {\n    println!(\"A baby dog is called a {}\", <Dog as Animal>::baby_name());\n}"],["body","\n"],["headingLink","trait中的继承"],["heading","Trait中的继承"],["body","\n"],["headingLink","干什么用的"],["heading","干什么用的?"],["body","\n\n"],["body","\n"],["body","用于在另一个 trait 中使用某 trait 的功能"],["body","\n"],["body","\n"],["body","\n"],["body","Trait 定义指定了 要实现它就 必须先 实现 Display"],["body","\n"],["body","\n\n"],["headingLink","如何使用-2"],["heading","如何使用"],["body","\n"],["body","定义"],["body","\n"],["body","#![allow(unused)]\nfn main() {\nuse std::fmt;\n\ntrait OutlinePrint: fmt::Display {\n    fn outline_print(&self) {\n        let output = self.to_string();\n        let len = output.len();\n        println!(\"{}\", \"*\".repeat(len + 4));\n        println!(\"*{}*\", \" \".repeat(len + 2));\n        println!(\"* {} *\", output);\n        println!(\"*{}*\", \" \".repeat(len + 2));\n        println!(\"{}\", \"*\".repeat(len + 4));\n    }\n}\n}"],["body","\n"],["body","使用"],["body","\n"],["body","#![allow(unused)]\nfn main() {\nstruct Point {\n    x: i32,\n    y: i32,\n}\nimpl OutlinePrint for Point {}\n}"],["body","\n"],["headingLink","为什么要定义这个"],["heading","为什么要定义这个"],["body","\n\n"],["body","广义上来说是为了 重用代码"],["body","\n"],["body","狭义上 就是实现某一trait 需要依赖另一个 trait"],["body","\n"],["body","类似于继承的概念"],["body","\n\n"],["headingLink","解决为-外部类型-实现外部-trait"],["heading","解决为 外部类型 实现外部 Trait"],["body","\n"],["headingLink","背景"],["heading","背景"],["body","\n"],["body","外部类型或Trait"],["body","\n"],["body","即非本地的, 例如标准库,第三方库的类型或Trait"],["body","\n"],["body","孤儿规则 (orphan rule)"],["body","\n\n"],["body","不能为外部类型,实现外部trait"],["body","\n"],["body","避免本地库 影响第三方库的行为"],["body","\n\n"],["body","什么是newType 模式"],["body","\n"],["body","举例"],["body","\n"],["body","#![allow(unused)]\nfn main() {\n//常规定义\nstruct Person{\n\tage:u32,\n\taddress:String\n}\n//newType定义\nstruct Person{\n\tage:Year,\n\taddress:Address\n}\n\nstruct Year(u32);\nstruct Address(String);\n}"],["body","\n"],["body","说明"],["body","\n\n"],["body","\n"],["body","使用这个模式没有运行时性能惩罚，这个封装类型在编译时就被省略了。"],["body","\n"],["body","\n"],["body","\n"],["body","在编写代码时,很快就能知道 某个字段的具体 业务含义"],["body","\n"],["body","\n"],["body","\n"],["body","nwType模式可以在外部类型上实现外部Trait"],["body","\n"],["body","\n\n"],["headingLink","如何使用-3"],["heading","如何使用"],["body","\n"],["body","use std::fmt;\n\nstruct Wrapper(Vec<String>);\n\nimpl fmt::Display for Wrapper {\n    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n        write!(f, \"[{}]\", self.0.join(\", \"))\n    }\n}\n\nfn main() {\n    let w = Wrapper(vec![String::from(\"hello\"), String::from(\"world\")]);\n    println!(\"w = {}\", w);\n}"],["body","\n\n"],["body","\n"],["body","Display 的实现使用 self.0 来访问其内部的 Vec<T>"],["body","\n"],["body","\n"],["body","\n"],["body","此方法的缺点是，因为 Wrapper 是一个新类型，它没有定义于其值之上的方法；必须直接在 Wrapper 上实现 Vec<T> 的所有方法，这样就可以代理到self.0 上 "],["body","\n"],["body","\n"],["body","\n"],["body","如果希望新类型拥有其内部类型的每一个方法，为封装类型实现 Deref trait（第十五章 “通过 Deref trait 将智能指针当作常规引用处理” 部分讨论过）并返回其内部类型是一种解决方案。"],["body","\n"],["body","\n\n\n\n\n"],["body","\n\n                    "],["body","\n\n                    \n                \n            \n\n            \n\n        \n\n\n\n\n        \n\n\n\n        \n        \n        \n\n        \n\n\n    \n    \n"]],[["_relative_fp","3.rust/迭代与闭包.html"],["title","迭代与闭包 - 各项编程语言"],["body","\n    \n        \n        \n\n        \n        \n\n        \n        \n\n        \n        \n\n        \n\n        \n\n            \n                                \n                \n                    \n                        "],["body","\n                            \n                        "],["body","\n                        "],["body","\n                            \n                        "],["body","\n                        \n                            "],["body","Light"],["body","\n                            "],["body","Rust"],["body","\n                            "],["body","Coal"],["body","\n                            "],["body","Navy"],["body","\n                            "],["body","Ayu"],["body","\n                        \n                    \n\n                    "],["heading","各项编程语言"],["body","\n\n                    \n\n                    \n                \n\n\n                \n                \n\n                \n                    "],["body","\n                        \n\n"],["body","\n"],["body","\n\n"],["headingLink","闭包"],["heading","闭包"],["body","\n\n"],["body","\n"],["body","Rust 的 闭包（closures）是可以保存进变量或作为参数传递给其他函数的匿名函数。"],["body","\n"],["body","\n"],["body","\n"],["body","可以在一个地方创建闭包，然后在不同的上下文中执行闭包运算。"],["body","\n"],["body","\n"],["body","\n"],["body","不同于函数，闭包允许捕获调用者作用域中的值。我们将展示闭包的这些功能如何复用代码和自定义行为。"],["body","\n"],["body","\n\n"],["headingLink","闭包写法"],["heading","闭包写法"],["body","\n"],["body","#![allow(unused)]\nfn main() {\n//函数写法,捕获上下文变量\nfn  add_one_v1   (x: u32) -> u32 { x + 1 }\n//闭包完整写法\nlet add_one_v2 = |x: u32| -> u32 { x + 1 };\n//省略类型\nlet add_one_v3 = |x|             { x + 1 };\n//只有一行时省略大括号\nlet add_one_v4 = |x|               x + 1  ;\n}"],["body","\n"],["headingLink","带有泛型的-fn-traint闭包"],["heading","带有泛型的 Fn traint闭包"],["body","\n"],["body","#![allow(unused)]\nfn main() {\n//泛型 T 的定义是 Fn(u32)->u32, 接受一个int返回一个int. 使用了Fn的闭包\nstruct Cacher<T>\n    where T: Fn(u32) -> u32\n{\n    calculation: T,\n    value: Option<u32>,\n}\n}"],["body","\n"],["headingLink","闭包引用变量的场景"],["heading","闭包引用变量的场景"],["body","\n"],["headingLink","默认是不可变引用"],["heading","默认是不可变引用"],["body","\n"],["body","#![allow(unused)]\nfn main() {\n    let str = String::from(\"士大夫大师傅\");\n\n    let consume = || {\n        println!(\"{}\",str);\n    };\n    consume();\n    consume();\n    consume();\n    consume();\n}"],["body","\n"],["headingLink","可变借用"],["heading","可变借用"],["body","\n"],["body","\n"],["body","只能有一个可变借用"],["body","\n"],["body","\n"],["body","#![allow(unused)]\nfn main() {\npub fn test_closure_4(){\n    let mut str = String::from(\"士大夫大师傅\");\n    use std::mem;\n    let mut consume = || {\n        str.push('a');\n        println!(\"{}\",str);\n    };\n    consume();\n    consume();\n}\n//中途借用会报错\npub fn test_closure_4(){\n    let mut str = String::from(\"士大夫大师傅\");\n    use std::mem;\n    let mut consume = || {\n        str.push('a');\n        println!(\"{}\",str);\n    };\n    consume();\n    println!(\"{}\",str);\n    consume();\n}\n\n//借用完毕后可以重新使用\npub fn test_closure_4(){\n    let mut str = String::from(\"士大夫大师傅\");\n    use std::mem;\n    let mut consume = || {\n        str.push('a');\n        println!(\"{}\",str);\n    };\n    consume();\n    consume();\n    println!(\"{}\",str);\n}\n}"],["body","\n"],["headingLink","移动所有权到闭包"],["heading","移动所有权到闭包"],["body","\n"],["body","#![allow(unused)]\nfn main() {\n//除闭包之外的任何地方都不能访问\npub fn test_closure_4(){\n    let mut str = String::from(\"士大夫大师傅\");\n    use std::mem;\n    let mut consume = move || {\n        str.push('a');\n        println!(\"{}\",str);\n    };\n    consume();\n    consume();\n}\n}"],["body","\n"],["headingLink","从闭包中返回可变引用或不可变引用"],["heading","从闭包中返回可变引用或不可变引用"],["body","\n"],["body","#![allow(unused)]\nfn main() {\n//编译错误\npub fn test_closure_4(){\n    let mut str = String::from(\"士大夫大师傅\");\n    use std::mem;\n    let mut consume =  || -> &String{\n        str.push('a');\n        println!(\"{}\",str);\n        &str\n    };\n    consume();\n}\n}"],["body","\n"],["headingLink","从闭包中返回所有权"],["heading","从闭包中返回所有权"],["body","\n"],["body","\n"],["body","只能调用一次"],["body","\n"],["body","\n"],["body","#![allow(unused)]\nfn main() {\npub fn test_closure_4(){\n    let mut str = String::from(\"士大夫大师傅\");\n    use std::mem;\n    let mut consume = move || -> String{\n        str.push('a');\n        println!(\"{}\",str);\n        str\n    };\n    let string = consume();\n    println!(\"{}\",string);\n    //下面的consume会报错,因为所有权被返回出去了\n    consume();\n}\n}"],["body","\n"],["headingLink","从闭包中放弃所有权"],["heading","从闭包中放弃所有权"],["body","\n"],["body","\n"],["body","只能调用一次"],["body","\n"],["body","\n"],["body","#![allow(unused)]\n\nfn main() {\npub fn test_closure_4(){\n    let str = String::from(\"士大夫大师傅\");\n    use std::mem;\n    let consume = || {\n        println!(\"{}\",str);\n        mem::drop(str);\n    };\n    consume();\n    consume();\n    consume();\n    consume();\n}\n}"],["body","\n"],["headingLink","作为输入参数"],["heading","作为输入参数"],["body","\n\n"],["body","\n"],["body","虽然 Rust 无需类型说明就能在大多数时候完成变量捕获，但在编写函数时，这种模糊写法 是不允许的。"],["body","\n"],["body","\n"],["body","\n"],["body","当以闭包作为输入参数时，必须指出闭包的完整类型，它是通过使用以下 trait 中的一种来指定的"],["body","\n"],["body","\n\n"],["headingLink","闭包捕获环境的三种方式"],["heading","闭包捕获环境的三种方式"],["body","\n\n"],["body","Fn：表示捕获方式为通过引用（&T）的闭包"],["body","\n"],["body","FnMut：表示捕获方式为通过可变引用（&mut T）的闭包"],["body","\n"],["body","FnOnce：表示捕获方式为通过值（T）的闭包"],["body","\n\n"],["headingLink","闭包捕获变量的形式"],["heading","闭包捕获变量的形式"],["body","\n"],["body","在满足使用需求的前提下尽量以限制最多的方式捕获"],["body","\n"],["body","// 该函数将闭包作为参数并调用它。\nfn apply<F>(f: F) where\n    // 闭包没有输入值和返回值。\n    F: FnOnce() {\n    // ^ 试一试：将 `FnOnce` 换成 `Fn` 或 `FnMut`。\n\n    f();\n}\n\n// 输入闭包，返回一个 `i32` 整型的函数。\nfn apply_to_3<F>(f: F) -> i32 where\n    // 闭包处理一个 `i32` 整型并返回一个 `i32` 整型。\n    F: Fn(i32) -> i32 {\n\n    f(3)\n}\n\nfn main() {\n    use std::mem;\n    \n    let greeting = \"hello\";\n    // 不可复制的类型。\n    // `to_owned` 从借用的数据创建有所有权的数据。\n    let mut farewell = \"goodbye\".to_owned();\n\n    // 捕获 2 个变量：通过引用捕获 `greeting`，通过值捕获 `farewell`。\n    let diary = || {\n        // `greeting` 通过引用捕获，故需要闭包是 `Fn`。\n        println!(\"I said {}.\", greeting);\n\n        // 下文改变了 `farewell` ，因而要求闭包通过可变引用来捕获它。\n        // 现在需要 `FnMut`。\n        farewell.push_str(\"!!!\");\n        println!(\"Then I screamed {}.\", farewell);\n        println!(\"Now I can sleep. zzzzz\");\n\n        // 手动调用 drop 又要求闭包通过值获取 `farewell`。\n        // 现在需要 `FnOnce`。\n        mem::drop(farewell);\n    };\n\n    // 以闭包作为参数，调用函数 `apply`。\n    apply(diary);\n\n    // 闭包 `double` 满足 `apply_to_3` 的 trait 约束。\n    let double = |x| 2 * x;\n\n    println!(\"3 doubled: {}\", apply_to_3(double));\n}"],["body","\n"],["headingLink","作为输出参数"],["heading","作为输出参数"],["body","\n\n"],["body","\n"],["body","闭包作为输入参数是可能的，所以返回闭包作为输出参数（output parameter）也应该是 可能的。然而返回闭包类型会有问题，"],["body","\n"],["body","\n"],["body","\n"],["body","因为目前 Rust 只支持返回具体（非泛型）的 类型。按照定义，匿名的闭包的类型是未知的，所以只有使用impl Trait才能返回一个闭包。"],["body","\n"],["body","\n\n"],["body","返回值的合法 trait 和前面的略有不同："],["body","\n\n"],["body","Fn：和前面的一样"],["body","\n"],["body","FnMut：和前面的一样"],["body","\n"],["body","FnOnce：不太一样。总之现在你需要返回 [FnBox][fnbox] 类型，目前该类型还是不稳定的。这个情况估计将来会改进。"],["body","\n\n"],["body","除此之外，还必须使用 move 关键字，它表明所有的捕获都是通过值进行的。这是必须 的，因为在函数退出时，任何通过引用的捕获都被丢弃，在闭包中留下无效的引用。"],["body","\n"],["body","fn create_fn() -> impl Fn() {\n    let text = \"Fn\".to_owned();\n\n    move || println!(\"This is a: {}\", text)\n}\n\nfn create_fnmut() -> impl FnMut() {\n    let text = \"FnMut\".to_owned();\n\n    move || println!(\"This is a: {}\", text)\n}\n\nfn main() {\n    let fn_plain = create_fn();\n    let mut fn_mut = create_fnmut();\n\n    fn_plain();\n    fn_mut();\n}"],["body","\n"],["headingLink","迭代"],["heading","迭代"],["body","\n"],["headingLink","定义"],["heading","定义"],["body","\n"],["body","\n"],["body","迭代器都实现了一个叫做 Iterator 的定义于标准库的 trait"],["body","\n"],["body","\n"],["body","#![allow(unused)]\nfn main() {\npub trait Iterator {\n    type Item;\n\n    fn next(&mut self) -> Option<Self::Item>;\n\n    // 此处省略了方法的默认实现\n}\n}"],["body","\n\n"],["body","type Item 和 Self::Item，他们定义了 trait 的 关联类型（associated type）"],["body","\n"],["body","这个 Item 类型被用作 next 方法的返回值类型"],["body","\n\n"],["headingLink","使用"],["heading","使用"],["body","\n"],["body","#![allow(unused)]\nfn main() {\n#[test]\nfn iterator_demonstration() {\n    let v1 = vec![1, 2, 3];\n\n    let mut v1_iter = v1.iter();\n\n    assert_eq!(v1_iter.next(), Some(&1));\n    assert_eq!(v1_iter.next(), Some(&2));\n    assert_eq!(v1_iter.next(), Some(&3));\n    assert_eq!(v1_iter.next(), None);\n}\n}"],["body","\n"],["body","迭代器变量需要是可变的：在迭代器上调用 next 方法改变了迭代器中用来记录序列位置的状态"],["body","\n"],["headingLink","消费迭代器的方式"],["heading","消费迭代器的方式"],["body","\n"],["body","调用 next 方法的方法被称为 消费适配器（consuming adaptors）"],["body","\n"],["headingLink","sum"],["heading","SUM"],["body","\n"],["body","\n"],["body","　调用 sum 之后不再允许使用 v1_iter 因为调用 sum 时它会获取迭代器的所有权。"],["body","\n"],["body","\n"],["body","#![allow(unused)]\nfn main() {\n#[test]\nfn iterator_sum() {\n    let v1 = vec![1, 2, 3];\n\n    let v1_iter = v1.iter();\n\n    let total: i32 = v1_iter.sum();\n\n    assert_eq!(total, 6);\n}\n}"],["body","\n"],["headingLink","产生其他迭代器"],["heading","产生其他迭代器"],["body","\n"],["body","\n"],["body","迭代器适配器（iterator adaptors）"],["body","\n"],["body","\n\n"],["body","\n"],["body","允许我们将当前迭代器变为不同类型的迭代器"],["body","\n"],["body","\n"],["body","\n"],["body","可以链式调用多个迭代器适配器"],["body","\n"],["body","\n\n"],["body","#![allow(unused)]\nfn main() {\nlet v1: Vec<i32> = vec![1, 2, 3];\n\nv1.iter().map(|x| x + 1);\n\n// 迭代器适配器是惰性的,只有真正消费的了才会执行\n}"],["body","\n"],["headingLink","collect收集"],["heading","collect收集"],["body","\n"],["body","#![allow(unused)]\nfn main() {\nlet v2: Vec<_> = v1.iter().map(|x| x + 1).collect();\n}"],["body","\n"],["headingLink","filter过滤"],["heading","filter过滤"],["body","\n"],["body","#![allow(unused)]\nfn main() {\n    shoes.into_iter()\n        .filter(|s| s.size == shoe_size)\n        .collect()\n}"],["body","\n"],["headingLink","自定义迭代器"],["heading","自定义迭代器"],["body","\n"],["headingLink","第一步定义结构体"],["heading","第一步定义结构体"],["body","\n"],["body","#![allow(unused)]\nfn main() {\nstruct Counter{\n    counter:i32,\n    range:i32\n}\n}"],["body","\n"],["headingLink","第二步实现构造函数"],["heading","第二步实现构造函数"],["body","\n"],["body","#![allow(unused)]\nfn main() {\nimpl Counter{\n    fn new(range:i32)->Counter{\n        Counter{\n            counter:0,\n            range\n        }\n    }\n}\n}"],["body","\n"],["headingLink","第三步实现迭代器"],["heading","第三步实现迭代器"],["body","\n"],["body","#![allow(unused)]\nfn main() {\nimpl Iterator for Counter{\n    type Item = i32;\n\n    fn next(&mut self) -> Option<Self::Item> {\n        if self.counter >= self.range {\n            None\n        }else{\n            self.counter+=1;\n            Some(self.counter)\n        }\n    }\n}\n}"],["body","\n"],["headingLink","第四步使用"],["heading","第四步使用"],["body","\n"],["body","#![allow(unused)]\nfn main() {\n    let counter1 = Counter::new(10);\n    let counter2 = Counter::new(11);\n    let counter3 = Counter::new(12);\n\n    counter1.zip(counter2.skip(1)).zip(counter3.skip(2)).for_each(|((x,y),z)|{\n        println!(\"x={},y={},z={}\",x,y,z);\n    });\n}"],["body","\n"],["headingLink","使用迭代器读取命令行"],["heading","使用迭代器读取命令行"],["body","\n"],["body","#![allow(unused)]\nfn main() {\nuse std::env;\n\npub fn test_iter() {\n    env::args().for_each(|e|{\n        println!(\"{}\",e)\n    })\n}\n}"],["body","\n"],["body","#![allow(unused)]\nfn main() {\n // 函数式的写法\n    let sum_of_squared_odd_numbers: u32 =\n        (0..).map(|n| n * n)             // 所有自然数取平方\n             .take_while(|&n| n < upper) // 取小于上限的\n             .filter(|&n| is_odd(n))     // 取奇数\n             .fold(0, |sum, i| sum + i); // 最后加起来\n    println!(\"functional style: {}\", sum_of_squared_odd_numbers);\n}"],["body","\n\n\n\n"],["body","\n\n                    "],["body","\n\n                    \n                \n            \n\n            \n\n        \n\n\n\n\n        \n\n\n\n        \n        \n        \n\n        \n\n\n    \n    \n"]],[["_relative_fp","3.rust/2所有权.html"],["title","2所有权 - 各项编程语言"],["body","\n    \n        \n        \n\n        \n        \n\n        \n        \n\n        \n        \n\n        \n\n        \n\n            \n                                \n                \n                    \n                        "],["body","\n                            \n                        "],["body","\n                        "],["body","\n                            \n                        "],["body","\n                        \n                            "],["body","Light"],["body","\n                            "],["body","Rust"],["body","\n                            "],["body","Coal"],["body","\n                            "],["body","Navy"],["body","\n                            "],["body","Ayu"],["body","\n                        \n                    \n\n                    "],["heading","各项编程语言"],["body","\n\n                    \n\n                    \n                \n\n\n                \n                \n\n                \n                    "],["body","\n                        \n\n"],["body","\n"],["body","\n\n"],["headingLink","认识所有权"],["heading","认识所有权"],["body","\n"],["body","\n"],["body","所有权（系统）是 Rust 最为与众不同的特性，它让 Rust 无需垃圾回收（garbage collector）即可保障内存安全。因此，理解 Rust 中所有权如何工作是十分重要的。本章，我们将讲到所有权以及相关功能：借用、slice 以及 Rust 如何在内存中布局数据。"],["body","\n"],["body","\n"],["body","变量的所有权总是遵循相同的模式：将值赋给另一个变量时移动它"],["body","\n"],["headingLink","所有权"],["heading","所有权"],["body","\n"],["headingLink","规则"],["heading","规则"],["body","\n\n"],["body","Rust 中的每一个值都有一个被称为其 所有者（owner）的变量。"],["body","\n"],["body","值在任一时刻有且只有一个所有者。"],["body","\n"],["body","当所有者（变量）离开作用域，这个值将被丢弃。"],["body","\n\n"],["headingLink","变量作用域"],["heading","变量作用域"],["body","\n"],["body","\n"],["body","变量 s 绑定到了一个字符串字面值，这个字符串值是硬编码进程序代码中的。这个变量从声明的点开始直到当前 作用域 结束时都是有效的"],["body","\n"],["body","\n"],["body","{                      // s 在这里无效, 它尚未声明\n    let s = \"hello\";   // 从此处起，s 是有效的\n\n    // 使用 s\n}                      // 此作用域已结\n"],["body","\n"],["headingLink","string类型"],["heading","String类型"],["body","\n"],["body","// 这两个冒号（::）是运算符，允许将特定的 from 函数置于 String 类型的命名空间（namespace）\nlet s = String::from(\"hello\");\n"],["body","\n"],["body","内存在拥有它的变量离开作用域后就被自动释放。下面是示例 4-1 中作用域例子的一个使用 String 而不是字符串字面值的版本："],["body","\n"],["body","这是一个将 String 需要的内存返回给操作系统的很自然的位置：当 s 离开作用域的时候。当变量离开作用域，Rust 为我们调用一个特殊的函数。这个函数叫做 drop，在这里 String 的作者可以放置释放内存的代码。Rust 在结尾的 } 处自动调用 drop。"],["body","\n"],["headingLink","变量与数据交互的方式"],["heading","变量与数据交互的方式"],["body","\n"],["headingLink","移动"],["heading","移动"],["body","\n"],["body","//基础类型是 移动\nlet x = 5;\nlet y = x;\n"],["body","\n"],["body","引用类型的移动"],["body","\n"],["body","#![allow(unused)]\n\nfn main() {\nlet s1 = String::from(\"hello\");\nlet s2 = s1; //赋值给s1之后s1不在有效,编译器禁止使用 s1\n}"],["body","\n"],["headingLink","克隆"],["heading","克隆"],["body","\n"],["body","#![allow(unused)]\nfn main() {\nlet s1 = String::from(\"hello\");\nlet s2 = s1.clone();\n\nprintln!(\"s1 = {}, s2 = {}\", s1, s2);\n}"],["body","\n\n"],["body","\n"],["body","Rust 有一个叫做 Copy trait 的特殊注解,可以用在类似整型这样的存储在栈上的类型上"],["body","\n"],["body","\n"],["body","\n"],["body","如果一个类型拥有 Copy trait，一个旧的变量在将其赋值给其他变量后仍然可用"],["body","\n"],["body","\n"],["body","\n"],["body","Rust 不允许自身或其任何部分实现了 Drop trait 的类型使用 Copy trait"],["body","\n"],["body","\n"],["body","\n"],["body","要学习如何为你的类型增加 Copy 注解，请阅读附录 C 中的 “可派生的 trait”。"],["body","\n"],["body","\n\n"],["body","任何简单标量值的组合可以是 Copy 的，不需要分配内存或某种形式资源的类型是 Copy 的。如下是一些 Copy 的类型："],["body","\n\n"],["body","所有整数类型，比如 u32。"],["body","\n"],["body","布尔类型，bool，它的值是 true 和 false。"],["body","\n"],["body","所有浮点数类型，比如 f64。"],["body","\n"],["body","字符类型，char。"],["body","\n"],["body","元组，当且仅当其包含的类型也都是 Copy 的时候。比如，(i32, i32) 是 Copy 的，但 (i32, String) 就不是。"],["body","\n\n"],["headingLink","所有权与函数"],["heading","所有权与函数"],["body","\n"],["body","\n"],["body","将值传递给函数在语义上与给变量赋值相似。向函数传递值可能会移动或者复制，就像赋值语句一样。"],["body","\n"],["body","\n"],["body","fn main() {\n    let s = String::from(\"hello\");  // s 进入作用域\n\n    takes_ownership(s);             // s 的值移动到函数里 ...\n                                    // ... 所以到这里不再有效\n\n    let x = 5;                      // x 进入作用域\n\n    makes_copy(x);                  // x 应该移动函数里，\n                                    // 但 i32 是 Copy 的，所以在后面可继续使用 x\n\n} // 这里, x 先移出了作用域，然后是 s。但因为 s 的值已被移走，\n  // 所以不会有特殊操作\n\nfn takes_ownership(some_string: String) { // some_string 进入作用域\n    println!(\"{}\", some_string);\n} // 这里，some_string 移出作用域并调用 `drop` 方法。占用的内存被释放\n\nfn makes_copy(some_integer: i32) { // some_integer 进入作用域\n    println!(\"{}\", some_integer);\n} // 这里，some_integer 移出作用域。不会有特殊操作\n"],["body","\n"],["headingLink","引用与借用"],["heading","引用与借用"],["body","\n"],["headingLink","引用与借用-1"],["heading","引用与借用"],["body","\n"],["body","fn main() {\n    let s1 = String::from(\"hello\");\n\n    let len = calculate_length(&s1);\n\n    println!(\"The length of '{}' is {}.\", s1, len);\n}\n\nfn calculate_length(s: &String) -> usize {\n    s.len()\n}"],["body","\n"],["body","其次，注意我们传递 &s1 给 calculate_length，同时在函数定义中，我们获取 &String 而不是 String。"],["body","\n"],["body","与使用 & 引用相反的操作是 解引用（dereferencing），它使用解引用运算符，*。我们将会在第八章遇到一些解引用运算符，并在第十五章详细讨论解引用。"],["body","\n"],["body","同理，函数签名使用 & 来表明参数 s 的类型是一个引用。让我们增加一些解释性的注释："],["body","\n"],["body","#![allow(unused)]\nfn main() {\nfn calculate_length(s: &String) -> usize { // s 是对 String 的引用\n    s.len()\n} // 这里，s 离开了作用域。但因为它并不拥有引用值的所有权，\n  // 所以什么也不会发生\n}"],["body","\n"],["body","我们将获取引用作为函数参数称为 借用（borrowing）。"],["body","\n"],["body","正如变量默认是不可变的，引用也一样。（默认）不允许修改引用的值\n"],["body","\n"],["headingLink","可变引用"],["heading","可变引用"],["body","\n"],["body","#![allow(unused)]\nfn main() {\nfn change(some_string: &mut String) {\n    some_string.push_str(\", world\");\n}\n}"],["body","\n\n"],["body","当有可变引用时 只能存在一个,其他的都会失效,不可用"],["body","\n\n"],["headingLink","悬垂引用"],["heading","悬垂引用"],["body","\n"],["body","#![allow(unused)]\nfn main() {\n//报错 s已经被释放了\nfn dangle() -> &String {\n    let s = String::from(\"hello\");\n\n    &s\n}\n//正确,所有权被移动出去，所以没有值被释放\nfn no_dangle() -> String {\n    let s = String::from(\"hello\");\n\n    s\n}\n}"],["body","\n\n"],["body","在任意给定时间，要么 只能有一个可变引用，要么 只能有多个不可变引用。"],["body","\n"],["body","引用必须总是有效的。"],["body","\n\n"],["headingLink","slice引用"],["heading","slice引用"],["body","\n"],["body","\n"],["body","slice 允许你引用集合中一段连续的元素序列，而不用引用整个集合。"],["body","\n"],["body","拥有某值的不可变引用时，就不能再获取一个可变引用"],["body","\n"],["body","\n"],["body","字符串slice"],["body","\n"],["body","#![allow(unused)]\n\nfn main() {\nlet s = String::from(\"hello world\");\nlet hello = &s[0..5];\nlet world = &s[6..11];\n}"],["body","\n"],["body","range 语法"],["body","\n"],["body","#![allow(unused)]\nfn main() {\nlet s = String::from(\"hello\");\n\nlet slice = &s[0..2];\nlet slice = &s[..2];\n\nlet slice = &s[0..len];\nlet slice = &s[..];\n}"],["body","\n\n\n\n"],["body","\n\n                    "],["body","\n\n                    \n                \n            \n\n            \n\n        \n\n\n\n\n        \n\n\n\n        \n        \n        \n\n        \n\n\n    \n    \n"]],[["_relative_fp","3.rust/rust面向对象特性.html"],["title","rust面向对象特性 - 各项编程语言"],["body","\n    \n        \n        \n\n        \n        \n\n        \n        \n\n        \n        \n\n        \n\n        \n\n            \n                                \n                \n                    \n                        "],["body","\n                            \n                        "],["body","\n                        "],["body","\n                            \n                        "],["body","\n                        \n                            "],["body","Light"],["body","\n                            "],["body","Rust"],["body","\n                            "],["body","Coal"],["body","\n                            "],["body","Navy"],["body","\n                            "],["body","Ayu"],["body","\n                        \n                    \n\n                    "],["heading","各项编程语言"],["body","\n\n                    \n\n                    \n                \n\n\n                \n                \n\n                \n                    "],["body","\n                        \n\n"],["body","\n"],["body","\n\n"],["headingLink","简述"],["heading","简述"],["body","\n"],["body","关于一个语言被称为面向对象所需的功能，Rust 被很多不同的编程范式影响，包括面向对象编程，函数式编程的特性"],["body","\n"],["headingLink","对象包含数据和行为"],["heading","对象包含数据和行为"],["body","\n"],["body","面向对象的程序是由对象组成的。一个 对象 包含数据和操作这些数据的过程。这些过程通常被称为 方法 或 操作。"],["body","\n"],["body","在这个定义下，Rust 是面向对象的：结构体和枚举包含数据而 impl 块提供了在结构体和枚举之上的方法。"],["body","\n"],["body","虽然带有方法的结构体和枚举并不被 称为 对象，但是他们提供了与对象相同的功能，"],["body","\n"],["headingLink","封装隐藏了实现细节"],["heading","封装隐藏了实现细节"],["body","\n"],["body","对象的实现细节不能被使用对象的代码获取到，所以唯一与对象交互的方式是通过对象提供的公有 API"],["body","\n"],["body","使用对象的代码无法深入到对象内部并直接改变数据或者行为"],["body","\n"],["body","封装使得改变和重构对象的内部时无需改变使用对象的代码"],["body","\n"],["body","可以使用 pub 关键字来决定模块、类型、函数和方法是公有的，而默认情况下其他一切都是私有的"],["body","\n"],["body","#![allow(unused)]\nfn main() {\npub struct AveragedCollection {\n    list: Vec<i32>,\n    average: f64,\n}\n}"],["body","\n"],["body","注意，结构体自身被标记为 pub，这样其他代码就可以使用这个结构体，但是在结构体内部的字段仍然是私有的。这是非常重要的，因为我们希望保证变量被增加到列表或者被从列表删除时，也会同时更新平均值。可以通过在结构体上实现 add、remove 和 average 方法来做到这一点，"],["body","\n"],["body","#![allow(unused)]\n\nfn main() {\nimpl AveragedCollection {\n    pub fn add(&mut self, value: i32) {\n        self.list.push(value);\n        self.update_average();\n    }\n\n    pub fn remove(&mut self) -> Option<i32> {\n        let result = self.list.pop();\n        match result {\n            Some(value) => {\n                self.update_average();\n                Some(value)\n            },\n            None => None,\n        }\n    }\n\n    pub fn average(&self) -> f64 {\n        self.average\n    }\n\n    fn update_average(&mut self) {\n        let total: i32 = self.list.iter().sum();\n        self.average = total as f64 / self.list.len() as f64;\n    }\n}\n}"],["body","\n"],["headingLink","继承作为类型系统与代码共享"],["heading","继承，作为类型系统与代码共享"],["body","\n\n"],["body","\n"],["body","一个对象可以定义为继承另一个对象的定义，这使其可以获得父对象的数据和行为，而无需重新定义。"],["body","\n"],["body","\n"],["body","\n"],["body","如果一个语言必须有继承才能被称为面向对象语言的话，那么 Rust 就不是面向对象的"],["body","\n"],["body","\n"],["body","\n"],["body","选择继承有两个主要的原因。"],["body","\n\n"],["body","第一个是为了重用代码：一旦为一个类型实现了特定行为，继承可以对一个不同的类型重用这个实现,相反 Rust 代码可以使用默认 trait 方法实现来进行共享"],["body","\n"],["body","第二个使用继承的原因与类型系统有关：表现为子类型可以用于父类型被使用的地方。这也被称为 多态（polymorphism），这意味着如果多种对象共享特定的属性，则可以相互替代使用。"],["body","\n\n"],["body","\n\n"],["body","为什么不用继承"],["body","\n\n"],["body","\n"],["body","近来继承作为一种语言设计的解决方案在很多语言中失宠了，因为其时常带有共享多于所需的代码的风险。"],["body","\n"],["body","\n"],["body","\n"],["body","子类不应总是共享其父类的所有特征，但是继承却始终如此。如此会使程序设计更为不灵活，并引入无意义的子类方法调用，或由于方法实际并不适用于子类而造成错误的可能性。某些语言还只允许子类继承一个父类，进一步限制了程序设计的灵活性。"],["body","\n"],["body","\n\n"],["body","因为这些原因，Rust 选择了一个不同的途径，使用 trait 对象而不是继承。让我们看一下 Rust 中的 trait 对象是如何实现多态的。"],["body","\n"],["headingLink","为使用不同类型的值而设计的-trait-对象"],["heading","为使用不同类型的值而设计的 trait 对象"],["body","\n"],["headingLink","gui的component-与draw设计"],["heading","GUI的Component 与Draw设计"],["body","\n"],["headingLink","状态模式的设计"],["heading","状态模式的设计"],["body","\n\n\n\n"],["body","\n\n                    "],["body","\n\n                    \n                \n            \n\n            \n\n        \n\n\n\n\n        \n\n\n\n        \n        \n        \n\n        \n\n\n    \n    \n"]],[["_relative_fp","3.rust/Rust中的Sizedness.html"],["title","Rust中的Sizedness - 各项编程语言"],["body","\n    \n        \n        \n\n        \n        \n\n        \n        \n\n        \n        \n\n        \n\n        \n\n            \n                                \n                \n                    \n                        "],["body","\n                            \n                        "],["body","\n                        "],["body","\n                            \n                        "],["body","\n                        \n                            "],["body","Light"],["body","\n                            "],["body","Rust"],["body","\n                            "],["body","Coal"],["body","\n                            "],["body","Navy"],["body","\n                            "],["body","Ayu"],["body","\n                        \n                    \n\n                    "],["heading","各项编程语言"],["body","\n\n                    \n\n                    \n                \n\n\n                \n                \n\n                \n                    "],["body","\n                        \n\n"],["body","\n"],["body","\n\n"],["headingLink","介绍"],["heading","介绍"],["body","\n"],["body","本文将会探讨 从  已知大小类型(sized type)、未知大小类型(unsized type)、在到 零大小类型(zero type)等各种类型的 sizedness，并同时对他们的优点 、缺点、痛点、以及解决方法进行评估"],["body","\n"],["body","以下是文中的术语表格"],["body","\n"],["body","术语"],["body","含义"],["body","\n"],["body","sizedness"],["body","不同大小类型的特性"],["body","\n"],["body","sized type"],["body","编译期可以确定大小的类型"],["body","\n"],["body","unsized type or DST"],["body","动态大小类型"],["body","\n"],["body","?sized type"],["body","可能确定也可能不确定的大小类型"],["body","\n"],["body","unsized coercion"],["body","从确定大小类型转换为 不确定大小类型"],["body","\n"],["body","zst"],["body","零大小类型"],["body","\n"],["body","width"],["body","指针的宽度的单位"],["body","\n"],["body","thin point|single width point"],["body","1个宽度的指针"],["body","\n"],["body","fat point | double-width point"],["body","2个宽度的指针"],["body","\n"],["body","slice"],["body","数据的动态大小视图"],["body","\n\n\n"],["headingLink","sizedness"],["heading","Sizedness"],["body","\n\n"],["body","如果一个类型 的大小能在编译期确定，也称作 sizedType,那确定类型大小的类型就能在 栈上分配空间。数据的传递也就能通过 值传递或者引用传递的方式"],["body","\n"],["body","如果一个类型的大小不能在编译期确定，也叫作，dst、动态类型大小。无法在栈上分配空间。数据的传递只能通过引用传递"],["body","\n\n"],["body","以下是一些 sized type或者 unsized type"],["body","\n\n"],["body","基本类型"],["body","\n"],["body","元祖类型"],["body","\n"],["body","结构体类型"],["body","\n"],["body","数组类型：固定数组类型、不固定数组类型"],["body","\n"],["body","枚举类型"],["body","\n"],["body","普通指针、字符串指针、数组指针"],["body","\n"],["body","trait类型"],["body","\n"],["body","自定义 unsized类型"],["body","\n\n"],["body","use std::mem::size_of;\n\nfn main() {\n    // primitives\n    assert_eq!(4, size_of::<i32>());\n    assert_eq!(8, size_of::<f64>());\n\n    // tuples\n    assert_eq!(8, size_of::<(i32, i32)>());\n\n    // arrays\n    assert_eq!(0, size_of::<[i32; 0]>());\n    assert_eq!(12, size_of::<[i32; 3]>());\n\n    struct Point {\n        x: i32,\n        y: i32,\n    }\n\n    // structs\n    assert_eq!(8, size_of::<Point>());\n\n    // enums\n    assert_eq!(8, size_of::<Option<i32>>());\n\n    // get pointer width, will be\n    // 4 bytes wide on 32-bit targets or\n    // 8 bytes wide on 64-bit targets\n    const WIDTH: usize = size_of::<&()>();\n\n    // pointers to sized types are 1 width\n    assert_eq!(WIDTH, size_of::<&i32>());\n    assert_eq!(WIDTH, size_of::<&mut i32>());\n    assert_eq!(WIDTH, size_of::<Box<i32>>());\n    assert_eq!(WIDTH, size_of::<fn(i32) -> i32>());\n\n    const DOUBLE_WIDTH: usize = 2 * WIDTH;\n\n    // unsized struct\n    struct Unsized {\n        unsized_field: [i32],\n    }\n\n    // pointers to unsized types are 2 widths\n    assert_eq!(DOUBLE_WIDTH, size_of::<&str>()); // slice\n    assert_eq!(DOUBLE_WIDTH, size_of::<&[i32]>()); // slice\n    assert_eq!(DOUBLE_WIDTH, size_of::<&dyn ToString>()); // trait object\n    assert_eq!(DOUBLE_WIDTH, size_of::<Box<dyn ToString>>()); // trait object\n    assert_eq!(DOUBLE_WIDTH, size_of::<&Unsized>()); // user-defined unsized type\n\n    // unsized types\n    size_of::<str>(); // compile error\n    size_of::<[i32]>(); // compile error\n    size_of::<dyn ToString>(); // compile error\n    size_of::<Unsized>(); // compile error\n}"],["body","\n"],["headingLink","protips"],["heading","proTIPS"],["body","\n\n"],["body","rust中 指向数组的动态大小视图 dynamic sized view 被称为 切片（slice）,&str是字符串切片、&[i32] 是数组切片"],["body","\n"],["body","切片是双宽度的、因为它们存储了 指向 数组的 指针 和 数组中元素的个数"],["body","\n"],["body","trait对象是 双宽度的，因为它们 存储了 指向 数据的指针 和 指向  vnode的指针"],["body","\n"],["body","不确定大小的结构体是 双宽的。因为 它拥有 指针指向 结构体的指针 和 结构体大小的size"],["body","\n"],["body","不确定大小的结构体 只能拥有 一个 不确定大小的 字段 且 只能是 结构体最后一个字段"],["body","\n\n"],["body","总结"],["body","\n\n"],["body","确定大小的 类型可以 分配在 栈上。可以通过值传递"],["body","\n"],["body","不确定大小的类型不能分配在栈上，且必须通过 引用传递"],["body","\n"],["body","不确定大小的类型是双宽度的，除了要记录 指针位置外，还需要记录 数据量大小、或者 vnodetable等"],["body","\n\n"],["headingLink","trait对象trait-objects"],["heading","Trait对象(Trait Objects)"],["body","\n"],["body","Traits默认是?Sized。"],["body","\n"],["body","#![allow(unused)]\nfn main() {\ntrait Trait: ?Sized {}\n\n\ntrait Trait where Self: ?Sized {}\n}"],["body","\n\n"],["body","\n"],["body","默认情况下，trait允许self可能是一个不确定大小类型(unsized type)"],["body","\n"],["body","\n"],["body","\n"],["body","不确定大小类型无法 通过 值传递，所以没法以传值的方式 接收 或返回 self "],["body","\n"],["body","\n"],["body","\n"],["body","但是是 可以编译，如果一旦为这个方法 提供默认的实现，或者实现其他的 都会编译错误"],["body","\n"],["body","\n"],["body","\n"],["body","可以通过 引用传递方式 传递 self"],["body","\n"],["body","#![allow(unused)]\nfn main() {\ntrait Trait {\n    fn method(&self) {} // compiles\n}\n\nimpl Trait for str {\n    fn method(&self) {} // compiles\n}\n}"],["body","\n"],["body","\n"],["body","\n"],["body","可以有更细粒度和更精确的选择 来标记 单个方法 为 Sized"],["body","\n"],["body","trait Trait {\n    fn method(self) where Self: Sized {}\n}\n\nimpl Trait for str {} // compiles!?\n\nfn main() {\n    \"str\".method(); // compile error\n}"],["body","\n"],["body","\n\n"],["headingLink","trait对象的限制trait-object-limitations"],["heading","Trait对象的限制(Trait Object Limitations)"],["body","\n"],["body","即使一个trait是对象安全的，仍然存在sizeness相关的边界情况，这些情况限制了什么类型可以转成trait对象以及多少种trait和什么样的trait可以通过一个trait对象来表示。"],["body","\n"],["headingLink","不能把不确定大小类型unsized-type转成trait对象"],["heading","不能把不确定大小类型(unsized type)转成trait对象"],["body","\n"],["body","类型"],["body","指向数据的指针"],["body","数据长度"],["body","指向Vtable的指针"],["body","总长度"],["body","\n"],["body","&String"],["body","有"],["body","没有"],["body","没有"],["body","1w"],["body","\n"],["body","&str"],["body","有"],["body","有"],["body","没有"],["body","2w"],["body","\n"],["body","&String as & dyn ToString"],["body","有"],["body","没有"],["body","有"],["body","2w"],["body","\n"],["body","&str as & &dyn ToString"],["body","有"],["body","有"],["body","有"],["body","3w"],["body","\n\n\n"],["headingLink","不能创建多trait的对象cannot-create-multi-trait-objects"],["heading","不能创建多Trait的对象(Cannot create Multi-Trait Objects)"],["body","\n"],["body","#![allow(unused)]\nfn main() {\ntrait Trait {}\ntrait Trait2 {}\n\nfn function(t: &(dyn Trait + Trait2)) {}\n}"],["body","\n\n"],["body","一个trait对象指针是双宽度的:存储一个指向数据的指针、和指向vttable的指针"],["body","\n"],["body","这里有 两个 Trait 就存在 指向 两个vtable的 指针  &(dyn Trait+Trait2) 就是三宽度 ，rust最多支持 两个宽度的指针"],["body","\n"],["body","像 Sync 与 Send 这样的 Trait不存在 方法，所以可以有多个"],["body","\n"],["body","解决办法是，借助第三个 Trait实现 上述 两个 Trait,但是也会存在 无法自动向上转型"],["body","\n\n"],["body","trait Trait {\n    fn method(&self) {}\n}\n\ntrait Trait2 {\n    fn method2(&self) {}\n}\n\ntrait Trait3: Trait + Trait2 {}\n\nimpl<T: Trait + Trait2> Trait3 for T {}\n\nstruct Struct;\nimpl Trait for Struct {}\nimpl Trait2 for Struct {}\n\nfn takes_trait(t: &dyn Trait) {}\nfn takes_trait2(t: &dyn Trait2) {}\n\nfn main() {\n    let t: &dyn Trait3 = &Struct;\n    takes_trait(t); // compile error\n    takes_trait2(t); // compile error\n}"],["body","\n\n"],["body","无法自动向上转型：只能显示向上转型"],["body","\n\n"],["body","trait Trait {}\ntrait Trait2 {}\n\ntrait Trait3: Trait + Trait2 {\n    fn as_trait(&self) -> &dyn Trait;\n    fn as_trait2(&self) -> &dyn Trait2;\n}\n\nimpl<T: Trait + Trait2> Trait3 for T {\n    fn as_trait(&self) -> &dyn Trait {\n        self\n    }\n    fn as_trait2(&self) -> &dyn Trait2 {\n        self\n    }\n}\n\nstruct Struct;\nimpl Trait for Struct {}\nimpl Trait2 for Struct {}\n\nfn takes_trait(t: &dyn Trait) {}\nfn takes_trait2(t: &dyn Trait2) {}\n\nfn main() {\n    let t: &dyn Trait3 = &Struct;\n    takes_trait(t.as_trait()); // compiles\n    takes_trait2(t.as_trait2()); // compiles\n}"],["body","\n"],["headingLink","关键点key-takeaway"],["heading","关键点(Key Takeaway)"],["body","\n\n"],["body","Rust不支持超过2个宽度的指针，所以"],["body","\n"],["body","我们不能够把不确定大小类型(unsized type)转换为trait对象"],["body","\n"],["body","我们不能有多trait对象，但是我们可以通过把多个trait合并到一个trait里来解决"],["body","\n\n"],["headingLink","用户定义的不确定大小类型"],["heading","用户定义的不确定大小类型"],["body","\n"],["body","#![allow(unused)]\nfn main() {\nstruct Unsized {\n  unsized_field: [i32],\n}\n}"],["body","\n\n"],["body","可以给结构体 定义一个不确定大小的字段 来定义一个不确定大小的类型"],["body","\n"],["body","不确定大小的结构体 只能有一个不确定大小字段"],["body","\n"],["body","使用一个双宽度 最多只能 追踪 一个 不确定大小字段"],["body","\n\n"],["body","如何实例化该 不确定大小类型："],["body","\n\n"],["body","\n"],["body","尽管如此，根据定义，Unsized总是不确定大小的，没有办法构造一个它的确定性大小版本。"],["body","\n"],["body","\n"],["body","\n"],["body","唯一的解决方法是把这个结构体变成泛型(generic)的，这样它就可以存在于确定性大小和不确定性大小的版本里。"],["body","\n"],["body","\n"],["body","\n"],["body","申明一个该 确定 大小类型 "],["body","\n"],["body","\n"],["body","\n"],["body","然后将其转化为 不确定大小类型"],["body","\n"],["body","\n\n"],["body","struct MaybeSized<T: ?Sized> {\n    maybe_sized: T,\n}\n\nfn main() {\n    // unsized coercion from MaybeSized<[i32; 3]> to MaybeSized<[i32]>\n    let ms: &MaybeSized<[i32]> = &MaybeSized { maybe_sized: [1, 2, 3] };\n}"],["body","\n\n"],["body","用户 定义 不确定大小的类型，目前没有什么使用场景，是一个不成熟的特性"],["body","\n"],["body","std::ffi::OsStr和std::path::Path是标准库里的两个不确定大小结构体"],["body","\n\n"],["headingLink","零大小类型zero-sized-types"],["heading","零大小类型(Zero-Sized Types)"],["body","\n"],["headingLink","单元类型unit-type"],["heading","单元类型(Unit Type)"],["body","\n"],["body","最常见的ZST 是单元类型，也见空元祖"],["body","\n\n"],["body","\n"],["body","所空块 {} 的计算结果为 () "],["body","\n"],["body","\n"],["body","\n"],["body","所有以 分号结尾的 也返回 ()"],["body","\n"],["body","\n"],["body","\n"],["body","没有明确返回类型的 也 返回 ()"],["body","\n"],["body","\n"],["body","\n"],["body","所有 ()都相等"],["body","\n"],["body","\n"],["body","\n"],["body","单元类型的 标准Trait实现"],["body","\n"],["body","#![allow(unused)]\nfn main() {\nuse std::cmp::Ordering;\n\nimpl Default for () {\n    fn default() {}\n}\n\nimpl PartialEq for () {\n    fn eq(&self, _other: &()) -> bool {\n        true\n    }\n    fn ne(&self, _other: &()) -> bool {\n        false\n    }\n}\n\nimpl Ord for () {\n    fn cmp(&self, _other: &()) -> Ordering {\n        Ordering::Equal\n    }\n}\n}"],["body","\n"],["body","\n"],["body","\n"],["body","编译器理解()是零大小类型并且会优化和()实例有关的交互。例如:一个Vec<()>永远不会执行堆分配，从Vec里推进(push)和弹出(pop)()只是对它里面的len字段进行增加或减少。"],["body","\n"],["body","\n\n"],["headingLink","用户定义的单元结构体user-defined-unit-structs"],["heading","用户定义的单元结构体(User-Defined Unit Structs)"],["body","\n"],["body","#![allow(unused)]\nfn main() {\nstruct Struct;\n}"],["body","\n"],["body","单元结构比()更有用的一些属性:"],["body","\n\n"],["body","可以为单元结构体实现 trait，而 空元祖 由于 孤儿规则 阻止"],["body","\n"],["body","单元结构体 可以赋予更有意义的名字"],["body","\n"],["body","单元结构体 默认是非 copy类型的"],["body","\n\n"],["headingLink","never-type"],["heading","Never Type"],["body","\n"],["body","！：它被叫做never类型是因为它表示永远不会产生任何值的计算。"],["body","\n"],["body","never类型不同于 () 它有一些有趣的属性"],["body","\n\n"],["body","! 可以被强制转化到任意类型"],["body","\n"],["body","无法创建 ！ 类型的实例"],["body","\n\n"],["body","#![allow(unused)]\nfn main() {\n// nice for quick prototyping\nfn example<T>(t: &[T]) -> Vec<T> {\n    unimplemented!() // ! coerced to Vec<T>\n}\n\nfn example2() -> i32 {\n    // we know this parse call will never fail\n    match \"123\".parse::<i32>() {\n        Some(num) => num,\n        None => unreachable!(), // ! coerced to i32\n    }\n}\n\nfn example3(bool: someCondition) -> &'static str {\n    if (!someCondition) {\n        panic!() // ! coerced to &str\n    } else {\n        \"str\"\n    }\n}\n}"],["body","\n"],["body","break，continue，和return表达式也有!类型："],["body","\n"],["body","#![allow(unused)]\nfn main() {\nfn example() -> i32 {\n    // we can set the type of x to anything here\n    // since the block never evaluates to any value\n    let x: String = {\n        return 123 // ! coerced to String\n    };\n}\n\nfn example2(nums: &[i32]) -> Vec<i32> {\n    let mut filtered = Vec::new();\n    for num in nums {\n        filtered.push(\n            if *num < 0 {\n                break // ! coerced to i32\n            } else if *num % 2 == 0 {\n                *num\n            } else {\n                continue // ! coerced to i32\n            }\n        );\n    }\n    filtered\n}\n}"],["body","\n"],["body","!的第二个有趣的属性让我们能够让我们在类型级别把特定的状态标记为不可能。让我们看看下面的函数:"],["body","\n"],["body","#![allow(unused)]\nfn main() {\nfn function() -> Result<Success, Error>;\n}"],["body","\n"],["body","#![allow(unused)]\nfn main() {\n//永远也不会失败\nfn function() -> Result<Success, !>;\n//永远也不会成功\nfn function() -> Result<!, Error>;\n}"],["body","\n"],["body","keypoint"],["body","\n\n"],["body","!可以被强制转到到任何其他的类型"],["body","\n"],["body","无法创建!的实例，我们可以使用这一点在类型级别把一个状态标记为不可能的"],["body","\n\n"],["headingLink","用户定义的伪never类型user-defined-pseudo-never-types"],["heading","用户定义的伪Never类型(User-Defined Pseudo Never Types)"],["body","\n"],["body","尽管定义一个能够强制转换到任意其他类型的类型是不可能的"],["body","\n"],["body","但是定义一个无法创建实例的类型是有可能的，例如一个没有任何variant的enum:"],["body","\n"],["body","#![allow(unused)]\nfn main() {\nenum Void {}\n}"],["body","\n"],["body","#![allow(unused)]\nfn main() {\nenum Void {}\n\n// example 1\nimpl FromStr for String {\n    type Err = Void;\n    fn from_str(s: &str) -> Result<String, Self::Err> {\n        Ok(String::from(s))\n    }\n}\n\n// example 2\nfn run_server() -> Result<Void, ConnectionError> {\n    loop {\n        let (request, response) = get_request()?;\n        let result = request.process();\n        response.send(result);\n    }\n}\n}"],["body","\n"],["body","这是Rust标准库里使用的技术，因为String的FromStr实现里的Err类型是std::convert::Infallible， 其定义如下:"],["body","\n"],["body","#![allow(unused)]\nfn main() {\npub enum Infallible {}\n}"],["body","\n"],["headingLink","phantomdata"],["heading","PhantomData"],["body","\n"],["body","PhantomData是一个零大小标记结构体"],["body","\n"],["body","如果不想实现 Send Sync 这项的自动 trait 要么使用 feature 的 !  功能"],["body","\n"],["body","#![allow(unused)]\n#![feature(negative_impls)]\n\nfn main() {\n// this type is Send and Sync\nstruct Struct;\n\n// opt-out of Send trait\nimpl !Send for Struct {}\n\n// opt-out of Sync trait\nimpl !Sync for Struct {}\n}"],["body","\n"],["body","要么增加一个成员变量：是非 send或 sync的"],["body","\n"],["body","#![allow(unused)]\nfn main() {\nuse std::rc::Rc;\n\n// this type is not Send or Sync\nstruct Struct {\n    // adds 8 bytes to every instance\n    _not_send_or_sync: Rc<()>,\n}\n}"],["body","\n"],["body","但是这增加了 trait的大小"],["body","\n"],["body","针对上述的场景，可以使用 PhantomData"],["body","\n"],["body","#![allow(unused)]\nfn main() {\nuse std::rc::Rc;\nuse std::marker::PhantomData;\n\ntype NotSendOrSyncPhantom = PhantomData<Rc<()>>;\n\n// this type is not Send or Sync\nstruct Struct {\n    // adds no additional size to instances\n    _not_send_or_sync: NotSendOrSyncPhantom,\n}\n}"],["body","\n"],["body","关键点(Key Takeaway)"],["body","\n\n"],["body","PhantomData是一个零大小标记结构体，可以用于标记一个包含结构体为拥有特定的属性"],["body","\n\n"],["headingLink","总结conclusion"],["heading","总结(Conclusion)"],["body","\n\n"],["body","只有确定大小类型(sized type)的实例才可以放到栈上，也就是，可以通过传值的方式传递"],["body","\n"],["body","不确定大小类型(unsized tpe)的实例不能放到栈上而且必须通过传引用的方式传递"],["body","\n"],["body","指向不确定大小类型(unsized tpe)的指针是双宽度的，因为除了保存指向数据的指针外，还需要额外的比特位来追踪数据的长度或者指向一个vtable"],["body","\n"],["body","Sized是一个\"自动(auto)\"标记trait"],["body","\n"],["body","所有的泛型类型参数默认是被Sized自动约束"],["body","\n"],["body","如果我们有一个泛型函数，它接收隐于指针后的类型T为参数，例如&T，Box<T>，Rc<T>等，那么我们总是选择退出默认的Sized约束而选用T:?Sized约束"],["body","\n"],["body","利用切片和Rust的自动类型强制转换能够让我们写出灵活的API"],["body","\n"],["body","所有的trait默认都是?Sized"],["body","\n"],["body","对于impl Trait for dyn Trait，要求Trait: ?Sized"],["body","\n"],["body","我们可以在每个方法上要求Self:Sized"],["body","\n"],["body","由Sized约束的trait不能转为trait对象"],["body","\n"],["body","Rust不支持超过2个宽度的指针，因此"],["body","\n"],["body","我们不能把不确定大小类型转为trait对象"],["body","\n"],["body","我们不能有多trait对象，但是我们可以通过把多个trait合并到一个trait里来解决这个问题"],["body","\n"],["body","用户定义的不确定类型大小类型是个不成熟的特性，现在其局限性超过所能带来的益处"],["body","\n"],["body","ZST的所有实例都相等"],["body","\n"],["body","Rust编译器会去优化和ZST相关的交互"],["body","\n"],["body","!可以被强制转换为其他类型"],["body","\n"],["body","无法创建一个!的实例，我们可以利用这一点在类型级别把特定状态标记为不可能"],["body","\n"],["body","PhantomData是一个零大小标记结构体，可以用于把一个包含结构体标记为含有特定属性"],["body","\n\n"],["body","原文链接"],["body","\n"],["headingLink","rust-dyn-关键字"],["heading","Rust-dyn 关键字"],["body","\n"],["body","dyn是trait对象类型的前缀"],["body","\n"],["body","dyn关键字用于强调相关trait的方法是动态分配的。要以这种方式使用trait，它必须是“对象安全”的。"],["body","\n"],["body","与泛型参数或植入型特质不同，编译器不知道被传递的具体类型。也就是说，该类型已经被抹去"],["body","\n"],["body","因此，一个dyn Trait引用包含两个指针"],["body","\n"],["body","一个指针指向数据（例如，一个结构的实例）"],["body","\n"],["body","另一个指针指向方法调用名称与函数指针的映射（被称为虚拟方法表各vtable）"],["body","\n"],["body","impl trait 和 dyn trait 在Rust分别被称为静态分发和动态分发，即当代码涉及多态时，需要某种机制决定实际调动类型。"],["body","\n"],["body","每当在堆上分配内存时，Rust都会尝试尽可能明确。因此，如果你的函数以这种方式返回指向堆的trait指针，则需要使用dyn关键字编写返回类型，如示例2:"],["body","\n"],["body","#![allow(unused)]\nfn main() {\nfn random_animal(random_number: f64) -> Box<dyn Animal> {\n    if random_number < 0.5 {\n        Box::new(Sheep {})\n    } else {\n        Box::new(Cow {})\n    }\n}\n}"],["body","\n\n\n\n"],["body","\n\n                    "],["body","\n\n                    \n                \n            \n\n            \n\n        \n\n\n\n\n        \n\n\n\n        \n        \n        \n\n        \n\n\n    \n    \n"]],[["_relative_fp","3.rust/常见集合.html"],["title","常见集合 - 各项编程语言"],["body","\n    \n        \n        \n\n        \n        \n\n        \n        \n\n        \n        \n\n        \n\n        \n\n            \n                                \n                \n                    \n                        "],["body","\n                            \n                        "],["body","\n                        "],["body","\n                            \n                        "],["body","\n                        \n                            "],["body","Light"],["body","\n                            "],["body","Rust"],["body","\n                            "],["body","Coal"],["body","\n                            "],["body","Navy"],["body","\n                            "],["body","Ayu"],["body","\n                        \n                    \n\n                    "],["heading","各项编程语言"],["body","\n\n                    \n\n                    \n                \n\n\n                \n                \n\n                \n                    "],["body","\n                        \n\n"],["body","\n"],["body","\n\n"],["headingLink","vectort"],["heading","Vector<T>"],["body","\n"],["headingLink","新建vector"],["heading","新建Vector"],["body","\n"],["body","//新建一个空的 vector 来储存 i32 类型的值\n#![allow(unused)]\nfn main() {\nlet v: Vec<i32> = Vec::new();\n}"],["body","\n"],["body","使用宏"],["body","\n"],["body","#![allow(unused)]\nfn main() {\nlet v = vec![1, 2, 3];\n}"],["body","\n"],["headingLink","更新-vector"],["heading","更新 vector"],["body","\n"],["body","#![allow(unused)]\n\nfn main() {\nlet mut v = Vec::new();\n\nv.push(5);\nv.push(6);\n}"],["body","\n"],["headingLink","读取"],["heading","读取"],["body","\n"],["body","索引语法"],["body","\n"],["body","#![allow(unused)]\nfn main() {\nlet v = vec![1, 2, 3, 4, 5];\nlet third: &i32 = &v[2];\nprintln!(\"The third element is {}\", third);\nmatch v.get(2) {\n    Some(third) => println!(\"The third element is {}\", third),\n    None => println!(\"There is no third element.\"),\n}\n}"],["body","\n"],["body","get语法"],["body","\n"],["body","#![allow(unused)]\nfn main() {\nlet v = vec![1, 2, 3, 4, 5];\n\nlet does_not_exist = &v[100];\nlet does_not_exist = v.get(100);\n}"],["body","\n"],["headingLink","集合中的-所有权检查"],["heading","集合中的 所有权检查"],["body","\n"],["body","#![allow(unused)]\nfn main() {\n//编译会报错\nlet mut v = vec![1, 2, 3, 4, 5];\n\nlet first = &v[0];\n\nv.push(6);\n\nprintln!(\"The first element is: {}\", first);\n}"],["body","\n"],["body","在 vector 的结尾增加新元素时，在没有足够空间将所有所有元素依次相邻存放的情况下，可能会要求分配新内存并将老的元素拷贝到新的空间中。这时，第一个元素的引用就指向了被释放的内存。借用规则阻止程序陷入这种状况"],["body","\n"],["headingLink","遍历"],["heading","遍历"],["body","\n"],["body","可变遍历"],["body","\n"],["body","#![allow(unused)]\n\nfn main() {\nlet mut v = vec![100, 32, 57];\nfor i in &mut v {\n    *i += 50;\n}\n}"],["body","\n"],["headingLink","string字符串"],["heading","String字符串"],["body","\n"],["headingLink","什么是字符串类型"],["heading","什么是字符串类型"],["body","\n\n"],["body","Rust 的核心语言中只有一种字符串类型, str"],["body","\n"],["body","字符串 slice，它通常以被借用的形式出现 &str"],["body","\n"],["body","称作 String 的类型是由标准库提供的,而没有写进核心语言部分，它是可增长的、可变的、有所有权的、UTF-8 编码的字符串类型"],["body","\n\n"],["headingLink","新建字符串"],["heading","新建字符串"],["body","\n"],["headingLink","new关键字"],["heading","new关键字"],["body","\n"],["body","#![allow(unused)]\nfn main() {\nlet mut s = String::new();\n}"],["body","\n"],["headingLink","tostring转string"],["heading","toString()转string"],["body","\n"],["body","\n"],["body","用于任何实现了 Display的 trait"],["body","\n"],["body","\n"],["body","#![allow(unused)]\n\nfn main() {\nlet data = \"initial contents\";\n\nlet s = data.to_string();\n\n// 该方法也可直接用于字符串字面值：\nlet s = \"initial contents\".to_string();\n}"],["body","\n"],["headingLink","从字面量转string"],["heading","从字面量转String"],["body","\n"],["body","\n"],["body","字符串是 UTF-8 编码的"],["body","\n"],["body","\n"],["body","#![allow(unused)]\nfn main() {\nlet s = String::from(\"initial contents\");\n}"],["body","\n"],["headingLink","更新字符串"],["heading","更新字符串"],["body","\n"],["body","#![allow(unused)]\nfn main() {\nlet mut s = String::from(\"foo\");\ns.push_str(\"bar\");\n\nlet mut s1 = String::from(\"foo\");\nlet s2 = \"bar\";\ns1.push_str(s2);\nprintln!(\"s2 is {}\", s2);\n\n\nlet mut s = String::from(\"lo\");\ns.push('l');\n}"],["body","\n"],["headingLink","拼接字符串"],["heading","拼接字符串"],["body","\n"],["headingLink","使用加号运算符"],["heading","使用加号运算符"],["body","\n"],["body","\n"],["body","add函数"],["body","\n"],["body","\n"],["body","fn add(self, s: &str) -> String {\n"],["body","\n"],["body","#![allow(unused)]\nfn main() {\nlet s1 = String::from(\"Hello, \");\nlet s2 = String::from(\"world!\");\nlet s3 = s1 + &s2; // 注意 s1 被移动了，不能继续使用\n}"],["body","\n"],["body","所有权分析"],["body","\n"],["body","​\t会取得第一个参数的所有权,然后将剩余的字符串复制在该字符串的后面"],["body","\n"],["headingLink","索引字符串"],["heading","索引字符串"],["body","\n"],["body","\n"],["body","String 是一个 Vec<u8> 的封装"],["body","\n"],["body","\n"],["body","#![allow(unused)]\nfn main() {\nlet len = String::from(\"Hola\").len();\n\nlet hello = \"Здравствуйте\";\nlet answer = &hello[0];\n}"],["body","\n"],["body","底层以字节存储"],["body","\n"],["body","Rust 不允许使用索引获取 String 字符的原因是"],["body","\n\n"],["body","\n"],["body","索引操作预期总是需要常数时间 (O(1))。但是对于 String 不可能保证这样的性能"],["body","\n"],["body","\n"],["body","\n"],["body","因为 Rust 必须从开头到索引位置遍历来确定有多少有效的字符"],["body","\n"],["body","\n\n"],["headingLink","字符串-slice"],["heading","字符串 slice"],["body","\n"],["body","\n"],["body","可以使用 [] 和一个 range 来创建含特定字节的字符串 slice："],["body","\n"],["body","\n"],["body","#![allow(unused)]\nfn main() {\nlet hello = \"Здравствуйте\";\nlet s = &hello[0..4];\n//访问也是按字节访问的\n}"],["body","\n"],["headingLink","字符串遍历"],["heading","字符串遍历"],["body","\n"],["body","如果你需要操作单独的 Unicode 标量值，最好的选择是使用 chars 方法。对 “नमस्ते” 调用 chars 方法会将其分开并返回六个 char 类型的值"],["body","\n"],["body","#![allow(unused)]\n\nfn main() {\nfor c in \"नमस्ते\".chars() {\n    println!(\"{}\", c);\n}\n\n//返回原始字节\nfor b in \"नमस्ते\".bytes() {\n    println!(\"{}\", b);\n}\n}"],["body","\n"],["headingLink","hashmap"],["heading","HashMap"],["body","\n"],["headingLink","新建hashmap"],["heading","新建HashMap"],["body","\n"],["headingLink","构造函数构建"],["heading","构造函数构建"],["body","\n"],["body","#![allow(unused)]\nfn main() {\nuse std::collections::HashMap;\nlet mut scores = HashMap::new();\nscores.insert(String::from(\"Blue\"), 10);\nscores.insert(String::from(\"Yellow\"), 50);\n}"],["body","\n"],["headingLink","使用元组构建"],["heading","使用元组构建"],["body","\n"],["body","\n"],["body","使用一个元组的 vector 的 collect 方法，其中每个元组包含一个键值对。collect 方法可以将数据收集进一系列的集合类型，包括 HashMap"],["body","\n"],["body","\n"],["body","#![allow(unused)]\nfn main() {\nuse std::collections::HashMap;\nlet teams  = vec![String::from(\"Blue\"), String::from(\"Yellow\")];\nlet initial_scores = vec![10, 50];\n//zip方法创建一个元组, 将两个vec按索引对应创建\nlet scores: HashMap<_, _> = teams.iter().zip(initial_scores.iter()).collect();\n}"],["body","\n"],["headingLink","hashmap所有权"],["heading","HashMap所有权"],["body","\n\n"],["body","对于像 i32 这样的实现了 Copy trait 的类型，其值可以拷贝进哈希 map。"],["body","\n"],["body","对于像 String 这样拥有所有权的值，其值将被移动而哈希 map 会成为这些值的所有者"],["body","\n\n"],["body","#![allow(unused)]\nfn main() {\nuse std::collections::HashMap;\n\nlet field_name = String::from(\"Favorite color\");\nlet field_value = String::from(\"Blue\");\n\nlet mut map = HashMap::new();\nmap.insert(field_name, field_value);\n// 这里 field_name 和 field_value 不再有效，\n// 尝试使用它们看看会出现什么编译错误\n}"],["body","\n"],["headingLink","hashmap访问"],["heading","hashMap访问"],["body","\n"],["headingLink","get-返回-optionv"],["heading","get 返回 Option<V>"],["body","\n"],["body","#![allow(unused)]\nfn main() {\nuse std::collections::HashMap;\n\nlet mut scores = HashMap::new();\n\nscores.insert(String::from(\"Blue\"), 10);\nscores.insert(String::from(\"Yellow\"), 50);\n\nlet team_name = String::from(\"Blue\");\nlet score = scores.get(&team_name);\n}"],["body","\n"],["headingLink","遍历map"],["heading","遍历Map"],["body","\n"],["body","#![allow(unused)]\nfn main() {\nfor (key, value) in &scores {\n    println!(\"{}: {}\", key, value);\n}\n}"],["body","\n"],["headingLink","更新hashmap"],["heading","更新HashMap"],["body","\n"],["headingLink","覆盖旧的键值"],["heading","覆盖旧的键值"],["body","\n"],["body","#![allow(unused)]\nfn main() {\nscores.insert(String::from(\"Blue\"), 10);\nscores.insert(String::from(\"Blue\"), 25);\n}"],["body","\n"],["headingLink","键不存在时插入"],["heading","键不存在时插入"],["body","\n"],["body","\n#![allow(unused)]\nfn main() {\nuse std::collections::HashMap;\n\nlet mut scores = HashMap::new();\nscores.insert(String::from(\"Blue\"), 10);\n\nscores.entry(String::from(\"Yellow\")).or_insert(50);\nscores.entry(String::from(\"Blue\")).or_insert(50);\n\nprintln!(\"{:?}\", scores);\n}"],["body","\n"],["headingLink","根据旧值更新新值"],["heading","根据旧值更新新值"],["body","\n"],["body","or_insert 方法事实上会返回这个键的值的一个可变引用（&mut V）。这里我们将这个可变引用储存在 count 变量中"],["body","\n"],["body","\n#![allow(unused)]\nfn main() {\nuse std::collections::HashMap;\n\nlet text = \"hello world wonderful world\";\n\nlet mut map = HashMap::new();\n\nfor word in text.split_whitespace() {\n    let count = map.entry(word).or_insert(0);\n    *count += 1;\n}\n\nprintln!(\"{:?}\", map);\n}"],["body","\n"],["headingLink","哈希函数"],["heading","哈希函数"],["body","\n\n"],["body","\n"],["body","HashMap 默认使用一种 “密码学安全的”（“cryptographically strong” ）1 哈希函数，它可以抵抗拒绝服务（Denial of Service, DoS）攻击。"],["body","\n"],["body","\n"],["body","\n"],["body","然而这并不是可用的最快的算法，不过为了更高的安全性值得付出一些性能的代价。"],["body","\n"],["body","\n"],["body","\n"],["body","如果性能监测显示此哈希函数非常慢，以致于你无法接受，你可以指定一个不同的 hasher 来切换为其它函数。hasher 是一个实现了 BuildHasher trait 的类型"],["body","\n"],["body","\n\n\n\n\n"],["body","\n\n                    "],["body","\n\n                    \n                \n            \n\n            \n\n        \n\n\n\n\n        \n\n\n\n        \n        \n        \n\n        \n\n\n    \n    \n"]],[["_relative_fp","3.rust/rust执行shell命令.html"],["title","rust执行shell命令 - 各项编程语言"],["body","\n    \n        \n        \n\n        \n        \n\n        \n        \n\n        \n        \n\n        \n\n        \n\n            \n                                \n                \n                    \n                        "],["body","\n                            \n                        "],["body","\n                        "],["body","\n                            \n                        "],["body","\n                        \n                            "],["body","Light"],["body","\n                            "],["body","Rust"],["body","\n                            "],["body","Coal"],["body","\n                            "],["body","Navy"],["body","\n                            "],["body","Ayu"],["body","\n                        \n                    \n\n                    "],["heading","各项编程语言"],["body","\n\n                    \n\n                    \n                \n\n\n                \n                \n\n                \n                    "],["body","\n                        \n\n"],["body","\n"],["body","\n\n"],["headingLink","struct-stdprocesscommand"],["heading","Struct std::process::[Command]"],["body","\n"],["body","流程构建器，提供对应如何生成新流程的细粒度控制。"],["body","\n"],["body","可以使用Command::new(program)生成默认配置，其中"],["body","\n\n"],["body","program 给出要执行的程序的路径。"],["body","\n"],["body","其他构建器方法允许在生成之前更改配置 (例如，通过添加参数):"],["body","\n"],["body","继承当前进程的环境"],["body","\n"],["body","继承当前进程的工作目录"],["body","\n"],["body","Inherit stdin/stdout/stderr for spawn or status, but create pipes for output"],["body","\n\n"],["body","use std::process::Command;\n\nlet output = if cfg!(target_os = \"windows\") {\n    Command::new(\"cmd\")\n            .args([\"/C\", \"echo hello\"])\n            .output()\n            .expect(\"failed to execute process\")\n} else {\n    Command::new(\"sh\")\n            .arg(\"-c\")\n            .arg(\"echo hello\")\n            .output()\n            .expect(\"failed to execute process\")\n};\n\nlet hello = output.stdout;\n"],["body","\n"],["body","命令可以重复使用以产生多个进程"],["body","\n"],["body","use std::process::Command;\n\nlet mut echo_hello = Command::new(\"sh\");\necho_hello.arg(\"-c\")\n          .arg(\"echo hello\");\nlet hello_1 = echo_hello.output().expect(\"failed to execute process\");\nlet hello_2 = echo_hello.output().expect(\"failed to execute process\");\n"],["body","\n"],["body","生成进程后调用方法"],["body","\n"],["body","use std::process::Command;\n\nlet mut list_dir = Command::new(\"ls\");\n\n// Execute `ls` in the current directory of the program.\nlist_dir.status().expect(\"process failed to execute\");\n\nprintln!();\n\n// Change `ls` to execute in the root directory.\nlist_dir.current_dir(\"/\");\n\n// And then execute `ls` again but in the root directory.\nlist_dir.status().expect(\"process failed to execute\");\n"],["body","\n"],["body","use std::process::Command;\n\nCommand::new(\"sh\")\n        .spawn()\n        .expect(\"sh command failed to start\");\n"],["body","\n"],["headingLink","api"],["heading","API"],["body","\n"],["headingLink","new"],["heading","new"],["body","\n"],["body","pub fn new<S: AsRef<OsStr>>(program: S) -> Command\n"],["body","\n"],["headingLink","arg"],["heading","arg"],["body","\n"],["body",".arg(\"-C /path/to/repo\")\n\n.arg(\"-C\")\n.arg(\"/path/to/repo\")\n"],["body","\n"],["headingLink","args"],["heading","args"],["body","\n"],["body","use std::process::Command;\n\nCommand::new(\"ls\")\n        .args([\"-l\", \"-a\"])\n        .spawn()\n        .expect(\"ls command failed to start\");\n"],["body","\n"],["headingLink","env"],["heading","env"],["body","\n"],["body","插入或者更新环境变量"],["body","\n"],["body","use std::process::Command;\n\nCommand::new(\"ls\")\n        .env(\"PATH\", \"/bin\")\n        .spawn()\n        .expect(\"ls command failed to start\");\n"],["body","\n"],["headingLink","envs"],["heading","envs"],["body","\n"],["body","use std::process::{Command, Stdio};\nuse std::env;\nuse std::collections::HashMap;\n\nlet filtered_env : HashMap<String, String> =\n    env::vars().filter(|&(ref k, _)|\n        k == \"TERM\" || k == \"TZ\" || k == \"LANG\" || k == \"PATH\"\n    ).collect();\n\nCommand::new(\"printenv\")\n        .stdin(Stdio::null())\n        .stdout(Stdio::inherit())\n        .env_clear()\n        .envs(&filtered_env)\n        .spawn()\n        .expect(\"printenv failed to start\");\n"],["body","\n"],["headingLink","env_remove"],["heading","env_remove"],["body","\n"],["body","use std::process::Command;\n\nCommand::new(\"ls\")\n        .env_remove(\"PATH\")\n        .spawn()\n        .expect(\"ls command failed to start\");\n"],["body","\n"],["headingLink","env_clear"],["heading","Env_clear"],["body","\n"],["body","use std::process::Command;\n\nCommand::new(\"ls\")\n        .env_clear()\n        .spawn()\n        .expect(\"ls command failed to start\");\n"],["body","\n"],["headingLink","current_dir"],["heading","current_dir"],["body","\n"],["body","use std::process::Command;\n\nCommand::new(\"ls\")\n        .current_dir(\"/bin\")\n        .spawn()\n        .expect(\"ls command failed to start\");\n"],["body","\n"],["headingLink","stdin"],["heading","stdin"],["body","\n"],["body","子进程的标准输入 (stdin) 句柄的配置。"],["body","\n"],["body","use std::process::{Command, Stdio};\n\nCommand::new(\"ls\")\n        .stdin(Stdio::null())\n        .spawn()\n        .expect(\"ls command failed to start\");\n"],["body","\n"],["headingLink","stdout"],["heading","stdout"],["body","\n"],["body","use std::process::{Command, Stdio};\n\nCommand::new(\"ls\")\n        .stdout(Stdio::null())\n        .spawn()\n        .expect(\"ls command failed to start\");\n"],["body","\n"],["headingLink","stderr"],["heading","stderr"],["body","\n"],["body","use std::process::{Command, Stdio};\n\nCommand::new(\"ls\")\n        .stderr(Stdio::null())\n        .spawn()\n        .expect(\"ls command failed to start\");\n"],["body","\n"],["headingLink","spawn"],["heading","spawn"],["body","\n"],["body","use std::process::Command;\n\nCommand::new(\"ls\")\n        .spawn()\n        .expect(\"ls command failed to start\");\n"],["body","\n\n"],["body","\n"],["body","将命令作为子进程执行，并返回一个句柄。"],["body","\n"],["body","\n"],["body","\n"],["body","默认情况下，stdin、stdouts和stderr是从父级继承的。"],["body","\n"],["body","\n\n"],["headingLink","output"],["heading","output"],["body","\n"],["body","将命令作为子进程执行，等待它完成并收集其所有输出。"],["body","\n"],["body","默认情况下，stdot和stderr被捕获 (并用于提供结果输出)。Stdin不会从父级继承，并且子进程尝试从stdin流读取的任何尝试都会导致流立即关闭。"],["body","\n"],["body","use std::process::Command;\nuse std::io::{self, Write};\nlet output = Command::new(\"/bin/cat\")\n                     .arg(\"file.txt\")\n                     .output()\n                     .expect(\"failed to execute process\");\n\nprintln!(\"status: {}\", output.status);\nio::stdout().write_all(&output.stdout).unwrap();\nio::stderr().write_all(&output.stderr).unwrap();\n\nassert!(output.status.success());\n"],["body","\n"],["headingLink","status"],["heading","status"],["body","\n\n"],["body","作为子进程执行命令，等待它完成并收集其状态。"],["body","\n"],["body","默认情况下，stdin、stdouts和stderr是从父级继承的。"],["body","\n\n"],["body","use std::process::Command;\n\nlet status = Command::new(\"/bin/cat\")\n                     .arg(\"file.txt\")\n                     .status()\n                     .expect(\"failed to execute process\");\n\nprintln!(\"process finished with: {status}\");\n\nassert!(status.success());\n"],["body","\n"],["headingLink","get_program"],["heading","get_program"],["body","\n"],["body","返回给程序路径。"],["body","\n"],["body","use std::process::Command;\n\nlet cmd = Command::new(\"echo\");\nassert_eq!(cmd.get_program(), \"echo\");\n"],["body","\n"],["headingLink","get_args"],["heading","get_args"],["body","\n\n"],["body","返回参数迭代器"],["body","\n"],["body","这不包括程序的路径作为第一个参数; 它只包括  Command::arg  指定的参数"],["body","\n\n"],["headingLink","get_envs"],["heading","get_envs"],["body","\n\n"],["body","返回设置子进程的迭代器"],["body","\n"],["body","元素是(&OsStr, Option<&OsStr>)\n\n"],["body","其中第一个值是键，第二个值是值，"],["body","\n"],["body","如果要显式删除环境变量，则该值为None。"],["body","\n\n"],["body","\n"],["body","这仅包括使用 Command::env，Command::envs和Command::env_remove显式设置的环境变量。"],["body","\n"],["body","它不包括将由子进程继承的环境变量。"],["body","\n\n"],["headingLink","get_current_dir"],["heading","get_current_dir"],["body","\n"],["body","use std::path::Path;\nuse std::process::Command;\n\nlet mut cmd = Command::new(\"ls\");\nassert_eq!(cmd.get_current_dir(), None);\ncmd.current_dir(\"/bin\");\nassert_eq!(cmd.get_current_dir(), Some(Path::new(\"/bin\")));\n"],["body","\n"],["body","参考链接"],["body","\n\n\n\n"],["body","\n\n                    "],["body","\n\n                    \n                \n            \n\n            \n\n        \n\n\n\n\n        \n\n\n\n        \n        \n        \n\n        \n\n\n    \n    \n"]],[["_relative_fp","2.LUA/index.html"],["title","LUA - 各项编程语言"],["body","\n    \n        \n        \n\n        \n        \n\n        \n        \n\n        \n        \n\n        \n\n        \n\n            \n                                \n                \n                    \n                        "],["body","\n                            \n                        "],["body","\n                        "],["body","\n                            \n                        "],["body","\n                        \n                            "],["body","Light"],["body","\n                            "],["body","Rust"],["body","\n                            "],["body","Coal"],["body","\n                            "],["body","Navy"],["body","\n                            "],["body","Ayu"],["body","\n                        \n                    \n\n                    "],["heading","各项编程语言"],["body","\n\n                    \n\n                    \n                \n\n\n                \n                \n\n                \n                    "],["body","\n                        \n\n"],["body","\n"],["body","\n\n"],["headingLink","概述"],["heading","概述"],["body","\n"],["body","Lua是一种用C语言编写的可扩展，轻量级的编程语言。它于1993年由Roberto Ierusalimschy，Luiz Henrique de Figueiredo和Waldemar Celes作为内部项目开始研发。"],["body","\n"],["body","Lua从一开始就设计成一个可以与用C语言和其他传统语言编写的代码集成的软件。 这种集成带来许多好处。 Lua并没有尝试做C语言已经做过的事情，而是提供C语言不擅长的东西：与硬件的良好距离，动态结构，无冗余，易于测试和调试。 为此，Lua是具有安全的环境，自动内存管理以及用于处理动态大小的字符串和其他类型数据的良好工具。"],["body","\n"],["headingLink","lua特征"],["heading","Lua特征"],["body","\n"],["body","扩展"],["body","\n"],["body","简单"],["body","\n"],["body","高效"],["body","\n"],["body","可移植"],["body","\n"],["body","免费开放源码"],["body","\n"],["headingLink","lua是如何实现的"],["heading","Lua是如何实现的？"],["body","\n"],["body","Lua由两部分组成 -  Lua解释器部分和功能软件系统。 功能正常的软件系统是一个实际的计算机应用程序，可以解释用Lua编程语言编写的程序。 Lua解释器是用ANSI C编写的，因此它具有高度的可移植性，可以运行在高端网络服务器和小型设备的各种设备上。"],["body","\n"],["body","Lua语言和解释器都是成熟，小巧，快速的。 它已经从其他编程语言和顶级软件标准发展而来。软件代码较小使它可以在内存较低的小型设备上运行。"],["body","\n"],["headingLink","lua的一些用途"],["heading","Lua的一些用途"],["body","\n"],["body","游戏编程"],["body","\n"],["body","独立应用程序中的脚本"],["body","\n"],["body","在Web上编写脚本"],["body","\n"],["body","MySQL Proxy和MySQL WorkBench等数据库的扩展和附加组件"],["body","\n"],["body","安全系统，如入侵检测系统。"],["body","\n"],["headingLink","lua开发环境配置"],["heading","Lua开发环境配置"],["body","\n"],["body","$ curl -R -O http://www.lua.org/ftp/lua-5.3.5.tar.gz\n$ yum install readline-devel\n$ tar zxf lua-5.3.5.tar.gz\n$ cd lua-5.3.5\n$ make linux test\n"],["body","\n"],["headingLink","lua基础语法"],["heading","Lua基础语法"],["body","\n"],["headingLink","交互式模式编程"],["heading","交互式模式编程"],["body","\n"],["body","Lua提供了一种叫作交互模式的模式。 在此模式下，可以依次输入命令代码并获得即时结果。 这可以通过使用lua -i或lua命令在shell中调用。 输入此内容后，按Enter 键，将启动交互模式，如下所示\n"],["body","\n"],["headingLink","默认模式编程"],["heading","默认模式编程"],["body","\n"],["body","使用Lua文件名参数调用解释器开始执行文件并继续直到脚本完成。 脚本完成后，解释器不再处于活动状态。"],["body","\n"],["body","#!/usr/local/bin/lua\nprint(\"Hello, Welcome\")\n"],["body","\n"],["headingLink","luatoken标记"],["heading","LuaToken标记"],["body","\n"],["body","Lua程序由各种标记组成，标记可以是关键字，标识符，常量，字符串文字或符号。 例如，以下Lua语句由三个标记组成 -"],["body","\n"],["headingLink","注释"],["heading","注释"],["body","\n"],["body","--[[ my first program in Lua --]]\n"],["body","\n"],["headingLink","标识符"],["heading","标识符"],["body","\n"],["body","Lua标识符是用于标识变量，函数或任何其他用户定义项的名称。 标识符以字母A到Z或a到z或下划线_开头，后跟零个或多个字母，下划线和数字(0到9)。"],["body","\n"],["body","Lua不允许标识符中的标点符号，如@，$和%。 Lua是一种区分大小写的编程语言。"],["body","\n"],["headingLink","关键字"],["heading","关键字"],["body","\n"],["body","以下列表显示了Lua中的一些保留字。 这些保留字不能用作常量或变量或任何其他标识符名称。"],["body","\n"],["body","and break do else elseif end false for function if in local nil not or repeat return then true until while\n"],["body","\n"],["headingLink","lua空白符"],["heading","Lua空白符"],["body","\n"],["body","只包含空格(可能带有注释)的行称为空行，Lua解释器完全忽略它。"],["body","\n"],["body","空白符是Lua用来描述空格，制表符，换行符和注释的术语。 空格符将语句的一部分与另一部分分开，并使解释器能够识别语句中的一个元素(如int结束)和下一个元素的开始位置。 因此，在以下声明中"],["body","\n\n\n\n"],["body","\n\n                    "],["body","\n\n                    \n                \n            \n\n            \n\n        \n\n\n\n\n        \n\n\n\n        \n        \n        \n\n        \n\n\n    \n    \n"]],[["_relative_fp","2.LUA/高级语法.html"],["title","高级语法 - 各项编程语言"],["body","\n    \n        \n        \n\n        \n        \n\n        \n        \n\n        \n        \n\n        \n\n        \n\n            \n                                \n                \n                    \n                        "],["body","\n                            \n                        "],["body","\n                        "],["body","\n                            \n                        "],["body","\n                        \n                            "],["body","Light"],["body","\n                            "],["body","Rust"],["body","\n                            "],["body","Coal"],["body","\n                            "],["body","Navy"],["body","\n                            "],["body","Ayu"],["body","\n                        \n                    \n\n                    "],["heading","各项编程语言"],["body","\n\n                    \n\n                    \n                \n\n\n                \n                \n\n                \n                    "],["body","\n                        \n\n"],["body","\n"],["body","\n\n"],["headingLink","高级语法"],["heading","高级语法"],["body","\n\n\n\n"],["body","\n\n                    "],["body","\n\n                    \n                \n            \n\n            \n\n        \n\n\n\n\n        \n\n\n\n        \n        \n        \n\n        \n\n\n    \n    \n"]],[["_relative_fp","2.LUA/基本语法.html"],["title","基本语法 - 各项编程语言"],["body","\n    \n        \n        \n\n        \n        \n\n        \n        \n\n        \n        \n\n        \n\n        \n\n            \n                                \n                \n                    \n                        "],["body","\n                            \n                        "],["body","\n                        "],["body","\n                            \n                        "],["body","\n                        \n                            "],["body","Light"],["body","\n                            "],["body","Rust"],["body","\n                            "],["body","Coal"],["body","\n                            "],["body","Navy"],["body","\n                            "],["body","Ayu"],["body","\n                        \n                    \n\n                    "],["heading","各项编程语言"],["body","\n\n                    \n\n                    \n                \n\n\n                \n                \n\n                \n                    "],["body","\n                        \n\n"],["body","\n"],["body","\n\n"],["headingLink","基本语法"],["heading","基本语法"],["body","\n\n\n\n"],["body","\n\n                    "],["body","\n\n                    \n                \n            \n\n            \n\n        \n\n\n\n\n        \n\n\n\n        \n        \n        \n\n        \n\n\n    \n    \n"]],[["_relative_fp","5.typescript/4.模块.html"],["title","模块 - 各项编程语言"],["body","\n    \n        \n        \n\n        \n        \n\n        \n        \n\n        \n        \n\n        \n\n        \n\n            \n                                \n                \n                    \n                        "],["body","\n                            \n                        "],["body","\n                        "],["body","\n                            \n                        "],["body","\n                        \n                            "],["body","Light"],["body","\n                            "],["body","Rust"],["body","\n                            "],["body","Coal"],["body","\n                            "],["body","Navy"],["body","\n                            "],["body","Ayu"],["body","\n                        \n                    \n\n                    "],["heading","各项编程语言"],["body","\n\n                    \n\n                    \n                \n\n\n                \n                \n\n                \n                    "],["body","\n                        \n\n"],["body","\n"],["body","\n\n"],["headingLink","说明"],["heading","说明"],["body","\n"],["body","从ES2015开始，JavaScript里增加了 模块的概念，即在模块中申明的变量、函数、类都对外部不可见，除非显示 export  。并且在 需要使用该模块的位置需要显示 import它"],["body","\n"],["headingLink","how-javascript-modules-are-defined"],["heading","How JavaScript Modules are Defined"],["body","\n"],["body","\n"],["body","javascipt 模组 是如何定义的"],["body","\n"],["body","\n"],["body","任何包含 顶层级 import export 的文件会 被认为是一个模块，反之，则其中的声明的作用域为全局作用域\n模块在自己的作用域执行，而不是全局作用域"],["body","\n"],["headingLink","non-modules"],["heading","Non-modules"],["body","\n"],["body","The JavaScript specification  规则：任何 没有 top-level-export-await 应当被当做一个 script而不是 一个模块"],["body","\n"],["body","在 一个script file 当中的变量、类型 是声明在全局作用域中的。\n要么使用   outFile 编译选项将所有文件编译在一起。或者 使用 html script 标签"],["body","\n"],["headingLink","导出声明"],["heading","导出声明"],["body","\n"],["body","任何申明都可以通过 export 导出\n导出语法"],["body","\n"],["body","export Syantax1=export <declation>\ndelclation=变量声明|函数声明|类声明|类型别名声明|接口声明\n\nexport Syantax2=export {\n\tidentifier[,identifier]*\n}\nidentifier=变量|函数|类|类型|接口\n\n//重导出\nreexport Syantax==export { Identifier1 as Identifier2 } | * from './path'\n"],["body","\n"],["headingLink","导入声明"],["heading","导入声明"],["body","\n"],["body","import {identifier+} from 'module-name';\n\n//导入重命名\nimport { Identifier1 as Identifier2  } from \"./path\";\n\n\n// 具有副作用的导入模块\nimport \"./my-module.js\";\n"],["body","\n"],["headingLink","默认导出导入"],["heading","默认导出导入"],["body","\n"],["body","语法"],["body","\n"],["body","syntax=export default Identifier;\nIdentifier=class|types|interfeaces|variables\n"],["body","\n"],["body","example"],["body","\n"],["body","declare let $: JQuery; \nexport default $;\n"],["body","\n"],["headingLink","export--和-import--require"],["heading","export = 和 import = require()"],["body","\n"],["body","\n"],["body","为了支持CommonJS和AMD的exports, TypeScript提供了export =语法。"],["body","\n"],["body","\n"],["body","若使用export =导出一个模块，则必须使用TypeScript的特定语法import module = require(\"module\")来导入此模块。"],["body","\n"],["body","export"],["body","\n"],["body","let numberRegexp = /^[0-9]+$/; \nclass ZipCodeValidator\n{ \n\tisAcceptable(s: string)\n\t{ \n\treturn s.length === 5 && numberRegexp.test(s); } \n\t} export = ZipCodeValidator;\n\n\n"],["body","\n"],["body","import"],["body","\n"],["body","import zip = require(\"./ZipCodeValidator\");\n\n"],["body","\n"],["headingLink","生成模块代码"],["heading","生成模块代码"],["body","\n"],["body","下面的例子说明了导入导出语句里使用的名字是怎么转换为相应的模块加载器代码的。"],["body","\n"],["headingLink","amd--requirejs"],["heading","AMD / RequireJS"],["body","\n"],["body","//SimpleModule.ts\nimport m = require(\"mod\");\nexport let t = m.something + 1;\n\n\n//generator code\ndefine([\"require\", \"exports\", \"./mod\"], \n   function (require, exports, mod_1) { \n\t\texports.t = mod_1.something + 1; \n\t}\n);\n"],["body","\n"],["headingLink","commonjs--node"],["heading","CommonJS / Node"],["body","\n"],["body","let mod_1 = require(\"./mod\");\nexports.t = mod_1.something + 1;\n\n"],["body","\n"],["headingLink","umd"],["heading","UMD"],["body","\n"],["body","//generator code\n(function (factory) {\n\n if (typeof module === \"object\" && typeof module.exports === \"object\") {\n\n\t let v = factory(require, exports);\n\t if (v !== undefined) module.exports = v;\n\n }\n\n else if (typeof define === \"function\" && define.amd) {\n\n define([\"require\", \"exports\", \"./mod\"], factory);\n\n }})(function (require, exports) {\n\n let mod_1 = require(\"./mod\");\n\n exports.t = mod_1.something + 1;\n\n});\n\n"],["body","\n"],["headingLink","system"],["heading","System"],["body","\n"],["body","System.register([\"./mod\"], function(exports_1) {\n\n let mod_1;\n\n let t;\n\n return {\n\n setters:[\n\n function (mod_1_1) {\n\n mod_1 = mod_1_1;\n\n }],\n\n execute: function() {\n\n\t exports_1(\"t\", t = mod_1.something + 1);\n\n\t }\n }\n\n});\n"],["body","\n"],["headingLink","native-ecmascript-2015-modules"],["heading","Native ECMAScript 2015 modules"],["body","\n"],["body","import { something } from \"./mod\"; \nexport let t = something + 1;\n"],["body","\n"],["headingLink","外部模块"],["heading","外部模块"],["body","\n"],["body","declare module \"url\" {\n\n export interface Url {\n\n protocol?: string;\n\n hostname?: string;\n\n pathname?: string;\n\n }\n\n\n export function parse(urlStr: string, parseQueryString?, slashesDenoteHost?): Url;\n\n}\n\ndeclare module \"path\" {\n\n export function normalize(p: string): string;\n\n export function join(...paths: any[]): string;\n\n export let sep: string;\n\n}\n\n"],["body","\n"],["body","外部模块简写\ndeclare module \"hot-new-module\";"],["body","\n"],["body","简写模块里所有导出的类型将是any"],["body","\n\n\n\n"],["body","\n\n                    "],["body","\n\n                    \n                \n            \n\n            \n\n        \n\n\n\n\n        \n\n\n\n        \n        \n        \n\n        \n\n\n    \n    \n"]],[["_relative_fp","5.typescript/index.html"],["title","typescript - 各项编程语言"],["body","\n    \n        \n        \n\n        \n        \n\n        \n        \n\n        \n        \n\n        \n\n        \n\n            \n                                \n                \n                    \n                        "],["body","\n                            \n                        "],["body","\n                        "],["body","\n                            \n                        "],["body","\n                        \n                            "],["body","Light"],["body","\n                            "],["body","Rust"],["body","\n                            "],["body","Coal"],["body","\n                            "],["body","Navy"],["body","\n                            "],["body","Ayu"],["body","\n                        \n                    \n\n                    "],["heading","各项编程语言"],["body","\n\n                    \n\n                    \n                \n\n\n                \n                \n\n                \n                    "],["body","\n                        \n\n"],["body","\n"],["body","\n\n"],["headingLink","手册指南"],["heading","手册指南"],["body","\n"],["body","[[基础类型]]\n[[变量声明]]\n[[模块]]"],["body","\n\n\n\n"],["body","\n\n                    "],["body","\n\n                    \n                \n            \n\n            \n\n        \n\n\n\n\n        \n\n\n\n        \n        \n        \n\n        \n\n\n    \n    \n"]],[["_relative_fp","5.typescript/1.基础类型.html"],["title","基础类型 - 各项编程语言"],["body","\n    \n        \n        \n\n        \n        \n\n        \n        \n\n        \n        \n\n        \n\n        \n\n            \n                                \n                \n                    \n                        "],["body","\n                            \n                        "],["body","\n                        "],["body","\n                            \n                        "],["body","\n                        \n                            "],["body","Light"],["body","\n                            "],["body","Rust"],["body","\n                            "],["body","Coal"],["body","\n                            "],["body","Navy"],["body","\n                            "],["body","Ayu"],["body","\n                        \n                    \n\n                    "],["heading","各项编程语言"],["body","\n\n                    \n\n                    \n                \n\n\n                \n                \n\n                \n                    "],["body","\n                        \n\n"],["body","\n"],["body","\n\n"],["headingLink","基础类型"],["heading","基础类型"],["body","\n"],["headingLink","布尔值"],["heading","布尔值："],["body","\n"],["body","bool"],["body","\n"],["headingLink","数字"],["heading","数字："],["body","\n"],["body","number"],["body","\n"],["headingLink","字符串"],["heading","字符串："],["body","\n"],["body","string"],["body","\n"],["headingLink","数组"],["heading","数组："],["body","\n"],["body","let list: number[] = [1, 2, 3];"],["body","\n"],["headingLink","元组-tuple"],["heading","元组 Tuple："],["body","\n"],["body","let x: [string, number];"],["body","\n"],["headingLink","枚举"],["heading","枚举："],["body","\n"],["body","enum Color {Red, Green, Blue}"],["body","\n"],["headingLink","any"],["heading","Any："],["body","\n"],["body","let list: any[] = [1, true, \"free\"];"],["body","\n"],["headingLink","void"],["heading","Void"],["body","\n"],["body","没有任何返回值"],["body","\n"],["headingLink","null-和-undefined"],["heading","Null 和 Undefined"],["body","\n"],["body","// Not much else we can assign to these variables! \nlet u: undefined = undefined;\nlet n: null = null;\n"],["body","\n"],["headingLink","never"],["heading","Never"],["body","\n\n"],["body","never类型表示的是那些永不存在的值的类型"],["body","\n"],["body","never类型是那些总是会抛出异常或根本就不会有返回值的函数表达式或箭头函数表达式的返回值类型；"],["body","\n\n"],["headingLink","object"],["heading","Object"],["body","\n"],["headingLink","类型断言"],["heading","类型断言"],["body","\n\n"],["body","有时候你会遇到这样的情况，你会比TypeScript更了解某个值的详细信息"],["body","\n"],["body","通常这会发生在你清楚地知道一个实体具有比它现有类型更确切的类型"],["body","\n\n"],["body","let strLength: number = (<string>someValue).length;\nlet strLength: number = (someValue as string).length;\n"],["body","\n\n\n\n"],["body","\n\n                    "],["body","\n\n                    \n                \n            \n\n            \n\n        \n\n\n\n\n        \n\n\n\n        \n        \n        \n\n        \n\n\n    \n    \n"]],[["_relative_fp","5.typescript/3.接口.html"],["title","接口 - 各项编程语言"],["body","\n    \n        \n        \n\n        \n        \n\n        \n        \n\n        \n        \n\n        \n\n        \n\n            \n                                \n                \n                    \n                        "],["body","\n                            \n                        "],["body","\n                        "],["body","\n                            \n                        "],["body","\n                        \n                            "],["body","Light"],["body","\n                            "],["body","Rust"],["body","\n                            "],["body","Coal"],["body","\n                            "],["body","Navy"],["body","\n                            "],["body","Ayu"],["body","\n                        \n                    \n\n                    "],["heading","各项编程语言"],["body","\n\n                    \n\n                    \n                \n\n\n                \n                \n\n                \n                    "],["body","\n                        \n\n"],["body","\n"],["body","\n\n"],["headingLink","接口"],["heading","接口"],["body","\n"],["body","介绍"],["body","\n"],["body","TypeScript的核心原则之一是对值所具有的结构进行类型检查。 它有时被称做“鸭式辨型法”或“结构性子类型化”。 在TypeScript里，接口的作用就是为这些类型命名和为你的代码或第三方代码定义契约。"],["body","\n"],["headingLink","接口初探"],["heading","接口初探"],["body","\n"],["body","下面通过一个简单示例来观察接口是如何工作的："],["body","\n"],["body","function printLabel(labelledObj: { label: string }) {\n  console.log(labelledObj.label);\n}\n\nlet myObj = { size: 10, label: \"Size 10 Object\" };\nprintLabel(myObj);\n"],["body","\n"],["body","interface LabelledValue {\n  label: string;\n}\n\nfunction printLabel(labelledObj: LabelledValue) {\n  console.log(labelledObj.label);\n}\n\nlet myObj = {size: 10, label: \"Size 10 Object\"};\nprintLabel(myObj);\n"],["body","\n"],["headingLink","可选属性"],["heading","可选属性"],["body","\n"],["body","接口里的属性不全都是必需的。 有些是只在某些条件下存在，或者根本不存在。 可选属性在应用“option bags”模式时很常用，即给函数传入的参数对象中只有部分属性赋值了。"],["body","\n"],["body","interface SquareConfig {\n  color?: string;\n  width?: number;\n}\n\nfunction createSquare(config: SquareConfig): {color: string; area: number} {\n  let newSquare = {color: \"white\", area: 100};\n  if (config.color) {\n    newSquare.color = config.color;\n  }\n  if (config.width) {\n    newSquare.area = config.width * config.width;\n  }\n  return newSquare;\n}\n\nlet mySquare = createSquare({color: \"black\"});\n"],["body","\n"],["body","带有可选属性的接口与普通的接口定义差不多**，只是在可选属性名字定义的后面加一个?符号**。"],["body","\n"],["body","可选属性的"],["body","\n\n"],["body","\n"],["body","好处之一是可以对可能存在的属性进行预定义，"],["body","\n"],["body","\n"],["body","\n"],["body","好处之二是可以捕获引用了不存在的属性时的错误。 比如，我们故意将 createSquare里的color属性名拼错，就会得到一个错误提示："],["body","\n"],["body","\n\n"],["headingLink","只读属性"],["heading","只读属性"],["body","\n"],["body","一些对象属性只能在对象刚刚创建的时候修改其值。 你可以在属性名前用 readonly来指定只读属性:"],["body","\n"],["body","interface Point {\n    readonly x: number;\n    readonly y: number;\n}\n"],["body","\n"],["body","你可以通过赋值一个对象字面量来构造一个Point。 赋值后， x和y再也不能被改变了。"],["body","\n"],["body","let p1: Point = { x: 10, y: 20 };\np1.x = 5; // error!\n"],["body","\n"],["body","TypeScript具有ReadonlyArray<T>类型，它与Array<T>相似，只是把所有可变方法去掉了，因此可以确保数组创建后再也不能被修改："],["body","\n"],["body","let a: number[] = [1, 2, 3, 4];\nlet ro: ReadonlyArray<number> = a;\nro[0] = 12; // error!\nro.push(5); // error!\nro.length = 100; // error!\na = ro; // error!\n"],["body","\n"],["body","上面代码的最后一行，可以看到就算把整个ReadonlyArray赋值到一个普通数组也是不可以的。 但是你可以用类型断言重写："],["body","\n"],["body","a = ro as number[];\n"],["body","\n"],["body","最简单判断该用readonly还是const的方法是看要把它做为变量使用还是做为一个属性。 做为变量使用的话用 const，若做为属性则使用readonly。"],["body","\n"],["headingLink","额外的属性检查"],["heading","额外的属性检查"],["body","\n"],["body","对于传入 接口中不存在的属性名则 会编译报错"],["body","\n"],["body","绕开这些检查非常简单。 最简便的方法是使用类型断言："],["body","\n"],["body","let mySquare = createSquare({ width: 100, opacity: 0.5 } as SquareConfig);\n"],["body","\n"],["body","然而，最佳的方式是能够添加一个字符串索引签名，前提是你能够确定这个对象可能具有某些做为特殊用途使用的额外属性。 如果 SquareConfig带有上面定义的类型的color和width属性，并且还会带有任意数量的其它属性，那么我们可以这样定义它："],["body","\n"],["body","interface SquareConfig {\n    color?: string;\n    width?: number;\n    [propName: string]: any;\n}\n"],["body","\n"],["body","还有最后一种跳过这些检查的方式，这可能会让你感到惊讶，它就是将这个对象赋值给一个另一个变量： 因为 squareOptions不会经过额外属性检查，所以编译器不会报错。"],["body","\n"],["body","let squareOptions = { colour: \"red\", width: 100 };\nlet mySquare = createSquare(squareOptions); //被强制类型转换\n"],["body","\n"],["headingLink","函数类型"],["heading","函数类型"],["body","\n"],["body","接口能够描述JavaScript中对象拥有的各种各样的外形。 "],["body","\n"],["body","除了描述带有属性的普通对象外，接口也可以描述函数类型。"],["body","\n"],["body","为了使用接口表示函数类型，我们需要给接口定义一个调用签名。 它就像是一个只有参数列表和返回值类型的函数定义。参数列表里的每个参数都需要名字和类型。"],["body","\n"],["body","interface SearchFunc {\n  (source: string, subString: string): boolean;\n}\n"],["body","\n"],["body","这样定义后，我们可以像使用其它接口一样使用这个函数类型的接口。 下例展示了如何创建一个函数类型的变量，并将一个同类型的函数赋值给这个变量。"],["body","\n"],["body","let mySearch: SearchFunc;\nmySearch = function(source: string, subString: string) {\n  let result = source.search(subString);\n  return result > -1;\n}\n"],["body","\n"],["body","函数的参数会逐个进行检查，要求对应位置上的参数类型是兼容的。 如果你不想指定类型，TypeScript的类型系统会推断出参数类型，因为函数直接赋值给了 SearchFunc类型变量。 函数的返回值类型是通过其返回值推断出来的（此例是 false和true）。 如果让这个函数返回数字或字符串，类型检查器会警告我们函数的返回值类型与 SearchFunc接口中的定义不匹配。"],["body","\n"],["body","let mySearch: SearchFunc;\nmySearch = function(src, sub) {\n    let result = src.search(sub);\n    return result > -1;\n}\n"],["body","\n"],["headingLink","可索引的类型"],["heading","可索引的类型"],["body","\n"],["body","与使用接口描述函数类型差不多，我们也可以描述那些能够“通过索引得到”的类型，比如a[10]或ageMap[\"daniel\"]。 可索引类型具有一个 索引签名，它描述了对象索引的类型，还有相应的索引返回值类型。 让我们看一个例子："],["body","\n"],["body","interface StringArray {\n  [index: number]: string;\n}\n\nlet myArray: StringArray;\nmyArray = [\"Bob\", \"Fred\"];\n\nlet myStr: string = myArray[0];\n"],["body","\n"],["body","上面例子里，我们定义了StringArray接口，它具有索引签名。 这个索引签名表示了当用 number去索引StringArray时会得到string类型的返回值。"],["body","\n"],["body","TypeScript支持两种索引签名：字符串和数字。 可以同时使用两种类型的索引，但是数字索引的返回值必须是字符串索引返回值类型的子类型。"],["body","\n"],["body","这是因为当使用 number来索引时，JavaScript会将它转换成string然后再去索引对象。 也就是说用 100（一个number）去索引等同于使用\"100\"（一个string）去索引，因此两者需要保持一致。"],["body","\n"],["body","class Animal {\n    name: string;\n}\nclass Dog extends Animal {\n    breed: string;\n}\n\n// 错误：使用数值型的字符串索引，有时会得到完全不同的Animal!\ninterface NotOkay {\n    [x: number]: Animal;\n    [x: string]: Dog;\n}\n"],["body","\n"],["body","字符串索引签名能够很好的描述dictionary模式，并且它们也会确保所有属性与其返回值类型相匹配。 因为字符串索引声明了 obj.property和obj[\"property\"]两种形式都可以。 下面的例子里， name的类型与字符串索引类型不匹配，所以类型检查器给出一个错误提示："],["body","\n"],["body","interface NumberDictionary {\n  [index: string]: number;\n  length: number;    // 可以，length是number类型\n  name: string       // 错误，`name`的类型与索引类型返回值的类型不匹配\n}\n"],["body","\n"],["body","最后，你可以将索引签名设置为只读，这样就防止了给索引赋值："],["body","\n"],["body","interface ReadonlyStringArray {\n    readonly [index: number]: string;\n}\nlet myArray: ReadonlyStringArray = [\"Alice\", \"Bob\"];\nmyArray[2] = \"Mallory\"; // error!\n"],["body","\n"],["headingLink","类类型"],["heading","类类型"],["body","\n"],["headingLink","实现接口"],["heading","实现接口"],["body","\n"],["body","接口描述了类的公共部分，而不是公共和私有两部分。 它不会帮你检查类是否具有某些私有成员。"],["body","\n"],["body","类静态部分与实例部分的区别"],["body","\n"],["body","当你操作类和接口的时候，你要知道类是具有两个类型的：静态部分的类型和实例的类型。 你会注意到，当你用构造器签名去定义一个接口并试图定义一个类去实现这个接口时会得到一个错误："],["body","\n"],["body","interface ClockConstructor {\n    new (hour: number, minute: number);\n}\n\nclass Clock implements ClockConstructor {\n    currentTime: Date;\n    constructor(h: number, m: number) { }\n}\n"],["body","\n"],["body","这里因为当一个类实现了一个接口时，只对其实例部分进行类型检查。 constructor存在于类的静态部分，所以不在检查的范围内。"],["body","\n"],["body","因此，我们应该直接操作类的静态部分。 看下面的例子，我们定义了两个接口， ClockConstructor为构造函数所用和ClockInterface为实例方法所用。 为了方便我们定义一个构造函数 createClock，它用传入的类型创建实例。"],["body","\n"],["body","interface ClockConstructor {\n    new (hour: number, minute: number): ClockInterface;\n}\ninterface ClockInterface {\n    tick();\n}\n\nfunction createClock(ctor: ClockConstructor, hour: number, minute: number): ClockInterface {\n    return new ctor(hour, minute);\n}\n\nclass DigitalClock implements ClockInterface {\n    constructor(h: number, m: number) { }\n    tick() {\n        console.log(\"beep beep\");\n    }\n}\nclass AnalogClock implements ClockInterface {\n    constructor(h: number, m: number) { }\n    tick() {\n        console.log(\"tick tock\");\n    }\n}\n\nlet digital = createClock(DigitalClock, 12, 17);\nlet analog = createClock(AnalogClock, 7, 32);\n"],["body","\n"],["headingLink","继承接口"],["heading","继承接口"],["body","\n"],["body","和类一样，接口也可以相互继承。 这让我们能够从一个接口里复制成员到另一个接口里，可以更灵活地将接口分割到可重用的模块里。"],["body","\n"],["body","interface Shape {\n    color: string;\n}\n\ninterface Square extends Shape {\n    sideLength: number;\n}\n\nlet square = <Square>{};\nsquare.color = \"blue\";\nsquare.sideLength = 10;\n"],["body","\n"],["body","一个接口可以继承多个接口，创建出多个接口的合成接口。"],["body","\n"],["body","interface Shape {\n    color: string;\n}\n\ninterface PenStroke {\n    penWidth: number;\n}\n\ninterface Square extends Shape, PenStroke {\n    sideLength: number;\n}\n\nlet square = <Square>{};\nsquare.color = \"blue\";\nsquare.sideLength = 10;\nsquare.penWidth = 5.0;\n"],["body","\n"],["headingLink","混合类型"],["heading","混合类型"],["body","\n"],["body","先前我们提过，接口能够描述JavaScript里丰富的类型。 因为JavaScript其动态灵活的特点，有时你会希望一个对象可以同时具有上面提到的多种类型。"],["body","\n"],["body","一个例子就是，一个对象可以同时做为函数和对象使用，并带有额外的属性。"],["body","\n"],["body","interface Counter {\n    (start: number): string;\n    interval: number;\n    reset(): void;\n}\n\nfunction getCounter(): Counter {\n    let counter = <Counter>function (start: number) { };\n    counter.interval = 123;\n    counter.reset = function () { };\n    return counter;\n}\n\nlet c = getCounter();\nc(10);\nc.reset();\nc.interval = 5.0;\n"],["body","\n"],["headingLink","接口继承类"],["heading","接口继承类"],["body","\n"],["body","当接口继承了一个类类型时**，它会继承类的成员但不包括其实现**"],["body","\n"],["body","就好像接口声明了所有类中存在的成员，但并没有提供具体实现一样"],["body","\n"],["body","接口同样会继承到类的private和protected成员。 这意味着当你创建了一个接口继承了一个拥有私有或受保护的成员的类时，这个接口类型只能被这个类或其子类所实现（implement）。"],["body","\n"],["body","class Control {\n    private state: any;\n}\n\ninterface SelectableControl extends Control {\n    select(): void;\n}\n\nclass Button extends Control implements SelectableControl {\n    select() { }\n}\n\nclass TextBox extends Control {\n    select() { }\n}\n\n// 错误：“Image”类型缺少“state”属性。\nclass Image implements SelectableControl {\n    select() { }\n}\n\nclass Location {\n\n}\n"],["body","\n\n\n\n"],["body","\n\n                    "],["body","\n\n                    \n                \n            \n\n            \n\n        \n\n\n\n\n        \n\n\n\n        \n        \n        \n\n        \n\n\n    \n    \n"]],[["_relative_fp","5.typescript/2.变量声明.html"],["title","变量声明 - 各项编程语言"],["body","\n    \n        \n        \n\n        \n        \n\n        \n        \n\n        \n        \n\n        \n\n        \n\n            \n                                \n                \n                    \n                        "],["body","\n                            \n                        "],["body","\n                        "],["body","\n                            \n                        "],["body","\n                        \n                            "],["body","Light"],["body","\n                            "],["body","Rust"],["body","\n                            "],["body","Coal"],["body","\n                            "],["body","Navy"],["body","\n                            "],["body","Ayu"],["body","\n                        \n                    \n\n                    "],["heading","各项编程语言"],["body","\n\n                    \n\n                    \n                \n\n\n                \n                \n\n                \n                    "],["body","\n                        \n\n"],["body","\n"],["body","\n\n"],["headingLink","let-vsconst"],["heading","let vsconst"],["body","\n\n"],["body","基本原则就是如果一个变量不需要对它写入，那么其它使用这些代码的人也不能够写入它们，并且要思考为什么会需要对这些变量重新赋值"],["body","\n"],["body","使用 const也可以让我们更容易的推测数据的流动。"],["body","\n\n"],["headingLink","解构"],["heading","解构"],["body","\n"],["headingLink","解构数组"],["heading","解构数组"],["body","\n"],["body","let input = [1, 2];\nlet [first, second] = input;\n"],["body","\n"],["headingLink","解构作用于已声明的变量"],["heading","解构作用于已声明的变量"],["body","\n"],["body","// swap variables \n[first, second] = [second, first];\n"],["body","\n"],["headingLink","函数参数"],["heading","函数参数"],["body","\n"],["body","\nfunction f([first, second]: [number, number]) { \n\tconsole.log(first); \n\tconsole.log(second); \n} \n\nf(input);\n"],["body","\n"],["headingLink","使用语法创建剩余变量"],["heading","使用...语法创建剩余变量"],["body","\n"],["body","let [first, ...rest] = [1, 2, 3, 4]; \nconsole.log(first); // outputs 1 \nconsole.log(rest); // outputs [ 2, 3, 4 ]\n"],["body","\n"],["headingLink","数组-first元素"],["heading","数组 first元素"],["body","\n"],["body","let [first] = [1, 2, 3, 4]; \nconsole.log(first); // outputs 1\nlet [, second, , fourth] = [1, 2, 3, 4];\n"],["body","\n"],["headingLink","对象解构"],["heading","对象解构"],["body","\n"],["body","\tlet o = { a: \"foo\", b: 12, c: \"bar\" }; \n\tlet { a, b } = o;\n"],["body","\n"],["headingLink","属性重命名"],["heading","属性重命名"],["body","\n"],["body","let newName2 = o.b;\n"],["body","\n"],["headingLink","默认值"],["heading","默认值"],["body","\n"],["body","默认值可以让你在属性为 undefined 时使用缺省值："],["body","\n"],["body","function keepWholeObject(wholeObject: { a: string, b?: number }) \n{ \n\tlet { a, b = 1001 } = wholeObject; \n}\n"],["body","\n"],["headingLink","函数声明"],["heading","函数声明"],["body","\n"],["body","解构也能用于函数声明"],["body","\n"],["body","type C = { a: string, b?: number } \nfunction f({ a, b }: C): void \n{ \n\t// ... \n}\n"],["body","\n"],["body","function f({ a=\"\", b=0 } = {}): void { \n\t// ... \n} f();\n"],["body","\n\n\n\n"],["body","\n\n                    "],["body","\n\n                    \n                \n            \n\n            \n\n        \n\n\n\n\n        \n\n\n\n        \n        \n        \n\n        \n\n\n    \n    \n"]],[["_relative_fp","5.typescript/jtest测试框架/Globals.html"],["title","Globals - 各项编程语言"],["body","\n    \n        \n        \n\n        \n        \n\n        \n        \n\n        \n        \n\n        \n\n        \n\n            \n                                \n                \n                    \n                        "],["body","\n                            \n                        "],["body","\n                        "],["body","\n                            \n                        "],["body","\n                        \n                            "],["body","Light"],["body","\n                            "],["body","Rust"],["body","\n                            "],["body","Coal"],["body","\n                            "],["body","Navy"],["body","\n                            "],["body","Ayu"],["body","\n                        \n                    \n\n                    "],["heading","各项编程语言"],["body","\n\n                    \n\n                    \n                \n\n\n                \n                \n\n                \n                    "],["body","\n                        \n\n"],["body","\n"],["body","\n\n"],["headingLink","globals"],["heading","Globals"],["body","\n"],["body","在您的测试文件中，Jest将这些方法和对象中的每一个都放入全局环境中。您不必要求或导入任何东西即可使用它们。但是，如果您更喜欢显式导入，则可以从 “@ jest/globals” 中  \timport {describe, expect, test} from '@jest/globals'。"],["body","\n"],["headingLink","afterallfn-timeout"],["heading","afterAll(fn, timeout)"],["body","\n\n"],["body","\n"],["body","在此文件中的所有测试完成后运行一个函数。如果函数返回 Promise 或是generator，则Jest等待该承诺解决后再继续。"],["body","\n"],["body","\n"],["body","\n"],["body","您可以提供一个超时时间 (以毫秒为单位)，用于指定在中止之前等待多长时间。注意: 默认超时时间为5秒。\n如果要清理跨测试共享的某些全局设置状态，这通常很有用。"],["body","\n"],["body","\n\n"],["body","const globalDatabase = makeGlobalDatabase();\n\nfunction cleanUpDatabase(db) {\n  db.cleanUp();\n}\n\nafterAll(() => {\n  cleanUpDatabase(globalDatabase);\n});\n\ntest('can find things', () => {\n  return globalDatabase.find('thing', {}, results => {\n    expect(results.length).toBeGreaterThan(0);\n  });\n});\n\ntest('can insert a thing', () => {\n  return globalDatabase.insert('thing', makeThing(), response => {\n    expect(response.success).toBeTruthy();\n  });\n});\n"],["body","\n"],["headingLink","aftereachfn-timeout"],["heading","afterEach(fn, timeout)"],["body","\n"],["body","当每一个test结束时 执行的动作"],["body","\n"],["body","const globalDatabase = makeGlobalDatabase();\n\nfunction cleanUpDatabase(db) {\n  db.cleanUp();\n}\n\nafterEach(() => {\n  cleanUpDatabase(globalDatabase);\n});\n\ntest('can find things', () => {\n  return globalDatabase.find('thing', {}, results => {\n    expect(results.length).toBeGreaterThan(0);\n  });\n});\n\ntest('can insert a thing', () => {\n  return globalDatabase.insert('thing', makeThing(), response => {\n    expect(response.success).toBeTruthy();\n  });\n});\n"],["body","\n"],["headingLink","beforeallfn-timeout"],["heading","beforeAll(fn, timeout)"],["body","\n"],["body","所有test文件执行前执行"],["body","\n"],["body","const globalDatabase = makeGlobalDatabase();\n\nbeforeAll(() => {\n  // Clears the database and adds some testing data.\n  // Jest will wait for this promise to resolve before running tests.\n  return globalDatabase.clear().then(() => {\n    return globalDatabase.insert({testData: 'foo'});\n  });\n});\n\n// Since we only set up the database once in this example, it's important\n// that our tests don't modify it.\ntest('can find things', () => {\n  return globalDatabase.find('thing', {}, results => {\n    expect(results.length).toBeGreaterThan(0);\n  });\n});\n"],["body","\n"],["headingLink","beforeeachfn-timeout"],["heading","beforeEach(fn, timeout)"],["body","\n"],["body","在每个测试任务运行前执行"],["body","\n"],["body","const globalDatabase = makeGlobalDatabase();\n\nbeforeEach(() => {\n  // Clears the database and adds some testing data.\n  // Jest will wait for this promise to resolve before running tests.\n  return globalDatabase.clear().then(() => {\n    return globalDatabase.insert({testData: 'foo'});\n  });\n});\n\ntest('can find things', () => {\n  return globalDatabase.find('thing', {}, results => {\n    expect(results.length).toBeGreaterThan(0);\n  });\n});\n\ntest('can insert a thing', () => {\n  return globalDatabase.insert('thing', makeThing(), response => {\n    expect(response.success).toBeTruthy();\n  });\n});\n"],["body","\n"],["headingLink","describename-fn"],["heading","describe(name, fn)"],["body","\n"],["body","创建一个块，该块将几个相关测试分组在一起。"],["body","\n"],["body","const myBeverage = {\n  delicious: true,\n  sour: false,\n};\n\ndescribe('my beverage', () => {\n  test('is delicious', () => {\n    expect(myBeverage.delicious).toBeTruthy();\n  });\n\n  test('is not sour', () => {\n    expect(myBeverage.sour).toBeFalsy();\n  });\n});\n"],["body","\n"],["body","这不是必需的-您可以直接在顶层编写测试块。但是，如果您希望将测试分为组，这可能会很方便。\n如果你有测试的层次结构，你也可以嵌套描述块:"],["body","\n"],["body","const binaryStringToNumber = binString => {\n  if (!/^[01]+$/.test(binString)) {\n    throw new CustomError('Not a binary number.');\n  }\n\n  return parseInt(binString, 2);\n};\n\ndescribe('binaryStringToNumber', () => {\n  describe('given an invalid binary string', () => {\n    test('composed of non-numbers throws CustomError', () => {\n      expect(() => binaryStringToNumber('abc')).toThrowError(CustomError);\n    });\n\n    test('with extra whitespace throws CustomError', () => {\n      expect(() => binaryStringToNumber('  100')).toThrowError(CustomError);\n    });\n  });\n\n  describe('given a valid binary string', () => {\n    test('returns the correct number', () => {\n      expect(binaryStringToNumber('100')).toBe(4);\n    });\n  });\n});\n"],["body","\n"],["headingLink","describeeachtablename-fn-timeout"],["heading","describe.each(table)(name, fn, timeout)"],["body","\n\n"],["body","\n"],["body","使用不同的数据执行重复的测试集"],["body","\n"],["body","\n"],["body","\n"],["body","name: 测试套件的名称"],["body","\n"],["body","\n"],["body","\n"],["body","describe.each(table)(name, fn, timeout)"],["body","\n"],["body","\n"],["body","\n"],["body","通过占位符注入参数生成唯一的测试标题"],["body","\n"],["body","printf formatting"],["body","\n\n"],["body","%p - pretty-format."],["body","\n"],["body","%s- String."],["body","\n"],["body","%d- Number."],["body","\n"],["body","%i - Integer."],["body","\n"],["body","%f - Floating point value."],["body","\n"],["body","%j - JSON."],["body","\n"],["body","%o - Object."],["body","\n"],["body","%# - Index of the test case."],["body","\n"],["body","%% - single percent sign ('%'). This does not consume an argument."],["body","\n\n"],["body","\n"],["body","\n"],["body","或通过使用 $variable注入测试用例对象的属性来生成唯一的测试标题"],["body","\n\n"],["body","\n"],["body","嵌套对象使用： $variable.path.to.value"],["body","\n"],["body","\n"],["body","\n"],["body","可以使用 $#注入测试用例的索引"],["body","\n"],["body","\n"],["body","\n"],["body","您不能将 “$ variableable” 与 “printf” format 一起使用，除非 使用 %%"],["body","\n"],["body","\n\n"],["body","\n"],["body","\n"],["body","fn: 函数要运行的测试套件，这是将接收每行中的参数作为函数参数的函数。"],["body","\n"],["body","\n"],["body","\n"],["body","您可以提供一个超时时间 (以毫秒为单位)，用于指定在中止之前等待每一行多长时间。注意: 默认超时时间为5秒。"],["body","\n"],["body","\n\n"],["body","describe.each([\n  [1, 1, 2],\n  [1, 2, 3],\n  [2, 1, 3],\n])('.add(%i, %i)', (a, b, expected) => {\n  test(`returns ${expected}`, () => {\n    expect(a + b).toBe(expected);\n  });\n\n  test(`returned value not be greater than ${expected}`, () => {\n    expect(a + b).not.toBeGreaterThan(expected);\n  });\n\n  test(`returned value not be less than ${expected}`, () => {\n    expect(a + b).not.toBeLessThan(expected);\n  });\n});\n"],["body","\n"],["body","describe.each([\n  {a: 1, b: 1, expected: 2},\n  {a: 1, b: 2, expected: 3},\n  {a: 2, b: 1, expected: 3},\n])('.add($a, $b)', ({a, b, expected}) => {\n  test(`returns ${expected}`, () => {\n    expect(a + b).toBe(expected);\n  });\n\n  test(`returned value not be greater than ${expected}`, () => {\n    expect(a + b).not.toBeGreaterThan(expected);\n  });\n\n  test(`returned value not be less than ${expected}`, () => {\n    expect(a + b).not.toBeLessThan(expected);\n  });\n});\n"],["body","\n"],["headingLink","describeeachtablename-fn-timeout-1"],["heading","describe.each`table`(name, fn, timeout)"],["body","\n"],["body","table"],["body","\n"],["body","标记模板文字"],["body","\n"],["body","name"],["body","\n"],["body","测试套件名称"],["body","\n"],["body","describe.each`\n  a    | b    | expected\n  ${1} | ${1} | ${2}\n  ${1} | ${2} | ${3}\n  ${2} | ${1} | ${3}\n`('$a + $b', ({a, b, expected}) => {\n  test(`returns ${expected}`, () => {\n    expect(a + b).toBe(expected);\n  });\n\n  test(`returned value not be greater than ${expected}`, () => {\n    expect(a + b).not.toBeGreaterThan(expected);\n  });\n\n  test(`returned value not be less than ${expected}`, () => {\n    expect(a + b).not.toBeLessThan(expected);\n  });\n});\n"],["body","\n"],["headingLink","describeonlyname-fn"],["heading","describe.only(name, fn)"],["body","\n"],["body","同名函数：fdescribe(name, fn)"],["body","\n"],["body","只运行该测试块，而不运行其他测试块"],["body","\n\n"],["body","describe.only.each(table)(name, fn)"],["body","\n"],["body","describe.only.eachtable(name, fn)"],["body","\n\n"],["body","describe.only('my beverage', () => {\n  test('is delicious', () => {\n    expect(myBeverage.delicious).toBeTruthy();\n  });\n\n  test('is not sour', () => {\n    expect(myBeverage.sour).toBeFalsy();\n  });\n});\n\ndescribe('my other beverage', () => {\n  // ... will be skipped\n});\n"],["body","\n"],["headingLink","describeskipname-fn"],["heading","describe.skip(name, fn)"],["body","\n\n"],["body","跳过该测试块"],["body","\n"],["body","同义函数：xdescribe(name, fn)"],["body","\n"],["body","使用describe.skip 一般用来临时取消掉不用的注释。请注意，describe块仍将运行。如果您有一些也应该跳过的设置，请在beforall或beforeach块中进行。"],["body","\n"],["body","describe.skip.each(table)(name, fn)"],["body","\n"],["body","xdescribe.`each`table(name, fn)"],["body","\n"],["body","describe.skip.each`table`(name, fn)"],["body","\n\n"],["body","describe('my beverage', () => {\n  test('is delicious', () => {\n    expect(myBeverage.delicious).toBeTruthy();\n  });\n\n  test('is not sour', () => {\n    expect(myBeverage.sour).toBeFalsy();\n  });\n});\n\ndescribe.skip('my other beverage', () => {\n  // ... will be skipped\n});\n"],["body","\n"],["headingLink","testname-fn-timeout"],["heading","test(name, fn, timeout)"],["body","\n\n"],["body","同义函数：it(name, fn, timeout)"],["body","\n\n"],["body","test('did not rain', () => {\n  expect(inchesOfRain()).toBe(0);\n});\n"],["body","\n\n"],["body","\n"],["body","第一个参数是测试名称"],["body","\n"],["body","\n"],["body","\n"],["body","第二个参数是包含要测试的期望的函数。"],["body","\n"],["body","\n"],["body","\n"],["body","第三个参数 (可选) 是超时 (以毫秒为单位)，用于指定中止前等待多长时间。注意: 默认超时时间为5秒。"],["body","\n"],["body","\n"],["body","\n"],["body","如果从test返回promise ，Jest将等待Promis resloved，然后再完成测试。"],["body","\n"],["body","\n"],["body","\n"],["body","如果您为测试函数提供了一个参数，名字叫做，done，那么Jest也会等待。"],["body","\n"],["body","\n\n"],["body","当你想测试回调时，这可能很方便。here  看到如何测试异步代码。"],["body","\n"],["body","例如，假设fetchBeverageList() 返回一个承诺，该承诺应该解析为包含柠檬的列表。您可以使用以下方法进行测试:"],["body","\n"],["body","test('has lemon in it', () => {\n  return fetchBeverageList().then(list => {\n    expect(list).toContain('lemon');\n  });\n});\n"],["body","\n"],["body","即使测试调用将立即返回，测试也要等到promise解决后才能完成。"],["body","\n"],["headingLink","testconcurrentname-fn-timeout"],["heading","test.concurrent(name, fn, timeout)"],["body","\n\n"],["body","\n"],["body","it.concurrent(name, fn, timeout)"],["body","\n"],["body","\n"],["body","\n"],["body","test.concurrent.each(table)(name, fn, timeout)"],["body","\n"],["body","\n"],["body","\n"],["body","test.concurrent.only.each(table)(name, fn)"],["body","\n"],["body","\n"],["body","\n"],["body","test.concurrent.skip.each(table)(name, fn)"],["body","\n"],["body","\n"],["body","\n"],["body","test.concurrent.skip.eachtable(name, fn)"],["body","\n"],["body","\n"],["body","\n"],["body","第一个参数是测试名称; "],["body","\n"],["body","\n"],["body","\n"],["body","第二个参数是包含要测试的期望的异步函数。"],["body","\n"],["body","\n"],["body","\n"],["body","第三个参数 (可选) 是超时 (以毫秒为单位)，用于指定中止前等待多长时间。注意: 默认超时时间为5秒。"],["body","\n"],["body","\n\n"],["body","test.concurrent('addition of 2 numbers', async () => {\n  expect(5 + 3).toBe(8);\n});\n\ntest.concurrent('subtraction 2 numbers', async () => {\n  expect(5 - 3).toBe(2);\n});\n"],["body","\n"],["headingLink","testeachtablename-fn-timeout"],["heading","test.each(table)(name, fn, timeout)"],["body","\n"],["headingLink","testonlyname-fn-timeout"],["heading","test.only(name, fn, timeout)"],["body","\n\n\n\n"],["body","\n\n                    "],["body","\n\n                    \n                \n            \n\n            \n\n        \n\n\n\n\n        \n\n\n\n        \n        \n        \n\n        \n\n\n    \n    \n"]],[["_relative_fp","5.typescript/jtest测试框架/Hook顺序.html"],["title","Hook顺序 - 各项编程语言"],["body","\n    \n        \n        \n\n        \n        \n\n        \n        \n\n        \n        \n\n        \n\n        \n\n            \n                                \n                \n                    \n                        "],["body","\n                            \n                        "],["body","\n                        "],["body","\n                            \n                        "],["body","\n                        \n                            "],["body","Light"],["body","\n                            "],["body","Rust"],["body","\n                            "],["body","Coal"],["body","\n                            "],["body","Navy"],["body","\n                            "],["body","Ayu"],["body","\n                        \n                    \n\n                    "],["heading","各项编程语言"],["body","\n\n                    \n\n                    \n                \n\n\n                \n                \n\n                \n                    "],["body","\n                        \n\n"],["body","\n"],["body","\n\n"],["body","beforeAll(() => console.log('1 - beforeAll'));\nafterAll(() => console.log('1 - afterAll'));\nbeforeEach(() => console.log('1 - beforeEach'));\nafterEach(() => console.log('1 - afterEach'));\ntest('', () => console.log('1 - test'));\ndescribe('Scoped / Nested block', () => {\n  beforeAll(() => console.log('2 - beforeAll'));\n  afterAll(() => console.log('2 - afterAll'));\n  beforeEach(() => console.log('2 - beforeEach'));\n  afterEach(() => console.log('2 - afterEach'));\n  test('', () => console.log('2 - test'));\n});\n"],["body","\n"],["body","// 1 - beforeAll\n// 1 - beforeEach\n// 1 - test\n// 1 - afterEach\n// 2 - beforeAll\n// 1 - beforeEach\n// 2 - beforeEach\n// 2 - test\n// 2 - afterEach\n// 1 - afterEach\n// 2 - afterAll\n// 1 - afterAll\n"],["body","\n\n\n\n"],["body","\n\n                    "],["body","\n\n                    \n                \n            \n\n            \n\n        \n\n\n\n\n        \n\n\n\n        \n        \n        \n\n        \n\n\n    \n    \n"]],[["_relative_fp","5.typescript/jtest测试框架/index.html"],["title","jtest测试框架 - 各项编程语言"],["body","\n    \n        \n        \n\n        \n        \n\n        \n        \n\n        \n        \n\n        \n\n        \n\n            \n                                \n                \n                    \n                        "],["body","\n                            \n                        "],["body","\n                        "],["body","\n                            \n                        "],["body","\n                        \n                            "],["body","Light"],["body","\n                            "],["body","Rust"],["body","\n                            "],["body","Coal"],["body","\n                            "],["body","Navy"],["body","\n                            "],["body","Ayu"],["body","\n                        \n                    \n\n                    "],["heading","各项编程语言"],["body","\n\n                    \n\n                    \n                \n\n\n                \n                \n\n                \n                    "],["body","\n                        \n\n"],["body","\n"],["body","\n\n"],["headingLink","installation"],["heading","Installation"],["body","\n"],["body","yarn add --dev jest typescript ts-jest @types/jest\n"],["body","\n"],["headingLink","jest-config-file"],["heading","Jest config file"],["body","\n"],["headingLink","creating"],["heading","Creating"],["body","\n"],["body","默认情况下，Jest可以在没有任何配置文件的情况下运行，但不会编译.ts文件。为了使它与ts-jest转换TypeScript，我们将需要创建一个配置文件，该文件将告诉Jest使用ts-jest预设。"],["body","\n"],["body","ts-jest can create the configuration file for you automatically:"],["body","\n"],["body","yarn ts-jest config:init\n"],["body","\n"],["body","这将创建一个基本的Jest配置文件，该文件将通知Jest如何处理.ts文件正确。"],["body","\n"],["body","您还可以使用jest -- init命令 (根据您使用的内容，以npx或yarn为前缀) 来提供更多与Jest相关的选项。"],["body","\n"],["body","但是，对于有关是否启用TypeScript的Jtest问题，请回答 “否”。"],["body","\n"],["body","相反，在之后的jest.config.js文件中添加一行，预设: ts-jest"],["body","\n\n\n\n"],["body","\n\n                    "],["body","\n\n                    \n                \n            \n\n            \n\n        \n\n\n\n\n        \n\n\n\n        \n        \n        \n\n        \n\n\n    \n    \n"]],[["_relative_fp","5.typescript/jtest测试框架/Except.html"],["title","Except - 各项编程语言"],["body","\n    \n        \n        \n\n        \n        \n\n        \n        \n\n        \n        \n\n        \n\n        \n\n            \n                                \n                \n                    \n                        "],["body","\n                            \n                        "],["body","\n                        "],["body","\n                            \n                        "],["body","\n                        \n                            "],["body","Light"],["body","\n                            "],["body","Rust"],["body","\n                            "],["body","Coal"],["body","\n                            "],["body","Navy"],["body","\n                            "],["body","Ayu"],["body","\n                        \n                    \n\n                    "],["heading","各项编程语言"],["body","\n\n                    \n\n                    \n                \n\n\n                \n                \n\n                \n                    "],["body","\n                        \n\n"],["body","\n"],["body","\n\n"],["headingLink","expect"],["heading","Expect"],["body","\n"],["body","在编写测试时，通常需要检查值是否满足某些条件。expect使您可以访问许多 “matchers”，使您可以验证不同的内容。"],["body","\n"],["headingLink","expectvalue"],["heading","expect(value)"],["body","\n\n"],["body","\n"],["body","每次要测试值时都会使用expect函数。很少 expect  值 本身"],["body","\n"],["body","\n"],["body","\n"],["body","相反，您将使用expect和 “matcher” 函数来断言某个值。"],["body","\n"],["body","\n"],["body","\n"],["body","用一个例子来理解这一点更容易。假设你有一个方法bestroixflavor () 应该返回字符串 'grapefruit'。以下是你将如何测试:"],["body","\n"],["body","\n\n"],["body","test('the best flavor is grapefruit', () => {\n  expect(bestLaCroixFlavor()).toBe('grapefruit');\n});\n"],["body","\n"],["body","在这种情况下，toBe是matcher function。下面记录了许多不同的匹配器功能，以帮助您测试不同的东西。\n期望的参数应该是您的代码产生的值，并且匹配器的任何参数都应该是正确的值。"],["body","\n"],["headingLink","expectextendmatchers"],["heading","expect.extend(matchers)"],["body","\n"],["body","使用expect.extend 扩展自己的matchers到Jest。"],["body","\n"],["body","例如，假设您正在测试数字实用程序库，并且经常断言数字出现在其他数字的特定范围内。你可以把它抽象成一个toBeWithinRange匹配器:"],["body","\n"],["body","expect.extend({\n  toBeWithinRange(received, floor, ceiling) {\n    const pass = received >= floor && received <= ceiling;\n    if (pass) {\n      return {\n        message: () =>\n          `expected ${received} not to be within range ${floor} - ${ceiling}`,\n        pass: true,\n      };\n    } else {\n      return {\n        message: () =>\n          `expected ${received} to be within range ${floor} - ${ceiling}`,\n        pass: false,\n      };\n    }\n  },\n});\n\ntest('numeric ranges', () => {\n  expect(100).toBeWithinRange(90, 110);\n  expect(101).not.toBeWithinRange(0, 100);\n  expect({apples: 6, bananas: 3}).toEqual({\n    apples: expect.toBeWithinRange(1, 10),\n    bananas: expect.not.toBeWithinRange(11, 20),\n  });\n});\n"],["body","\n"],["body","注意: 在TypeScript中，例如使用 @ types/jest时，您可以在导入的模块中声明新的toBeWithinRange匹配器，如下所示:"],["body","\n"],["body","interface CustomMatchers<R = unknown> {\n  toBeWithinRange(floor: number, ceiling: number): R;\n}\n\ndeclare global {\n  namespace jest {\n    interface Expect extends CustomMatchers {}\n    interface Matchers<R> extends CustomMatchers<R> {}\n    interface InverseAsymmetricMatchers extends CustomMatchers {}\n  }\n}\n"],["body","\n"],["headingLink","expectanything"],["heading","expect.anything()"],["body","\n"],["body","expect.anything() 除了 null或者 undefine其他都匹配"],["body","\n"],["body","You can use it inside toEqual or toBeCalledWith instead of a literal value. "],["body","\n"],["body","一般在  toEqual or toBeCalledWith 内部使用 "],["body","\n"],["body","test('map calls its argument with a non-null argument', () => {\n  const mock = jest.fn();\n  [1].map(x => mock(x));\n  expect(mock).toBeCalledWith(expect.anything());\n});\n"],["body","\n"],["headingLink","expectanyconstructor"],["heading","expect.any(constructor)"],["body","\n"],["body","expect.any(constructor) matches anything that was created with the given constructor or if it's a primitive that is of the passed type. You can use it inside toEqual or toBeCalledWith instead of a literal value. For example, if you want to check that a mock function is called with a number:"],["body","\n"],["body","class Cat {}\nfunction getCat(fn) {\n  return fn(new Cat());\n}\n\ntest('randocall calls its callback with a class instance', () => {\n  const mock = jest.fn();\n  getCat(mock);\n  expect(mock).toBeCalledWith(expect.any(Cat));\n});\n\nfunction randocall(fn) {\n  return fn(Math.floor(Math.random() * 6 + 1));\n}\n\ntest('randocall calls its callback with a number', () => {\n  const mock = jest.fn();\n  randocall(mock);\n  expect(mock).toBeCalledWith(expect.any(Number));\n});\n"],["body","\n"],["headingLink","expectarraycontainingarray"],["heading","expect.arrayContaining(array)"],["body","\n"],["body","expect.arrayContaining(array) 匹配数组元素"],["body","\n"],["body","即 期望的数组必须是 返回数组的子集 "],["body","\n"],["body","describe('arrayContaining', () => {\n  const expected = ['Alice', 'Bob'];\n  it('matches even if received contains additional elements', () => {\n    expect(['Alice', 'Bob', 'Eve']).toEqual(expect.arrayContaining(expected));\n  });\n  it('does not match if received does not contain expected elements', () => {\n    expect(['Bob', 'Eve']).not.toEqual(expect.arrayContaining(expected));\n  });\n});\n"],["body","\n"],["body","describe('Beware of a misunderstanding! A sequence of dice rolls', () => {\n  const expected = [1, 2, 3, 4, 5, 6];\n  it('matches even with an unexpected number 7', () => {\n    expect([4, 1, 6, 7, 3, 5, 2, 5, 4, 6]).toEqual(\n      expect.arrayContaining(expected),\n    );\n  });\n  it('does not match without an expected number 2', () => {\n    expect([4, 1, 6, 7, 3, 5, 7, 5, 4, 6]).not.toEqual(\n      expect.arrayContaining(expected),\n    );\n  });\n});\n"],["body","\n"],["headingLink","expectassertionsnumber"],["heading","expect.assertions(number)"],["body","\n"],["body","expect.assertions(number) "],["body","\n"],["body","验证在测试过程中调用了一定数量的断言，这在测试异步代码很有用，以确保回调中的断言实际上被调用了"],["body","\n"],["body","例如， 有两个 异步 函数 callback1 callback2，它将以未知顺序异步调用它们。我们可以用:"],["body","\n"],["body","test('doAsync calls both callbacks', () => {\n  expect.assertions(2);\n  function callback1(data) {\n    expect(data).toBeTruthy();\n  }\n  function callback2(data) {\n    expect(data).toBeTruthy();\n  }\n\n  doAsync(callback1, callback2);\n});\n"],["body","\n"],["body","The expect.assertions(2) call ensures that both callbacks actually get called."],["body","\n\n\n\n"],["body","\n\n                    "],["body","\n\n                    \n                \n            \n\n            \n\n        \n\n\n\n\n        \n\n\n\n        \n        \n        \n\n        \n\n\n    \n    \n"]],[["_relative_fp","4.groovy/RuntimeAndCompile-timeMetaprogramming.html"],["title","RuntimeAndCompile-timeMetaprogramming - 各项编程语言"],["body","\n    \n        \n        \n\n        \n        \n\n        \n        \n\n        \n        \n\n        \n\n        \n\n            \n                                \n                \n                    \n                        "],["body","\n                            \n                        "],["body","\n                        "],["body","\n                            \n                        "],["body","\n                        \n                            "],["body","Light"],["body","\n                            "],["body","Rust"],["body","\n                            "],["body","Coal"],["body","\n                            "],["body","Navy"],["body","\n                            "],["body","Ayu"],["body","\n                        \n                    \n\n                    "],["heading","各项编程语言"],["body","\n\n                    \n\n                    \n                \n\n\n                \n                \n\n                \n                    "],["body","\n                        \n\n"],["body","\n"],["body","\n\n"],["headingLink","runtime-and-compile-time-metaprogramming"],["heading","Runtime and compile-time metaprogramming"],["body","\n"],["body","\n"],["body","运行时和编译时的元编程"],["body","\n"],["body","\n"],["body","Groovy支持两种编程模型：运行时、编译时"],["body","\n"],["headingLink","runtime-metaprogramming"],["heading","Runtime metaprogramming"],["body","\n"],["body","运行时、元编程可以将 拦截、注入、甚至类与接口得合成推迟到运行时"],["body","\n"],["body","为了深入理解 Groovy 的元对象协议 (MOP)，我们需要了解 Groovy 对象和 Groovy 的方法处理。"],["body","\n"],["body","在 Groovy 中，我们使用三种对象"],["body","\n\n"],["body","POJO"],["body","\n"],["body","POGO"],["body","\n"],["body","Groovy Interceptors"],["body","\n\n"],["body","Groovy 允许对所有类型的对象进行元编程，但方式不同。"],["body","\n\n"],["body","POJO - 常规 Java 对象，其类可以用 Java 或任何其他 JVM 语言编写"],["body","\n"],["body","POGO - 一个 Groovy 对象，其类是用 Groovy 编写的。继承了 Object 实现了 groovy.lang.GroovyObject"],["body","\n"],["body","Groovy Interceptor - 一个 Groovy 对象 实现了 groovy.lang.GroovyInterceptable "],["body","\n\n"],["body","对于每个方法调用 Groovy 检查对象是 POJO 还是 POGO"],["body","\n\n"],["body","对于POJO，Groovy  从  groovy.lang.MetaClassRegistry 获取 MetaClass ，将方法调用委托给它。"],["body","\n"],["body","对于POGO，Groovy 有更多的步骤"],["body","\n\n"],["body","\n"],["headingLink","groovyobject-interface"],["heading","GroovyObject interface"],["body","\n\n\n\n"],["body","\n\n                    "],["body","\n\n                    \n                \n            \n\n            \n\n        \n\n\n\n\n        \n\n\n\n        \n        \n        \n\n        \n\n\n    \n    \n"]],[["_relative_fp","4.groovy/操作符.html"],["title","操作符 - 各项编程语言"],["body","\n    \n        \n        \n\n        \n        \n\n        \n        \n\n        \n        \n\n        \n\n        \n\n            \n                                \n                \n                    \n                        "],["body","\n                            \n                        "],["body","\n                        "],["body","\n                            \n                        "],["body","\n                        \n                            "],["body","Light"],["body","\n                            "],["body","Rust"],["body","\n                            "],["body","Coal"],["body","\n                            "],["body","Navy"],["body","\n                            "],["body","Ayu"],["body","\n                        \n                    \n\n                    "],["heading","各项编程语言"],["body","\n\n                    \n\n                    \n                \n\n\n                \n                \n\n                \n                    "],["body","\n                        \n\n"],["body","\n"],["body","\n\n"],["headingLink","arithmetic-operators"],["heading","Arithmetic operators"],["body","\n"],["headingLink","normal-arithmetic-operators"],["heading","Normal arithmetic operators"],["body","\n"],["body","The following binary arithmetic operators are available in Groovy:"],["body","\n"],["body","Operator"],["body","Purpose"],["body","Remarks"],["body","\n"],["body","+"],["body","addition"],["body","\n"],["body","-"],["body","subtraction"],["body","\n"],["body","*"],["body","multiplication"],["body","\n"],["body","/"],["body","division"],["body","Use intdiv() for integer division, and see the section about integer division for more information on the return type of the division."],["body","\n"],["body","%"],["body","remainder"],["body","\n"],["body","**"],["body","power"],["body","See the section about the power operation for more information on the return type of the operation."],["body","\n\n\n"],["headingLink","unary-operators"],["heading","Unary operators"],["body","\n"],["body","一元运算符"],["body","\n"],["body","assert +3 == 3\nassert -4 == 0 - 4\n\nassert -(-1) == 1  \n"],["body","\n"],["body","请注意使用括号包围表达式以将一元减号应用于该被包围的表达式。"],["body","\n"],["body","就一元算术运算符而言，可用前缀和后缀表示法的 ++（增量）和 --（减量）运算符："],["body","\n"],["body","def a = 2\ndef b = a++ * 3             \n\nassert a == 3 && b == 6\n\ndef c = 3\ndef d = c-- * 2             \n\nassert c == 2 && d == 6\n\ndef e = 1\ndef f = ++e + 3             \n\nassert e == 2 && f == 5\n\ndef g = 4\ndef h = --g + 1             \n\nassert g == 3 && h == 4\n"],["body","\n"],["headingLink","assignment-arithmetic-operators"],["heading","Assignment arithmetic operators"],["body","\n"],["body","赋值算术运算符"],["body","\n"],["body","我们上面看到的二元算术运算符也有赋值形式：-+="],["body","\n\n"],["body","-="],["body","\n"],["body","*="],["body","\n"],["body","/="],["body","\n"],["body","%="],["body","\n"],["body","**="],["body","\n\n"],["body","def a = 4\na += 3\n\nassert a == 7\n\ndef b = 5\nb -= 3\n\nassert b == 2\n\ndef c = 5\nc *= 3\n\nassert c == 15\n\ndef d = 10\nd /= 2\n\nassert d == 5\n\ndef e = 10\ne %= 3\n\nassert e == 1\n\ndef f = 3\nf **= 2\n\nassert f == 9\n"],["body","\n"],["headingLink","relational-operators"],["heading","Relational operators"],["body","\n"],["body","关系运算符允许在对象之间进行比较，以了解两个对象是否相同或不同，或者一个对象是否大于、小于或等于另一个。"],["body","\n"],["body","The following operators are available:"],["body","\n"],["body","Operator"],["body","Purpose"],["body","\n"],["body","=="],["body","equal"],["body","\n"],["body","!="],["body","different"],["body","\n"],["body","<"],["body","less than"],["body","\n"],["body","<="],["body","less than or equal"],["body","\n"],["body",">"],["body","greater than"],["body","\n"],["body",">="],["body","greater than or equal"],["body","\n"],["body","==="],["body","identical (Since Groovy 3.0.0)"],["body","\n"],["body","!=="],["body","not identical (Since Groovy 3.0.0)"],["body","\n\n\n"],["body","===和!==都被支持，它们分别与调用is()方法和否定调用is()` 方法相同。"],["body","\n"],["headingLink","logical-operators"],["heading","Logical operators"],["body","\n\n"],["body","&&: logical \"and\""],["body","\n"],["body","||: logical \"or\""],["body","\n"],["body","!: logical \"not\""],["body","\n\n"],["body","assert !false           \nassert true && true     \nassert true || false    \n"],["body","\n"],["headingLink","precedence"],["heading","Precedence"],["body","\n"],["body","逻辑“非”比逻辑“与”具有更高的优先级。"],["body","\n"],["body","assert (!false && false) == false   \n"],["body","\n"],["body","逻辑“与”比逻辑“或”具有更高的优先级。"],["body","\n"],["body","assert true || true && false        \n"],["body","\n"],["headingLink","short-circuiting"],["heading","Short-circuiting"],["body","\n"],["body","boolean checkIfCalled() {   \n    called = true\n}\n\ncalled = false\ntrue || checkIfCalled()\nassert !called              \n\ncalled = false\nfalse || checkIfCalled()\nassert called               \n\ncalled = false\nfalse && checkIfCalled()\nassert !called              \n\ncalled = false\ntrue && checkIfCalled()\nassert called               \n"],["body","\n"],["headingLink","bitwise-and-bit-shift-operators"],["heading","Bitwise and bit shift operators"],["body","\n"],["headingLink","bitwise-operators"],["heading","Bitwise operators"],["body","\n"],["body","\n"],["body","位运算"],["body","\n"],["body","\n"],["body","按位和位移运算符"],["body","\n\n"],["body","&: bitwise \"and\""],["body","\n"],["body","|: bitwise \"or\""],["body","\n"],["body","^: bitwise \"xor\" (exclusive \"or\")"],["body","\n"],["body","~: bitwise negation"],["body","\n\n"],["body","位运算符可应用于字节、短整型、整型、长整型或大整数类型的参数。"],["body","\n"],["body","如果参数之一是 BigInteger，则结果将是 BigInteger 类型；"],["body","\n"],["body","否则，如果其中一个参数是 long，则结果将是 long 类型；"],["body","\n"],["headingLink","bit-shift-operators"],["heading","Bit shift operators"],["body","\n"],["body","移位运算"],["body","\n\n"],["body","<<: left shift"],["body","\n"],["body",">>: right shift"],["body","\n"],["body",">>>: right shift unsigned"],["body","\n\n"],["body","assert 12.equals(3 << 2)           \nassert 24L.equals(3L << 3)         \nassert 48G.equals(3G << 4)         \n\nassert 4095 == -200 >>> 20\nassert -1 == -200 >> 20\nassert 2G == 5G >> 1\nassert -3G == -5G >> 1\n"],["body","\n"],["body","在 Groovy 中，位移运算符是可重载的，这意味着您可以为任何类型的对象定义这些运算符的行为。"],["body","\n"],["headingLink","conditional-operators"],["heading","Conditional operators"],["body","\n"],["headingLink","not-operator"],["heading","Not operator"],["body","\n"],["body","“not”运算符用感叹号 (!) 表示，并反转底层布尔表达式的结果。特别是，可以将 not 运算符与 Groovy  truth 结合起来："],["body","\n"],["body","assert (!true)    == false                      \nassert (!'foo')   == false                      \nassert (!'')      == true                       \n"],["body","\n"],["headingLink","ternary-operator"],["heading","Ternary operator"],["body","\n"],["body","三元运算符"],["body","\n"],["body","result = (string!=null && string.length()>0) ? 'Found' : 'Not found'\n"],["body","\n"],["headingLink","elvis-operator"],["heading","Elvis operator"],["body","\n"],["body","是三元运算符得缩写形式"],["body","\n"],["body","displayName = user.name ? user.name : 'Anonymous'   \ndisplayName = user.name ?: 'Anonymous'     \n"],["body","\n"],["body","Elvis 运算符的使用减少了代码的冗长性，并降低了重构时出错的风险，因为无需复制在条件和正返回值中都测试过的表达式。"],["body","\n"],["headingLink","elvis-assignment-operator"],["heading","Elvis assignment operator"],["body","\n"],["body","import groovy.transform.ToString\n\n@ToString\nclass Element {\n    String name\n    int atomicNumber\n}\n\ndef he = new Element(name: 'Helium')\nhe.with {\n    name = name ?: 'Hydrogen'   // existing Elvis operator\n    atomicNumber ?= 2           // new Elvis assignment shorthand\n}\nassert he.toString() == 'Element(Helium, 2)'\n"],["body","\n"],["headingLink","object-operators"],["heading","Object operators"],["body","\n"],["headingLink","safe-navigation-operator"],["heading","Safe navigation operator"],["body","\n"],["body","安全导航运算符用于避免 NullPointerException。"],["body","\n"],["body","通常，当您有一个对象的引用时，您可能需要在访问该对象的方法或属性之前验证它是否为空。"],["body","\n"],["body","为了避免这种情况，安全导航运算符将简单地返回 null 而不是抛出异常，如下所示："],["body","\n"],["body","def person = Person.find { it.id == 123 }    \ndef name = person?.name                      \nassert name == null                          \n"],["body","\n"],["headingLink","direct-field-access-operator"],["heading","Direct field access operator"],["body","\n"],["body","\n"],["body","直接字段访问操作符."],["body","\n"],["body","\n"],["body","普通访问会调用Get方法"],["body","\n"],["body","class User {\n    public final String name                 \n    User(String name) { this.name = name}\n    String getName() { \"Name: $name\" }       \n}\ndef user = new User('Bob')\nassert user.name == 'Name: Bob'              \n"],["body","\n"],["body","如果要检索字段而不是调用 getter，可以使用直接字段访问运算符："],["body","\n"],["body","assert user.@name == 'Bob'                   \n"],["body","\n"],["body","使用 .@ 强制使用字段而不是 getter"],["body","\n"],["headingLink","method-pointer-operator"],["heading","Method pointer operator"],["body","\n"],["body","方法指针运算符 (.&) 可用于在变量中存储对方法的引用，以便稍后调用："],["body","\n"],["body","def str = 'example of method reference'            \ndef fun = str.&toUpperCase                         \ndef upper = fun()                                  \nassert upper == str.toUpperCase()                  \n"],["body","\n"],["body","使用方法指针有很多优点。"],["body","\n"],["body","首先，这种方法指针的类型是 groovy.lang.Closure，所以它可以用在任何需要使用闭包的地方。"],["body","\n"],["body","特别适合将现有的方法转换为策略模式的需要："],["body","\n"],["body","def transform(List elements, Closure action) {                    \n    def result = []\n    elements.each {\n        result << action(it)\n    }\n    result\n}\nString describe(Person p) {                                       \n    \"$p.name is $p.age\"\n}\ndef action = this.&describe                                       \ndef list = [\n    new Person(name: 'Bob',   age: 42),\n    new Person(name: 'Julia', age: 35)]                           \nassert transform(list, action) == ['Bob is 42', 'Julia is 35']    \n"],["body","\n"],["body","方法指针由接收者和方法名绑定。"],["body","\n"],["body","参数是在运行时解析的，这意味着如果您有多个同名的方法，语法没有不同，只会在运行时解析要调用的适当方法："],["body","\n"],["body","def doSomething(String str) { str.toUpperCase() }    \ndef doSomething(Integer x) { 2*x }                   \ndef reference = this.&doSomething                    \nassert reference('foo') == 'FOO'                     \nassert reference(123)   == 246                       \n"],["body","\n"],["body","为了符合 Java 8 方法引用期望，在 Groovy 3 及更高版本中，您可以使用 new 作为方法名称来获取指向构造函数的方法指针："],["body","\n"],["body","def foo  = BigInteger.&new\ndef fortyTwo = foo('42')\nassert fortyTwo == 42G\n"],["body","\n"],["body","同样在 Groovy 3 及更高版本中，您可以获得指向类的实例方法的方法指针。"],["body","\n"],["body","此方法指针采用一个附加参数作为接收器实例来调用该方法："],["body","\n"],["body","def instanceMethod = String.&toUpperCase\nassert instanceMethod('foo') == 'FOO'\n"],["body","\n"],["body","为了向后兼容，在这种情况下，任何碰巧具有正确调用参数的静态方法都将优先于实例方法"],["body","\n"],["headingLink","method-reference-operator"],["heading","Method reference operator"],["body","\n"],["body","Groovy 3+ 中的 Parrot 解析器支持 Java 8+ 方法引用运算符。"],["body","\n"],["body","方法引用运算符 (::) 可用于在需要函数式接口的上下文中引用方法或构造函数。"],["body","\n"],["body","这与 Groovy 的方法指针运算符提供的功能有些重叠。"],["body","\n"],["body","import groovy.transform.CompileStatic\nimport static java.util.stream.Collectors.toList\n\n@CompileStatic\nvoid methodRefs() {\n    assert 6G == [1G, 2G, 3G].stream().reduce(0G, BigInteger::add)                           \n\n    assert [4G, 5G, 6G] == [1G, 2G, 3G].stream().map(3G::add).collect(toList())              \n\n    assert [1G, 2G, 3G] == [1L, 2L, 3L].stream().map(BigInteger::valueOf).collect(toList())  \n\n    assert [1G, 2G, 3G] == [1L, 2L, 3L].stream().map(3G::valueOf).collect(toList())          \n}\n\nmethodRefs()\n"],["body","\n"],["body","以下脚本显示了一些突出显示各种受支持的构造函数参考案例的示例："],["body","\n"],["body","@CompileStatic\nvoid constructorRefs() {\n    assert [1, 2, 3] == ['1', '2', '3'].stream().map(Integer::new).collect(toList())  \n\n    def result = [1, 2, 3].stream().toArray(Integer[]::new)                           \n    assert result instanceof Integer[]\n    assert result.toString() == '[1, 2, 3]'\n}\n\nconstructorRefs()\n"],["body","\n"],["headingLink","regular-expression-operators"],["heading","Regular expression operators"],["body","\n"],["headingLink","pattern-operator"],["heading","Pattern operator"],["body","\n"],["body","模式运算符 (~) 提供了一种创建 java.util.regex.Pattern 实例的简单方法："],["body","\n"],["body","def p = ~/foo/\nassert p instanceof Pattern\n"],["body","\n"],["body","通常，您会在斜线字符串中找到带有表达式的模式运算符，但它可以与 Groovy 中的任何类型的字符串一起使用："],["body","\n"],["body","p = ~'foo'                                                        \np = ~\"foo\"                                                        \np = ~$/dollar/slashy $ string/$                                   \np = ~\"${pattern}\"     \n"],["body","\n"],["body","虽然您可以将大多数字符串形式与 Pattern、Find 和 Match 运算符一起使用，但我们建议在大多数情况下使用斜线字符串，以便不必记住其他需要的转义要求。"],["body","\n"],["headingLink","find-operator"],["heading","Find operator"],["body","\n"],["body","作为构建模式的替代方法，您可以使用 find 运算符 =~ 直接创建一个 java.util.regex.Matcher 实例："],["body","\n"],["body","def text = \"some text to match\"\ndef m = text =~ /match/                                           \nassert m instanceof Matcher                                       \n//equivalent to calling if (!m.find(0))\nif (!m) {                                                         \n    throw new RuntimeException(\"Oops, text not found!\")\n}\n"],["body","\n"],["headingLink","match-operator"],["heading","Match operator"],["body","\n"],["body","匹配运算符 (==~) 是查找运算符的轻微变体，它不返回匹配器而是返回布尔值，并且需要输入字符串的严格匹配："],["body","\n"],["body","m = text ==~ /match/                                              \nassert m instanceof Boolean                                       \nif (m) {                                                          \n    throw new RuntimeException(\"Should not reach that point!\")\n}\n"],["body","\n"],["headingLink","comparing-find-vs-match-operators"],["heading","Comparing Find vs Match operators"],["body","\n"],["body","通常，当模式涉及单个完全匹配时使用匹配运算符，否则查找运算符可能更有用。"],["body","\n"],["body","assert 'two words' ==~ /\\S+\\s+\\S+/\nassert 'two words' ==~ /^\\S+\\s+\\S+$/         \nassert !(' leading space' ==~ /\\S+\\s+\\S+/)   \n\ndef m1 = 'two words' =~ /^\\S+\\s+\\S+$/\nassert m1.size() == 1                          \ndef m2 = 'now three words' =~ /^\\S+\\s+\\S+$/    \nassert m2.size() == 0                          \ndef m3 = 'now three words' =~ /\\S+\\s+\\S+/\nassert m3.size() == 1                          \nassert m3[0] == 'now three'\ndef m4 = ' leading space' =~ /\\S+\\s+\\S+/\nassert m4.size() == 1                          \nassert m4[0] == 'leading space'\ndef m5 = 'and with four words' =~ /\\S+\\s+\\S+/\nassert m5.size() == 2                          \nassert m5[0] == 'and with'\nassert m5[1] == 'four words'\n"],["body","\n"],["headingLink","other-operators"],["heading","Other operators"],["body","\n"],["headingLink","spread-operator"],["heading","Spread operator"],["body","\n"],["body","扩展点运算符 (*.)，通常缩写为扩展运算符，用于对聚合对象的所有 item 调用操作。"],["body","\n"],["body","相当于在每一项上调用action，将结果收集到一个列表中："],["body","\n"],["body","class Car {\n    String make\n    String model\n}\ndef cars = [\n       new Car(make: 'Peugeot', model: '508'),\n       new Car(make: 'Renault', model: 'Clio')]       \ndef makes = cars*.make                                \nassert makes == ['Peugeot', 'Renault']                \n"],["body","\n"],["body","展开运算符是空安全的，这意味着如果集合的元素为空，它将返回空而不是抛出 NullPointerException："],["body","\n"],["body","cars = [\n   new Car(make: 'Peugeot', model: '508'),\n   null,                                              \n   new Car(make: 'Renault', model: 'Clio')]\nassert cars*.make == ['Peugeot', null, 'Renault']     \nassert null*.make == null       \n"],["body","\n"],["body","展开运算符可用于任何实现 Iterable 接口的类："],["body","\n"],["body","class Component {\n    Long id\n    String name\n}\nclass CompositeObject implements Iterable<Component> {\n    def components = [\n        new Component(id: 1, name: 'Foo'),\n        new Component(id: 2, name: 'Bar')]\n\n    @Override\n    Iterator<Component> iterator() {\n        components.iterator()\n    }\n}\ndef composite = new CompositeObject()\nassert composite*.id == [1,2]\nassert composite*.name == ['Foo','Bar']\n"],["body","\n"],["body","在处理本身包含聚合的数据结构聚合时，使用扩展点运算符的多次调用（此处为cars*.models*.name）："],["body","\n"],["body","class Make {\n    String name\n    List<Model> models\n}\n\n@Canonical\nclass Model {\n    String name\n}\n\ndef cars = [\n    new Make(name: 'Peugeot',\n             models: [new Model('408'), new Model('508')]),\n    new Make(name: 'Renault',\n             models: [new Model('Clio'), new Model('Captur')])\n]\n\ndef makes = cars*.name\nassert makes == ['Peugeot', 'Renault']\n\ndef models = cars*.models*.name\nassert models == [['408', '508'], ['Clio', 'Captur']]\nassert models.sum() == ['408', '508', 'Clio', 'Captur'] // flatten one level\nassert models.flatten() == ['408', '508', 'Clio', 'Captur'] // flatten all levels (one in this case)\n"],["body","\n"],["body","class Car {\n    String make\n    String model\n}\ndef cars = [\n   [\n       new Car(make: 'Peugeot', model: '408'),\n       new Car(make: 'Peugeot', model: '508')\n   ], [\n       new Car(make: 'Renault', model: 'Clio'),\n       new Car(make: 'Renault', model: 'Captur')\n   ]\n]\ndef models = cars.collectNested{ it.model }\nassert models == [['408', '508'], ['Clio', 'Captur']]\n"],["body","\n"],["body","Spreading method arguments"],["body","\n"],["body","在某些情况下，可以在列表中找到方法调用的参数，您需要适应方法参数。"],["body","\n"],["body","在这种情况下，您可以使用扩展运算符来调用该方法。"],["body","\n"],["body","int function(int x, int y, int z) {\n    x*y+z\n}\n\ndef args = [4,5,6]\nassert function(*args) == 26\n\nargs = [4]\nassert function(*args,5,6) == 26\n"],["body","\n"],["body","Spread list elements"],["body","\n"],["body","def items = [4,5]                      \ndef list = [1,2,3,*items,6]            \nassert list == [1,2,3,4,5,6]           \n"],["body","\n"],["body","Spread map elements"],["body","\n"],["body","def m1 = [c:3, d:4]                   \ndef map = [a:1, b:2, *:m1]            \nassert map == [a:1, b:2, c:3, d:4]    \n"],["body","\n"],["headingLink","range-operator"],["heading","Range operator"],["body","\n"],["body","def range = 0..5                                    \nassert (0..5).collect() == [0, 1, 2, 3, 4, 5]       \nassert (0..<5).collect() == [0, 1, 2, 3, 4]         \nassert (0..5) instanceof List                       \nassert (0..5).size() == 6                           \n"],["body","\n"],["headingLink","spaceship-operator"],["heading","Spaceship operator"],["body","\n"],["body","飞船运算符 (<=>) 委托给 compareTo 方法："],["body","\n"],["body","assert (1 <=> 1) == 0\nassert (1 <=> 2) == -1\nassert (2 <=> 1) == 1\nassert ('a' <=> 'z') == -1\n"],["body","\n"],["headingLink","subscript-operator"],["heading","Subscript operator"],["body","\n"],["body","下标运算符是 getAt 或 putAt 的简写符号，具体取决于您是在赋值的左侧还是右侧找到它："],["body","\n"],["body","def list = [0,1,2,3,4]\nassert list[2] == 2                         \nlist[2] = 4                                 \nassert list[0..2] == [0,1,4]                \nlist[0..2] = [6,6,6]                        \nassert list == [6,6,6,3,4]                  \n"],["body","\n"],["body","下标运算符与 getAt/putAt 的自定义实现相结合是解构对象的便捷方法："],["body","\n"],["body","class User {\n    Long id\n    String name\n    def getAt(int i) {                                             \n        switch (i) {\n            case 0: return id\n            case 1: return name\n        }\n        throw new IllegalArgumentException(\"No such element $i\")\n    }\n    void putAt(int i, def value) {                                 \n        switch (i) {\n            case 0: id = value; return\n            case 1: name = value; return\n        }\n        throw new IllegalArgumentException(\"No such element $i\")\n    }\n}\ndef user = new User(id: 1, name: 'Alex')                           \nassert user[0] == 1                                                \nassert user[1] == 'Alex'                                           \nuser[1] = 'Bob'                                                    \nassert user.name == 'Bob'   \n"],["body","\n"],["headingLink","safe-index-operator"],["heading","Safe index operator"],["body","\n"],["body","Groovy 3.0.0 引入了安全索引操作符，即 ?[]，类似于 ?.. 例如："],["body","\n"],["body","String[] array = ['a', 'b']\nassert 'b' == array?[1]      // get using normal array index\narray?[1] = 'c'              // set using normal array index\nassert 'c' == array?[1]\n\narray = null\nassert null == array?[1]     // return null for all index values\narray?[1] = 'c'              // quietly ignore attempt to set value\nassert null == array?[1]\n\ndef personInfo = [name: 'Daniel.Sun', location: 'Shanghai']\nassert 'Daniel.Sun' == personInfo?['name']      // get using normal map index\npersonInfo?['name'] = 'sunlan'                  // set using normal map index\nassert 'sunlan' == personInfo?['name']\n\npersonInfo = null\nassert null == personInfo?['name']              // return null for all map values\npersonInfo?['name'] = 'sunlan'                  // quietly ignore attempt to set value\nassert null == personInfo?['name']\n"],["body","\n"],["headingLink","membership-operator"],["heading","Membership operator"],["body","\n"],["body","成员资格运算符 (in) 等效于调用 isCase 方法。在 List 的上下文中，它相当于调用 contains，如下例所示"],["body","\n"],["body","def list = ['Grace','Rob','Emmy']\nassert ('Emmy' in list) \n"],["body","\n"],["body","equivalent to calling list.contains('Emmy') or list.isCase('Emmy')"],["body","\n"],["headingLink","identity-operator"],["heading","Identity operator"],["body","\n"],["body","在 Groovy 中，使用 == 来测试相等性与在 Java 中使用相同的运算符不同。"],["body","\n"],["body","在 Groovy 中，它调用的是 equals。"],["body","\n"],["body","如果你想比较引用相等，你应该像下面的例子一样使用："],["body","\n"],["body","def list1 = ['Groovy 1.8','Groovy 2.0','Groovy 2.3']        \ndef list2 = ['Groovy 1.8','Groovy 2.0','Groovy 2.3']        \nassert list1 == list2                                       \nassert !list1.is(list2)  \n"],["body","\n"],["headingLink","coercion-operator"],["heading","Coercion operator"],["body","\n"],["body","强制操作符"],["body","\n"],["body","强制运算符 (as) 是强制转换的变体。"],["body","\n"],["body","强制将对象从一种类型转换为另一种类型，而它们不兼容赋值。"],["body","\n"],["body","Integer x = 123\nString s = (String) x      \n"],["body","\n"],["body","Integer 不能分配给 String，所以它会在运行时产生 ClassCastException,这可以通过使用强制来解决："],["body","\n"],["body","Integer x = 123\n//整数不可分配给字符串，但使用 as 会将其强制为字符串\nString s = x as String      \n"],["body","\n"],["body","当一个对象被强制转换为另一个对象时，除非目标类型与源类型相同，否则强制将返回一个新对象。"],["body","\n"],["body","转换规则因源和目标类型而异，如果找不到转换规则，则转换可能会失败。"],["body","\n"],["body","由于 asType 方法，可以实现自定义转换规则："],["body","\n"],["body","class Identifiable {\n    String name\n}\nclass User {\n    Long id\n    String name\n    def asType(Class target) {                                              \n        if (target == Identifiable) {\n            return new Identifiable(name: name)\n        }\n        throw new ClassCastException(\"User cannot be coerced into $target\")\n    }\n}\ndef u = new User(name: 'Xavier')                                            \ndef p = u as Identifiable                                                   \nassert p instanceof Identifiable                                            \nassert !(p instanceof User)             \n"],["body","\n"],["headingLink","diamond-operator"],["heading","Diamond operator"],["body","\n"],["body","菱形运算符 (<>) 是一种语法糖运算符，用于支持与 Java 7 中同名运算符的兼容性。它用于指示应从声明中推断出泛型类型："],["body","\n"],["body","List<String> strings = new LinkedList<>()\n"],["body","\n"],["body","在动态 Groovy 中，这是完全未使用的。"],["body","\n"],["body","在静态类型检查的 Groovy 中，它也是可选的，因为无论该运算符是否存在，Groovy 类型检查器都会执行类型推断。"],["body","\n"],["headingLink","call-operator"],["heading","Call operator"],["body","\n"],["body","调用运算符 () 用于隐式调用名为 call 的方法。"],["body","\n"],["body","对于定义调用方法的任何对象，您可以省略 .call 部分并使用调用运算符代替："],["body","\n"],["body","class MyCallable {\n    int call(int x) {           \n        2*x\n    }\n}\n\ndef mc = new MyCallable()\nassert mc.call(2) == 4          \nassert mc(2) == 4               \n"],["body","\n"],["headingLink","operator-precedence"],["heading","Operator precedence"],["body","\n"],["body","he table below lists all groovy operators in order of precedence."],["body","\n"],["body","Level"],["body","Operator(s)"],["body","Name(s)"],["body","\n"],["body","1"],["body","new  ()"],["body","object creation, explicit parentheses"],["body","\n"],["body","()  {}  []"],["body","method call, closure, literal list/map"],["body","\n"],["body",".  .&  .@"],["body","member access, method closure, field/attribute access"],["body","\n"],["body","?.  *  *.  *:"],["body","safe dereferencing, spread, spread-dot, spread-map"],["body","\n"],["body","~  !  (type)"],["body","bitwise negate/pattern, not, typecast"],["body","\n"],["body","[]  ?[]  ++  --"],["body","list/map/array (safe) index, post inc/decrement"],["body","\n"],["body","2"],["body","**"],["body","power"],["body","\n"],["body","3"],["body","++  --  +  -"],["body","pre inc/decrement, unary plus, unary minus"],["body","\n"],["body","4"],["body","*  /  %"],["body","multiply, div, remainder"],["body","\n"],["body","5"],["body","+  -"],["body","addition, subtraction"],["body","\n"],["body","6"],["body","<<  >>  >>>  ..  ..<"],["body","left/right (unsigned) shift, inclusive/exclusive range"],["body","\n"],["body","7"],["body","<  <=  >  >=  in  !in  instanceof  !instanceof  as"],["body","less/greater than/or equal, in, not in, instanceof, not instanceof, type coercion"],["body","\n"],["body","8"],["body","==  !=  <=>  ===  !=="],["body","equals, not equals, compare to, identical to, not identical to"],["body","\n"],["body","=~  ==~"],["body","regex find, regex match"],["body","\n"],["body","9"],["body","&"],["body","binary/bitwise and"],["body","\n"],["body","10"],["body","^"],["body","binary/bitwise xor"],["body","\n"],["body","11"],["body","`"],["body","`"],["body","\n"],["body","12"],["body","&&"],["body","logical and"],["body","\n"],["body","13"],["body","`"],["body","\n"],["body","14"],["body","? :"],["body","ternary conditional"],["body","\n"],["body","?:"],["body","elvis operator"],["body","\n"],["body","15"],["body","=  **=  *=  /=  %=  +=  -=  <<=  >>=  >>>=  &=  ^=  `"],["body","=   ?=`"],["body","\n\n\n"],["headingLink","operator-overloading"],["heading","Operator overloading"],["body","\n"],["body","Groovy 允许您重载各种运算符，以便它们可以与您自己的类一起使用。"],["body","\n"],["body","class Bucket {\n    int size\n\n    Bucket(int size) { this.size = size }\n\n    Bucket plus(Bucket other) {                     \n        return new Bucket(this.size + other.size)\n    }\n}\n"],["body","\n"],["body","Just by implementing the plus() method, the Bucket class can now be used with the + operator like so:"],["body","\n"],["body","def b1 = new Bucket(4)\ndef b2 = new Bucket(11)\nassert (b1 + b2).size == 15    \n"],["body","\n"],["body","所有（非比较器）Groovy 运算符都有相应的方法，您可以在自己的类中实现该方法。"],["body","\n"],["body","唯一的要求是您的方法是公共的，具有正确的名称，并且具有正确数量的参数。"],["body","\n"],["body","参数类型取决于您希望在运算符右侧支持什么类型。"],["body","\n"],["body","以下是运算符及其相应方法的完整列表： "],["body","\n"],["body","Operator"],["body","Method"],["body","Operator"],["body","Method"],["body","\n"],["body","+"],["body","a.plus(b)"],["body","a[b]"],["body","a.getAt(b)"],["body","\n"],["body","-"],["body","a.minus(b)"],["body","a[b] = c"],["body","a.putAt(b, c)"],["body","\n"],["body","*"],["body","a.multiply(b)"],["body","a in b"],["body","b.isCase(a)"],["body","\n"],["body","/"],["body","a.div(b)"],["body","<<"],["body","a.leftShift(b)"],["body","\n"],["body","%"],["body","a.mod(b)"],["body",">>"],["body","a.rightShift(b)"],["body","\n"],["body","**"],["body","a.power(b)"],["body",">>>"],["body","a.rightShiftUnsigned(b)"],["body","\n"],["body","`"],["body","`"],["body","a.or(b)"],["body","++"],["body","\n"],["body","&"],["body","a.and(b)"],["body","--"],["body","a.previous()"],["body","\n"],["body","^"],["body","a.xor(b)"],["body","+a"],["body","a.positive()"],["body","\n"],["body","as"],["body","a.asType(b)"],["body","-a"],["body","a.negative()"],["body","\n"],["body","a()"],["body","a.call()"],["body","~a"],["body","a.bitwiseNegate()"],["body","\n\n\n\n\n"],["body","\n\n                    "],["body","\n\n                    \n                \n            \n\n            \n\n        \n\n\n\n\n        \n\n\n\n        \n        \n        \n\n        \n\n\n    \n    \n"]],[["_relative_fp","4.groovy/基础语法.html"],["title","基础语法 - 各项编程语言"],["body","\n    \n        \n        \n\n        \n        \n\n        \n        \n\n        \n        \n\n        \n\n        \n\n            \n                                \n                \n                    \n                        "],["body","\n                            \n                        "],["body","\n                        "],["body","\n                            \n                        "],["body","\n                        \n                            "],["body","Light"],["body","\n                            "],["body","Rust"],["body","\n                            "],["body","Coal"],["body","\n                            "],["body","Navy"],["body","\n                            "],["body","Ayu"],["body","\n                        \n                    \n\n                    "],["heading","各项编程语言"],["body","\n\n                    \n\n                    \n                \n\n\n                \n                \n\n                \n                    "],["body","\n                        \n\n"],["body","\n"],["body","\n\n"],["headingLink","注释"],["heading","注释"],["body","\n"],["headingLink","单行注释"],["heading","单行注释"],["body","\n"],["body","// a standalone single line comment\n"],["body","\n"],["headingLink","多行注释"],["heading","多行注释"],["body","\n"],["body","/* a standalone multiline comment\n   spanning two lines */\n"],["body","\n"],["headingLink","文档注释"],["heading","文档注释"],["body","\n"],["body","/**\n * A Class description\n */\n"],["body","\n"],["body","Groovydoc 遵循与 Java 自己的 Javadoc 相同的约定。因此，您将能够使用与 Javadoc 相同的标签。"],["body","\n"],["headingLink","运行时文档保留"],["heading","运行时文档保留"],["body","\n"],["body","另外，Groovy 从 3.0.0 开始支持 Runtime Groovydoc，即可以在运行时保留 Groovydoc。"],["body","\n"],["body","默认情况下禁用运行时 Groovydoc。可以通过添加 JVM 选项 -Dgroovy.attach.runtime.groovydoc=true 来启用它"],["body","\n"],["body","Runtime Groovydoc 以 /**@ 开头并以 */ 结尾，例如："],["body","\n"],["body","/**@\n * Some class groovydoc for Foo\n */\nclass Foo {\n    /**@\n     * Some method groovydoc for bar\n     */\n    void bar() {\n    }\n}\n"],["body","\n"],["body","assert Foo.class.groovydoc.content.contains('Some class groovydoc for Foo') \nassert Foo.class.getMethod('bar', new Class[0]).groovydoc.content.contains('Some method groovydoc for bar') \n"],["body","\n"],["headingLink","shebang-line"],["heading","Shebang line"],["body","\n"],["body","除了单行注释之外，还有一个特殊的行注释，通常被称为 UNIX 系统理解的 shebang 行，它允许直接从命令行运行脚本，前提是您已经安装了 Groovy 发行版并且 groovy 命令可用于路径。"],["body","\n"],["body","#!/usr/bin/env groovy\nprintln \"Hello from the shebang line\"\n"],["body","\n"],["body","The # character must be the first character of the file. Any indentation would yield a compilation error."],["body","\n"],["headingLink","keywords"],["heading","Keywords"],["body","\n"],["body","The following list represents all the keywords of the Groovy language:"],["body","\n"],["body","\n"],["body","as"],["body","assert"],["body","break"],["body","case"],["body","\n"],["body","catch"],["body","class"],["body","const"],["body","continue"],["body","\n"],["body","def"],["body","default"],["body","do"],["body","else"],["body","\n"],["body","enum"],["body","extends"],["body","false"],["body","finally"],["body","\n"],["body","for"],["body","goto"],["body","if"],["body","implements"],["body","\n"],["body","import"],["body","in"],["body","instanceof"],["body","interface"],["body","\n"],["body","new"],["body","null"],["body","package"],["body","return"],["body","\n"],["body","super"],["body","switch"],["body","this"],["body","throw"],["body","\n"],["body","throws"],["body","trait"],["body","true"],["body","try"],["body","\n"],["body","var"],["body","while"],["body","\n\n\n"],["headingLink","标识符"],["heading","标识符"],["body","\n"],["headingLink","普通标识符"],["heading","普通标识符"],["body","\n"],["body","标识符以字母、美元或下划线开头。它们不能以数字开头。"],["body","\n"],["body","字母可以在以下范围内： 'a' 到 'z'（小写 ascii 字母） 'A' 到 'Z'（大写 ascii 字母） '\\u00C0' 到 '\\u00D6' '\\u00D8' 到 '\\u00F6 "],["body","\n"],["body","' '\\u00F8' 到 '\\u00FF' '\\u0100' 到 '\\uFFFE'"],["body","\n"],["headingLink","带引号的标识符"],["heading","带引号的标识符"],["body","\n"],["body","带引号的标识符出现在带点表达式的点之后。"],["body","\n"],["body","例如，person.name 表达式的 name 部分可以用 person.\"name\" 或 person.'name' 引用。"],["body","\n"],["body","当某些标识符包含 Java 语言规范禁止的非法字符时，但在引用时 Groovy 允许这些字符。"],["body","\n"],["body","例如，破折号、空格、感叹号等字符。"],["body","\n"],["body","def firstname = \"Homer\"\nmap.\"Simpson-${firstname}\" = \"Homer Simpson\"\n\nassert map.'Simpson-Homer' == \"Homer Simpson\"\n"],["body","\n"],["headingLink","strings"],["heading","Strings"],["body","\n"],["body","文本文字以称为字符串的字符链的形式表示。 Groovy 允许您实例化 java.lang.String 对象以及 GStrings (groovy.lang.GString)，它们在其他编程语言中也称为内插字符串。"],["body","\n"],["headingLink","single-quoted-string"],["heading","Single-quoted string"],["body","\n"],["body","单引号字符串是纯 java.lang.String 并且不支持插值。"],["body","\n"],["headingLink","字符串连接"],["heading","字符串连接"],["body","\n"],["body","assert 'ab' == 'a' + 'b'\n"],["body","\n"],["headingLink","triple-single-quoted-string"],["heading","Triple-single-quoted string"],["body","\n"],["body","'''a triple-single-quoted string'''\n"],["body","\n"],["body","三重单引号字符串是纯 java.lang.String 并且不支持插值。"],["body","\n"],["body","三重单引号字符串可以跨越多行。"],["body","\n"],["body","字符串的内容可以跨越行边界，无需将字符串分成几部分，也无需连接或换行转义字符："],["body","\n"],["body","def aMultilineString = '''line one\nline two\nline three'''\n"],["body","\n"],["body","反斜杠去除开头的换行符"],["body","\n"],["body","def strippedFirstNewline = '''\\\nline one\nline two\nline three\n'''\n\nassert !strippedFirstNewline.startsWith('\\n')\n"],["body","\n"],["headingLink","escaping-special-characters"],["heading","Escaping special characters"],["body","\n"],["body","'an escaped single quote: \\' needs a backslash'\n"],["body","\n"],["body","'an escaped escape character: \\\\ needs a double backslash'\n"],["body","\n"],["body","Some special characters also use the backslash as escape character:"],["body","\n"],["body","Escape sequence"],["body","Character"],["body","\n"],["body","\\b"],["body","backspace"],["body","\n"],["body","\\f"],["body","formfeed"],["body","\n"],["body","\\n"],["body","newline"],["body","\n"],["body","\\r"],["body","carriage return"],["body","\n"],["body","\\s"],["body","single space"],["body","\n"],["body","\\t"],["body","tabulation"],["body","\n"],["body","\\"],["body","backslash"],["body","\n"],["body","'"],["body","single quote within a single-quoted string (and optional for triple-single-quoted and double-quoted strings)"],["body","\n"],["body","\""],["body","double quote within a double-quoted string (and optional for triple-double-quoted and single-quoted strings)"],["body","\n\n\n"],["body","您可以使用 unicode 转义序列：反斜杠，后跟“u”，然后是 4 个十六进制数字。"],["body","\n"],["body","'The Euro currency symbol: \\u20AC'\n"],["body","\n"],["headingLink","double-quoted-string"],["heading","Double-quoted string"],["body","\n"],["body","如果没有插值表达式，双引号字符串就是普通的 java.lang.String，如果存在插值，则是 groovy.lang.GString 实例。"],["body","\n"],["headingLink","string-interpolation"],["heading","String interpolation"],["body","\n"],["body","除了单引号和三重单引号字符串外，任何 Groovy 表达式都可以插入到所有字符串文字中。"],["body","\n"],["body","占位符使用 ${}"],["body","\n"],["body","使用本地变量"],["body","\n"],["body","def name = 'Guillaume' // a plain string\ndef greeting = \"Hello ${name}\"\n\nassert greeting.toString() == 'Hello Guillaume'\n"],["body","\n"],["body","表达式"],["body","\n"],["body","def sum = \"The sum of 2 and 3 equals ${2 + 3}\"\nassert sum.toString() == 'The sum of 2 and 3 equals 5'\n"],["body","\n"],["body","不仅在 ${} 占位符之间允许表达式，而且语句也是如此。"],["body","\n"],["body","但是，语句的值只是 null。"],["body","\n"],["body","因此，如果在该占位符中插入了多个语句，插入的表达式最终应该返回 值"],["body","\n"],["body","\"The sum of 1 and 2 is equal to ${def a = 1; def b = 2; a + b}\"\n"],["body","\n"],["body","除了 ${} 占位符之外，我们还可以使用单独的 $ 符号作为 点表达式的前缀"],["body","\n"],["body","但是只能是 属性访问"],["body","\n"],["body","def person = [name: 'Guillaume', age: 36]\nassert \"$person.name is $person.age years old\" == 'Guillaume is 36 years old'\n"],["body","\n"],["headingLink","插入闭包表达式的特例"],["heading","插入闭包表达式的特例"],["body","\n"],["body","到目前为止，我们已经看到我们可以在 ${} 占位符中插入任意表达式，但是闭包表达式有一个特殊的情况和符号。"],["body","\n"],["body","当占位符包含一个箭头 ${→} 时，表达式实际上是一个闭包表达式 — 你可以把它想象成一个前面加了一个美元的闭包："],["body","\n"],["body","//无参闭包\ndef sParameterLessClosure = \"1 + 2 == ${-> 3}\" \nassert sParameterLessClosure == '1 + 2 == 3'\n\n//单参数闭包，w 为stringWriter\ndef sOneParamClosure = \"1 + 2 == ${ w -> w << 3}\" \nassert sOneParamClosure == '1 + 2 == 3'\n"],["body","\n"],["body","闭包的好处：惰性求值"],["body","\n"],["body","def number = 1 \ndef eagerGString = \"value == ${number}\"\ndef lazyGString = \"value == ${ -> number }\"\n\nassert eagerGString == \"value == 1\" \nassert lazyGString ==  \"value == 1\" \n\nnumber = 2 \nassert eagerGString == \"value == 1\" \nassert lazyGString ==  \"value == 2\" \n"],["body","\n"],["headingLink","interoperability-with-java"],["heading","Interoperability with Java"],["body","\n"],["body","String takeString(String message) {         \n    assert message instanceof String        \n    return message\n\n}\n\n//定义 GString\ndef message = \"The message is ${'hello'}\"   \nassert message instanceof GString           \n\n//调用 申明为String的方法，会隐式的调用 GString的 toString\ndef result = takeString(message)     \nassert result instanceof String\nassert result == 'The message is hello'\n"],["body","\n"],["headingLink","gstring-and-string-hashcodes"],["heading","GString and String hashCodes"],["body","\n"],["body","尽管可以使用内插字符串代替纯 Java 字符串，但它们与字符串的不同之处在于：它们的哈希码不同。"],["body","\n"],["body","纯 Java 字符串是不可变的，而 GString 的结果字符串表示形式可能会有所不同，具体取决于其内插值。"],["body","\n"],["body","即使对于相同的结果字符串，GStrings 和 Strings 也没有相同的 hashCode。"],["body","\n"],["body","assert \"one: ${1}\".hashCode() != \"one: 1\".hashCode()\n"],["body","\n"],["body","GString 和具有不同 hashCode 值的字符串，应避免使用 GString 作为 Map 键，尤其是当我们尝试使用 String 而不是 GString 检索关联值时。"],["body","\n"],["body","def key = \"a\"\ndef m = [\"${key}\": \"letter ${key}\"]     \n\nassert m[\"a\"] == null                   \n"],["body","\n"],["headingLink","triple-double-quoted-string"],["heading","Triple-double-quoted string"],["body","\n"],["body","三重双引号字符串的行为类似于双引号字符串，另外还有它们是多行的，就像三重单引号字符串一样。"],["body","\n"],["body","双引号和单引号都不需要在三重双引号字符串中转义。"],["body","\n"],["body","def name = 'Groovy'\ndef template = \"\"\"\n    Dear Mr ${name},\n\n    You're the winner of the lottery!\n\n    Yours sincerly,\n\n    Dave\n\"\"\"\n\nassert template.toString().contains('Groovy')\n"],["body","\n"],["headingLink","slashy-string"],["heading","Slashy string"],["body","\n"],["body","除了通常的带引号的字符串之外，Groovy 还提供斜线字符串，它使用 / 作为开始和结束分隔符。"],["body","\n"],["body","斜线字符串对于定义正则表达式和模式特别有用，因为不需要转义反斜线。"],["body","\n"],["body","def fooPattern = /.*foo.*/\nassert fooPattern == '.*foo.*'\n"],["body","\n"],["body","def escapeSlash = /The character \\/ is a forward slash/\nassert escapeSlash == 'The character / is a forward slash'\n"],["body","\n"],["body","Slashy strings are multiline:"],["body","\n"],["body","def multilineSlashy = /one\n    two\n    three/\n\nassert multilineSlashy.contains('\\n')\n"],["body","\n"],["body","Slashy 字符串可以被认为是定义 GString 的另一种方式，但具有不同的转义规则。"],["body","\n"],["body","因此，它们支持插值："],["body","\n"],["body","def color = 'blue'\ndef interpolatedSlashy = /a ${color} car/\n\nassert interpolatedSlashy == 'a blue car'\n"],["body","\n"],["headingLink","special-cases"],["heading","Special cases"],["body","\n"],["body","空斜杠字符串不能用双正斜杠表示，因为 Groovy 解析器将其理解为行注释。"],["body","\n"],["body","这就是为什么以下断言实际上不会通过编译的原因，因为它看起来像一个未终止的语句："],["body","\n"],["body","assert '' == //\n"],["body","\n"],["headingLink","dollar-slashy-string"],["heading","Dollar slashy string"],["body","\n"],["body","Dollar 斜线字符串是多行 GString，以开头的 $/ 和结尾的 /$ 分隔。"],["body","\n"],["body","转义字符是美元符号，它可以转义另一个美元或正斜杠。"],["body","\n"],["body","但是美元和正斜杠都不需要转义，除非要转义以 GString 占位符序列开头的字符串子序列的美元，或者如果您需要转义以结束美元斜杠字符串分隔符开头的序列"],["body","\n"],["body","def name = \"Guillaume\"\ndef date = \"April, 1st\"\n\ndef dollarSlashy = $/\n    Hello $name,\n    today we're ${date}.\n\n    $ dollar sign\n    $$ escaped dollar sign\n    \\ backslash\n    / forward slash\n    $/ escaped forward slash\n    $$$/ escaped opening dollar slashy\n    $/$$ escaped closing dollar slashy\n/$\n\nassert [\n    'Guillaume',\n    'April, 1st',\n    '$ dollar sign',\n    '$ escaped dollar sign',\n    '\\\\ backslash',\n    '/ forward slash',\n    '/ escaped forward slash',\n    '$/ escaped opening dollar slashy',\n    '/$ escaped closing dollar slashy'\n].every { dollarSlashy.contains(it) }\n"],["body","\n"],["body","它的创建是为了克服斜线字符串转义规则的一些限制。"],["body","\n"],["body","当它的转义规则适合你的字符串内容时使用它（通常如果它有一些你不想转义的斜线）。"],["body","\n"],["headingLink","字符串汇总表"],["heading","字符串汇总表"],["body","\n"],["body","String name"],["body","String syntax"],["body","Interpolated"],["body","Multiline"],["body","Escape character"],["body","\n"],["body","Single-quoted"],["body","'…'"],["body","\\"],["body","\n"],["body","Triple-single-quoted"],["body","'''…'''"],["body","1"],["body","\\"],["body","\n"],["body","Double-quoted"],["body","\"…\""],["body","1"],["body","\\"],["body","\n"],["body","Triple-double-quoted"],["body","\"\"\"…\"\"\""],["body","1"],["body","1"],["body","\\"],["body","\n"],["body","Slashy"],["body","/…/"],["body","1"],["body","1"],["body","\\"],["body","\n"],["body","Dollar slashy"],["body","$/…/$"],["body","1"],["body","1"],["body","$"],["body","\n\n\n"],["headingLink","characters"],["heading","Characters"],["body","\n"],["body","与 Java 不同，Groovy 没有明确的字符字面量。"],["body","\n"],["body","但是，您可以通过三种不同的方式明确地将 Groovy 字符串设为实际字符："],["body","\n"],["body","char c1 = 'A' \nassert c1 instanceof Character\n\ndef c2 = 'B' as char \nassert c2 instanceof Character\n\ndef c3 = (char)'C' \nassert c3 instanceof Character\n"],["body","\n"],["headingLink","numbers"],["heading","Numbers"],["body","\n"],["body","Groovy 支持不同类型的整数文字和十进制文字，由 Java 的常用 Number 类型支持。"],["body","\n"],["headingLink","integral-literals"],["heading","Integral literals"],["body","\n"],["body","The integral literal types are the same as in Java:"],["body","\n\n"],["body","byte"],["body","\n"],["body","char"],["body","\n"],["body","short"],["body","\n"],["body","int"],["body","\n"],["body","long"],["body","\n"],["body","java.lang.BigInteger"],["body","\n\n"],["body","// primitive types\nbyte  b = 1\nchar  c = 2\nshort s = 3\nint   i = 4\nlong  l = 5\n\n// infinite precision\nBigInteger bi =  6\n"],["body","\n"],["body","如果您使用 def 关键字使用可选类型，则整数的类型会有所不同：它将适应可以容纳该数字的类型的容量。"],["body","\n"],["body","对于正数："],["body","\n"],["body","def a = 1\nassert a instanceof Integer\n\n// Integer.MAX_VALUE\ndef b = 2147483647\nassert b instanceof Integer\n\n// Integer.MAX_VALUE + 1\ndef c = 2147483648\nassert c instanceof Long\n\n// Long.MAX_VALUE\ndef d = 9223372036854775807\nassert d instanceof Long\n\n// Long.MAX_VALUE + 1\ndef e = 9223372036854775808\nassert e instanceof BigInteger\n"],["body","\n"],["body","对于负数"],["body","\n"],["body","def na = -1\nassert na instanceof Integer\n\n// Integer.MIN_VALUE\ndef nb = -2147483648\nassert nb instanceof Integer\n\n// Integer.MIN_VALUE - 1\ndef nc = -2147483649\nassert nc instanceof Long\n\n// Long.MIN_VALUE\ndef nd = -9223372036854775808\nassert nd instanceof Long\n\n// Long.MIN_VALUE - 1\ndef ne = -9223372036854775809\nassert ne instanceof BigInteger\n"],["body","\n"],["body","几种非十进制"],["body","\n"],["headingLink","binary-literal"],["heading","Binary literal"],["body","\n"],["body","二进制数字以 0b 前缀开头："],["body","\n"],["body","int xInt = 0b10101111\nassert xInt == 175\n\nshort xShort = 0b11001001\nassert xShort == 201 as short\n\nbyte xByte = 0b11\nassert xByte == 3 as byte\n\nlong xLong = 0b101101101101\nassert xLong == 2925l\n\nBigInteger xBigInteger = 0b111100100001\nassert xBigInteger == 3873g\n\nint xNegativeInt = -0b10101111\nassert xNegativeInt == -175\n"],["body","\n"],["headingLink","octal-literal"],["heading","Octal literal"],["body","\n"],["body","八进制数以“0”后跟八进制数字的典型格式指定。"],["body","\n"],["body","int xInt = 077\nassert xInt == 63\n\nshort xShort = 011\nassert xShort == 9 as short\n\nbyte xByte = 032\nassert xByte == 26 as byte\n\nlong xLong = 0246\nassert xLong == 166l\n\nBigInteger xBigInteger = 01111\nassert xBigInteger == 585g\n\nint xNegativeInt = -077\nassert xNegativeInt == -63\n"],["body","\n"],["headingLink","hexadecimal-literal"],["heading","Hexadecimal literal"],["body","\n"],["body","十六进制数字以 0x 后跟十六进制数字的典型格式指定。"],["body","\n"],["body","nt xInt = 0x77\nassert xInt == 119\n\nshort xShort = 0xaa\nassert xShort == 170 as short\n\nbyte xByte = 0x3a\nassert xByte == 58 as byte\n\nlong xLong = 0xffff\nassert xLong == 65535l\n\nBigInteger xBigInteger = 0xaaaa\nassert xBigInteger == 43690g\n\nDouble xDouble = new Double('0x1.0p0')\nassert xDouble == 1.0d\n\nint xNegativeInt = -0x77\nassert xNegativeInt == -119\n"],["body","\n"],["headingLink","decimal-literals"],["heading","Decimal literals"],["body","\n"],["body","小数类型"],["body","\n\n"],["body","float"],["body","\n"],["body","double"],["body","\n"],["body","java.lang.BigDecimal"],["body","\n\n"],["body","// primitive types\nfloat  f = 1.234\ndouble d = 2.345\n\n// infinite precision\nBigDecimal bd =  3.456\n"],["body","\n"],["body","小数可以使用指数，用 e 或 E 指数字母，后跟可选符号，以及表示指数的整数："],["body","\n"],["body","assert 1e3  ==  1_000.0\nassert 2E4  == 20_000.0\nassert 3e+1 ==     30.0\nassert 4E-2 ==      0.04\nassert 5e-1 ==      0.5\n"],["body","\n"],["body","为了方便地计算精确的十进制数，Groovy 选择 java.lang.BigDecimal 作为其十进制数类型。"],["body","\n"],["body","此外，支持 float 和 double，但需要明确的类型声明、类型强制或后缀。"],["body","\n"],["body","即使 BigDecimal 是十进制数的默认值，在以 float 或 double 作为参数类型的方法或闭包中也接受此类文字。"],["body","\n"],["body","十进制数不能用二进制、八进制或十六进制表示。"],["body","\n"],["headingLink","underscore-in-literals"],["heading","Underscore in literals"],["body","\n"],["body","写长的文字数字时，眼睛很难弄清楚一些数字是如何组合在一起的，例如千组、单词等。通过允许您在数字文字中放置下划线，更容易发现这些组："],["body","\n"],["body","long creditCardNumber = 1234_5678_9012_3456L\nlong socialSecurityNumbers = 999_99_9999L\ndouble monetaryAmount = 12_345_132.12\nlong hexBytes = 0xFF_EC_DE_5E\nlong hexWords = 0xFFEC_DE5E\nlong maxLong = 0x7fff_ffff_ffff_ffffL\nlong alsoMaxLong = 9_223_372_036_854_775_807L\nlong bytes = 0b11010010_01101001_10010100_10010010\n"],["body","\n"],["headingLink","number-type-suffixes"],["heading","Number type suffixes"],["body","\n"],["body","我们可以通过给一个大写或小写的后缀（见下表）来强制一个数字（包括二进制、八进制和十六进制）具有特定的类型。"],["body","\n"],["body","Type"],["body","Suffix"],["body","\n"],["body","BigInteger"],["body","G or g"],["body","\n"],["body","Long"],["body","L or l"],["body","\n"],["body","Integer"],["body","I or i"],["body","\n"],["body","BigDecimal"],["body","G or g"],["body","\n"],["body","Double"],["body","D or d"],["body","\n"],["body","Float"],["body","F or f"],["body","\n\n\n"],["body","assert 42I == new Integer('42')\nassert 42i == new Integer('42') // lowercase i more readable\nassert 123L == new Long(\"123\") // uppercase L more readable\nassert 2147483648 == new Long('2147483648') // Long type used, value too large for an Integer\nassert 456G == new BigInteger('456')\nassert 456g == new BigInteger('456')\nassert 123.45 == new BigDecimal('123.45') // default BigDecimal type used\nassert 1.200065D == new Double('1.200065')\nassert 1.234F == new Float('1.234')\nassert 1.23E23D == new Double('1.23E23')\nassert 0b1111L.class == Long // binary\nassert 0xFFi.class == Integer // hexadecimal\nassert 034G.class == BigInteger // octal\n"],["body","\n"],["headingLink","math-operations"],["heading","Math operations"],["body","\n\n"],["body","binary operations between byte, char, short and int result in int"],["body","\n"],["body","binary operations involving long with byte, char, short and int result in long"],["body","\n"],["body","binary operations involving BigInteger and any other integral type result in BigInteger"],["body","\n"],["body","binary operations involving BigDecimal with byte, char, short, int and BigInteger result in BigDecimal"],["body","\n"],["body","binary operations between float, double and BigDecimal result in double"],["body","\n"],["body","binary operations between two BigDecimal result in BigDecimal"],["body","\n\n"],["headingLink","table-summarizes-those-rules"],["heading","table summarizes those rules:"],["body","\n"],["body","byte"],["body","char"],["body","short"],["body","int"],["body","long"],["body","BigInteger"],["body","float"],["body","double"],["body","BigDecimal"],["body","\n"],["body","byte"],["body","int"],["body","int"],["body","int"],["body","int"],["body","long"],["body","BigInteger"],["body","double"],["body","double"],["body","BigDecimal"],["body","\n"],["body","char"],["body","int"],["body","int"],["body","int"],["body","long"],["body","BigInteger"],["body","double"],["body","double"],["body","BigDecimal"],["body","\n"],["body","short"],["body","int"],["body","int"],["body","long"],["body","BigInteger"],["body","double"],["body","double"],["body","BigDecimal"],["body","\n"],["body","int"],["body","int"],["body","long"],["body","BigInteger"],["body","double"],["body","double"],["body","BigDecimal"],["body","\n"],["body","long"],["body","long"],["body","BigInteger"],["body","double"],["body","double"],["body","BigDecimal"],["body","\n"],["body","BigInteger"],["body","BigInteger"],["body","double"],["body","double"],["body","BigDecimal"],["body","\n"],["body","float"],["body","double"],["body","double"],["body","double"],["body","\n"],["body","double"],["body","double"],["body","double"],["body","\n"],["body","BigDecimal"],["body","BigDecimal"],["body","\n\n\n"],["body","由于 Groovy 的运算符重载，通常的算术运算符可以与 BigInteger 和 BigDecimal 一起使用，这与在 Java 中必须使用显式方法对这些数字进行运算不同。"],["body","\n"],["headingLink","除法运算符的情况"],["heading","除法运算符的情况"],["body","\n"],["body","除法运算符 /（和 /= 用于除法和赋值）如果操作数是浮点数或双精度数，则产生双精度结果，否则产生 BigDecimal 结果（当两个操作数都是整数类型 short、char、byte、int、 "],["body","\n"],["body","long、BigInteger 或 BigDecimal）。"],["body","\n"],["body","BigDecimal division is performed with the divide() method if the division is exact (i.e. yielding a result that can be represented within the bounds of the same precision and scale), or using a MathContext with a precision of the maximum of the two operands' precision plus an extra precision of 10, and a scale of the maximum of 10 and the maximum of the operands' scale."],["body","\n"],["headingLink","幂运算符"],["heading","幂运算符"],["body","\n"],["body","幂运算由 **  运算符表示，有两个参数：基数和指数。"],["body","\n"],["body","幂运算的结果取决于其操作数和运算结果（特别是如果结果可以表示为整数值）。"],["body","\n"],["body","Groovy 的幂运算使用以下规则来确定结果类型："],["body","\n\n"],["body","如果指数是 小数\n\n"],["body","如果结果可以表示为整数，则返回整数"],["body","\n"],["body","否则 如果结果可以表示为 Long，则返回 Long"],["body","\n"],["body","otherwise return a Double"],["body","\n\n"],["body","\n"],["body","如果指数是 整数\n\n"],["body","如果指数严格为负，则如果结果值适合该类型，则返回 Integer、Long 或 Double"],["body","\n"],["body","如果指数为正数或零\n\n"],["body","如果基数是 BigDecimal，则返回 BigDecimal 结果值"],["body","\n"],["body","如果基数是 BigInteger，则返回 BigInteger 结果值"],["body","\n"],["body","如果基数是一个 Integer，则如果结果值 装得下它，则返回一个Integer，否则返回一个 BigInteger"],["body","\n"],["body","如果基数是 Long，则如果结果值适合，则返回 Long，否则返回 BigInteger"],["body","\n\n"],["body","\n\n"],["body","\n\n"],["body","我们可以用几个例子来说明这些规则："],["body","\n"],["body","// base and exponent are ints and the result can be represented by an Integer\nassert    2    **   3    instanceof Integer    //  8\nassert   10    **   9    instanceof Integer    //  1_000_000_000\n\n// the base is a long, so fit the result in a Long\n// (although it could have fit in an Integer)\nassert    5L   **   2    instanceof Long       //  25\n\n// the result can't be represented as an Integer or Long, so return a BigInteger\nassert  100    **  10    instanceof BigInteger //  10e20\nassert 1234    ** 123    instanceof BigInteger //  170515806212727042875...\n\n// the base is a BigDecimal and the exponent a negative int\n// but the result can be represented as an Integer\nassert    0.5  **  -2    instanceof Integer    //  4\n\n// the base is an int, and the exponent a negative float\n// but again, the result can be represented as an Integer\nassert    1    **  -0.3f instanceof Integer    //  1\n\n// the base is an int, and the exponent a negative int\n// but the result will be calculated as a Double\n// (both base and exponent are actually converted to doubles)\nassert   10    **  -1    instanceof Double     //  0.1\n\n// the base is a BigDecimal, and the exponent is an int, so return a BigDecimal\nassert    1.2  **  10    instanceof BigDecimal //  6.1917364224\n\n// the base is a float or double, and the exponent is an int\n// but the result can only be represented as a Double value\nassert    3.4f **   5    instanceof Double     //  454.35430372146965\nassert    5.6d **   2    instanceof Double     //  31.359999999999996\n\n// the exponent is a decimal value\n// and the result can only be represented as a Double value\nassert    7.8  **   1.9  instanceof Double     //  49.542708423868476\nassert    2    **   0.1f instanceof Double     //  1.0717734636432956\n"],["body","\n"],["headingLink","booleans"],["heading","Booleans"],["body","\n"],["body","Boolean 是一种特殊的数据类型，用于表示真值：true 和 false。"],["body","\n"],["body","将此数据类型用于跟踪真/假条件的简单标志。"],["body","\n"],["body","def myBooleanVariable = true\nboolean untypedBooleanVar = false\nbooleanField = true\n"],["body","\n"],["body","其他集合类详见 基础语法"],["body","\n\n\n\n"],["body","\n\n                    "],["body","\n\n                    \n                \n            \n\n            \n\n        \n\n\n\n\n        \n\n\n\n        \n        \n        \n\n        \n\n\n    \n    \n"]],[["_relative_fp","4.groovy/开发工具类.html"],["title","开发工具类 - 各项编程语言"],["body","\n    \n        \n        \n\n        \n        \n\n        \n        \n\n        \n        \n\n        \n\n        \n\n            \n                                \n                \n                    \n                        "],["body","\n                            \n                        "],["body","\n                        "],["body","\n                            \n                        "],["body","\n                        \n                            "],["body","Light"],["body","\n                            "],["body","Rust"],["body","\n                            "],["body","Coal"],["body","\n                            "],["body","Navy"],["body","\n                            "],["body","Ayu"],["body","\n                        \n                    \n\n                    "],["heading","各项编程语言"],["body","\n\n                    \n\n                    \n                \n\n\n                \n                \n\n                \n                    "],["body","\n                        \n\n"],["body","\n"],["body","\n\n"],["headingLink","io"],["heading","IO"],["body","\n"],["headingLink","读文件"],["heading","读文件"],["body","\n"],["body","读文件"],["body","\n"],["body","new File(baseDir, 'haiku.txt').eachLine { line ->\n    println line\n}\n"],["body","\n"],["body","行号与line"],["body","\n"],["body","new File(baseDir, 'haiku.txt').eachLine { line, nb ->\n    println \"Line $nb: $line\"\n}\n"],["body","\n"],["body","自定义reader"],["body","\n"],["body","\n"],["body","会自动关闭流"],["body","\n"],["body","\n"],["body","def count = 0, MAXSIZE = 3\nnew File(baseDir,\"haiku.txt\").withReader { reader ->\n    while (reader.readLine()) {\n        if (++count > MAXSIZE) {\n            throw new RuntimeException('Haiku should only have 3 verses')\n        }\n    }\n}\n"],["body","\n"],["body","转list"],["body","\n"],["body","def list = new File(baseDir, 'haiku.txt').collect {it}\n"],["body","\n"],["body","或者您甚至可以利用 as 运算符将文件的内容放入行数组："],["body","\n"],["body","def array = new File(baseDir, 'haiku.txt') as String[]\n"],["body","\n"],["body","转换字节数组"],["body","\n"],["body","byte[] contents = file.bytes\n"],["body","\n"],["body","获取输入流"],["body","\n"],["body","def is = new File(baseDir,'haiku.txt').newInputStream()\n// do something ...\nis.close()\n"],["body","\n"],["body","自动关闭流"],["body","\n"],["body","new File(baseDir,'haiku.txt').withInputStream { stream ->\n    // do something ...\n}\n"],["body","\n"],["headingLink","写文件"],["heading","写文件"],["body","\n"],["body","闭包写文件"],["body","\n"],["body","new File(baseDir,'haiku.txt').withWriter('utf-8') { writer ->\n    writer.writeLine 'Into the ancient pond'\n    writer.writeLine 'A frog jumps'\n    writer.writeLine 'Water’s sound!'\n}\n"],["body","\n"],["body","重定向符写文件"],["body","\n"],["body","new File(baseDir,'haiku.txt') << '''Into the ancient pond\nA frog jumps\nWater’s sound!'''\n"],["body","\n"],["body","直接写字节数组"],["body","\n"],["body","file.bytes = [66,22,11]\n"],["body","\n"],["body","直接使用 outputstream"],["body","\n"],["body","def os = new File(baseDir,'data.bin').newOutputStream()\n// do something ...\nos.close()\n"],["body","\n"],["body","闭包使用outputstream"],["body","\n"],["body","new File(baseDir,'data.bin').withOutputStream { stream ->\n    // do something ...\n}\n"],["body","\n"],["headingLink","遍历文件树"],["heading","遍历文件树"],["body","\n"],["body","dir.eachFile { file ->                      \n    println file.name\n}\ndir.eachFileMatch(~/.*\\.txt/) { file ->     \n    println file.name\n}\n//递归\ndir.eachFileRecurse { file ->                      \n    println file.name\n}\n\ndir.eachFileRecurse(FileType.FILES) { file ->      \n    println file.name\n}\n"],["body","\n"],["body","手动控制递归"],["body","\n"],["body","dir.traverse { file ->\n    if (file.directory && file.name=='bin') {\n        FileVisitResult.TERMINATE                   \n    } else {\n        println file.name\n        FileVisitResult.CONTINUE                    \n    }\n\n}\n"],["body","\n"],["headingLink","数据和对象"],["heading","数据和对象"],["body","\n"],["body","在Java中很少使用 java.io.DataOutputStreamandjava.io.DataInputStream"],["body","\n"],["body","boolean b = true\nString message = 'Hello from Groovy'\n// Serialize data into a file\nfile.withDataOutputStream { out ->\n    out.writeBoolean(b)\n    out.writeUTF(message)\n}\n// ...\n// Then read it back\nfile.withDataInputStream { input ->\n    assert input.readBoolean() == b\n    assert input.readUTF() == message\n}\n"],["body","\n"],["body","同样，如果要序列化的数据实现了 Serializable 接口，则可以继续使用对象输出流，"],["body","\n"],["body","Person p = new Person(name:'Bob', age:76)\n// Serialize data into a file\nfile.withObjectOutputStream { out ->\n    out.writeObject(p)\n}\n// ...\n// Then read it back\nfile.withObjectInputStream { input ->\n    def p2 = input.readObject()\n    assert p2.name == p.name\n    assert p2.age == p.age\n}\n"],["body","\n"],["body","执行外部程序"],["body","\n"],["body","// 执行外部命令\ndef process = \"ls -l\".execute()             \n// 获取外部命令的输出，返回值类型 java.lang.Process\nprintln \"Found text ${process.text}\"        \n"],["body","\n"],["body","处理 输入流"],["body","\n"],["body","def process = \"ls -l\".execute()             \nprocess.in.eachLine { line ->               \n    println line                            \n}\n"],["body","\n"],["body","windows命令"],["body","\n"],["body","//这会直接报错，因为 dir是 windows shell自带命令，不能使用可执行路径执行，\ndef process = \"dir\".execute()\nprintln \"${process.text}\"\n\ndef process = \"cmd /c dir\".execute()\nprintln \"${process.text}\"\n"],["body","\n"],["body","由于一些原生平台只为标准的输入输出流提供有限的缓冲区大小，未能及时写入输入流或读取子进程的输出流可能会导致子进程阻塞，甚至死锁"],["body","\n"],["body","因此，Groovy 提供了一些额外的辅助方法，使流程的流处理更容易。"],["body","\n"],["body","以下是如何从您的过程中 获取所有输出（包括错误流输出）："],["body","\n"],["body","def p = \"rm -f foo.tmp\".execute([], tmpDir)\np.consumeProcessOutput()\np.waitFor()\n"],["body","\n"],["body","也有使用 StringBuffer、InputStream、OutputStream 等的消耗进程输出的变体......有关完整列表，请阅读 java.lang.Process 的 GDK API"],["body","\n"],["body","此外，这是一个 pipeTo 命令（映射到 | 以允许重载），它允许一个进程的输出流被馈送到另一个进程的输入流中。"],["body","\n"],["body","proc1 = 'ls'.execute()\nproc2 = 'tr -d o'.execute()\nproc3 = 'tr -d e'.execute()\nproc4 = 'tr -d i'.execute()\nproc1 | proc2 | proc3 | proc4\nproc4.waitFor()\nif (proc4.exitValue()) {\n    println proc4.err.text\n} else {\n    println proc4.text\n}\n"],["body","\n"],["body","def sout = new StringBuilder()\ndef serr = new StringBuilder()\nproc2 = 'tr -d o'.execute()\nproc3 = 'tr -d e'.execute()\nproc4 = 'tr -d i'.execute()\nproc4.consumeProcessOutput(sout, serr)\nproc2 | proc3 | proc4\n[proc2, proc3].each { it.consumeProcessErrorStream(serr) }\nproc2.withWriter { writer ->\n    writer << 'testfile.groovy'\n}\nproc4.waitForOrKill(1000)\nprintln \"Standard output: $sout\"\nprintln \"Standard error: $serr\"\n"],["body","\n"],["headingLink","集合"],["heading","集合"],["body","\n"],["headingLink","lists"],["heading","Lists"],["body","\n"],["headingLink","定义与取值"],["heading","定义与取值"],["body","\n"],["body","#定义\ndef list = [5, 6, 7, 8]\n# 取值\nassert list.get(2) == 7\n# 取值\nassert list[2] == 7\n# 类型比较\nassert list instanceof java.util.List\n# 空集合\ndef emptyList = []\n# 集合大小\nassert emptyList.size() == 0\n# 添加集合\nemptyList.add(5)\nassert emptyList.size() == 1\n"],["body","\n"],["headingLink","arraylist构造"],["heading","ArrayList构造"],["body","\n"],["body","def list1 = ['a', 'b', 'c']\n//construct a new list, seeded with the same items as in list1\ndef list2 = new ArrayList<String>(list1)\n\nassert list2 == list1 // == checks that each corresponding element is the same\n\n// clone() can also be called\ndef list3 = list1.clone()\nassert list3 == list1\n"],["body","\n"],["headingLink","getat-putat"],["heading","getAt putAt"],["body","\n"],["body","def list = [5, 6, 7, 8]\nassert list.size() == 4\nassert list.getClass() == ArrayList     // the specific kind of list being used\n\nassert list[2] == 7                     // indexing starts at 0\nassert list.getAt(2) == 7               // equivalent method to subscript operator []\nassert list.get(2) == 7                 // alternative method\n\nlist[2] = 9\nassert list == [5, 6, 9, 8,]           // trailing comma OK\n\nlist.putAt(2, 10)                       // equivalent method to [] when value being changed\nassert list == [5, 6, 10, 8]\nassert list.set(2, 11) == 10            // alternative method that returns old value\nassert list == [5, 6, 11, 8]\n\nassert ['a', 1, 'a', 'a', 2.5, 2.5f, 2.5d, 'hello', 7g, null, 9 as byte]\n//objects can be of different types; duplicates allowed\n\nassert [1, 2, 3, 4, 5][-1] == 5             // use negative indices to count from the end\nassert [1, 2, 3, 4, 5][-2] == 4\nassert [1, 2, 3, 4, 5].getAt(-2) == 4       // getAt() available with negative index...\ntry {\n    [1, 2, 3, 4, 5].get(-2)                 // but negative index not allowed with get()\n    assert false\n} catch (e) {\n    assert e instanceof IndexOutOfBoundsException\n}\n"],["body","\n"],["body","迭代"],["body","\n"],["body","[1, 2, 3].each {\n    println \"Item: $it\" // `it` is an implicit parameter corresponding to the current element\n}\n['a', 'b', 'c'].eachWithIndex { it, i -> // `it` is the current element, while `i` is the index\n    println \"$i: $it\"\n}\n"],["body","\n"],["headingLink","转换"],["heading","转换"],["body","\n"],["body","assert [1, 2, 3].collect { it * 2 } == [2, 4, 6]\n\n// shortcut syntax instead of collect\nassert [1, 2, 3]*.multiply(2) == [1, 2, 3].collect { it.multiply(2) }\n\ndef list = [0]\n// it is possible to give `collect` the list which collects the elements\nassert [1, 2, 3].collect(list) { it * 2 } == [0, 2, 4, 6]\nassert list == [0, 2, 4, 6]\n"],["body","\n"],["headingLink","修改集合-搜索过滤"],["heading","修改集合-搜索过滤"],["body","\n"],["body","assert [1, 2, 3].find { it > 1 } == 2           // find 1st element matching criteria\nassert [1, 2, 3].findAll { it > 1 } == [2, 3]   // find all elements matching critieria\nassert ['a', 'b', 'c', 'd', 'e'].findIndexOf {      // find index of 1st element matching criteria\n    it in ['c', 'e', 'g']\n} == 2\n\nassert ['a', 'b', 'c', 'd', 'c'].indexOf('c') == 2  // index returned\nassert ['a', 'b', 'c', 'd', 'c'].indexOf('z') == -1 // index -1 means value not in list\nassert ['a', 'b', 'c', 'd', 'c'].lastIndexOf('c') == 4\n\nassert [1, 2, 3].every { it < 5 }               // returns true if all elements match the predicate\nassert ![1, 2, 3].every { it < 3 }\nassert [1, 2, 3].any { it > 2 }                 // returns true if any element matches the predicate\nassert ![1, 2, 3].any { it > 3 }\n\nassert [1, 2, 3, 4, 5, 6].sum() == 21                // sum anything with a plus() method\nassert ['a', 'b', 'c', 'd', 'e'].sum {\n    it == 'a' ? 1 : it == 'b' ? 2 : it == 'c' ? 3 : it == 'd' ? 4 : it == 'e' ? 5 : 0\n    // custom value to use in sum\n} == 15\nassert ['a', 'b', 'c', 'd', 'e'].sum { ((char) it) - ((char) 'a') } == 10\nassert ['a', 'b', 'c', 'd', 'e'].sum() == 'abcde'\nassert [['a', 'b'], ['c', 'd']].sum() == ['a', 'b', 'c', 'd']\n\n// an initial value can be provided\nassert [].sum(1000) == 1000\nassert [1, 2, 3].sum(1000) == 1006\n\nassert [1, 2, 3].join('-') == '1-2-3'           // String joining\nassert [1, 2, 3].inject('counting: ') {\n    str, item -> str + item                     // reduce operation\n} == 'counting: 123'\nassert [1, 2, 3].inject(0) { count, item ->\n    count + item\n} == 6\n"],["body","\n"],["headingLink","最大值最小值"],["heading","最大值最小值"],["body","\n"],["body","def list = [9, 4, 2, 10, 5]\nassert list.max() == 10\nassert list.min() == 2\n\n// we can also compare single characters, as anything comparable\nassert ['x', 'y', 'a', 'z'].min() == 'a'\n\n// we can use a closure to specify the sorting behaviour\ndef list2 = ['abc', 'z', 'xyzuvw', 'Hello', '321']\nassert list2.max { it.size() } == 'xyzuvw'\nassert list2.min { it.size() } == 'z'\n"],["body","\n"],["headingLink","定义排序器"],["heading","定义排序器"],["body","\n"],["body","Comparator mc = { a, b -> a == b ? 0 : (a < b ? -1 : 1) }\n\ndef list = [7, 4, 9, -6, -1, 11, 2, 3, -9, 5, -13]\nassert list.max(mc) == 11\nassert list.min(mc) == -13\n\nComparator mc2 = { a, b -> a == b ? 0 : (Math.abs(a) < Math.abs(b)) ? -1 : 1 }\n\n\nassert list.max(mc2) == -13\nassert list.min(mc2) == -1\n\nassert list.max { a, b -> a.equals(b) ? 0 : Math.abs(a) < Math.abs(b) ? -1 : 1 } == -13\nassert list.min { a, b -> a.equals(b) ? 0 : Math.abs(a) < Math.abs(b) ? -1 : 1 } == -1\n"],["body","\n"],["headingLink","移除元素"],["heading","移除元素"],["body","\n"],["body","def list = []\nassert list.empty\n\nlist << 5\nassert list.size() == 1\n\nlist << 7 << 'i' << 11\nassert list == [5, 7, 'i', 11]\n\nlist << ['m', 'o']\nassert list == [5, 7, 'i', 11, ['m', 'o']]\n\n//first item in chain of << is target list\nassert ([1, 2] << 3 << [4, 5] << 6) == [1, 2, 3, [4, 5], 6]\n\n//using leftShift is equivalent to using <<\nassert ([1, 2, 3] << 4) == ([1, 2, 3].leftShift(4))\n"],["body","\n"],["headingLink","集合加减与展开"],["heading","集合加减与展开"],["body","\n"],["body","# 连加\nassert [1, 2] + 3 + [4, 5] + 6 == [1, 2, 3, 4, 5, 6]\n\n//API连＋ equivalent to calling the `plus` method\nassert [1, 2].plus(3).plus([4, 5]).plus(6) == [1, 2, 3, 4, 5, 6]\n# +=，每次都会建一个新的集合\ndef a = [1, 2, 3]\na += 4      // creates a new list and assigns it to `a`\na += [5, 6]\nassert a == [1, 2, 3, 4, 5, 6]\n\n# 平铺符\nassert [1, *[222, 333], 456] == [1, 222, 333, 456]\nassert [*[1, 2, 3]] == [1, 2, 3]\n# 展开符\nassert [1, [2, 3, [4, 5], 6], 7, [8, 9]].flatten() == [1, 2, 3, 4, 5, 6, 7, 8, 9]\n\ndef list = [1, 2]\nlist.add(3)\nlist.addAll([5, 4])\nassert list == [1, 2, 3, 5, 4]\n\nlist = [1, 2]\nlist.add(1, 3) // add 3 just before index 1\nassert list == [1, 3, 2]\n\nlist.addAll(2, [5, 4]) //add [5,4] just before index 2\nassert list == [1, 3, 5, 4, 2]\n\nlist = ['a', 'b', 'z', 'e', 'u', 'v', 'g']\nlist[8] = 'x' // the [] operator is growing the list as needed\n// nulls inserted if required\nassert list == ['a', 'b', 'z', 'e', 'u', 'v', 'g', null, 'x']\n"],["body","\n"],["body","assert ['a','b','c','b','b'] - 'c' == ['a','b','b','b']\nassert ['a','b','c','b','b'] - 'b' == ['a','c']\nassert ['a','b','c','b','b'] - ['b','c'] == ['a']\n\ndef list = [1,2,3,4,3,2,1]\nlist -= 3           // creates a new list by removing `3` from the original one\nassert list == [1,2,4,2,1]\nassert ( list -= [2,4] ) == [1,1]\n"],["body","\n"],["body","def list = ['a','b','c','d','e','f','b','b','a']\nassert list.remove(2) == 'c'        // remove the third element, and return it\nassert list == ['a','b','d','e','f','b','b','a']\n"],["body","\n"],["headingLink","set-操作"],["heading","set 操作"],["body","\n"],["body","assert 'a' in ['a','b','c']             // returns true if an element belongs to the list\nassert ['a','b','c'].contains('a')      // equivalent to the `contains` method in Java\nassert [1,3,4].containsAll([1,4])       // `containsAll` will check that all elements are found\n\nassert [1,2,3,3,3,3,4,5].count(3) == 4  // count the number of elements which have some value\nassert [1,2,3,3,3,3,4,5].count {\n    it%2==0                             // count the number of elements which match the predicate\n} == 2\n\nassert [1,2,4,6,8,10,12].intersect([1,3,6,9,12]) == [1,6,12]\n\nassert [1,2,3].disjoint( [4,6,9] )\nassert ![1,2,3].disjoint( [2,4,6] )\n"],["body","\n"],["headingLink","排序"],["heading","排序"],["body","\n"],["body","assert [6, 3, 9, 2, 7, 1, 5].sort() == [1, 2, 3, 5, 6, 7, 9]\n\ndef list = ['abc', 'z', 'xyzuvw', 'Hello', '321']\nassert list.sort {\n    it.size()\n} == ['z', 'abc', '321', 'Hello', 'xyzuvw']\n\ndef list2 = [7, 4, -6, -1, 11, 2, 3, -9, 5, -13]\nassert list2.sort { a, b -> a == b ? 0 : Math.abs(a) < Math.abs(b) ? -1 : 1 } ==\n        [-1, 2, 3, 4, 5, -6, 7, -9, 11, -13]\n\nComparator mc = { a, b -> a == b ? 0 : Math.abs(a) < Math.abs(b) ? -1 : 1 }\n\n// JDK 8+ only\n// list2.sort(mc)\n// assert list2 == [-1, 2, 3, 4, 5, -6, 7, -9, 11, -13]\n\ndef list3 = [6, -3, 9, 2, -7, 1, 5]\n\nCollections.sort(list3)\nassert list3 == [-7, -3, 1, 2, 5, 6, 9]\n\nCollections.sort(list3, mc)\nassert list3 == [1, 2, -3, 5, 6, -7, 9]\n"],["body","\n"],["body","复制元素"],["body","\n"],["body","assert [1, 2, 3] * 3 == [1, 2, 3, 1, 2, 3, 1, 2, 3]\nassert [1, 2, 3].multiply(2) == [1, 2, 3, 1, 2, 3]\nassert Collections.nCopies(3, 'b') == ['b', 'b', 'b']\n\n// nCopies from the JDK has different semantics than multiply for lists\nassert Collections.nCopies(2, [1, 2]) == [[1, 2], [1, 2]] //not [1,2,1,2]\n"],["body","\n"],["headingLink","maps"],["heading","Maps"],["body","\n"],["headingLink","字面量map"],["heading","字面量Map"],["body","\n"],["body","//定义\ndef map = [name: 'Gromit', likes: 'cheese', id: 1234]\n#取值\nassert map.get('name') == 'Gromit'\nassert map.get('id') == 1234\nassert map['name'] == 'Gromit'\nassert map['id'] == 1234\n# 判断类型\nassert map instanceof java.util.Map\n# 空Map\ndef emptyMap = [:]\n\nassert emptyMap.size() == 0\nemptyMap.put(\"foo\", 5)\nassert emptyMap.size() == 1\nassert emptyMap.get(\"foo\") == 5\n"],["body","\n"],["body","\n"],["body","Map keys are strings by default: [a:1] is equivalent to ['a':1]"],["body","\n"],["body","\n"],["headingLink","浅拷贝"],["heading","浅拷贝"],["body","\n"],["body","def map = [\n        simple : 123,\n        complex: [a: 1, b: 2]\n]\ndef map2 = map.clone()\nassert map2.get('simple') == map.get('simple')\nassert map2.get('complex') == map.get('complex')\nmap2.get('complex').put('c', 3)\nassert map.get('complex').get('c') == 3\n"],["body","\n"],["headingLink","属性符号"],["heading","属性符号"],["body","\n"],["body","\n"],["body","Maps 也像 bean 一样，所以你可以使用属性符号来获取/设置 Map 内的项目，只要键是有效的 Groovy 标识符的字符串"],["body","\n"],["body","\n"],["body","def map = [name: 'Gromit', likes: 'cheese', id: 1234]\nassert map.name == 'Gromit'     // can be used instead of map.get('name')\nassert map.id == 1234\n\ndef emptyMap = [:]\nassert emptyMap.size() == 0\nemptyMap.foo = 5\nassert emptyMap.size() == 1\nassert emptyMap.foo == 5\n"],["body","\n"],["body","字符串不能 与保留字相同"],["body","\n"],["body","def map = [name: 'Gromit', likes: 'cheese', id: 1234]\nassert map.class == null\nassert map.get('class') == null\nassert map.getClass() == LinkedHashMap // this is probably what you want\n\nmap = [1      : 'a',\n       (true) : 'p',\n       (false): 'q',\n       (null) : 'x',\n       'null' : 'z']\nassert map.containsKey(1) // 1 is not an identifier so used as is\nassert map.true == null\nassert map.false == null\nassert map.get(true) == 'p'\nassert map.get(false) == 'q'\nassert map.null == 'z'\nassert map.get(null) == 'x'\n"],["body","\n"],["headingLink","迭代"],["heading","迭代"],["body","\n"],["body","def map = [\n        Bob  : 42,\n        Alice: 54,\n        Max  : 33\n]\n\n// `entry` is a map entry\nmap.each { entry ->\n    println \"Name: $entry.key Age: $entry.value\"\n}\n\n// `entry` is a map entry, `i` the index in the map\nmap.eachWithIndex { entry, i ->\n    println \"$i - Name: $entry.key Age: $entry.value\"\n}\n\n// Alternatively you can use key and value directly\nmap.each { key, value ->\n    println \"Name: $key Age: $value\"\n}\n\n// Key, value and i as the index in the map\nmap.eachWithIndex { key, value, i ->\n    println \"$i - Name: $key Age: $value\"\n}\n"],["body","\n"],["headingLink","修改map"],["heading","修改Map"],["body","\n"],["body","def defaults = [1: 'a', 2: 'b', 3: 'c', 4: 'd']\ndef overrides = [2: 'z', 5: 'x', 13: 'x']\n\ndef result = new LinkedHashMap(defaults)\nresult.put(15, 't')\nresult[17] = 'u'\nresult.putAll(overrides)\nassert result == [1: 'a', 2: 'z', 3: 'c', 4: 'd', 5: 'x', 13: 'x', 15: 't', 17: 'u']\n"],["body","\n"],["body","清空"],["body","\n"],["body","def m = [1:'a', 2:'b']\nassert m.get(1) == 'a'\nm.clear()\nassert m == [:]\n"],["body","\n"],["body","注意：GString 的hashCode与String的HashCode值不一样"],["body","\n"],["body","def key = 'some key'\ndef map = [:]\ndef gstringKey = \"${key.toUpperCase()}\"\nmap.put(gstringKey,'value')\nassert map.get('SOME KEY') == null\n"],["body","\n"],["body","key视图，value视图"],["body","\n"],["body","def map = [1:'a', 2:'b', 3:'c']\n\ndef entries = map.entrySet()\nentries.each { entry ->\n  assert entry.key in [1,2,3]\n  assert entry.value in ['a','b','c']\n}\n\ndef keys = map.keySet()\nassert keys == [1,2,3] as Set\n"],["body","\n"],["headingLink","过滤和排序"],["heading","过滤和排序"],["body","\n"],["body","def people = [\n    1: [name:'Bob', age: 32, gender: 'M'],\n    2: [name:'Johnny', age: 36, gender: 'M'],\n    3: [name:'Claire', age: 21, gender: 'F'],\n    4: [name:'Amy', age: 54, gender:'F']\n]\n\ndef bob = people.find { it.value.name == 'Bob' } // find a single entry\ndef females = people.findAll { it.value.gender == 'F' }\n\n// both return entries, but you can use collect to retrieve the ages for example\ndef ageOfBob = bob.value.age\ndef agesOfFemales = females.collect {\n    it.value.age\n}\n\nassert ageOfBob == 32\nassert agesOfFemales == [21,54]\n\n// but you could also use a key/pair value as the parameters of the closures\ndef agesOfMales = people.findAll { id, person ->\n    person.gender == 'M'\n}.collect { id, person ->\n    person.age\n}\nassert agesOfMales == [32, 36]\n\n// `every` returns true if all entries match the predicate\nassert people.every { id, person ->\n    person.age > 18\n}\n\n// `any` returns true if any entry matches the predicate\n\nassert people.any { id, person ->\n    person.age == 54\n}\n"],["body","\n"],["body","分组"],["body","\n"],["body","assert ['a', 7, 'b', [2, 3]].groupBy {\n    it.class\n} == [(String)   : ['a', 'b'],\n      (Integer)  : [7],\n      (ArrayList): [[2, 3]]\n]\n\nassert [\n        [name: 'Clark', city: 'London'], [name: 'Sharma', city: 'London'],\n        [name: 'Maradona', city: 'LA'], [name: 'Zhang', city: 'HK'],\n        [name: 'Ali', city: 'HK'], [name: 'Liu', city: 'HK'],\n].groupBy { it.city } == [\n        London: [[name: 'Clark', city: 'London'],\n                 [name: 'Sharma', city: 'London']],\n        LA    : [[name: 'Maradona', city: 'LA']],\n        HK    : [[name: 'Zhang', city: 'HK'],\n                 [name: 'Ali', city: 'HK'],\n                 [name: 'Liu', city: 'HK']],\n]\n"],["body","\n"],["headingLink","序列"],["heading","序列"],["body","\n"],["headingLink","定义序列"],["heading","定义序列"],["body","\n"],["body","\n"],["body","用 .. 符号定义的范围是包含的（即列表包含 from 和 to 值）。"],["body","\n"],["body","用 ..< 符号定义的范围是半开的，它们包括第一个值但不包括最后一个值。"],["body","\n"],["body","\n"],["body","// an inclusive range\ndef range = 5..8\nassert range.size() == 4\nassert range.get(2) == 7\nassert range[2] == 7\nassert range instanceof java.util.List\nassert range.contains(5)\nassert range.contains(8)\n\n// lets use a half-open range\nrange = 5..<8\nassert range.size() == 3\nassert range.get(2) == 7\nassert range[2] == 7\nassert range instanceof java.util.List\nassert range.contains(5)\nassert !range.contains(8)\n\n//get the end points of the range without using indexes\nrange = 1..10\nassert range.from == 1\nassert range.to == 10\n"],["body","\n"],["body","自定义序列"],["body","\n"],["body","只要实现 Comparable next() previoust() 就能创建序列"],["body","\n"],["body","// an inclusive range\ndef range = 'a'..'d'\nassert range.size() == 4\nassert range.get(2) == 'c'\nassert range[2] == 'c'\nassert range instanceof java.util.List\nassert range.contains('a')\nassert range.contains('d')\nassert !range.contains('e')\n"],["body","\n"],["headingLink","迭代-1"],["heading","迭代"],["body","\n"],["body","for循环"],["body","\n"],["body","for (i in 1..10) {\n    println \"Hello ${i}\"\n}\n"],["body","\n"],["body","(1..10).each { i ->\n    println \"Hello ${i}\"\n}\n"],["body","\n"],["body","switch (years) {\n    case 1..10: interestRate = 0.076; break;\n    case 11..25: interestRate = 0.052; break;\n    default: interestRate = 0.037;\n}\n"],["body","\n"],["headingLink","集合语法增强"],["heading","集合语法增强"],["body","\n"],["headingLink","gpath支持"],["heading","GPath支持"],["body","\n\n"],["body","dot 从集合中的每个元素上取 属性为a的对象，如果取不到则过滤"],["body","\n"],["body","*dot  从集合中的每个元素上取 属性为a的对象，如果取不到则赋值为空"],["body","\n\n"],["body","由于对 list 和 map 的属性表示法的支持，Groovy 提供了语法糖，使得处理嵌套集合非常容易"],["body","\n"],["body","def listOfMaps = [['a': 11, 'b': 12], ['a': 21, 'b': 22]]\nassert listOfMaps.a == [11, 21] //GPath notation\nassert listOfMaps*.a == [11, 21] //spread dot notation\n\nlistOfMaps = [['a': 11, 'b': 12], ['a': 21, 'b': 22], null]\nassert listOfMaps*.a == [11, 21, null] // caters for null values\nassert listOfMaps*.a == listOfMaps.collect { it?.a } //equivalent notation\n// But this will only collect non-null values\nassert listOfMaps.a == [11,21]\n"],["body","\n"],["headingLink","集合展开"],["heading","集合展开"],["body","\n"],["body","# 类似于 调用   putAll,但是已有的同名key不会更新\nassert [ 'z': 900,\n         *: ['a': 100, 'b': 200], 'a': 300] == ['a': 300, 'b': 200, 'z': 900]\n//spread map notation in map definition\nassert [*: [3: 3, *: [5: 5]], 7: 7] == [3: 3, 5: 5, 7: 7]\n//定义闭包返回Map\ndef f = { [1: 'u', 2: 'v', 3: 'w'] }\nassert [*: f(), 10: 'zz'] == [1: 'u', 10: 'zz', 2: 'v', 3: 'w']\n//spread map notation in function arguments\nf = { map -> map.c }\nassert f(*: ['a': 10, 'b': 20, 'c': 30], 'e': 50) == 30\n\nf = { m, i, j, k -> [m, i, j, k] }\n//using spread map notation with mixed unnamed and named arguments\nassert f('e': 100, *[4, 5], *: ['a': 10, 'b': 20, 'c': 30], 6) ==\n        [[\"e\": 100, \"b\": 20, \"c\": 30, \"a\": 10], 4, 5, 6]\n"],["body","\n"],["headingLink","点运算符"],["heading","*点运算符"],["body","\n"],["body","“星点”运算符是一个快捷运算符，允许您调用集合中所有元素的方法或属性："],["body","\n"],["body","assert [1, 3, 5] == ['a', 'few', 'words']*.size()\n\nclass Person {\n    String name\n    int age\n}\ndef persons = [new Person(name:'Hugo', age:17), new Person(name:'Sandra',age:19)]\nassert [17, 19] == persons*.age\n"],["body","\n"],["headingLink","使用下标运算符切片"],["heading","使用下标运算符切片"],["body","\n"],["body","您可以使用下标表达式对列表、数组、映射进行索引。有趣的是，在这种情况下，字符串被视为特殊类型的集合："],["body","\n"],["body","def text = 'nice cheese gromit!'\ndef x = text[2]\n\nassert x == 'c'\nassert x.class == String\n\ndef sub = text[5..10]\nassert sub == 'cheese'\n\ndef list = [10, 11, 12, 13]\ndef answer = list[2,3]\nassert answer == [12,13]\n"],["body","\n"],["body","断点切片"],["body","\n"],["body","list = 100..200\nsub = list[1, 3, 20..25, 33]\nassert sub == [101, 103, 120, 121, 122, 123, 124, 125, 133]\n"],["body","\n"],["body","下标运算符可用于更新现有集合（对于可变的集合类型）："],["body","\n"],["body","list = ['a','x','x','d']\nlist[1..2] = ['b','c']\nassert list == ['a','b','c','d']\n"],["body","\n"],["body","值得注意的是，允许使用负索引，以便更轻松地从集合的末尾提取："],["body","\n"],["body","text = \"nice cheese gromit!\"\nx = text[-1]\nassert x == \"!\"\n"],["body","\n"],["body","您可以使用负索引从列表、数组、字符串等的末尾开始计数。"],["body","\n"],["body","def name = text[-7..-2]\nassert name == \"gromit\"\n"],["body","\n"],["body","如果您使用反向索引（起始索引大于结束索引），则答案相反。"],["body","\n"],["body","text = \"nice cheese gromit!\"\nname = text[3..1]\nassert name == \"eci\"\n"],["body","\n"],["headingLink","java18日期类"],["heading","java1.8日期类"],["body","\n"],["body","groovy-datetime 模块支持许多扩展以使用 Java 8 中引入的日期/时间 API。本文档将此 API 定义的数据类型称为“JSR 310 类型”。"],["body","\n"],["headingLink","formatting-and-parsing"],["heading","Formatting and parsing"],["body","\n"],["body","Method"],["body","Description"],["body","Example"],["body","\n"],["body","getDateString()"],["body","针对于 LocalDate LocalDateTime 日期或时间类型转 string,"],["body","2018-03-10"],["body","\n"],["body","OffsetDateTime, DateTimeFormatter.ISO_OFFSET_DATE"],["body","2018-03-10+04:00"],["body","\n"],["body","For ZonedDateTime, formats with DateTimeFormatter.ISO_LOCAL_DAT  and appends the ZoneId short name"],["body","2018-03-10EST"],["body","\n"],["body","getDateTimeString()"],["body","For LocalDateTime, formats with DateTimeFormatter.ISO_LOCAL_DATE_TIME"],["body","2018-03-10T20:30:45"],["body","\n"],["body","For OffsetDateTime, formats with DateTimeFormatter.ISO_OFFSET_DATE_TIME"],["body","2018-03-10T20:30:45+04:00"],["body","\n"],["body","For ZonedDateTime, formats with DateTimeFormatter.ISO_LOCAL_DATE_TIME and appends the ZoneId short name"],["body","2018-03-10T20:30:45EST"],["body","\n"],["body","getTimeString()"],["body","For LocalTime and LocalDateTime, formats with DateTimeFormatter.ISO_LOCAL_TIME"],["body","20:30:45"],["body","\n"],["body","For OffsetTime and OffsetDateTime, formats with DateTimeFormatter.ISO_OFFSET_TIME formatter"],["body","20:30:45+04:00"],["body","\n"],["body","For ZonedDateTime, formats with DateTimeFormatter.ISO_LOCAL_TIME and appends the ZoneId short name"],["body","20:30:45EST"],["body","\n"],["body","format(FormatStyle style)"],["body","For LocalTime and OffsetTime, formats with DateTimeFormatter.ofLocalizedTime(style)"],["body","4:30 AM (with style FormatStyle.SHORT, e.g.)"],["body","\n"],["body","For LocalDate, formats with DateTimeFormatter.ofLocalizedDate(style)"],["body","Saturday, March 10, 2018 (with style FormatStyle.FULL, e.g.)"],["body","\n"],["body","For LocalDateTime, OffsetDateTime, and ZonedDateTime formats with DateTimeFormatter.ofLocalizedDateTime(style)"],["body","Mar 10, 2019 4:30:45 AM (with style FormatStyle.MEDIUM, e.g.)"],["body","\n"],["body","format(String pattern)"],["body","Formats with DateTimeFormatter.ofPattern(pattern)"],["body","03/10/2018 (with pattern ’MM/dd/yyyy', e.g.)"],["body","\n\n\n"],["headingLink","修改时间"],["heading","修改时间"],["body","\n"],["headingLink","加减"],["heading","加减"],["body","\n"],["body","def aprilFools = LocalDate.of(2018, Month.APRIL, 1)\n\ndef nextAprilFools = aprilFools + Period.ofDays(365) // add 365 days\nassert nextAprilFools.year == 2019\n\ndef idesOfMarch = aprilFools - Period.ofDays(17) // subtract 17 days\nassert idesOfMarch.dayOfMonth == 15\nassert idesOfMarch.month == Month.MARCH\n"],["body","\n"],["body","def nextAprilFools = aprilFools + 365 // add 365 days\ndef idesOfMarch = aprilFools - 17 // subtract 17 days\n"],["body","\n"],["body","这些整数的单位取决于 JSR 310 类型操作数"],["body","\n"],["body","//整形以秒为单位\ndef mars = LocalTime.of(12, 34, 56) // 12:34:56 pm\n\ndef thirtySecondsToMars = mars - 30 // go back 30 seconds\nassert thirtySecondsToMars.second == 26\n"],["body","\n"],["headingLink","乘除"],["heading","乘除"],["body","\n"],["body","乘法运算符可用于将 Period 和 Duration 实例乘以整数值； "],["body","\n"],["body","除法运算符可用于将 Duration 实例除以整数值。"],["body","\n"],["body","def period = Period.ofMonths(1) * 2 // a 1-month period times 2\nassert period.months == 2\n\ndef duration = Duration.ofSeconds(10) / 5// a 10-second duration divided by 5\nassert duration.seconds == 2\n"],["body","\n"],["body","递增递减"],["body","\n"],["body","def year = Year.of(2000)\n--year // decrement by one year\nassert year.value == 1999\n\ndef offsetTime = OffsetTime.of(0, 0, 0, 0, ZoneOffset.UTC) // 00:00:00.000 UTC\noffsetTime++ // increment by one second\nassert offsetTime.second == 1\n"],["body","\n"],["headingLink","negation"],["heading","Negation"],["body","\n"],["body","def duration = Duration.ofSeconds(-15)\ndef negated = -duration\nassert negated.seconds == 15\n"],["body","\n"],["headingLink","与日期时间值交互"],["heading","与日期/时间值交互"],["body","\n"],["headingLink","直接属性访问"],["heading","直接属性访问"],["body","\n"],["body","def date = LocalDate.of(2018, Month.MARCH, 12)\nassert date[ChronoField.YEAR] == 2018\nassert date[ChronoField.MONTH_OF_YEAR] == Month.MARCH.value\nassert date[ChronoField.DAY_OF_MONTH] == 12\nassert date[ChronoField.DAY_OF_WEEK] == DayOfWeek.MONDAY.value\n\ndef period = Period.ofYears(2).withMonths(4).withDays(6)\nassert period[ChronoUnit.YEARS] == 2\nassert period[ChronoUnit.MONTHS] == 4\nassert period[ChronoUnit.DAYS] == 6\n"],["body","\n"],["headingLink","ranges-upto-and-downto"],["heading","Ranges, upto, and downto"],["body","\n"],["body","时间范围迭代"],["body","\n"],["body","def start = LocalDate.now()\ndef end = start + 6 // 6 days later\n(start..end).each { date ->\n    println date.dayOfWeek\n}\n"],["body","\n"],["body","同上述"],["body","\n"],["body","def start = LocalDate.now()\ndef end = start + 6 // 6 days later\nstart.upto(end) { next ->\n    println next.dayOfWeek\n}\n"],["body","\n"],["body","upto、downto、ranges 的迭代单位与加减法的单位相同：LocalDate 一次迭代一天，YearMonth 迭代一个月，Year 迭代一年，其他时间迭代一秒。"],["body","\n"],["body","这两种方法还支持可选的 TemporalUnit 参数来更改迭代单位。"],["body","\n"],["body","//按月迭代\ndef start = LocalDate.of(2018, Month.MARCH, 1)\ndef end = start + 1 // 1 day later\n\nint iterationCount = 0\nstart.upto(end, ChronoUnit.MONTHS) { next ->\n    println next\n    ++iterationCount\n}\n\nassert iterationCount == 1\n"],["body","\n"],["headingLink","combining-datetime-values"],["heading","Combining date/time values"],["body","\n"],["body","左移运算符 (<<) 可用于将两个 JSR 310 类型组合成一个聚合类型。"],["body","\n"],["body","例如，可以将 LocalDate 左移到 LocalTime 以生成复合 LocalDateTime 实例。"],["body","\n"],["body","MonthDay monthDay = Month.JUNE << 3 // June 3rd\nLocalDate date = monthDay << Year.of(2015) // 3-Jun-2015\nLocalDateTime dateTime = date << LocalTime.NOON // 3-Jun-2015 @ 12pm\nOffsetDateTime offsetDateTime = dateTime << ZoneOffset.ofHours(-5) // 3-Jun-2015 @ 12pm UTC-5\n"],["body","\n"],["body","左移运算符是自反的；"],["body","\n"],["body","操作数的顺序无关紧要。"],["body","\n"],["body","def year = Year.of(2000)\ndef month = Month.DECEMBER\n\nYearMonth a = year << month\nYearMonth b = month << year\nassert a == b\n"],["body","\n"],["headingLink","创建时间段和持续时间"],["heading","创建时间段和持续时间"],["body","\n"],["body","右移运算符 (>>) 生成一个值，表示操作数之间的周期或持续时间。"],["body","\n"],["body","对于 ChronoLocalDate、YearMonth 和 Year，该运算符生成一个 Period 实例："],["body","\n"],["body","def newYears = LocalDate.of(2018, Month.JANUARY, 1)\ndef aprilFools = LocalDate.of(2018, Month.APRIL, 1)\n\ndef period = newYears >> aprilFools\nassert period instanceof Period\nassert period.months == 3\n"],["body","\n"],["body","The operator produces a Duration for the time-aware JSR types:"],["body","\n"],["body","def duration = LocalTime.NOON >> (LocalTime.NOON + 30)\nassert duration instanceof Duration\nassert duration.seconds == 30\n"],["body","\n"],["body","如果运算符左侧的值早于右侧的值，则结果为正。"],["body","\n"],["body","如果左侧晚于右侧，则结果为负："],["body","\n"],["headingLink","在传统和-jsr-310-类型之间转换"],["heading","在传统和 JSR 310 类型之间转换"],["body","\n"],["body","尽管 java.util 包中的 Date、Calendar 和 TimeZone 类型存在缺陷，但它们在 Java API 中非常常见（至少在 Java 8 之前的 API 中）。"],["body","\n"],["body","为了适应此类 API 的使用，Groovy 提供了在 JSR 310 类型和遗留类型之间进行转换的方法。"],["body","\n"],["body","大多数 JSR 类型都配备了 toDate() 和 toCalendar() 方法，用于转换为相对等效的 java.util.Date 和 java.util.Calendar 值。 "],["body","\n"],["body","ZoneId 和 ZoneOffset 都被赋予了一个 toTimeZone() 方法来转换为 java.util.TimeZone。"],["body","\n"],["body","/ LocalDate to java.util.Date\ndef valentines = LocalDate.of(2018, Month.FEBRUARY, 14)\nassert valentines.toDate().format('MMMM dd, yyyy') == 'February 14, 2018'\n\n// LocalTime to java.util.Date\ndef noon = LocalTime.of(12, 0, 0)\nassert noon.toDate().format('HH:mm:ss') == '12:00:00'\n\n// ZoneId to java.util.TimeZone\ndef newYork = ZoneId.of('America/New_York')\nassert newYork.toTimeZone() == TimeZone.getTimeZone('America/New_York')\n\n// ZonedDateTime to java.util.Calendar\ndef valAtNoonInNY = ZonedDateTime.of(valentines, noon, newYork)\nassert valAtNoonInNY.toCalendar().getTimeZone().toZoneId() == newYork\n"],["body","\n"],["body","请注意，在转换为旧类型时："],["body","\n\n"],["body","\n"],["body","纳秒值被截断为毫秒。"],["body","\n"],["body","例如，一个 LocalTime 的 ChronoUnit.NANOS 值为 999,999,999 纳秒转换为 999 毫秒。"],["body","\n"],["body","\n"],["body","\n"],["body","转换“本地”类型（LocalDate、LocalTime 和 LocalDateTime）时，返回的 Date 或 Calendar 的时区将是系统默认值"],["body","\n"],["body","\n"],["body","\n"],["body","转换仅时间类型（LocalTime 或 OffsetTime）时，Date 或 Calendar 的年/月/日设置为当前日期。"],["body","\n"],["body","\n"],["body","\n"],["body","转换仅日期类型（LocalDate）时，Date 或 Calendar 的时间值将被清除，即 00:00:00.000。"],["body","\n"],["body","\n"],["body","\n"],["body","将 OffsetDateTime 转换为 Calendar 时，只有 ZoneOffset 的小时和分钟传送到相应的 TimeZone。"],["body","\n"],["body","幸运的是，非零秒的区域偏移很少见。"],["body","\n"],["body","\n\n"],["body","Groovy 向 Date 和 Calendar 添加了许多方法，用于转换为各种 JSR 310 类型："],["body","\n"],["body","Date legacy = Date.parse('yyyy-MM-dd HH:mm:ss.SSS', '2010-04-03 10:30:58.999')\n\nassert legacy.toLocalDate() == LocalDate.of(2010, 4, 3)\nassert legacy.toLocalTime() == LocalTime.of(10, 30, 58, 999_000_000) // 999M ns = 999ms\nassert legacy.toOffsetTime().hour == 10\nassert legacy.toYear() == Year.of(2010)\nassert legacy.toMonth() == Month.APRIL\nassert legacy.toDayOfWeek() == DayOfWeek.SATURDAY\nassert legacy.toMonthDay() == MonthDay.of(Month.APRIL, 3)\nassert legacy.toYearMonth() == YearMonth.of(2010, Month.APRIL)\nassert legacy.toLocalDateTime().year == 2010\nassert legacy.toOffsetDateTime().dayOfMonth == 3\nassert legacy.toZonedDateTime().zone == ZoneId.systemDefault()\n"],["body","\n"],["headingLink","有用的工具类"],["heading","有用的工具类"],["body","\n"],["headingLink","configslurper"],["heading","ConfigSlurper"],["body","\n"],["body","ConfigSlurper 是一个实用程序类，用于读取以 Groovy 脚本形式定义的配置文件。"],["body","\n"],["body","就像 Java *.properties 文件的情况一样，ConfigSlurper 允许使用点符号。"],["body","\n"],["body","但此外，它允许闭包范围的配置值和任意对象类型。"],["body","\n"],["body","def config = new ConfigSlurper().parse('''\n//点表示\napp.date = new Date()  \n    app.age  = 42\n    //使用闭包作用域替代点表示法\n    app {                  \n        name = \"Test${42}\"\n    }\n''')\n\nassert config.app.date instanceof Date\nassert config.app.age == 42\nassert config.app.name == 'Test42'\n"],["body","\n"],["body","从上面的例子中可以看出，parse 方法可用于检索 groovy.util.ConfigObject 实例。 "],["body","\n"],["body","ConfigObject 是一个专门的 java.util.Map 实现，它要么返回配置的值，要么返回一个新的 ConfigObject 实例，但永远不会为空。"],["body","\n"],["body","def config = new ConfigSlurper().parse('''\n    app.date = new Date()\n    app.age  = 42\n    app.name = \"Test${42}\"\n''')\n\nassert config.test != null   \n"],["body","\n"],["body","如果点是配置变量名称的一部分，则可以使用单引号或双引号对其进行转义"],["body","\n"],["body","def config = new ConfigSlurper().parse('''\n    app.\"person.age\"  = 42\n''')\n\nassert config.app.\"person.age\" == 42\n"],["body","\n"],["body","环境变量"],["body","\n"],["body","def config = new ConfigSlurper('development').parse('''\n  environments {\n       development {\n           app.port = 8080\n       }\n\n       test {\n           app.port = 8082\n       }\n\n       production {\n           app.port = 80\n       }\n  }\n''')\n\nassert config.app.port == 8080\n"],["body","\n"],["body","环境方法是内置的，但 registerConditionalBlock 方法可用于注册除环境名称之外的其他方法名称。"],["body","\n"],["body","def slurper = new ConfigSlurper()\nslurper.registerConditionalBlock('myProject', 'developers')   \n\ndef config = slurper.parse('''\n  sendMail = true\n\n  myProject {\n       developers {\n           sendMail = false\n       }\n  }\n''')\n\nassert !config.sendMail\n"],["body","\n"],["body","出于 Java 集成的目的，可以使用 toProperties 方法将 ConfigObject 转换为 java.util.Properties 对象，该对象可能存储到 *.properties 文本文件中。"],["body","\n"],["body","请注意，在将配置值添加到新创建的 Properties 实例期间，它们会转换为 String 实例。"],["body","\n"],["body","def config = new ConfigSlurper().parse('''\n    app.date = new Date()\n    app.age  = 42\n    app {\n        name = \"Test${42}\"\n    }\n''')\n\ndef properties = config.toProperties()\n\nassert properties.\"app.date\" instanceof String\nassert properties.\"app.age\" == '42'\nassert properties.\"app.name\" == 'Test42'\n"],["body","\n"],["headingLink","expando"],["heading","Expando"],["body","\n"],["body","Expando 类可用于创建动态可扩展对象。每个 Expando 对象都代表一个独立的、动态制作的实例，可以在运行时使用属性（或方法）进行扩展。"],["body","\n"],["body","def expando = new Expando()\nexpando.name = 'John'\n\nassert expando.name == 'John'\n"],["body","\n"],["body","当动态属性注册一个闭包代码块时会发生一种特殊情况。"],["body","\n"],["body","一旦注册，就可以像调用方法一样调用它。"],["body","\n"],["body","def expando = new Expando()\nexpando.toString = { -> 'John' }\nexpando.say = { String s -> \"John says: ${s}\" }\n\nassert expando as String == 'John'\nassert expando.say('Hi') == 'John says: Hi'\n"],["body","\n"],["headingLink","observable-list-map-and-set"],["heading","Observable list, map and set"],["body","\n"],["body","当添加、删除或更改元素时，这些集合中的每一个都会触发 java.beans.PropertyChangeEvent 事件。"],["body","\n"],["body","请注意，PropertyChangeEvent 不仅表示某个事件已发生，而且还保存有关属性名称和某个属性已更改为的旧/新值的信息。"],["body","\n"],["body","def event                                       \ndef listener = {\n    if (it instanceof ObservableList.ElementEvent)  {  \n        event = it\n    }\n} as PropertyChangeListener\n\n\ndef observable = [1, 2, 3] as ObservableList    \nobservable.addPropertyChangeListener(listener)  \n\nobservable.add 42                               \n\nassert event instanceof ObservableList.ElementAddedEvent\n\ndef elementAddedEvent = event as ObservableList.ElementAddedEvent\nassert elementAddedEvent.changeType == ObservableList.ChangeType.ADDED\nassert elementAddedEvent.index == 3\nassert elementAddedEvent.oldValue == null\nassert elementAddedEvent.newValue == 42\n"],["body","\n"],["body","def event\ndef listener = {\n    if (it instanceof ObservableList.ElementEvent)  {\n        event = it\n    }\n} as PropertyChangeListener\n\n\ndef observable = [1, 2, 3] as ObservableList\nobservable.addPropertyChangeListener(listener)\n\nobservable.clear()\n\nassert event instanceof ObservableList.ElementClearedEvent\n\ndef elementClearedEvent = event as ObservableList.ElementClearedEvent\nassert elementClearedEvent.values == [1, 2, 3]\nassert observable.size() == 0\n"],["body","\n\n\n\n"],["body","\n\n                    "],["body","\n\n                    \n                \n            \n\n            \n\n        \n\n\n\n\n        \n\n\n\n        \n        \n        \n\n        \n\n\n    \n    \n"]],[["_relative_fp","4.groovy/编程结构.html"],["title","编程结构 - 各项编程语言"],["body","\n    \n        \n        \n\n        \n        \n\n        \n        \n\n        \n        \n\n        \n\n        \n\n            \n                                \n                \n                    \n                        "],["body","\n                            \n                        "],["body","\n                        "],["body","\n                            \n                        "],["body","\n                        \n                            "],["body","Light"],["body","\n                            "],["body","Rust"],["body","\n                            "],["body","Coal"],["body","\n                            "],["body","Navy"],["body","\n                            "],["body","Ayu"],["body","\n                        \n                    \n\n                    "],["heading","各项编程语言"],["body","\n\n                    \n\n                    \n                \n\n\n                \n                \n\n                \n                    "],["body","\n                        \n\n"],["body","\n"],["body","\n\n"],["headingLink","package-names"],["heading","Package names"],["body","\n"],["body","包名与 Java 中的作用完全相同。"],["body","\n"],["body","它们允许我们在没有任何冲突的情况下分离代码库。 "],["body","\n"],["body","Groovy 类必须在类定义之前指定它们的包，否则假定为默认包。"],["body","\n"],["body","// defining a package named com.yoursite\npackage com.yoursite\n"],["body","\n"],["body","要引用 com.yoursite.com 包中的某个类 Foo，您需要使用完全限定名称 com.yoursite.com.Foo，否则您可以使用 import 语句，如下所示。"],["body","\n"],["headingLink","imports"],["heading","Imports"],["body","\n"],["body","为了引用任何类，您需要对其包进行限定引用。 "],["body","\n"],["body","Groovy 遵循 Java 允许 import 语句解析类引用的概念"],["body","\n"],["body","// importing the class MarkupBuilder\nimport groovy.xml.MarkupBuilder\n\n// using the imported class to create an object\ndef xml = new MarkupBuilder()\n\nassert xml != null\n"],["body","\n"],["headingLink","default-imports"],["heading","Default imports"],["body","\n"],["body","默认导入是 Groovy 语言默认提供的导入。"],["body","\n"],["body","import java.lang.*\nimport java.util.*\nimport java.io.*\nimport java.net.*\nimport groovy.lang.*\nimport groovy.util.*\nimport java.math.BigInteger\nimport java.math.BigDecimal\n"],["body","\n"],["body","这样做是因为这些包中的类是最常用的。通过导入这些样板代码减少了。"],["body","\n"],["headingLink","simple-import"],["heading","Simple import"],["body","\n"],["body","简单导入"],["body","\n"],["body","// importing the class MarkupBuilder\nimport groovy.xml.MarkupBuilder\n\n// using the imported class to create an object\ndef xml = new MarkupBuilder()\n\nassert xml != null\n"],["body","\n"],["headingLink","star-import"],["heading","Star import"],["body","\n"],["body","提供了一种使用 * 从包中导入所有类的特殊方法，即所谓的星形导入。"],["body","\n"],["body","import groovy.xml.*\n\ndef markupBuilder = new MarkupBuilder()\n\nassert markupBuilder != null\n\nassert new StreamingMarkupBuilder() != null\n"],["body","\n"],["headingLink","static-import"],["heading","Static import"],["body","\n"],["body","Groovy 的静态导入功能允许您引用导入的类，就像它们是您自己类中的静态方法一样："],["body","\n"],["body","import static Boolean.FALSE\n\nassert !FALSE //use directly, without Boolean prefix!\n"],["body","\n"],["headingLink","静态导入别名"],["heading","静态导入别名"],["body","\n"],["body","带有 as 关键字的静态导入为命名空间问题提供了一种优雅的解决方案。"],["body","\n"],["body","假设您想使用其 getInstance() 方法获取 Calendar 实例。"],["body","\n"],["body","这是一个静态方法，所以我们可以使用静态导入。"],["body","\n"],["body","import static Calendar.getInstance as now\n\nassert now().class == Calendar.getInstance().class\n"],["body","\n"],["headingLink","static-star-import"],["heading","Static star import"],["body","\n"],["body","import static java.lang.Math.*\n\nassert sin(0) == 0.0\nassert cos(0) == 1.0\n"],["body","\n"],["headingLink","import-aliasing"],["heading","Import aliasing"],["body","\n"],["body","导入别名"],["body","\n"],["body","使用类型别名，我们可以使用我们选择的名称来引用完全限定的类名。"],["body","\n"],["body","这可以像以前一样使用 as 关键字来完成。"],["body","\n"],["body","例如，我们可以将 java.sql.Date 作为 SQLDate 导入并在与 java.util.Date 相同的文件中使用它，而不必使用任一类的完全限定名称："],["body","\n"],["body","import java.util.Date\nimport java.sql.Date as SQLDate\n\nDate utilDate = new Date(1000L)\nSQLDate sqlDate = new SQLDate(1000L)\n\nassert utilDate instanceof java.util.Date\nassert sqlDate instanceof java.sql.Date\n"],["body","\n"],["headingLink","scripts-versus-classes"],["heading","Scripts versus classes"],["body","\n"],["body","脚本与类"],["body","\n"],["headingLink","public-static-void-main-vs-script"],["heading","public static void main vs script"],["body","\n"],["body","Groovy 支持脚本和类。"],["body","\n"],["body","class Main {                                    \n    static void main(String... args) {          \n        println 'Groovy world!'                 \n    }\n}\n"],["body","\n"],["body","这是您会发现来自 Java 的典型代码，其中代码必须嵌入到一个类中才能执行。 "],["body","\n"],["body","println 'Groovy world!'\n"],["body","\n"],["body","一个脚本可以被认为是一个类而不需要声明它，但有一些区别。"],["body","\n"],["headingLink","script-class"],["heading","Script class"],["body","\n"],["body","脚本总是被编译成一个类。 "],["body","\n"],["body","Groovy 编译器将为您编译该类，并将脚本主体复制到 run 方法中。"],["body","\n"],["body","因此，前面的示例被编译为如下所示："],["body","\n"],["body","import org.codehaus.groovy.runtime.InvokerHelper\nclass Main extends Script {                     \n    def run() {                                 \n        println 'Groovy world!'                 \n    }\n    static void main(String[] args) {           \n        InvokerHelper.runScript(Main, args)     \n    }\n}\n"],["body","\n\n"],["body","Main 类扩展了 groovy.lang.Script 类"],["body","\n"],["body","groovy.lang.Script 需要一个返回值的 run 方法"],["body","\n"],["body","脚本主体进入 run 方法"],["body","\n"],["body","main方法是自动生成的"],["body","\n"],["body","并将脚本的执行委托给 run 方法"],["body","\n\n"],["body","如果脚本在文件中，则使用文件的基本名称来确定生成的脚本类的名称。"],["body","\n"],["body","在这个例子中，如果文件名是 Main.groovy，那么脚本类就是 Main。"],["body","\n"],["headingLink","methods"],["heading","Methods"],["body","\n"],["body","int fib(int n) {\n    n < 2 ? 1 : fib(n-1) + fib(n-2)\n}\nassert fib(10)==89\n"],["body","\n"],["body","您还可以混合使用方法和代码。"],["body","\n"],["body","生成的脚本类会将所有的方法携带到脚本类中，并将所有的脚本体组装到run方法中："],["body","\n"],["body","println 'Hello'                                 \n\nint power(int n) { 2**n }                       \n\nprintln \"2^6==${power(6)}\"                      \n"],["body","\n"],["body","import org.codehaus.groovy.runtime.InvokerHelper\nclass Main extends Script {\n    int power(int n) { 2** n}                   \n    def run() {\n        println 'Hello'                         \n        println \"2^6==${power(6)}\"              \n    }\n    static void main(String[] args) {\n        InvokerHelper.runScript(Main, args)\n    }\n}\n"],["body","\n"],["headingLink","variables"],["heading","Variables"],["body","\n"],["body","脚本中的变量不需要类型定义。"],["body","\n"],["body","这意味着这个脚本："],["body","\n"],["body","int x = 1\nint y = 2\nassert x+y == 3\n"],["body","\n"],["body","will behave the same as:"],["body","\n"],["body","x = 1\ny = 2\nassert x+y == 3\n"],["body","\n"],["body","但是，两者之间存在语义差异："],["body","\n"],["body","如果变量如第一个示例中那样声明，则它是局部变量。"],["body","\n"],["body","它将在编译器将生成的 run 方法中声明，并且在脚本主体之外不可见。"],["body","\n"],["body","特别是，这样的变量在脚本的其他方法中是不可见的"],["body","\n"],["body","如果变量未声明，它会进入脚本绑定。"],["body","\n"],["body","绑定从方法中可见，如果您使用脚本与应用程序交互并需要在脚本和应用程序之间共享数据，则该绑定尤其重要。"],["body","\n"],["body","使变量对所有方法可见的另一种方法是使用 @Field 注释。"],["body","\n"],["body","这样注解的变量会成为生成的脚本类的一个字段，对于局部变量，访问不会涉及到脚本绑定。"],["body","\n"],["body","虽然不推荐，但如果您有一个与绑定变量同名的局部变量或脚本字段，您可以使用 binding.varName 来访问绑定变量。"],["body","\n\n\n\n"],["body","\n\n                    "],["body","\n\n                    \n                \n            \n\n            \n\n        \n\n\n\n\n        \n\n\n\n        \n        \n        \n\n        \n\n\n    \n    \n"]],[["_relative_fp","index.html"],["title","我的笔记库 - 各项编程语言"],["body","\n    \n        \n        \n\n        \n        \n\n        \n        \n\n        \n        \n\n        \n\n        \n\n            \n                                \n                \n                    \n                        "],["body","\n                            \n                        "],["body","\n                        "],["body","\n                            \n                        "],["body","\n                        \n                            "],["body","Light"],["body","\n                            "],["body","Rust"],["body","\n                            "],["body","Coal"],["body","\n                            "],["body","Navy"],["body","\n                            "],["body","Ayu"],["body","\n                        \n                    \n\n                    "],["heading","各项编程语言"],["body","\n\n                    \n\n                    \n                \n\n\n                \n                \n\n                \n                    "],["body","\n                        \n\n"],["body","\n"],["body","\n\n"],["headingLink","其他编程语言合集"],["heading","其他编程语言合集"],["body","\n\n\n\n                    "],["body","\n\n                    \n                \n            \n\n            \n\n        \n\n\n\n\n        \n\n\n\n        \n        \n        \n\n        \n\n\n    \n    \n"]],[["_relative_fp","1.C++/C++与C的区别.html"],["title","C++与C的区别 - 各项编程语言"],["body","\n    \n        \n        \n\n        \n        \n\n        \n        \n\n        \n        \n\n        \n\n        \n\n            \n                                \n                \n                    \n                        "],["body","\n                            \n                        "],["body","\n                        "],["body","\n                            \n                        "],["body","\n                        \n                            "],["body","Light"],["body","\n                            "],["body","Rust"],["body","\n                            "],["body","Coal"],["body","\n                            "],["body","Navy"],["body","\n                            "],["body","Ayu"],["body","\n                        \n                    \n\n                    "],["heading","各项编程语言"],["body","\n\n                    \n\n                    \n                \n\n\n                \n                \n\n                \n                    "],["body","\n                        \n\n"],["body","\n"],["body","\n\n"],["headingLink","c对-c-的加强"],["heading","C++对 C 的加强"],["body","\n"],["headingLink","变量与常量"],["heading","变量与常量"],["body","\n\n"],["body","\n"],["body","register 关键字在 C++中失效了,只是为了兼容C语言"],["body","\n"],["body","\n"],["body","\n"],["body","C 语言可以同时声明多个同名变量,指向同一个地址空间,C++编译不通过"],["body","\n"],["body","\n"],["body","\n"],["body","C 语言中的 const 关键字只是在编译器限制 变量不可变"],["body","\n"],["body","①C++对于 const 作了加强,当碰见常量声明时,在符号表中放入常量,编译过程中若发现使用常量则直接以符号表中的值替换"],["body","\n"],["body","②C++编译器不一定给常量分配空间,  只有对 const 使用了 extern 或者&操作符, 时才会分配空间但是不会使用这个存储空间的值 "],["body","\n"],["body","③C++ 常量跟宏的区别, 作用域的区别"],["body","\n"],["body","\n\n"],["body","宏的作用域 是整个文件,这样会导致权限无法限定, (可以通过 undefined 来限定) "],["body","\n"],["body","#define a 3\n#undefine a\n"],["body","\n"],["headingLink","struct-为新类型"],["heading","struct 为新类型"],["body","\n\n"],["body","\n"],["body","C++的类型: struct 类型"],["body","\n"],["body","\n"],["body","\n"],["body","C 语言的 struct 类型 ,编译器认为只是变量的集合, 而不是新类型, C++是新类型"],["body","\n"],["body","\n\n"],["body","struct Student{\n\tconst char * name;\n\tint age;\n}\n//C++\nint main(){\n\tStudent s1 = {\"sdff\",30};\n\tStudent s2 = {\"sdff\",31};\n}\n//C\n{\n    struct Student s1 = {};\n}\n"],["body","\n"],["headingLink","函数默认参数与默认返回值"],["heading","函数默认参数与默认返回值"],["body","\n\n"],["body","C 语言中的默认类型 f(i); "],["body","\n"],["body","默认为整数参数,返回值默认为整数"],["body","\n"],["body","在 C++中不支持"],["body","\n\n"],["headingLink","cbool类型"],["heading","c++bool类型"],["body","\n\n"],["body","\n"],["body","C++中的 bool 类型 取值 是 true false ,"],["body","\n"],["body","\n"],["body","\n"],["body","理论上只占用 一个字节,如果多个 bool 类型定义在一起,可能会被放到 同一个字节中(依据编译器的不同) "],["body","\n"],["body","\n"],["body","\n"],["body","给 C++中的 bool 类型赋值 整数时,非 0 为 true,0 为 false,(兼容C语言)"],["body","\n"],["body","\n\n"],["headingLink","c中的三目运算符"],["heading","C++中的三目运算符"],["body","\n\n"],["body","\n"],["body","可以作为左值使用"],["body","\n"],["body","三目运算符的返回值 如果返回的时一个变量,则可以当做左值使用,如果可能的返回值里面有一个是常量,则不能作为左值使用"],["body","\n"],["body","\n\n"],["headingLink","c中的引用"],["heading","C++中的引用"],["body","\n"],["body","变量"],["body","\n\n"],["body","变量 一段连续内存空间的别名"],["body","\n"],["body","程序通过变量来申请存储空间"],["body","\n"],["body","通过变量可以使用存储空间"],["body","\n\n"],["body","**引用 **"],["body","\n"],["body","是已经定义变量的别名(引用 必须用其他的变量初始化)"],["body","\n\n"],["body","语法 Type& name=varname;"],["body","\n"],["body","引用 可读性 好"],["body","\n"],["body","引用作为函数参数"],["body","\n"],["body","const int &a 引用,const 引用只是让变量 拥有只读属性"],["body","\n"],["body","const 引用进行初始化 时,C++编译器会为常量值 分配空间,并将引用名作为这段空间的别名, 跟 C 语言中的 只读变量一样"],["body","\n"],["body","引用有自己的空间吗? 引用的 本质上是 C 语言中的 常指针 Type & name -> Type * const name 为了实用性,而做出的细节隐藏"],["body","\n"],["body","引用作为函数返回值 时 不能 作为左值使用, 当引用是静态全局变量时 可以"],["body","\n"],["body","无法建立引用数组"],["body","\n\n"],["headingLink","内联函数"],["heading","内联函数"],["body","\n\n"],["body","\n"],["body","内联函数 必须与函数定义结合在一起"],["body","\n\n"],["body","\n"],["body","inline int func(int a){return a<b?:a:b;} 直接 对其他调用它的函数 进行 直接 插入替换"],["body","\n"],["body","\n"],["body","\n"],["body","C++不一定响应函数的内联 请求,如果 请求不通过,则 退化成普通函数,"],["body","\n"],["body","\n"],["body","\n"],["body","内联函数没有普通函数 调用的开销,编译器还是会进行类型检查"],["body","\n"],["body","\n"],["body","\n"],["body","宏是由 预处理器进行简单的替换的,而 内联函数 是 由编译器进行的"],["body","\n"],["body","\n"],["body","\n"],["body","强制 内联编译 inline int func(int a) **attribute_((always_inline)); g++ -S 编译成汇编代码 **"],["body","\n"],["body","\n"],["body","\n"],["body","C++内联 编译的 限制 :"],["body","\n\n"],["body","\n"],["body","不能存在任何形式的循环语句"],["body","\n"],["body","\n"],["body","\n"],["body","不能存在过多的条件判断"],["body","\n"],["body","\n"],["body","\n"],["body","函数体不能过于庞大,一般比超过五句"],["body","\n"],["body","\n"],["body","\n"],["body","不能对函数进行取址操作"],["body","\n"],["body","\n"],["body","\n"],["body","函数内联声明必须在调用语句之前"],["body","\n"],["body","\n\n"],["body","\n\n"],["body","\n"],["body","\n"],["body","C++中的 符号表 ,是 C++编译器 在编译代码 时 自己使用的 在处理内联请求 时,会把 内联函数放到 符号表中,当有地方调用它时,会进行类型检查,返回值检查"],["body","\n"],["body","\n"],["body","\n"],["body","函数默认参数"],["body","\n\n"],["body","int mul(x=0); 函数参数默认值"],["body","\n"],["body","一旦函数参数开始使用 默认值,其后的参数必须也使用默认值"],["body","\n\n"],["body","\n"],["body","\n"],["body","C++的函数占位参数,"],["body","\n\n"],["body","int func(int a,int b,int) 无法使用函数占位参数"],["body","\n"],["body","int func(int a,int b,int=0)"],["body","\n\n"],["body","\n"],["body","\n"],["body","C++中的重载"],["body","\n\n"],["body","函数名相同,定义不同的函数参数"],["body","\n"],["body","函数重载,跟默认参数 会发生二义性, 编译不通过"],["body","\n"],["body","函数重载的编译方法精确匹配实参, 默认参数匹配, 默认类型转发匹配,同时进行,不能存在二义性"],["body","\n"],["body","函数重载 与函数指针 在用函数名称 跟函数指针 赋值时 选择与函数指针类型参数列表篇一致 的候选者"],["body","\n\n"],["body","\n"],["body","\n"],["body","C,与 C++的相互调用"],["body","\n\n"],["body","\n"],["body","C 语言的编译器 兼容 C 语言的编译器"],["body","\n"],["body","\n"],["body","\n"],["body","C++ 优先使用 C++的编译方式, extern 强制让 C++对代码进行 C 方式编译"],["body","\n"],["body","\n"],["body","\n"],["body","extern \"C\"{ #include \"add.h\" } 告诉 g++ 编译器, 这个头文件里的文件都是 C 语言编译的"],["body","\n"],["body","\n"],["body","\n"],["body","内置宏"],["body","\n"],["body","#ifdef  __cplusplus\nextern \"C\"{       #endif      #ifdef __cplusplus       }\n#endif\n"],["body","\n"],["body","\n"],["body","\n"],["body","C++ 编译器不能以 C 的方式 编译重载"],["body","\n"],["body","\n\n"],["body","\n"],["body","\n"],["body","动态内存申请:(新增)"],["body","\n\n"],["body","变量 Type * pointe=new Type;"],["body","\n"],["body","数组申请 Type * pointer =new Type[N];"],["body","\n"],["body","delete pointer 释放内存,delete [ ] pointer"],["body","\n"],["body","int * pi=new int(1) 申请空间时初始化,内存空间"],["body","\n\n"],["body","\n"],["body","\n"],["body","C++在中的命名空间"],["body","\n\n"],["body","\n"],["body","C 语言中所有的全局标识符共享同一个作用域,标识符之间可能会发生冲突"],["body","\n"],["body","\n"],["body","\n"],["body","命名空间将全局作用域分成不同的部分,不同命名空间中的标识符,可以重名,命名空间可以相互嵌套,全局作用域 也叫默认命名空间"],["body","\n"],["body","\n"],["body","\n"],["body","命名空间的定义"],["body","\n"],["body","namespace first{       int i=0;     }\nnamespace second{       int i=0;\n                 namespace Internal{       int p=0;\n}}\n"],["body","\n"],["body","\n"],["body","\n"],["body","命名空间的使用"],["body","\n"],["body","using namespace First; //可以直接使用命名空间的所有定义变量\nusing Second::Internal::P;     //Second::i 使用second命名空间中的i\n"],["body","\n"],["body","\n\n"],["body","\n"],["body","\n"],["body","强制类型转换"],["body","\n"],["body","① 基本类型转换 static_cast"],["body","\n"],["body","char c=static_cast<char)(i);\nchar *c=static_cast<char *)(i);  //错误 ,只能用于基本类型的转换,只是在编译器检查\n"],["body","\n"],["body","②const_cast 去除变量的 const 属性"],["body","\n"],["body","const int &j=1;\nint &k=const_cast<int &>(j);\nconst int x=2;\nint &y= const_cast<int&>(x) //这会发生x,y 地址相同,但是值不同\n"],["body","\n"],["body","③reinterpret_cast 指针类型转换 和 整数跟指针类型间的强制转换"],["body","\n"],["body","直接从二进制位进行复制,是一种及其不安全的转换"],["body","\n"],["body","④volatile const int y=2 退化成只读变量, const int z = y 将变量赋值给 一个常量 会退化成 只读变量"],["body","\n"],["body","⑤ 凡是不能在编译器确定的 常量,均退化成只读变量,"],["body","\n"],["body","⑥ 常(只读)引用,在用相同类型初始化时,会引用 相同的变量, 如果 用不同类型的初始化时,会生成一个新的只读变量"],["body","\n"],["body","\n"],["body","\n"],["body","操作引用就是操作变量本身"],["body","\n"],["body","\n"],["body","\n"],["body","extern C 告诉 C++ 编译器 以 C 语言的方式编译 但只是以 C 语言的函数命名方式 编译的,函数体还是 按 C++的方式编译, c++为了重载,函数名经过编译之后 会加上参数信息,因而编译后的函数名与源码中不同 C 语言的编译方式不允许函数重载"],["body","\n"],["body","\n\n\n\n\n"],["body","\n\n                    "],["body","\n\n                    \n                \n            \n\n            \n\n        \n\n\n\n\n        \n\n\n\n        \n        \n        \n\n        \n\n\n    \n    \n"]],[["_relative_fp","1.C++/cmake/index.html"],["title","cmake - 各项编程语言"],["body","\n    \n        \n        \n\n        \n        \n\n        \n        \n\n        \n        \n\n        \n\n        \n\n            \n                                \n                \n                    \n                        "],["body","\n                            \n                        "],["body","\n                        "],["body","\n                            \n                        "],["body","\n                        \n                            "],["body","Light"],["body","\n                            "],["body","Rust"],["body","\n                            "],["body","Coal"],["body","\n                            "],["body","Navy"],["body","\n                            "],["body","Ayu"],["body","\n                        \n                    \n\n                    "],["heading","各项编程语言"],["body","\n\n                    \n\n                    \n                \n\n\n                \n                \n\n                \n                    "],["body","\n                        \n\n"],["body","\n"],["body","\n\n"],["headingLink","源文件划分"],["heading","源文件划分"],["body","\n"],["body","cmake语言 将工程源文件划分为"],["body","\n\n"],["body","Directories (CMakeLists.txt)"],["body","\n"],["body","Scripts (<script>.cmake)"],["body","\n"],["body","Modules (<module>.cmake)"],["body","\n\n"],["headingLink","directories"],["heading","Directories"],["body","\n\n"],["body","CMakeLists.txt 位于目录顶层, 是工程的入口, 最终会被解析成 构建树"],["body","\n"],["body","这个文件中 可以 添加  entire build specification   也可以添加子目录 add_subdirectory(),.子目录也会产生构建树"],["body","\n"],["body","每个被添加的子目录必须包括 一个  CMakeLists.txt 的入口点文件 "],["body","\n\n"],["headingLink","scripts"],["heading","Scripts"],["body","\n\n"],["body","\n"],["body","独立 .cmake 源文件 "],["body","\n"],["body","\n"],["body","\n"],["body","按照Cmake语法执行脚本 通过 -P选项"],["body","\n"],["body","\n\n"],["headingLink","modules"],["heading","Modules"],["body","\n\n"],["body","\n"],["body","在 Scripts  Directories 中可以使用 include() 命令,"],["body","\n"],["body","\n"],["body","\n"],["body","导入<module>.cmake 脚本命令"],["body","\n"],["body","\n\n"],["headingLink","语法"],["heading","语法"],["body","\n"],["headingLink","sourcefile"],["heading","SourceFile"],["body","\n"],["body","file         ::=  file_element*\nfile_element ::=  command_invocation line_ending |\n                  (bracket_comment|space)* line_ending\nline_ending  ::=  line_comment? newline\nspace        ::=  <match '[ \\t]+'>\nnewline      ::=  <match '\\n'>\n"],["body","\n"],["headingLink","命令调用"],["heading","命令调用"],["body","\n"],["body","Command Invocations"],["body","\n"],["body","command_invocation  ::=  space* identifier space* '(' arguments ')'\nidentifier          ::=  <match '[A-Za-z_][A-Za-z0-9_]*'>\narguments           ::=  argument? separated_arguments*\nseparated_arguments ::=  separation+ argument? |\n                         separation* '(' arguments ')'\nseparation          ::=  space | line_ending\n"],["body","\n"],["body","Command Arguments"],["body","\n"],["body","argument ::=  bracket_argument | quoted_argument | unquoted_argument\n"],["body","\n"],["headingLink","参数形式"],["heading","参数形式"],["body","\n"],["body","Bracket Argument"],["body","\n"],["body","bracket_argument ::=  bracket_open bracket_content bracket_close\nbracket_open     ::=  '[' '='* '['\nbracket_content  ::=  <any text not containing a bracket_close with\n                       the same number of '=' as the bracket_open>\nbracket_close    ::=  ']' '='* ']'\n"],["body","\n"],["body","Quoted Argument"],["body","\n"],["body","quoted_argument     ::=  '\"' quoted_element* '\"'\nquoted_element      ::=  <any character except '\\' or '\"'> |\n                         escape_sequence |\n                         quoted_continuation\nquoted_continuation ::=  '\\' newline\n"],["body","\n"],["body","Unquoted Argument"],["body","\n"],["body","unquoted_argument ::=  unquoted_element+ | unquoted_legacy\nunquoted_element  ::=  <any character except whitespace or one of '()#\"\\'> |\n                       escape_sequence\nunquoted_legacy   ::=  <see note in text>\n"],["body","\n"],["body","例子"],["body","\n"],["body","foreach(arg\n    NoSpace\n    Escaped\\ Space\n    This;Divides;Into;Five;Arguments\n    Escaped\\;Semicolon\n    )\n  message(\"${arg}\")\nendforeach()\n"],["body","\n"],["body","Escape Sequences"],["body","\n"],["body","escape_sequence  ::=  escape_identity | escape_encoded | escape_semicolon\nescape_identity  ::=  '\\' <match '[^A-Za-z0-9;]'>  //字符串本身\nescape_encoded   ::=  '\\t' | '\\r' | '\\n'  // tab,回车,换行\nescape_semicolon ::=  '\\;' //;\n"],["body","\n"],["headingLink","变量引用"],["heading","变量引用"],["body","\n"],["body","Variable References"],["body","\n\n"],["body","形如${<variable>}  是被解析为  Quoted Argument,Unquoted Argument "],["body","\n"],["body","变量可以嵌套 从内而外. ${outer_${inner_variable}_variable}"],["body","\n"],["body","详见 Variables 变量作用域以及 如何设置值"],["body","\n"],["body","环境变量 形如  $ENV{<variable>}   详见Environment Variables"],["body","\n"],["body","缓存变量 形如 $CACHE{<variable>},详见 CACHE"],["body","\n"],["body","if() 命令 中的 变量 可以  <variable> instead of ${<variable>}., environment and cache variables always need to be referenced as $ENV{<variable>} or $CACHE{<variable>}."],["body","\n\n"],["headingLink","注释"],["heading","注释"],["body","\n"],["body","Bracket Comment"],["body","\n"],["body","#[[This is a bracket comment.\nIt runs until the close bracket.]]\nmessage(\"First Argument\\n\" #[[Bracket Comment]] \"Second Argument\")\n"],["body","\n"],["body","Line Comment"],["body","\n"],["body","# This is a line comment.\nmessage(\"First Argument\\n\" # This is a line comment :)\n        \"Second Argument\") # This is a line comment.\n"],["body","\n"],["headingLink","控制流程"],["heading","控制流程"],["body","\n"],["body","条件块"],["body","\n"],["body","if()/elseif()/else()/endif()\n"],["body","\n"],["body","LOOP"],["body","\n"],["body","The foreach()/endforeach() and while()/endwhile() commands delimit code blocks to be executed in a loop. \nInside such blocks the break() command may be used to terminate the loop early whereas the continue() command may be used to start with the next iteration immediately.\n"],["body","\n"],["body","命令定义"],["body","\n"],["body","The macro()/endmacro(), and function()/endfunction() "],["body","\n"],["headingLink","变量"],["heading","变量"],["body","\n\n"],["body","变量是 Cmake的  基本存储单元"],["body","\n"],["body","都是string类型"],["body","\n"],["body","set() and unset()  设置或取消变量"],["body","\n"],["body","变量名大小写敏感,可以包含任何文本"],["body","\n"],["body","变量有作用域  ,set,unset只在当前作用域"],["body","\n\n"],["body","Function Scope"],["body","\n"],["body","function 内部"],["body","\n"],["body","Directory Scope"],["body","\n\n"],["body","整个  CMakeLists.txt文件中,也继承父级 作用域的 变量"],["body","\n\n"],["body","Persistent Cache"],["body","\n"],["body","CMake stores a separate set of “cache” variables, or “cache entries”, whose values persist across multiple runs within a project build tree. Cache entries have an isolated binding scope modified only by explicit request, such as by the CACHE option of the set() and unset() commands."],["body","\n"],["body","Cmake保留命令"],["body","\n"],["body","CMake reserves identifiers that:\nbegin with CMAKE_ (upper-, lower-, or mixed-case), or\nbegin with _CMAKE_ (upper-, lower-, or mixed-case), or\nbegin with _ followed by the name of any\n"],["body","\n"],["body","Environment Variables"],["body","\n"],["body","与普通变量一样,除了以下几点"],["body","\n"],["body","Scope"],["body","\n"],["body","Environment variables have global scope in a CMake process. They are never cached."],["body","\n"],["body","References"],["body","\n"],["body","Variable References have the form $ENV{<variable>}."],["body","\n"],["headingLink","list"],["heading","list"],["body","\n"],["body","尽管所有值 存储为 string, 但在某些场合 也可以当作 list"],["body","\n"],["body","例如在  Unquoted Argument 的解析时, 参数以 ';'分隔"],["body","\n"],["body","数组元素 作为string展示时 以 ';' 连接"],["body","\n"],["body","set(srcs a.c b.c c.c) # sets \"srcs\" to \"a.c;b.c;c.c\"\nset(x a \"b;c\") \n"],["body","\n\n\n\n"],["body","\n\n                    "],["body","\n\n                    \n                \n            \n\n            \n\n        \n\n\n\n\n        \n\n\n\n        \n        \n        \n\n        \n\n\n    \n    \n"]],[["_relative_fp","1.C++/泛型编程.html"],["title","泛型编程 - 各项编程语言"],["body","\n    \n        \n        \n\n        \n        \n\n        \n        \n\n        \n        \n\n        \n\n        \n\n            \n                                \n                \n                    \n                        "],["body","\n                            \n                        "],["body","\n                        "],["body","\n                            \n                        "],["body","\n                        \n                            "],["body","Light"],["body","\n                            "],["body","Rust"],["body","\n                            "],["body","Coal"],["body","\n                            "],["body","Navy"],["body","\n                            "],["body","Ayu"],["body","\n                        \n                    \n\n                    "],["heading","各项编程语言"],["body","\n\n                    \n\n                    \n                \n\n\n                \n                \n\n                \n                    "],["body","\n                        \n\n"],["body","\n"],["body","\n\n"],["headingLink","c中的泛型编程"],["heading","C++中的泛型编程"],["body","\n"],["body","\n"],["body","函数模板是 C++中的泛型编程支持"],["body","\n"],["body","\n"],["headingLink","函数模板函数泛型"],["heading","函数模板（函数泛型）"],["body","\n"],["headingLink","语法"],["heading","语法"],["body","\n"],["body","template <typename T>\nvoid swap(T &a,T &b){\n\tT t = a;\n\ta = b;\n\tb = t;\n}\n\n\ntemplate <typename T，typename T1,typename T2>\n"],["body","\n"],["headingLink","函数模板的应用"],["heading","函数模板的应用"],["body","\n"],["body","自动类型推导调用"],["body","\n"],["body","int a=1;\nint b=2;\nswap(a,b);\n"],["body","\n"],["body","具体类型显示调用"],["body","\n"],["body","float fa =1;\nfloat fb =4;\nswap<float>(fa,fb)\n"],["body","\n"],["headingLink","c函数模板的原理"],["heading","C++函数模板的原理"],["body","\n\n"],["body","编译器从函数模板通过具体类型 产生不通的函数"],["body","\n"],["body","编译器会对函数模板进行两次编译\n\n"],["body","在申明的地方对模板代码本身进行编译"],["body","\n"],["body","在调用的地方对参数替换后的代码进行编译"],["body","\n\n"],["body","\n\n"],["headingLink","函数模板与函数重载冲突"],["heading","函数模板与函数重载冲突"],["body","\n\n"],["body","c++编译器优先考虑普通函数"],["body","\n"],["body","会从 普通函数与 模板函数中 选取一个匹配度更好的"],["body","\n"],["body","可以通过空模板实参列表的语法 限定编译器只通过模板匹配"],["body","\n"],["body","函数模板不能自动类型转换"],["body","\n"],["body","返回值类型不能自动推导\n\n"],["body","不完美的解决方案- 返回值的泛型声明放第一位，其他的就可以让编译器自动推导"],["body","\n\n"],["body","\n\n"],["body","//声明\nint max(int a,int b);\n\ntemplate<typename T>\nT max(T a ,T b){}\n\n//调用\nmax(a,b);//调用普通函数\nMax<>(a,b)//调用模板函数\n\nfloat fa = 3;\nfloat fb = 4;\nmax(fa,fb) //这种情况下，会调用函数模板，因为float到int类型，会导致精度损失\n"],["body","\n"],["headingLink","类模板"],["heading","类模板"],["body","\n"],["headingLink","类模板-1"],["heading","类模板"],["body","\n\n"],["body","提供一种 特殊的类 以相同的行为 处理不同的类型"],["body","\n"],["body","在类申明前 使用 template 进行标识"],["body","\n\n"],["headingLink","语法-1"],["heading","语法"],["body","\n"],["body","template<typename T>\nclass operator{\n\tpublic:\n\t\tT add(T a,T b){\n\t\t\treturn a+b;\n\t\t}\n\t\tT minus(T a,T b){\n\t\t\treturn a-b;\n\t\t}\n}\n"],["body","\n\n"],["body","泛型类型 T 可用于申明成员变量和 成员函数"],["body","\n"],["body","编译器对 类模板的处理方式 和 函数模板相同\n\n"],["body","从类模板 通过具体 类型产生 不通的类"],["body","\n"],["body","编译器在 申明的地方对类模板进行编译"],["body","\n"],["body","编译器 在 使用的地方对泛型替换后的 代码进行编译"],["body","\n\n"],["body","\n\n"],["headingLink","使用"],["heading","使用"],["body","\n"],["body","使用具体类型定义对象"],["body","\n\n"],["body","Operator<int> op1"],["body","\n"],["body","Operator<double> op1"],["body","\n\n"],["body","工程实践中"],["body","\n"],["body","一般会把类模板的定义直接放到头文件中，或者放到 .hpp头文件中，使用的时候 include hpp 文件"],["body","\n"],["headingLink","类模板的特化"],["heading","类模板的特化"],["body","\n"],["body","类模板定义"],["body","\n"],["body","template<typename T>\nclass Test{\n\tT test(T v){\n\t\tcount<<\"T test(T v)\"<<endl;\n\t\tcount<< sizeof(T)<<endl;\n\t}\n}\n"],["body","\n"],["body","类模板特化"],["body","\n"],["body","template<>\nclass Test<int>{\n\tpublic:\n\t\tint test(int v){\n\t\t\tcount<<\"int test(int v)\"<<endl;\n\t\t\tcount<<\"sizeof(int) =\" <<sizeof(int)<<endl;\n\t\t}\n}\n"],["body","\n"],["body","局部特化"],["body","\n"],["body","\n"],["body","编译器会考虑 最具体的 特化模板，如果遇到两个局部特化的模板，则编译器报错"],["body","\n"],["body","\n"],["body","template<typename T1,typename T2>\nclass Test{\n\tpublic void(T1 t1,T2 t2){\n\t\tcount<<t1+t2<<endl;\n\t}\n}\n\n//模板特化，特化的是模板，（更加具体化）\ntemplate<typename T>\nclass Test<T,T>{\n\tpublic void(T t1,T t2){\n\t\tcount<<t1+t2<<endl;\n\t}\n}\n\n//具体类型特化\ntemplate<typename T>\nclass Test<int,T>{\n\tpublic void(int t1,T t2){\n\t\tcount<<t1+t2<<endl;\n\t}\n}\n"],["body","\n"],["headingLink","非类型模板参数"],["heading","非类型模板参数"],["body","\n"],["body","\n"],["body","函数模板和类模板的模板参数可以是普通数值"],["body","\n"],["body","\n\n"],["body","变量不能作为模板参数"],["body","\n"],["body","浮点数和类对象不能作为模板参数"],["body","\n"],["body","全局指针不能作为模板参数"],["body","\n\n"],["headingLink","实例"],["heading","实例"],["body","\n"],["body","//定义\ntemplate<typename T,int N>\nvoid func(){\n\tT array[N] = {0};\n\tfor(int i=0;i<N;i++){\n\t\tarray[i] = i+1;\n\t\tcount<<array[i]<<endl;\n\t}\n}\n//使用\nint main(int argc,char *argv[]){\n    func<int,5>();\n\tfunc<float,10>();\n}\n"],["body","\n"],["headingLink","递归编译"],["heading","递归编译"],["body","\n"],["body","template<int N>\nclass Sum{\n\tpublic: static const int VALUE = Sum<N-1>::VALUE+N;\n}\n\ntemplate<>\nclass Sum<1>{\n\tpublic: static const int VALUE = 1;\n}\n"],["body","\n\n\n\n"],["body","\n\n                    "],["body","\n\n                    \n                \n            \n\n            \n\n        \n\n\n\n\n        \n\n\n\n        \n        \n        \n\n        \n\n\n    \n    \n"]],[["_relative_fp","1.C++/C++面向对象.html"],["title","C++面向对象 - 各项编程语言"],["body","\n    \n        \n        \n\n        \n        \n\n        \n        \n\n        \n        \n\n        \n\n        \n\n            \n                                \n                \n                    \n                        "],["body","\n                            \n                        "],["body","\n                        "],["body","\n                            \n                        "],["body","\n                        \n                            "],["body","Light"],["body","\n                            "],["body","Rust"],["body","\n                            "],["body","Coal"],["body","\n                            "],["body","Navy"],["body","\n                            "],["body","Ayu"],["body","\n                        \n                    \n\n                    "],["heading","各项编程语言"],["body","\n\n                    \n\n                    \n                \n\n\n                \n                \n\n                \n                    "],["body","\n                        \n\n"],["body","\n"],["body","\n\n"],["headingLink","类定义"],["heading","类定义"],["body","\n"],["body","class Test   {\n    private: int i;int j;int k;\n    public: Test(){ i=j=k=0; } //构造函数\n}\n"],["body","\n"],["headingLink","类实现"],["heading","类实现"],["body","\n"],["body","class Array {\nprivate:\n    int length;\n    int *data;\npublic:\n    Array(int length) {\n        std::cout << \"initailizer\"<<std::endl;\n        data = new int[length];\n        this->length = 0;\n    }\n    void setData(int val);\n    int getData(int index);\n};\n\nint Array::getData(int index) {\n    return data[index];\n}\nvoid Array::setData(int val) {\n    data[length++] = val;\n}\n\n"],["body","\n"],["headingLink","无参与拷贝构造"],["heading","无参与拷贝构造"],["body","\n"],["body","//两个特殊的构造函数\n无参构造,跟拷贝构造 :简单的对成员变量进行复制\n// C++默认提供,这两个\n    public:\n        Test(){ printf(\"Test()\\n\")}\n        Test(const Test &obj){ printf(\"Test(const Test &obj)\")}\n//一旦自己写了 以上构造函数之一的话,编译器就会不提供\n"],["body","\n"],["headingLink","成员变量"],["heading","成员变量"],["body","\n\n"],["body","\n"],["body","可以定义静态成员变量和静态成员函数"],["body","\n"],["body","\n"],["body","\n"],["body","静态成员属于整个类,不需要实例化"],["body","\n"],["body","\n"],["body","\n"],["body","可以通过类名直接访问 public 静态成员"],["body","\n"],["body","\n"],["body","\n"],["body","可以通过对象名访问 public 静态成员"],["body","\n"],["body","\n"],["body","\n"],["body","静态成员函数可以直接访问静态成员变量"],["body","\n"],["body","\n"],["body","\n"],["body","使用静态成员"],["body","\n"],["body","1.分配空间在外部 int Test::cI=0;"],["body","\n"],["body","2.使用通过类名: Test::SetI(5)"],["body","\n"],["body","\n"],["body","\n"],["body","从命名空将的角度看,类的静态成员只是类这个命名空间中的全局变量,和全局函数,不同之处是 类可以对静态成员进行访问权限的控制,而命名空间不行"],["body","\n"],["body","\n"],["body","\n"],["body","静态成员会进行 默认初始化 0"],["body","\n"],["body","\n"],["body","\n"],["body","静态成员可以用来统计 该类 实例化了多少个成员变量"],["body","\n"],["body","\n\n"],["headingLink","成员函数与成员变量的空间"],["heading","成员函数与成员变量的空间"],["body","\n\n"],["body","\n"],["body","静态成员变量在全局数据区中存放着,不在类的空间"],["body","\n"],["body","\n"],["body","\n"],["body","普通成员变量:存储与对象中,与 struct 变量有相同的内存布局和直接对齐方式"],["body","\n"],["body","\n"],["body","\n"],["body","成员函数是 存储于代码段中"],["body","\n"],["body","\n"],["body","\n"],["body","C++中的 class 从面向对象理论出发,将变量与函数集定义在一起, 在计算机内部,程序依然由 数据段和代码段组成"],["body","\n"],["body","\n\n"],["headingLink","cclass-内部处理"],["heading","C++Class 内部处理"],["body","\n"],["body","\n"],["body","C++标准库涵盖 C库的功能 <name.h> 头文件对应 C++中的 <cname>"],["body","\n"],["body","C++标准库预定义了多数常用的数据结构"],["body","\n"],["body","bitset deque list map queue set stack vector"],["body","\n"],["headingLink","友元类"],["heading","友元类"],["body","\n"],["body","private声明使得类的成员不能被外部访问,但是通过friend 关键字可以例外的开放权限"],["body","\n"],["headingLink","操作符重载"],["heading","操作符重载"],["body","\n"],["body","什么时候 用全局 ,什么时候 用 成员函数  来 重载操作符"],["body","\n"],["body","Array & Array::operator= (const Array &obj){\n \tdelete [] mspace;\n \tmlength = obj.length;\n \tmspace = new int[mlength];\n \tfor(int i=0;i<mlength;i++){\n \t\tmspace[i] = obj.mspace[i];\n \t}\n}\n\n\n// C++中通过一个占位参数来区分前置运算符和 后置运算\nComplex operator++ (int) // obj++;\n{\n    Complex ret = *this;\n    a++;\n    b++;\n    return ret;\n}\n\nComplex opeator++(){ // ++obj\n    ++a;\n    ++b;\n    return *this;\n}\n\n\n//重载左操作符\nostream& operator<< (ostream&out,const Complex&c){\n    out<<c.a<<\" + \"<<c.b<<\"i\";\n    return out;\n}\n"],["body","\n"],["body","不要重载 && || 操作符 , 因为会 违背 内定义的 短路法则"],["body","\n"],["body","为了支持 链式调用, 返回其自身的引用"],["body","\n\n\n\n"],["body","\n\n                    "],["body","\n\n                    \n                \n            \n\n            \n\n        \n\n\n\n\n        \n\n\n\n        \n        \n        \n\n        \n\n\n    \n    \n"]],[["_relative_fp","6.AppleScript/CommonUse.html"],["title","CommonUse - 各项编程语言"],["body","\n    \n        \n        \n\n        \n        \n\n        \n        \n\n        \n        \n\n        \n\n        \n\n            \n                                \n                \n                    \n                        "],["body","\n                            \n                        "],["body","\n                        "],["body","\n                            \n                        "],["body","\n                        \n                            "],["body","Light"],["body","\n                            "],["body","Rust"],["body","\n                            "],["body","Coal"],["body","\n                            "],["body","Navy"],["body","\n                            "],["body","Ayu"],["body","\n                        \n                    \n\n                    "],["heading","各项编程语言"],["body","\n\n                    \n\n                    \n                \n\n\n                \n                \n\n                \n                    "],["body","\n                        \n\n"],["body","\n"],["body","\n\n"],["body","display notification \"message\" with title \"title\" subtitle \"subtitle\"\n"],["body","\n"],["body","tell application \"Finder\"\n  empty the trash\n  beep\n  -- 打开启动磁盘\n  open the startup disk\nend tell\n"],["body","\n"],["body","launch application \"System Events\"\nlaunch application \"TextEditor\"\ntell application \"System Events\"\n  set frontmost of process \"TextEditor\" to true\n  keystroke \"input string from applescript\"\n  keystroke \"a\" using command down\n  keystroke \"c\" using command down\n  keystroke \"a\" using command down\n  key code 124 using command down\n  keystroke \"\n\"\n  keystroke \"v\" using command down\nend tell\n"],["body","\n"],["body","tell application \"Finder\" to sleep\n"],["body","\n"],["body","\ntell application \"Microsoft Edge\"\n\t\n\topen location \"http://www.baidu.com\"\n\t\n\tactivate\n\t\nend tell\n"],["body","\n"],["body","\n\ntell application \"iTerm\"\n\tlaunch\n\t\n\tdelay 0.1\n\t\n\t\n\trepeat with n from 1 to count of windows\n\t\trepeat with i from 1 to count of tabs of window n\n\t\t\ttell tab i of window n\n\t\t\t\tif name of current session = q then\n\t\t\t\t\tselect\n\t\t\t\t\tactivate\n\t\t\t\t\tname of current session\n\t\t\t\t\treturn\n\t\t\t\tend if\n\t\t\tend tell\n\t\tend repeat\n\tend repeat\n\t\n\t\n\t\n\tcreate tab current window with profile q\n\t\nend tell\n\n\n\n"],["body","\n"],["body","\ntell application \"iTerm\"\n\tlaunch\n\tdelay 0.5\n\t\n\trepeat with n from 1 to count of windows\n\t\trepeat with i from 1 to count of tabs of window n\n\t\t\ttell current session of tab i of window n\n\t\t\t\tif is processing then\n\t\t\t\telse\n\t\t\t\t\tselect\n\t\t\t\t\tactivate\n\t\t\t\t\twrite text \"ls\"\n\t\t\t\t\treturn\n\t\t\t\tend if\n\t\t\tend tell\n\t\tend repeat\n\tend repeat\n\t\n\t\n\ttell current session of (create tab with default profile current window)\n\t\tselect\n\t\tactivate\n\t\twrite text \"ls\"\n\tend tell\n\t\nend tell\n\n\n"],["body","\n"],["body","# 打开 sca-interfaces\n\n# 触发命令\n\n\nscript ITerm\n\ton select_profile(profile_name)\n\t\ttell application \"iTerm\"\n\t  \tlaunch\n\t\t\tdelay 0.1\n      repeat with n from 1 to count of windows\n        repeat with i from 1 to count of tabs of window n\n          tell tab i of window n\n            if name of current session = q then\n              select\n              activate\n              name of current session\n              return\n            end if\n          end tell\n        end repeat\n      end repeat\n\t\t\tcreate tab current window with profile q\n\t\tend tell\n\t end on select_profile\n\nend script\n\n"],["body","\n"],["body","script ITerm\n\ton select_profile in profile_name\n\t\tcreate_window()\n\t\ttell application \"iTerm\"\n\t\t\trepeat with n from 1 to count of windows\n\t\t\t\trepeat with i from 1 to count of tabs of window n\n\t\t\t\t\ttell tab i of window n\n\t\t\t\t\t\tif name of current session = profile_name then\n\t\t\t\t\t\t\tselect\n\t\t\t\t\t\t\tactivate\n\t\t\t\t\t\t\treturn (a reference to current session)\n\t\t\t\t\t\tend if\n\t\t\t\t\tend tell\n\t\t\t\tend repeat\n\t\t\tend repeat\n\t\t\treturn a reference to current session of (create tab current window with profile profile_name)\n\t\tend tell\n\tend select_profile\n\t\n\t\n\ton create_window()\n\t\ttell application \"iTerm\"\n\t\t\tlaunch\n\t\t\tdelay 0.3\n\t\t\tif exists current window then\n\t\t\telse\n\t\t\t\tcreate window with default profile\n\t\t\tend if\n\t\tend tell\n\tend create_window\n\t\n\t\n\ton run_cmd(cmdStr)\n\t\tselect_profile of \"scainter\"\n\tend run_cmd\nend script\ntell ITerm to run_cmd(\"ls\")\n\n"],["body","\n"],["body","script ITerm\n\ton select_profile given profile_name:profile_name, cmd:cmdStr : \"\"\n\t\tcreate_window()\n\t\ttell application \"iTerm\"\n\t\t\trepeat with n from 1 to count of windows\n\t\t\t\trepeat with i from 1 to count of tabs of window n\n\t\t\t\t\ttell tab i of window n\n\t\t\t\t\t\tif name of current session = profile_name then\n\t\t\t\t\t\t\tselect\n\t\t\t\t\t\t\tactivate\n\t\t\t\t\t\t\tif cmdStr = \"\" then\n\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t\twrite current session text cmdStr\n\t\t\t\t\t\t\tend if\n\t\t\t\t\t\t\treturn (a reference to current session)\n\t\t\t\t\t\tend if\n\t\t\t\t\tend tell\n\t\t\t\tend repeat\n\t\t\tend repeat\n\t\t\ttell current session of (create tab current window with profile profile_name)\n\t\t\t\tif cmdStr = \"\" then\n\t\t\t\telse\n\t\t\t\t\twrite text cmdStr\n\t\t\t\tend if\n\t\t\tend tell\n\t\tend tell\n\tend select_profile\n\t\n\t\n\ton create_window()\n\t\ttell application \"iTerm\"\n\t\t\tlaunch\n\t\t\tdelay 0.3\n\t\t\tif exists current window then\n\t\t\telse\n\t\t\t\tcreate window with default profile\n\t\t\tend if\n\t\tend tell\n\tend create_window\n\t\n\t\n\ton run_cmd(cmdStr)\n\t\tselect_profile given profile_name:\"scainter\", cmd:cmdStr\n\tend run_cmd\n\t\n\t\n\ton run_arthas(class_name)\n\t\trun_cmd(\"cd /Users/weisanju/gitrepo/sca-interfaces/python && fab arthas.retransform -p \" & class_name)\n\tend run_arthas\nend script\n\n\n"],["body","\n\n\n\n"],["body","\n\n                    "],["body","\n\n                    \n                \n            \n\n            \n\n        \n\n\n\n\n        \n\n\n\n        \n        \n        \n\n        \n\n\n    \n    \n"]],[["_relative_fp","6.AppleScript/3.VariablesAndProperties/2.DeclaringVariables.html"],["title","DeclaringVariables - 各项编程语言"],["body","\n    \n        \n        \n\n        \n        \n\n        \n        \n\n        \n        \n\n        \n\n        \n\n            \n                                \n                \n                    \n                        "],["body","\n                            \n                        "],["body","\n                        "],["body","\n                            \n                        "],["body","\n                        \n                            "],["body","Light"],["body","\n                            "],["body","Rust"],["body","\n                            "],["body","Coal"],["body","\n                            "],["body","Navy"],["body","\n                            "],["body","Ayu"],["body","\n                        \n                    \n\n                    "],["heading","各项编程语言"],["body","\n\n                    \n\n                    \n                \n\n\n                \n                \n\n                \n                    "],["body","\n                        \n\n"],["body","\n"],["body","\n\n"],["headingLink","declaring-variables"],["heading","Declaring Variables"],["body","\n\n"],["body","\n"],["body","Variable names follow the rules described in Identifiers."],["body","\n"],["body","\n"],["body","\n"],["body","要在AppleScript中创建变量，您可以使用 'copy' 或 'set' 命令为其分配一个值。"],["body","\n"],["body","\n"],["body","\n"],["body","For example, the following statements create and initialize two variables, one named circumference and one named savedResult:"],["body","\n\n"],["body","\n"],["body","set circumference to pi * 3.5 --result: 10.995574287564\ncopy circumference to savedResult --result: 10.995574287564 (copy of 1st variable)\n"],["body","\n"],["body","\n\n"],["body","\n"],["body","\n"],["body","如该示例所示，变量赋值可以使用先前定义的变量：它还可以利用在同一个 'script' 对象中声明的属性。"],["body","\n\n"],["body","使用 copy 和 set 创建变量有一些明显的差异，也有一些更微妙的差异-有关更多信息，请参见 [使用复制和设置命令](https://developer.apple.com/library/archive/documentation/AppleScript/Conceptual/AppleScriptLangGuide/conceptual/ASLR_variables.html # // apple_ref/doc/uid/TP40000983-CH223-SW7)。"],["body","\n"],["body","如果为已经在使用的变量分配新值，它将替换旧值。您可以分配一个简单值、一个表达式或一个对象说明符-计算表达式并解析对象说明符以获得要分配的值。"],["body","\n"],["body","要创建一个变量，其值是对象说明符本身，而不是指定对象的值，请使用 a reference to 运算符。"],["body","\n\n"],["body","\n\n"],["body","接下来的两节将描述如何显式定义  local or a global variable"],["body","\n\n"],["body","\n"],["body","这些变量类型主要在其范围上有所不同"],["body","\n"],["body","\n"],["body","\n"],["body","Scope, which refers to where a variable is accessible within a script, is described in detail in Scope of Variables and Properties."],["body","\n"],["body","\n\n"],["headingLink","local-variables"],["heading","Local Variables"],["body","\n"],["body","You can declare explicit local variables using the following syntax:"],["body","\n"],["body","您可以使用以下语法声明显式 “本地” 变量:"],["body","\n"],["body","local variableName [, variableName ]…\n"],["body","\n"],["body","The following are examples of valid local variable declarations:"],["body","\n"],["body","local windowCount -- defines one variable\nlocal agentName, agentNumber, agentHireDate -- defines three variables\n"],["body","\n"],["body","您不能在其声明中为 “本地” 变量分配初始值，也不能为该变量声明类。"],["body","\n"],["body","相反，您使用 'copy' 或 'set' 命令初始化变量并设置其类。例如:"],["body","\n"],["body","set windowCount to 0 -- initialize to zero; an integer\nset agentName to \"James Smith\" -- assign agent name; a text string\nset agentNumber to getAgentNumber(agentName) -- call handler; an integer\ncopy current date to agentHireDate -- call current date command; a date\n"],["body","\n"],["headingLink","global-variables"],["heading","Global Variables"],["body","\n"],["body","global 变量的语法与本地 变量的语法几乎相同:"],["body","\n"],["body","global variableName [, variableName ]…\n"],["body","\n"],["body","The following are examples of valid global variable declarations:"],["body","\n"],["body","global gAgentCount\nglobal gStatementDate, gNextAgentNumber\n"],["body","\n"],["body","As with local variables, you use the copy or set command to initialize global variables and set their class types. For example:"],["body","\n"],["body","set gAgentCount to getCurrentAgentCount() -- call handler to get count\nset gStatementDate to current date -- get date from current date command\nset gNextAgentNumber to getNextAvailNumber() -- call handler to get number\n"],["body","\n"],["headingLink","using-the-copy-and-set-commands"],["heading","Using the copy and set Commands"],["body","\n\n"],["body","\n"],["body","顾名思义，当您使用 copy 命令创建变量时，它总是创建一个单独的副本 (尽管请注意，对象说明符的副本仍指定相同的对象)"],["body","\n"],["body","\n"],["body","\n"],["body","但是，当您使用 'set' 命令创建变量时，新变量始终引用原始对象或值。"],["body","\n"],["body","\n"],["body","\n"],["body","您本质上已经为同一对象创建了另一个名称。"],["body","\n"],["body","\n"],["body","\n"],["body","当多个变量引用一个可变 (或可变) 对象时，可以通过任何变量观察到该对象的更改。AppleScript对象的类型是  date, list, record, and script objects."],["body","\n"],["body","\n"],["body","\n"],["body","对于无法修改的对象 (不可变对象)，使用 'set' 命令创建的变量可能看起来像副本-无法更改变量指向的对象，因此它们似乎是独立的。这将在下一节创建变量 'myName' 和 'yourName' 的示例中进行演示。"],["body","\n"],["body","\n\n"],["headingLink","declaring-variables-with-the-set-command"],["heading","Declaring Variables with the set Command"],["body","\n"],["body","您可以使用 'set' 命令将变量设置为任何类型的对象。如果变量不存在，则创建它; 如果存在，则替换其当前值:"],["body","\n"],["body","set numClowns to 5 --result: 5\nset myList to { 1, 2, \"four\" } --result: {1, 2, \"four\"}\ntell application \"TextEdit\"\n  set word1 to word 1 of front document --result: some word\nend tell\n"],["body","\n"],["body","下面的示例使用一个可变对象。它创建两个引用同一列表的变量，然后通过其中一个变量修改列表:"],["body","\n"],["body","set myList to { 1, 2, 3 }\nset yourList to myList\nset item 1 of myList to 4\n"],["body","\n"],["body","执行这些语句后，语句 'item 1 of myList' 和 'item 1 of yourList' 都会产生 '4'，因为两个变量都引用了同一个列表。"],["body","\n"],["body","现在假设你正在使用一个不可变的对象，比如一个 'text' 对象:"],["body","\n"],["body","`set myName to \"Sheila\"`\n`set yourName to myName`\n"],["body","\n"],["body","两个变量都引用相同的 'text' 对象，但是 'text' 对象不是可变的，因此无法更改值 'myName' 以使其影响 'yourName' 的值。(如果将新文本分配给其中一个变量，则只是创建一个新的单独的 “文本” 对象。)"],["body","\n\n"],["body","\n"],["body","'set' 命令可以使用模式一次分配几个变量，该模式可能是列表或记录"],["body","\n"],["body","\n"],["body","\n"],["body","一侧的变量列表或记录，另一侧的值列表或记录，值根据变量在列表中的位置与变量匹配，或者根据record的key"],["body","\n"],["body","\n"],["body","\n"],["body","没有足够的值是一个错误，如果值太多，则忽略多余的值。"],["body","\n"],["body","\n"],["body","\n"],["body","评估值和分配变量的顺序是未指定的，但是在进行任何赋值之前对所有值进行评估。"],["body","\n"],["body","\n\n"],["body","The Examples section of the set command shows some simple pattern assignments. Here is an example with more complex patterns:"],["body","\n"],["body","'set' 命令的example部分显示了一些简单的模式分配。这里是一个更复杂的模式的例子:"],["body","\n"],["body","set x to {8, 94133, {firstName:\"John\", lastName:\"Chapman\"}}\nset {p, q, r} to x\n(* now p, q, and r have these values:\np = 8\nq = 94133\nr = {firstName:\"John\", lastName:\"Chapman\"}  *)\nset {p, q, {lastName:r}} to x\n(* now p, q, and r have these values: \np = 8\nq = 94133\nr = \"Chapman\" *)\n"],["body","\n\n"],["body","\n"],["body","在上面最后的赋值语句中，{lastName:r} 是一个以前在脚本中没有使用过的记录，并且包含一个带有标签 lastName 和值 'r' (一个先前定义的变量) 的项目。"],["body","\n"],["body","\n"],["body","\n"],["body","The variable x has previously been set to have a record that has an item with label lastName and value \"Chapman\". During the assignment, the value of the item labeled lastName in the new record is set to the value of the item labeled lastName in x—hence it now has the value \"Chapman\"."],["body","\n"],["body","\n"],["body","\n"],["body","先前已将变量 'x' 设置为具有带有标签 'lastName' 和值 Chapmanterms的记录。在分配过程中，新记录中标记为 “lastname” 的项目的值设置为 “x” 中标记为 “lastname” 的项目的值- 因此，它现在具有值 “Chapman” ”。"],["body","\n"],["body","\n"],["body","\n"],["body","As this example demonstrates, the properties of a record need not be given in the same order and need not all be used when you set a pattern to a pattern, as long as the patterns match. For details, see the set command"],["body","\n"],["body","\n"],["body","\n"],["body","如该示例所示，记录的属性不需要以相同的顺序给出，并且在将模式设置为另一个模式时不需要全部使用，只要模式匹配即可。有关详细信息，请参见 “设置” 命令."],["body","\n"],["body","\n\n"],["body","Note: Using patterns with the set command is similar to using patterned parameters with handlers, which is described in Handlers with Patterned Positional Parameters."],["body","\n"],["headingLink","declaring-variables-with-the-copy-command"],["heading","Declaring Variables with the copy Command"],["body","\n\n"],["body","\n"],["body","您可以使用 'copy' 命令将变量设置为任何类型的对象。"],["body","\n"],["body","\n"],["body","\n"],["body","如果变量不存在，则创建它; 如果存在，则替换其当前值。"],["body","\n"],["body","\n"],["body","\n"],["body","copy 命令创建一个独立于原始副本的新副本-后续更改不会更改原始值 (尽管请注意，对象说明符的副本仍指定相同的对象)。"],["body","\n"],["body","\n"],["body","\n"],["body","要在应用程序中复制，您应该使用应用程序的 “duplicate” 命令，如果它有一个"],["body","\n"],["body","\n"],["body","\n"],["body","要在应用程序之间复制，可以使用 'get' 命令从一个应用程序获取信息，并使用 'set' 命令将其设置在另一个应用程序中。"],["body","\n"],["body","\n"],["body","\n"],["body","'copy' 命令创建一个深度副本-也就是说，如果复制一个嵌套的数据结构，例如包含另一个列表的列表，整个结构将被复制，如下面的示例所示。"],["body","\n"],["body","\n"],["body","\n"],["body","此示例创建一个记录 ('alpha')，然后是一个列表 ('beta')，然后是一个包含第一个记录和列表 ('gamma') 的列表，最后是一个 'gamma' ('delta') 的副本。"],["body","\n"],["body","\n"],["body","\n"],["body","然后更改原始记录 “alpha” 中的属性。结果显示，属性在出现 'alpha' 的地方被更改，除了在副本，'delta':"],["body","\n"],["body","\n\n"],["body","It then changes a property in the original record, alpha. The result shows that the property is changed wherever alpha appears, except in the copy, delta:"],["body","\n"],["body","set alpha to {property1:10, property2:20}\nset beta to {1, 2, \"Hello\"}\nset gamma to {alpha, beta, \"Goodbye\"}\ncopy gamma to delta\nset property1 of alpha to 42\n{alpha, beta, gamma, delta}  -- List variables to show contents\n(*result: {{property1:42, property2:20}, {1, 2, \"Hello\"}, {{property1:42, property2:20}, {1, 2, \"Hello\"}, \"Goodbye\"}, {{property1:10, property2:20}, {1, 2, \"Hello\"}, \"Goodbye\"}} *)\n"],["body","\n"],["body","如果您复制 “引用” 对象，它将引用与原始对象相同的对象 (因为两者都包含相同的对象说明符):"],["body","\n"],["body","set windowRef to a reference to window 1 of application \"Finder\"\nname of windowRef --result: \"Script testing folder\"\ncopy windowRef to currentWindowRef --result: a new object specifier\nname of currentWindowRef --result: \"Script testing folder\"\n"],["body","\n\n\n\n"],["body","\n\n                    "],["body","\n\n                    \n                \n            \n\n            \n\n        \n\n\n\n\n        \n\n\n\n        \n        \n        \n\n        \n\n\n    \n    \n"]],[["_relative_fp","6.AppleScript/3.VariablesAndProperties/index.html"],["title","3.VariablesAndProperties - 各项编程语言"],["body","\n    \n        \n        \n\n        \n        \n\n        \n        \n\n        \n        \n\n        \n\n        \n\n            \n                                \n                \n                    \n                        "],["body","\n                            \n                        "],["body","\n                        "],["body","\n                            \n                        "],["body","\n                        \n                            "],["body","Light"],["body","\n                            "],["body","Rust"],["body","\n                            "],["body","Coal"],["body","\n                            "],["body","Navy"],["body","\n                            "],["body","Ayu"],["body","\n                        \n                    \n\n                    "],["heading","各项编程语言"],["body","\n\n                    \n\n                    \n                \n\n\n                \n                \n\n                \n                    "],["body","\n                        \n\n"],["body","\n"],["body","\n\n"],["headingLink","variables-and-properties"],["heading","Variables and Properties"],["body","\n\n"],["body","变量和属性在本文档的前几章中进行了介绍。"],["body","\n"],["body","您可以在script对象中使用它们来存储和操作值。"],["body","\n\n"],["body","Important: In reading this chapter, you should be familiar with the information on implicit and explicit run handlers in run Handlers."],["body","\n"],["body","以下各节介绍了使用变量和属性时的常见问题, 包括如何声明它们以及AppleScript如何在脚本中解释它们的作用域:"],["body","\n\n"],["body","Defining Properties"],["body","\n"],["body","Declaring Variables"],["body","\n"],["body","Scope of Variables and Properties"],["body","\n\n\n\n\n"],["body","\n\n                    "],["body","\n\n                    \n                \n            \n\n            \n\n        \n\n\n\n\n        \n\n\n\n        \n        \n        \n\n        \n\n\n    \n    \n"]],[["_relative_fp","6.AppleScript/3.VariablesAndProperties/3.ScopeOfVariablesAndProperties.html"],["title","ScopeOfVariablesAndProperties - 各项编程语言"],["body","\n    \n        \n        \n\n        \n        \n\n        \n        \n\n        \n        \n\n        \n\n        \n\n            \n                                \n                \n                    \n                        "],["body","\n                            \n                        "],["body","\n                        "],["body","\n                            \n                        "],["body","\n                        \n                            "],["body","Light"],["body","\n                            "],["body","Rust"],["body","\n                            "],["body","Coal"],["body","\n                            "],["body","Navy"],["body","\n                            "],["body","Ayu"],["body","\n                        \n                    \n\n                    "],["heading","各项编程语言"],["body","\n\n                    \n\n                    \n                \n\n\n                \n                \n\n                \n                    "],["body","\n                        \n\n"],["body","\n"],["body","\n\n"],["headingLink","scope-of-variables-and-properties"],["heading","Scope of Variables and Properties"],["body","\n\n"],["body","\n"],["body","变量或属性标识符的声明是标识符在 script 对象中的第一个有效出现。"],["body","\n"],["body","\n"],["body","\n"],["body","声明的形式和位置决定了AppleScript如何处理该 script 对象中的标识符。"],["body","\n"],["body","\n"],["body","\n"],["body","scope 是AppleScript识别 script 对象中已声明的标识符的范围。"],["body","\n"],["body","\n"],["body","\n"],["body","变量的作用域取决于您在哪里声明它，以及您是将其声明为 “全局” 还是 “本地”。"],["body","\n"],["body","\n"],["body","\n"],["body","声明属性后，仅当您首先将其声明为 “本地” 变量时，才可以将相同的标识符重用为单独的变量。"],["body","\n"],["body","\n"],["body","\n"],["body","生存期 是指变量或属性存在的时间段。脚本运行后，只有属性和 “全局” 变量的值才能保留。"],["body","\n"],["body","\n\n"],["body","在随后的讨论中，出现在任何处理程序或嵌套的 script 对象外部的 script 对象中的声明和语句被标识为 外部。"],["body","\n"],["body","以下示例显示了在AppleScript中声明变量和属性的四种基本形式:"],["body","\n\n"],["body","\n"],["body","property x: 3"],["body","\n\n"],["body","属性定义的范围是声明它的 'script' 对象，包括任何处理程序或嵌套的 'script' 对象"],["body","\n"],["body","属性定义指定初始值。您不能在 hander 中声明属性。"],["body","\n"],["body","每次运行脚本时，不会重置由属性定义设置的值; 相反，它一直持续到脚本重新编译为止。"],["body","\n\n"],["body","\n"],["body","\n"],["body","global x"],["body","\n\n"],["body","global 变量的范围可以限于特定的 handler 或包含的 script 对象，也可以扩展到整个顶级 script 对象"],["body","\n"],["body","全局 声明未设置初始值-必须先通过 Copy 或 Set 命令对其进行初始化，然后脚本才能访问其值。"],["body","\n"],["body","每次运行脚本时，不会重置 “全局” 变量的值，除非执行其初始化语句。"],["body","\n\n"],["body","\n"],["body","\n"],["body","local x"],["body","\n\n"],["body","\n"],["body","local 变量的范围可以限于特定的 handler 或包含的 script 对象，也可以扩展到整个顶级 script 对象。"],["body","\n"],["body","\n"],["body","\n"],["body","local 声明未设置初始值-必须先通过 “复制” 或 “设置” 命令对其进行初始化，然后脚本才能访问其值。"],["body","\n"],["body","\n"],["body","\n"],["body","每次运行 handler 时，都会重置 loclal 变量的值 (脚本的 run  handler 或声明变量的特定handler)。"],["body","\n"],["body","\n\n"],["body","\n"],["body","\n"],["body","set x to 3"],["body","\n\n"],["body","在没有 global 变量声明的情况下，使用 copy 或 set 命令声明的变量的范围通常限于脚本的 run handler，使其隐式的对于 该运行处理程序 local"],["body","\n"],["body","但是，handler 或嵌套脚本对象可以使用 global 声明相同的变量以获取对其的访问权限。"],["body","\n"],["body","每次运行脚本时，都会重置使用 'copy' 或 'set' 命令声明的变量的值。"],["body","\n\n"],["body","\n\n"],["body","如果要在脚本中的多个不同位置使用相同的标识符，则应将其声明为属性或 “全局” 变量。"],["body","\n\n"],["body","将特定标识符的范围限制为单个 handler 或嵌套的 “脚本” 对象通常很方便，您可以通过将其定义为 handler 或 script 对象中的 local 变量来实现。"],["body","\n"],["body","在外部，标识符没有与其关联的值，可以在脚本中的其他地方重用。以这种方式使用时，local 变量被称为 shadow (或阻止访问) 具有相同名称的 global 变量或属性，从而使全局版本在处理程序或 “脚本” 对象的范围内无法访问，"],["body","\n\n"],["body","Note: 如果将脚本保存为脚本应用程序，然后在只读介质上运行该应用程序，则不会保存修改后的属性或 “全局” 变量的值。"],["body","\n"],["body","以下部分提供了有关范围的其他信息:"],["body","\n\n"],["body","Scope of Properties and Variables Declared in a Script Object"],["body","\n"],["body","Scope of Variables Declared in a Handler"],["body","\n\n"],["headingLink","scope-of-properties-and-variables-declared-in-a-script-object"],["heading","Scope of Properties and Variables Declared in a Script Object"],["body","\n"],["body","Table 3-1 shows the scope and lifetime for variables and properties that are declared at the top level in a script object (outside any handlers or nested script objects)."],["body","\n"],["body","以下表格显示了在 script 对象 (在任何handler 或嵌套的 script 对象之外) 顶层声明的变量和属性的作用域和生存期。"],["body","\n"],["body","Declaration type"],["body","Scope (visibility)"],["body","Lifetime"],["body","\n"],["body","property x: 3"],["body","Everywhere in script"],["body","Reset when script is recompiled"],["body","\n"],["body","global x"],["body","Everywhere in script"],["body","Reset when reinitialized in script or when script is recompiled"],["body","\n"],["body","local x"],["body","Within run handler only"],["body","Reset when script is run"],["body","\n"],["body","set x to 3"],["body","Within run handler only"],["body","Reset when script is run"],["body","\n\n\n"],["body","The scope of a property in a script object extends to any subsequent statements anywhere in the script. Consider the following example:"],["body","\n"],["body","脚本 对象中属性的范围扩展到脚本中的任何后续语句。考虑以下示例:"],["body","\n"],["body","property currentCount : 0\nincrement()\non increment()\n   set currentCount to currentCount + 1\n   display dialog \"Count is now \" & currentCount  & \".\"\nend increment\n"],["body","\n"],["body","当它在此脚本中的任何位置遇到标识符 currentCount 时，AppleScript将其与 currentCount 属性关联。"],["body","\n"],["body","属性的值在其中定义属性的脚本运行后持续存在"],["body","\n"],["body","属性的当前值与 script 对象一起保存，并且在重新编译脚本之前不会重置为0-即，修改并再次运行，保存或检查语法。"],["body","\n"],["body","global 变量的值在其中定义的脚本运行后也会持续存在"],["body","\n"],["body","但是，根据初始化方式，每次再次运行脚本时可能会重置 “全局” 变量"],["body","\n"],["body","下一个示例演示如何初始化全局变量，以便仅在第一次运行脚本时才对其进行初始化，从而产生与使用上一示例中的属性相同的结果:"],["body","\n"],["body","global currentCount\nincrement()\non increment()\n  try\n      set currentCount to currentCount + 1\n      on error\n        set currentCount to 1\n  end try\n\n\n  display dialog \"Count is now \" & currentCount  & \".\"\n\nend increment\n"],["body","\n"],["body","如果不想持久化全局变量。则使用set赋值"],["body","\n"],["body","global currentCount\nset currentCount to 0\non increment()\n set currentCount to currentCount + 1\n end increment\n \n increment() --result: 1\n increment() --result: 2\n"],["body","\n"],["body","在没有 “全局” 变量声明的情况下，使用 “set” 命令的变量声明的范围通常限于脚本的 run  handler 。例如，此脚本声明两个单独的 'currentCount' 变量:"],["body","\n"],["body","on increment()\n\tset currentCount to 10\n\tset currentCount to 5\nend increment\n\nincrement() --result: 5\ncurrentCount --result: 10\n"],["body","\n\n"],["body","\n"],["body","第一个 currentCount 变量声明的范围仅限于脚本的 run handler。"],["body","\n"],["body","\n"],["body","\n"],["body","由于此脚本没有显式的 run handler，因此外部语句是其隐式 run handler 的一部分，如 [run hander](https://developer.apple.com/library/archive/documentation/AppleScript/Conceptual/AppleScriptLangGuide/conceptual/ASLR_about_handlers.html # // apple_ref/doc/uid/TP40000983-CH206-SW15) 中所述。"],["body","\n"],["body","\n"],["body","\n"],["body","第二个  currentCount 声明的变量的作用域 在 on increment handler之内，AppleScript独立跟踪每个变量。"],["body","\n"],["body","\n"],["body","\n"],["body","要将handler 中的变量与在handler 外部用 'set' 命令声明的相同变量相关联，可以在处理程序中使用 'global' 声明，如下一个示例所示。(这种方法还可以在嵌套的 'script' 对象中关联变量。)"],["body","\n"],["body","\n"],["body","\n"],["body","set currentCount to 0\non increment()\n global currentCount\n set currentCount to currentCount + 1\nend increment\n\nincrement() --result: 1\ncurrentCount --result: 1\n"],["body","\n"],["body","\n\n"],["body","要将变量的上下文限制为脚本的 run handler，而不考虑后续的 global 声明，必须将其明确声明为 “本地” 变量，如以下示例所示:"],["body","\n"],["body","local currentCount\nset currentCount to 10\non increment()\nglobal currentCount\nset currentCount to currentCount + 2\nend increment\nincrement() --error: \"The variable currentCount is not defined\"\n"],["body","\n"],["body","因为此示例中的 'currentCount' 变量被声明为脚本的本地变量，因此，对于其隐式的 run handler，任何随后尝试将相同的变量声明为 “全局” 都会导致错误。"],["body","\n"],["body","如果使用 set 命令声明外部变量，然后声明与属性相同的标识符，则使用 set 命令的声明将覆盖属性定义。"],["body","\n"],["body","例如，下面的脚本返回10，而不是5。发生这种情况是因为AppleScript在评估 'set' 命令声明之前先评估属性定义:"],["body","\n"],["body","set numClowns to 10 -- evaluated after property definition\nproperty numClowns: 5 -- evaluated first\nnumClowns --result: 10\n"],["body","\n"],["body","下一个示例显示如何在 “脚本” 对象中使用 “全局” 变量声明，将 “全局” 变量与外部属性相关联:"],["body","\n"],["body","property currentCount : 0\nscript Paula\n\tproperty currentCount : 20\n  script Joe\n    global currentCount\n    on increment()\n      set currentCount to currentCount + 1\n      return currentCount、\n    end increment\n  end script\n\ttell Joe to increment()\nend script\nrun Paula --result: 1\nrun Paula --result: 2\ncurrentCount --result: 2\ncurrentCount of Paula --result: 20\n"],["body","\n"],["body","此脚本声明两个单独的 currentcount 属性"],["body","\n\n"],["body","one outside any handlers (and script objects) in the main script "],["body","\n"],["body","and one in the script object Paula but outside of any handlers or script objects within Paula. "],["body","\n\n"],["body","Because the script Joe declares the global variable currentCount, AppleScript looks for currentCount at the top level of the script, thus treating Joe’s currentCount and currentCount at the top level of the script as the same variable."],["body","\n"],["headingLink","scope-of-variables-declared-in-a-handler"],["heading","Scope of Variables Declared in a Handler"],["body","\n\n"],["body","handler 不能声明属性，尽管它可以引用在 script 对象中的任何handler 之外声明的属性"],["body","\n"],["body","(一个handler 可以包含脚本对象，但它不能包含另一个handler，除了在一个包含的脚本对象中。)"],["body","\n\n"],["body","下图总结了在 handler 中声明的变量的范围。每种声明形式的示例如下。"],["body","\n"],["body","Declaration type"],["body","Scope (visibility)"],["body","Lifetime"],["body","\n"],["body","global x"],["body","Within handler only"],["body","Reset when script is recompiled; if initialized in handler, then reset when handler is run"],["body","\n"],["body","local x"],["body","Within handler only"],["body","Reset when handler is run"],["body","\n"],["body","set x to 3"],["body","Within handler only"],["body","Reset when handler is run"],["body","\n\n\n"],["body","在handler 中声明的global 变量的作用域仅限于该 handler，尽管当AppleScript试图定位同一变量的较早出现时，它看起来超出了handler。下面是一个例子:"],["body","\n"],["body","set currentCount to 10\n  on increment()\n    global currentCount\n    set currentCount to currentCount + 2\n  end increment\nincrement() --result: 12\ncurrentCount --result: 12\n"],["body","\n"],["body","当AppleScript在 on increment 处理程序中遇到 currentCount 变量时，它不会将其对先前出现的事件的搜索限制为该handler，而是一直寻找直到找到任何handler 之外的声明。"],["body","\n"],["body","但是，在脚本中的任何后续处理程序中使用 currentCount 对该处理程序都是本地的，除非该处理程序还明确声明 'currentCount' 为 'global' 变量。"],["body","\n"],["body","handler中的 本地 变量声明的范围仅限于该handler，即使相同的标识符已被声明为handler之外的属性:"],["body","\n"],["body","property currentCount : 10\n  on increment()\n   local currentCount\n   set currentCount to 5\n  end increment\nincrement() --result: 5\ncurrentCount --result: 10\n"],["body","\n"],["body","在处理程序中使用 set 命令的变量声明的范围仅限于该handler:"],["body","\n"],["body","script Henry\n set currentCount to 10 -- implicit local variable in script object\n on increment()\n   set currentCount to 5-- implicit local variable in handler\n end increment\n return currentCount\nend script\n\ntell Henry to increment() --result: 5\nrun Henry --result: 10\n"],["body","\n"],["body","script 对象 Henry 中的第一个 currentCount 变量的第一个声明的范围仅限于 script 对象的 run handler  (在这种情况下，是隐式的 'run' 处理程序，由脚本中的最后两个语句组成)。在 increment  handler 中，第二个 currentcount 声明的范围仅限于该handler。“Currentcount” 的两个实例是变量。"],["body","\n\n\n\n"],["body","\n\n                    "],["body","\n\n                    \n                \n            \n\n            \n\n        \n\n\n\n\n        \n\n\n\n        \n        \n        \n\n        \n\n\n    \n    \n"]],[["_relative_fp","6.AppleScript/3.VariablesAndProperties/1.DefiningProperties.html"],["title","DefiningProperties - 各项编程语言"],["body","\n    \n        \n        \n\n        \n        \n\n        \n        \n\n        \n        \n\n        \n\n        \n\n            \n                                \n                \n                    \n                        "],["body","\n                            \n                        "],["body","\n                        "],["body","\n                            \n                        "],["body","\n                        \n                            "],["body","Light"],["body","\n                            "],["body","Rust"],["body","\n                            "],["body","Coal"],["body","\n                            "],["body","Navy"],["body","\n                            "],["body","Ayu"],["body","\n                        \n                    \n\n                    "],["heading","各项编程语言"],["body","\n\n                    \n\n                    \n                \n\n\n                \n                \n\n                \n                    "],["body","\n                        \n\n"],["body","\n"],["body","\n\n"],["headingLink","defining-properties"],["heading","Defining Properties"],["body","\n\n"],["body","\n"],["body","Property labels follow the rules described in Identifiers."],["body","\n"],["body","\n"],["body","\n"],["body","Property definitions use the following syntax:"],["body","\n"],["body","\n\n"],["body","​\tproperty  propertyLabel:expression"],["body","\n\n"],["body","\n"],["body","propertyLabel: An identifier."],["body","\n"],["body","\n"],["body","\n"],["body","expression"],["body","\n"],["body","设置属性初始值的AppleScript表达式。属性定义在变量赋值之前进行评估，因此属性定义不能包含变量。"],["body","\n"],["body","\n\n"],["body","以下是有效属性定义的示例:"],["body","\n"],["body","property windowCount : 0\nproperty defaultName : \"Barry\"\nproperty strangeValue : (pi * 7)^2\n"],["body","\n\n"],["body","定义属性后，可以使用 'copy' 或 'set' 命令更改其值。"],["body","\n"],["body","每次运行脚本时，不会重置由属性定义设置的值"],["body","\n"],["body","相反，它一直持续到脚本重新编译。"],["body","\n"],["body","您不能在 handler 中声明属性，但是 handler 可以访问  其包含 “script” 对象中定义的属性。"],["body","\n\n\n\n\n"],["body","\n\n                    "],["body","\n\n                    \n                \n            \n\n            \n\n        \n\n\n\n\n        \n\n\n\n        \n        \n        \n\n        \n\n\n    \n    \n"]],[["_relative_fp","6.AppleScript/8.ReferenceForms/2.Every.html"],["title","Every - 各项编程语言"],["body","\n    \n        \n        \n\n        \n        \n\n        \n        \n\n        \n        \n\n        \n\n        \n\n            \n                                \n                \n                    \n                        "],["body","\n                            \n                        "],["body","\n                        "],["body","\n                            \n                        "],["body","\n                        \n                            "],["body","Light"],["body","\n                            "],["body","Rust"],["body","\n                            "],["body","Coal"],["body","\n                            "],["body","Navy"],["body","\n                            "],["body","Ayu"],["body","\n                        \n                    \n\n                    "],["heading","各项编程语言"],["body","\n\n                    \n\n                    \n                \n\n\n                \n                \n\n                \n                    "],["body","\n                        \n\n"],["body","\n"],["body","\n\n"],["headingLink","every"],["heading","Every"],["body","\n"],["body","指定容器中特定类的每个对象。"],["body","\n"],["headingLink","syntax"],["heading","Syntax"],["body","\n"],["body","every  *class*  *pluralClass*\n"],["body","\n"],["headingLink","placeholders"],["heading","Placeholders"],["body","\n\n"],["body","\n"],["body","class"],["body","\n"],["body","A singular class (such as word or paragraph)."],["body","\n"],["body","\n"],["body","\n"],["body","pluralClass"],["body","\n"],["body","The plural form for a class (such as words or paragraphs)."],["body","\n"],["body","\n\n"],["headingLink","value"],["heading","Value"],["body","\n\n"],["body","\n"],["body","every 对象说明符的值是容器中对象的列表"],["body","\n"],["body","\n"],["body","\n"],["body","如果容器不包含指定类的任何对象，则列表为空列表: {}. "],["body","\n"],["body","\n"],["body","\n"],["body","例如，表达式的值 every word of {1, 2, 3} is the empty list {}."],["body","\n"],["body","\n\n"],["headingLink","examples"],["heading","Examples"],["body","\n"],["body","下面的示例使用 every 对象说明符来指定文本字符串中包含的每个单词:"],["body","\n"],["body","set myText to \"That's all, folks\"\nevery word of myText --result: {\"That's\", \"all\", \"folks\"} (a list of three words)\n"],["body","\n"],["body","The following object specifier specifies the same list:"],["body","\n"],["body","words of myText\n"],["body","\n"],["body","以下示例指定了启动盘 (引导分区) 的Users文件夹中所有项目的列表:"],["body","\n"],["body","The following specifies the same list as the previous example:"],["body","\n"],["body","tell application \"Finder\"\n    every item of folder \"Users\" of startup disk\nend tell\n"],["body","\n"],["body","tell application \"Finder\"\n    items of folder \"Users\" of startup disk\nend tell\n"],["body","\n"],["headingLink","discussion"],["heading","Discussion"],["body","\n\n"],["body","\n"],["body","Use of the every reference form implies the existence of an index property for the specified objects."],["body","\n"],["body","\n"],["body","\n"],["body","如果将 “every” 对象说明符 指定为从中获取属性或对象的容器，则结果是一个列表，其中包含容器每个对象的指定属性或对象。列表中的项目数与容器中的对象数相同。"],["body","\n"],["body","\n\n\n\n\n"],["body","\n\n                    "],["body","\n\n                    \n                \n            \n\n            \n\n        \n\n\n\n\n        \n\n\n\n        \n        \n        \n\n        \n\n\n    \n    \n"]],[["_relative_fp","6.AppleScript/8.ReferenceForms/8.Property.html"],["title","Property - 各项编程语言"],["body","\n    \n        \n        \n\n        \n        \n\n        \n        \n\n        \n        \n\n        \n\n        \n\n            \n                                \n                \n                    \n                        "],["body","\n                            \n                        "],["body","\n                        "],["body","\n                            \n                        "],["body","\n                        \n                            "],["body","Light"],["body","\n                            "],["body","Rust"],["body","\n                            "],["body","Coal"],["body","\n                            "],["body","Navy"],["body","\n                            "],["body","Ayu"],["body","\n                        \n                    \n\n                    "],["heading","各项编程语言"],["body","\n\n                    \n\n                    \n                \n\n\n                \n                \n\n                \n                    "],["body","\n                        \n\n"],["body","\n"],["body","\n\n"],["headingLink","property"],["heading","Property"],["body","\n"],["body","Specifies a property of an object."],["body","\n"],["headingLink","syntax"],["heading","Syntax"],["body","\n"],["body","*propertyLabel*\n"],["body","\n"],["headingLink","placeholders"],["heading","Placeholders"],["body","\n\n"],["body","\n"],["body","propertyLabel"],["body","\n"],["body","The label for the property."],["body","\n"],["body","\n\n"],["headingLink","examples"],["heading","Examples"],["body","\n\n"],["body","\n"],["body","以下示例是Finder窗口属性的对象说明符。"],["body","\n"],["body","\n"],["body","\n"],["body","It lists the label for the window’s property (zoomed) and its container (front window). zoomed is a Boolean property."],["body","\n"],["body","\n\n"],["body","zoomed of front window -- e.g., false, if the window isn't zoomed\n"],["body","\n"],["body","对于许多对象，您可以获取属性列表:"],["body","\n"],["body","tell app \"Finder\"\n     properties of window 1 --result: a list of properties and their values\nend tell\n"],["body","\n"],["body","The following example is an object specifier to the UnitPrice property of a record object. The label of the property is UnitPrice and the container is the record object."],["body","\n"],["body","UnitPrice of {Product:\"Super Snack\", UnitPrice:0.85, Quantity:10} --result: 0.85\n"],["body","\n"],["headingLink","discussion"],["heading","Discussion"],["body","\n\n"],["body","属性标签在应用程序词典的类定义中列出"],["body","\n"],["body","因为属性的标签在对象的属性中是唯一的"],["body","\n"],["body","标签是指定属性所需的全部-无需指定属性的类."],["body","\n\n\n\n\n"],["body","\n\n                    "],["body","\n\n                    \n                \n            \n\n            \n\n        \n\n\n\n\n        \n\n\n\n        \n        \n        \n\n        \n\n\n    \n    \n"]],[["_relative_fp","6.AppleScript/8.ReferenceForms/index.html"],["title","8.ReferenceForms - 各项编程语言"],["body","\n    \n        \n        \n\n        \n        \n\n        \n        \n\n        \n        \n\n        \n\n        \n\n            \n                                \n                \n                    \n                        "],["body","\n                            \n                        "],["body","\n                        "],["body","\n                            \n                        "],["body","\n                        \n                            "],["body","Light"],["body","\n                            "],["body","Rust"],["body","\n                            "],["body","Coal"],["body","\n                            "],["body","Navy"],["body","\n                            "],["body","Ayu"],["body","\n                        \n                    \n\n                    "],["heading","各项编程语言"],["body","\n\n                    \n\n                    \n                \n\n\n                \n                \n\n                \n                    "],["body","\n                        \n\n"],["body","\n"],["body","\n\n"],["headingLink","reference-forms"],["heading","Reference Forms"],["body","\n\n"],["body","\n"],["body","本章介绍了AppleScript reference forms。"],["body","\n"],["body","\n"],["body","\n"],["body","A reference form 指定用于标识应用程序或其他容器中的对象或对象组的语法—即构造对象说明符的语法 (described in Object Specifiers)."],["body","\n"],["body","\n"],["body","\n"],["body","例如，下面的对象说明符 (from a script targeting the Finder) uses several index reference forms, which identify an object by its number within a container:"],["body","\n"],["body","\n\n"],["body","item 1 of second folder of disk 1\n"],["body","\n"],["body","Important: 使用引用表单时，指定一个或多个被引用对象所在的容器. This takes the form referenceForm of containerObject."],["body","\n"],["body","You can also enclose a reference form in a tell statement, which then serves to specify the outer container. For more information, see Absolute and Relative Object Specifiers."],["body","\n"],["body","Some of the examples of reference forms shown in this chapter will not compile as shown. To compile them, you may need to add an enclosing tell statement, targeting the Finder or the word processing application TextEdit."],["body","\n\n\n\n"],["body","\n\n                    "],["body","\n\n                    \n                \n            \n\n            \n\n        \n\n\n\n\n        \n\n\n\n        \n        \n        \n\n        \n\n\n    \n    \n"]],[["_relative_fp","6.AppleScript/8.ReferenceForms/6.Middle.html"],["title","Middle - 各项编程语言"],["body","\n    \n        \n        \n\n        \n        \n\n        \n        \n\n        \n        \n\n        \n\n        \n\n            \n                                \n                \n                    \n                        "],["body","\n                            \n                        "],["body","\n                        "],["body","\n                            \n                        "],["body","\n                        \n                            "],["body","Light"],["body","\n                            "],["body","Rust"],["body","\n                            "],["body","Coal"],["body","\n                            "],["body","Navy"],["body","\n                            "],["body","Ayu"],["body","\n                        \n                    \n\n                    "],["heading","各项编程语言"],["body","\n\n                    \n\n                    \n                \n\n\n                \n                \n\n                \n                    "],["body","\n                        \n\n"],["body","\n"],["body","\n\n"],["headingLink","middle"],["heading","Middle"],["body","\n"],["body","指定容器中特定类的中间对象。这种格式很少使用。"],["body","\n"],["headingLink","syntax"],["heading","Syntax"],["body","\n"],["body","middle  *class* \n"],["body","\n"],["headingLink","placeholders"],["heading","Placeholders"],["body","\n\n"],["body","\n"],["body","class"],["body","\n"],["body","The class of the middle object to obtain."],["body","\n"],["body","\n\n"],["headingLink","examples"],["heading","Examples"],["body","\n"],["body","tell application \"TextEdit\"\n    middle paragraph of front document\nend tell\nmiddle item of {1, \"doughnut\", 33} --result: \"doughnut\"\nmiddle item of {1, \"doughnut\", 22, 33} --result: \"doughnut\"\nmiddle item of {1, \"doughnut\", 11, 22, 33} --result: 11\n"],["body","\n"],["headingLink","discussion"],["heading","Discussion"],["body","\n\n"],["body","\n"],["body","“middle” 引用格式通常仅在 “index” 格式也起作用时才起作用。"],["body","\n"],["body","\n"],["body","\n"],["body","AppleScript通过取一半的计数来计算中间对象，然后四舍五入"],["body","\n"],["body","\n"],["body","\n"],["body","例如，包含十个单词的段落的中间单词是第五个单词; 十一个单词的中间单词是第六个单词."],["body","\n"],["body","\n\n\n\n\n"],["body","\n\n                    "],["body","\n\n                    \n                \n            \n\n            \n\n        \n\n\n\n\n        \n\n\n\n        \n        \n        \n\n        \n\n\n    \n    \n"]],[["_relative_fp","6.AppleScript/8.ReferenceForms/3.Filter.html"],["title","Filter - 各项编程语言"],["body","\n    \n        \n        \n\n        \n        \n\n        \n        \n\n        \n        \n\n        \n\n        \n\n            \n                                \n                \n                    \n                        "],["body","\n                            \n                        "],["body","\n                        "],["body","\n                            \n                        "],["body","\n                        \n                            "],["body","Light"],["body","\n                            "],["body","Rust"],["body","\n                            "],["body","Coal"],["body","\n                            "],["body","Navy"],["body","\n                            "],["body","Ayu"],["body","\n                        \n                    \n\n                    "],["heading","各项编程语言"],["body","\n\n                    \n\n                    \n                \n\n\n                \n                \n\n                \n                    "],["body","\n                        \n\n"],["body","\n"],["body","\n\n"],["headingLink","filter"],["heading","Filter"],["body","\n\n"],["body","\n"],["body","指定容器中与布尔表达式指定的条件或测试匹配的所有对象"],["body","\n"],["body","\n"],["body","\n"],["body","The filter form specifies application objects only"],["body","\n"],["body","\n"],["body","\n"],["body","It cannot be used to filter the AppleScript objects list, record, or text. "],["body","\n"],["body","\n"],["body","\n"],["body","A term that uses the filter form is also known as a whose clause."],["body","\n"],["body","\n\n"],["body","Note: You can use the words where or that as synonyms for whose."],["body","\n"],["body","A filter reference form can often be replaced by a repeat statement, or vice versa. For example, the following script closes every TextEdit window that isn’t named \"Old Report.rtf\":"],["body","\n"],["body","tell application \"TextEdit\"\n    close every window whose name is not \"Old Report.rtf\"\nend tell\n"],["body","\n"],["body","You could instead obtain a list of open windows and set up a repeat statement that checks the name of each window and closes the window if it isn’t named \"Old Report.rtf\". However, a whose clause is often the fastest way to obtain the desired information."],["body","\n"],["body","The following is an abbreviated form of the previous script:"],["body","\n"],["body","windows of application \"TextEdit\" whose name is not \"Old Report.rtf\"\n"],["body","\n"],["body","For related information, see repeat Statements."],["body","\n"],["headingLink","syntax"],["heading","Syntax"],["body","\n"],["body","*objectSpecifier*  ( whose | where )  *booleanTest* \n"],["body","\n"],["headingLink","placeholders"],["heading","Placeholders"],["body","\n\n"],["body","\n"],["body","objectSpecifier"],["body","\n"],["body","Specifies the container in which to look for objects that match the Boolean test."],["body","\n"],["body","\n"],["body","\n"],["body","whose | where"],["body","\n"],["body","These words have the same meaning, and refer to all of the objects in the specified container that match the conditions in the specified Boolean expression."],["body","\n"],["body","\n"],["body","\n"],["body","booleanTest"],["body","\n"],["body","Any Boolean expression (see the boolean class definition)."],["body","\n"],["body","\n\n"],["headingLink","value"],["heading","Value"],["body","\n"],["body","The value of a filter reference form is a list of the objects that pass the test. If no objects pass the test, the list is an empty list: {}."],["body","\n"],["headingLink","examples"],["heading","Examples"],["body","\n"],["body","The following example shows an object specifier for all open Finder windows that do not have the name \"AppleScript Language Guide\"."],["body","\n"],["body","tell application \"Finder\"\n    every window whose name is not \"AppleScript Language Guide\"\nend tell    \n"],["body","\n"],["headingLink","discussion"],["heading","Discussion"],["body","\n\n"],["body","\n"],["body","实际上，过滤器减少了容器中对象的数量. "],["body","\n"],["body","\n"],["body","\n"],["body","Instead of specifying every Finder window, the following object specifier specifies just the windows that are currently zoomed:"],["body","\n"],["body","\n\n"],["body","every window whose zoomed is true\n"],["body","\n"],["body","要在 Filter 之后指定容器，必须将筛选器及其应用的对象说明符括在括号中，如以下示例所示:"],["body","\n"],["body","tell application \"Finder\"\n    (files whose file type is not \"APPL\") in folder \"HD:SomeFolder:\"\nend tell\n"],["body","\n\n"],["body","\n"],["body","在过滤器引用中的测试中，直接对象是被测试的对象。"],["body","\n"],["body","\n"],["body","\n"],["body","尽管通常不需要它，但可以使用关键字 it 显式指定此隐式目标  详见： The it and me Keywords."],["body","\n"],["body","\n\n"],["body","下面的示例显示了几种构造过滤器引用的等效方法，以查找名称包含单词 “AppleScript” 的文件夹中的所有文件。"],["body","\n"],["body","虽然术语 it 指的是过滤器语句之外的Finder应用程序，但在它们中的 “它” 指的是正在测试的当前文件，每个过滤器测试的结果都是相同的，并且不会通过包含或省略of it术语来更改"],["body","\n"],["body","tell application \"Finder\"\n    it --result: application \"Finder\" (target of tell statement)\n    set myFolder to path to home folder\n        --result: alias \"Leopard:Users:myUser:\"\n    files in myFolder --result: a list of Finder document files\n    files in myFolder where name of it contains \"AppleScript\"\n    (* result: document file \"AppleScriptLG.pdf\" of folder \"myUser\"\n        of folder \"Users\" of startup disk of application \"Finder\"}*)\n    files in myFolder where name contains \"AppleScript\" -- same result\n    every file in myFolder whose name contains \"AppleScript\" -- same result\n    every file in myFolder where name of it contains \"AppleScript\"\n        -- same result\nend tell\n"],["body","\n\n"],["body","A filter reference form includes one or more tests. "],["body","\n"],["body","每个测试都是一个布尔表达式，它将每个被测试对象的属性或元素或对象本身与另一个对象或值进行比较。"],["body","\n"],["body","显示一些过滤器引用，它们包含的布尔表达式，以及每个引用中正在测试的内容。"],["body","\n\n"],["body","Filter reference form"],["body","Boolean expression"],["body","What is being tested"],["body","\n"],["body","windows whose zoomed is true"],["body","zoomed is true"],["body","The zoomed property of each window"],["body","\n"],["body","windows whose name isn’t \"Hard Disk\""],["body","name isn’t \"Hard Disk\""],["body","The name property of each window"],["body","\n"],["body","files whose creator type is \"OMGR\""],["body","creator type is \"OMGR\""],["body","The creator type property of each file"],["body","\n\n\n"],["body","一个测试可以是任何布尔表达式。您可以链接多个测试，如以下语句所示:"],["body","\n"],["body","windows whose zoomed is true and floating is false\n"],["body","\n\n\n\n"],["body","\n\n                    "],["body","\n\n                    \n                \n            \n\n            \n\n        \n\n\n\n\n        \n\n\n\n        \n        \n        \n\n        \n\n\n    \n    \n"]],[["_relative_fp","6.AppleScript/8.ReferenceForms/1.Arbitrary.html"],["title","Arbitrary - 各项编程语言"],["body","\n    \n        \n        \n\n        \n        \n\n        \n        \n\n        \n        \n\n        \n\n        \n\n            \n                                \n                \n                    \n                        "],["body","\n                            \n                        "],["body","\n                        "],["body","\n                            \n                        "],["body","\n                        \n                            "],["body","Light"],["body","\n                            "],["body","Rust"],["body","\n                            "],["body","Coal"],["body","\n                            "],["body","Navy"],["body","\n                            "],["body","Ayu"],["body","\n                        \n                    \n\n                    "],["heading","各项编程语言"],["body","\n\n                    \n\n                    \n                \n\n\n                \n                \n\n                \n                    "],["body","\n                        \n\n"],["body","\n"],["body","\n\n"],["headingLink","arbitrary"],["heading","Arbitrary"],["body","\n"],["body","指定容器中的任意对象。只要需要随机性，这种形式就很有用。"],["body","\n"],["body","由于任意项本质上是随机的，因此此形式对于诸如处理一组文件，单词或其他对象中的每个项之类的操作没有用"],["body","\n"],["headingLink","syntax"],["heading","Syntax"],["body","\n"],["body","some  *class*\n"],["body","\n"],["headingLink","placeholders"],["heading","Placeholders"],["body","\n\n"],["body","\n"],["body","class"],["body","\n"],["body","The class for an arbitrary object"],["body","\n"],["body","\n\n"],["headingLink","examples"],["heading","Examples"],["body","\n"],["body","The following creates a new Mail message with a random signature (and depends on the user having at least one signature):"],["body","\n"],["body","下面创建一个带有随机签名的新邮件消息 (并且取决于用户具有至少一个签名):"],["body","\n"],["body","tell application \"Mail\"\n    activate\n    set randomSignature to some signature\n    set newMessage to make new outgoing message ¬\n        at end of outgoing messages with properties ¬\n        {subject:\"Guess who?\", content:\"Welcome aboard.\", visible:true}\n    set message signature of newMessage to randomSignature\nend tell\n"],["body","\n"],["body","下面简单地从TextEdit文档中获取一个随机单词:"],["body","\n"],["body","tell application \"TextEdit\"\n    some word of document 1 -- any word from the first document\nend tell\n"],["body","\n\n\n\n"],["body","\n\n                    "],["body","\n\n                    \n                \n            \n\n            \n\n        \n\n\n\n\n        \n\n\n\n        \n        \n        \n\n        \n\n\n    \n    \n"]],[["_relative_fp","6.AppleScript/8.ReferenceForms/5.Index.html"],["title","Index - 各项编程语言"],["body","\n    \n        \n        \n\n        \n        \n\n        \n        \n\n        \n        \n\n        \n\n        \n\n            \n                                \n                \n                    \n                        "],["body","\n                            \n                        "],["body","\n                        "],["body","\n                            \n                        "],["body","\n                        \n                            "],["body","Light"],["body","\n                            "],["body","Rust"],["body","\n                            "],["body","Coal"],["body","\n                            "],["body","Navy"],["body","\n                            "],["body","Ayu"],["body","\n                        \n                    \n\n                    "],["heading","各项编程语言"],["body","\n\n                    \n\n                    \n                \n\n\n                \n                \n\n                \n                    "],["body","\n                        \n\n"],["body","\n"],["body","\n\n"],["headingLink","index"],["heading","Index"],["body","\n\n"],["body","\n"],["body","通过描述对象相对于容器的开始或结束的位置来指定对象。"],["body","\n"],["body","\n"],["body","\n"],["body","For related information, see Relative."],["body","\n"],["body","\n\n"],["headingLink","syntax"],["heading","Syntax"],["body","\n"],["body","*class* [ index ] *integer* *integer* (st | nd | rd | th ) *class* ( first | second | third | fourth | fifth | sixth | seventh | eighth | ninth | tenth ) *class* ( last | front | back ) *class*\n"],["body","\n"],["headingLink","placeholders"],["heading","Placeholders"],["body","\n\n"],["body","\n"],["body","class"],["body","\n"],["body","The class of the indexed object to obtain."],["body","\n"],["body","\n"],["body","\n"],["body","integer"],["body","\n"],["body","An integer that describes the position of the object in relation to the beginning of the container (if integer is a positive integer) or the end of the container (if integer is a negative integer)."],["body","\n"],["body","\n"],["body","\n"],["body","st | nd | rd | th"],["body","\n"],["body","Appended to the appropriate integer to form an index. For example, 1st, 2nd, 3rd."],["body","\n"],["body","\n"],["body","\n"],["body","first | second | third | fourth | fifth | sixth | seventh | eighth | ninth | tenth"],["body","\n"],["body","Specify one of the ordinal indexes.The forms first, second, and so on are equivalent to the corresponding integer forms (for example, second word is equivalent to 2nd word). For objects whose index is greater than 10, you can use the forms 12th, 23rd, 101st, and so on. (Note that any integer followed by any of the suffixes listed is valid; for example, you can use 11rd to refer to the eleventh object.)"],["body","\n"],["body","\n"],["body","\n"],["body","last | front | back"],["body","\n"],["body","The front form (for example, front window) is equivalent to class 1 (window 1) or first class (first window). The last and back forms (for example, last word and back window) refer to the last object in a container. They are equivalent to class -1 (for example, window -1)."],["body","\n"],["body","\n\n"],["headingLink","examples"],["heading","Examples"],["body","\n"],["body","以下每个对象说明符指定启动盘上的第一项:"],["body","\n"],["body","item 1 of the startup disk\nitem index 1 of the startup disk -- \"index\" is usually omitted\nthe first item of the startup disk\n"],["body","\n"],["body","以下对象说明符从第三段开始指定第二个单词:"],["body","\n"],["body","word 2 of paragraph 3\n2nd word of paragraph 3\nsecond word of paragraph 3\n"],["body","\n"],["body","以下对象说明符指定第三段中的最后一个单词:"],["body","\n"],["body","word –1 of paragraph 3\nlast word of paragraph 3\n"],["body","\n"],["body","下面的对象说明符在第三段中指定倒数第二个单词。"],["body","\n"],["body","word –2 of paragraph 3\n-2th word of paragraph 3\n"],["body","\n"],["headingLink","discussion"],["heading","Discussion"],["body","\n\n"],["body","index是不稳定的。更改对象的某些其他属性可能会更改其索引以及其他类似对象的索引"],["body","\n"],["body","For example, after deleting word 4 from a paragraph, the word no longer exists. But there may still be a word 4—the word that was formerly word 5. After word 4 is deleted, any words with an index higher than 4 will also have a new index. So the object an index specifies can change."],["body","\n"],["body","对于唯一的持久对象说明符，可以使用 id 引用形式 (see ID),如果应用程序支持您正在使用的对象类。"],["body","\n"],["body","引用文件，您可以使用 “别名” 对象。"],["body","\n\n\n\n\n"],["body","\n\n                    "],["body","\n\n                    \n                \n            \n\n            \n\n        \n\n\n\n\n        \n\n\n\n        \n        \n        \n\n        \n\n\n    \n    \n"]],[["_relative_fp","6.AppleScript/8.ReferenceForms/9.Range.html"],["title","Range - 各项编程语言"],["body","\n    \n        \n        \n\n        \n        \n\n        \n        \n\n        \n        \n\n        \n\n        \n\n            \n                                \n                \n                    \n                        "],["body","\n                            \n                        "],["body","\n                        "],["body","\n                            \n                        "],["body","\n                        \n                            "],["body","Light"],["body","\n                            "],["body","Rust"],["body","\n                            "],["body","Coal"],["body","\n                            "],["body","Navy"],["body","\n                            "],["body","Ayu"],["body","\n                        \n                    \n\n                    "],["heading","各项编程语言"],["body","\n\n                    \n\n                    \n                \n\n\n                \n                \n\n                \n                    "],["body","\n                        \n\n"],["body","\n"],["body","\n\n"],["headingLink","range"],["heading","Range"],["body","\n\n"],["body","指定同一容器中同一类的一系列对象"],["body","\n"],["body","您可以使用一对索引指定对象 (such as words 12 thru 24) 或者用一对边界对象 (integers from integer 1 to integer 3)"],["body","\n\n"],["headingLink","syntax"],["heading","Syntax"],["body","\n"],["body","every  class  from  boundarySpecifier1  to  boundarySpecifier2"],["body","\n"],["body","pluralClass  from  boundarySpecifier1  to  boundarySpecifier2 "],["body","\n"],["body","class  startIndex  ( thru | through )  stopIndex"],["body","\n"],["body","pluralClass  startIndex  ( thru | through )  stopIndex"],["body","\n"],["headingLink","placeholders"],["heading","Placeholders"],["body","\n\n"],["body","\n"],["body","class"],["body","\n"],["body","A singular class (such as window or word)."],["body","\n"],["body","\n"],["body","\n"],["body","pluralClass"],["body","\n"],["body","A plural class (such as windows or words)."],["body","\n"],["body","\n"],["body","\n"],["body","boundarySpecifier1 and boundarySpecifier2"],["body","\n\n"],["body","\n"],["body","限制范围的对象的说明符。范围包括边界对象. "],["body","\n"],["body","\n"],["body","\n"],["body","您可以使用保留字 beginning 代替 boundarySpecifier1 来指示容器的第一个对象之前的位置"],["body","\n"],["body","\n"],["body","\n"],["body","同样，您可以使用保留字 end 代替 boundarySpecifier2 来指示容器中最后一个对象之后的位置"],["body","\n"],["body","\n\n"],["body","\n"],["body","\n"],["body","startIndex and stopIndex"],["body","\n\n"],["body","The indexes of the first and last object of the range (such as 1 and 10 in words 1 thru 10)."],["body","\n"],["body","虽然整数索引是最常见的类, "],["body","\n"],["body","开始和停止索引可以是任何类"],["body","\n"],["body","应用程序确定哪些索引类对它有意义"],["body","\n\n"],["body","\n\n"],["headingLink","value"],["heading","Value"],["body","\n\n"],["body","范围引用格式的值是范围中的对象的列表"],["body","\n"],["body","如果指定的容器不包含指定类的对象，或者范围超出范围，则返回错误"],["body","\n"],["body","例如，以下范围说明符会导致错误，因为列表中没有单词:"],["body","\n\n"],["body","words 1 thru 3 of {1, 2, 3} --result: an error\n"],["body","\n"],["headingLink","examples"],["heading","Examples"],["body","\n"],["body","下面的示例显示了范围说明符的边界对象形式。"],["body","\n"],["body","编译此语句时，脚本编辑器将 “from interger 1 to integer 2” 转换为 “integers 1 thru 2”"],["body","\n"],["body","set intList to integers from integer 1 to integer 2 of {17, 33, 24}\n--result: {17, 33}\n"],["body","\n"],["body","短语 “folders 3 thru 4” 是一个范围说明符，它指定了容器 “启动disk” 中两个文件夹的列表:"],["body","\n"],["body","tell application \"Finder\"\n    folders 3 thru 4 of startup disk\nend tell\n--result: a list of folders (depends on contents of startup disk)\n"],["body","\n"],["headingLink","discussion"],["heading","Discussion"],["body","\n"],["body","如果将范围说明符指定为属性或对象的容器，如"],["body","\n"],["body","name of folders 2 thru 3 of startup disk\n"],["body","\n"],["body","结果是一个列表，其中包含容器的每个对象的指定属性或对象"],["body","\n"],["body","列表中的项目数与容器中的对象数相同。"],["body","\n"],["body","要从 “text” 对象中获取连续的一系列字符 (而不是列表)，请使用 “文本” 类"],["body","\n"],["body","text from word 1 to word 4 of \"We're all in this together\"\n--result: \"We're all in this\"\nwords 1 thru 4 of \"We're all in this together\"\n--result: {\"We're\", \"all\", \"in\", \"this\"}\n"],["body","\n\n\n\n"],["body","\n\n                    "],["body","\n\n                    \n                \n            \n\n            \n\n        \n\n\n\n\n        \n\n\n\n        \n        \n        \n\n        \n\n\n    \n    \n"]],[["_relative_fp","6.AppleScript/8.ReferenceForms/10.Relative.html"],["title","Relative - 各项编程语言"],["body","\n    \n        \n        \n\n        \n        \n\n        \n        \n\n        \n        \n\n        \n\n        \n\n            \n                                \n                \n                    \n                        "],["body","\n                            \n                        "],["body","\n                        "],["body","\n                            \n                        "],["body","\n                        \n                            "],["body","Light"],["body","\n                            "],["body","Rust"],["body","\n                            "],["body","Coal"],["body","\n                            "],["body","Navy"],["body","\n                            "],["body","Ayu"],["body","\n                        \n                    \n\n                    "],["heading","各项编程语言"],["body","\n\n                    \n\n                    \n                \n\n\n                \n                \n\n                \n                    "],["body","\n                        \n\n"],["body","\n"],["body","\n\n"],["headingLink","relative"],["heading","Relative"],["body","\n"],["body","通过描述与另一个对象 (称为基础) 在同一容器中的位置来指定容器中的对象或插入点"],["body","\n"],["headingLink","syntax"],["heading","Syntax"],["body","\n"],["body","[ class ] ( before | [in] front of ) baseSpecifier "],["body","\n"],["body","[ class ] ( after | [in] back of | behind ) baseSpecifier"],["body","\n"],["headingLink","placeholders"],["heading","Placeholders"],["body","\n\n"],["body","\n"],["body","class"],["body","\n"],["body","The class identifier of the specified object. If you omit this parameter, the specifier refers to an insertion point."],["body","\n"],["body","\n"],["body","\n"],["body","baseSpecifier"],["body","\n"],["body","A specifier for the object."],["body","\n"],["body","\n"],["body","\n"],["body","before | [in] front of"],["body","\n"],["body","These forms are equivalent, and refer to the object immediately preceding the base object."],["body","\n"],["body","\n"],["body","\n"],["body","after | [in] back of | behind"],["body","\n"],["body","These forms are equivalent, and refer to the object immediately after the base."],["body","\n"],["body","\n"],["body","\n"],["body","beginning | front"],["body","\n"],["body","These forms are equivalent, and refer to the first insertion point of the container (insertion point 1)."],["body","\n"],["body","\n"],["body","\n"],["body","end | back"],["body","\n"],["body","These forms are equivalent, and refer to the last insertion point of the container (insertion point -1).Although terms such as beginning and end sound like absolute positions, they are relative to the existing contents of a container (that is, before or after the existing contents)."],["body","\n"],["body","\n\n"],["headingLink","examples"],["heading","Examples"],["body","\n"],["body","The two relative specifiers in the following tell block specify the same file by identifying its position relative to another file on a disk:"],["body","\n"],["body","tell application \"Finder\"\n    item before item 3 of startup disk --result: e.g., a specifier\n    item after item 1 of startup disk --result: e.g., a specifier\nend tell\n"],["body","\n"],["body","以下示例演示如何在文字处理文档中使用各种相对说明符:"],["body","\n"],["body","tell first document of application \"TextEdit\"\n    copy word 1 to before paragraph 3\n    copy word 3 to in back of paragraph 4\n    copy word 1 of the last paragraph to behind the third paragraph\nend tell\n"],["body","\n"],["headingLink","discussion"],["heading","Discussion"],["body","\n\n"],["body","The relative reference form generally works only when the index form also works."],["body","\n"],["body","您只能指定具有相对说明符的单个对象-在基本对象之前或之后的对象"],["body","\n\n\n\n\n"],["body","\n\n                    "],["body","\n\n                    \n                \n            \n\n            \n\n        \n\n\n\n\n        \n\n\n\n        \n        \n        \n\n        \n\n\n    \n    \n"]],[["_relative_fp","6.AppleScript/8.ReferenceForms/7.Name.html"],["title","Name - 各项编程语言"],["body","\n    \n        \n        \n\n        \n        \n\n        \n        \n\n        \n        \n\n        \n\n        \n\n            \n                                \n                \n                    \n                        "],["body","\n                            \n                        "],["body","\n                        "],["body","\n                            \n                        "],["body","\n                        \n                            "],["body","Light"],["body","\n                            "],["body","Rust"],["body","\n                            "],["body","Coal"],["body","\n                            "],["body","Navy"],["body","\n                            "],["body","Ayu"],["body","\n                        \n                    \n\n                    "],["heading","各项编程语言"],["body","\n\n                    \n\n                    \n                \n\n\n                \n                \n\n                \n                    "],["body","\n                        \n\n"],["body","\n"],["body","\n\n"],["headingLink","name"],["heading","Name"],["body","\n"],["body","Specifies an object by name."],["body","\n"],["headingLink","syntax"],["heading","Syntax"],["body","\n"],["body","*class*  [ named ]  *nameText* \n"],["body","\n"],["headingLink","placeholders"],["heading","Placeholders"],["body","\n\n"],["body","\n"],["body","class"],["body","\n"],["body","The class for the specified object."],["body","\n"],["body","\n"],["body","\n"],["body","nameText"],["body","\n"],["body","The value of the object’s name property."],["body","\n"],["body","\n\n"],["headingLink","examples"],["heading","Examples"],["body","\n"],["body","The following statements identify objects by name:"],["body","\n"],["body","document \"Report.rtf\"\nwindow named \"logs\"\n"],["body","\n"],["headingLink","discussion"],["heading","Discussion"],["body","\n\n"],["body","\n"],["body","使用 “name” 引用格式 意味着指定对象存在 “name” 属性。"],["body","\n"],["body","\n"],["body","\n"],["body","在某些应用程序中，有可能在具有相同名称的同一容器中具有相同类的多个对象。"],["body","\n"],["body","\n"],["body","\n"],["body","例如，如果有两个名为 “Hard Disk” 的驱动器，则以下语句是不明确的 (至少对读者而言):"],["body","\n"],["body","\n"],["body","\n"],["body","tell application \"Finder\"\n    item 1 of disk \"Hard Disk\"\nend tell\n"],["body","\n"],["body","\n"],["body","\n"],["body","在这种情况下，由应用程序决定由 “name” 引用指定哪个对象。"],["body","\n"],["body","\n\n\n\n\n"],["body","\n\n                    "],["body","\n\n                    \n                \n            \n\n            \n\n        \n\n\n\n\n        \n\n\n\n        \n        \n        \n\n        \n\n\n    \n    \n"]],[["_relative_fp","6.AppleScript/8.ReferenceForms/4.ID.html"],["title","ID - 各项编程语言"],["body","\n    \n        \n        \n\n        \n        \n\n        \n        \n\n        \n        \n\n        \n\n        \n\n            \n                                \n                \n                    \n                        "],["body","\n                            \n                        "],["body","\n                        "],["body","\n                            \n                        "],["body","\n                        \n                            "],["body","Light"],["body","\n                            "],["body","Rust"],["body","\n                            "],["body","Coal"],["body","\n                            "],["body","Navy"],["body","\n                            "],["body","Ayu"],["body","\n                        \n                    \n\n                    "],["heading","各项编程语言"],["body","\n\n                    \n\n                    \n                \n\n\n                \n                \n\n                \n                    "],["body","\n                        \n\n"],["body","\n"],["body","\n\n"],["headingLink","id"],["heading","ID"],["body","\n\n"],["body","通过其 id 属性的值指定对象。"],["body","\n"],["body","您只能将ID引用格式 与具有ID属性的应用程序对象一起使用。"],["body","\n\n"],["headingLink","syntax"],["heading","Syntax"],["body","\n"],["body","*class* id  *expression*\n"],["body","\n"],["headingLink","placeholders"],["heading","Placeholders"],["body","\n\n"],["body","expression：The id value."],["body","\n\n"],["headingLink","examples"],["heading","Examples"],["body","\n"],["body","The following examples use the ID reference form to specify an application by ID and a disk object by ID."],["body","\n"],["body","tell application id \"com.apple.finder\"\n-- specifies an application (Finder) by its ID\ndisk id -100 -- specifies a Finder disk object by ID\nname of disk id -100 --result: \"Leopard_GM\" (gets name from ID specifier)\nend tell\n"],["body","\n"],["headingLink","discussion"],["heading","Discussion"],["body","\n\n"],["body","\n"],["body","使用 id 引用格式意味着指定对象存在 “id” 属性。"],["body","\n"],["body","\n"],["body","\n"],["body","尽管 id 属性通常是整数，但 id 属性可以属于任何类"],["body","\n"],["body","\n"],["body","\n"],["body","scriptable objects支持 id 属性的应用程序必须保证id在容器中是唯一的"],["body","\n"],["body","\n"],["body","\n"],["body","Some applications may also provide additional guarantees, such as ensuring the uniqueness of an ID among all objects."],["body","\n"],["body","\n"],["body","\n"],["body","Id 属性的值通常不可修改"],["body","\n"],["body","\n"],["body","\n"],["body","即使对象在容器内移动，它也不会改变. "],["body","\n"],["body","\n"],["body","\n"],["body","这允许您保存对象的ID，并使用它来引用该对象，只要该对象存在. "],["body","\n"],["body","\n"],["body","\n"],["body","在某些脚本中，您可能希望通过对象的ID来引用对象，而不是通过其名称之类的属性来引用对象，该属性可能会更改"],["body","\n"],["body","\n"],["body","\n"],["body","同样，您可以通过索引跟踪Item，但是当添加，删除甚至重命名容器中的项目时，索引可能会更改."],["body","\n"],["body","\n\n"],["body","Note: 跟踪文件和文件夹的一种好方法是使用 别名"],["body","\n\n"],["body","从AppleScript 2.0开始，application class 的对象具有 id 属性，该属性表示应用程序的bundle标识符 (默认值) 或其四字符签名代码。"],["body","\n"],["body","同样从AppleScript 2.0开始，类 text 的对象具有 id 属性，表示对象中字符的一个或多个Unicode代码点"],["body","\n"],["body","因为 text 对象的ID基于它包含的字符，所以这些ID不能保证是唯一的，并且实际上对于存储相同字符的两个 'text' 对象将是相同的。事实上，没有办法通过检查区分两个这样的物体。"],["body","\n\n\n\n\n"],["body","\n\n                    "],["body","\n\n                    \n                \n            \n\n            \n\n        \n\n\n\n\n        \n\n\n\n        \n        \n        \n\n        \n\n\n    \n    \n"]],[["_relative_fp","6.AppleScript/index.html"],["title","AppleScript - 各项编程语言"],["body","\n    \n        \n        \n\n        \n        \n\n        \n        \n\n        \n        \n\n        \n\n        \n\n            \n                                \n                \n                    \n                        "],["body","\n                            \n                        "],["body","\n                        "],["body","\n                            \n                        "],["body","\n                        \n                            "],["body","Light"],["body","\n                            "],["body","Rust"],["body","\n                            "],["body","Coal"],["body","\n                            "],["body","Navy"],["body","\n                            "],["body","Ayu"],["body","\n                        \n                    \n\n                    "],["heading","各项编程语言"],["body","\n\n                    \n\n                    \n                \n\n\n                \n                \n\n                \n                    "],["body","\n                        \n\n"],["body","\n"],["body","\n\n"],["headingLink","introduction-to-applescript-language-guide"],["heading","Introduction to AppleScript Language Guide"],["body","\n\n"],["body","本文档是AppleScript语言的指南-其词汇约定，语法，关键字和其他元素。它主要用于AppleScript 2.0或更高版本以及macOS版本10.5或更高版本。"],["body","\n"],["body","AppleScript 2.0 can use scripts developed for any version of AppleScript from 1.1 through 1.10.7, any scripting addition created for AppleScript 1.5 or later for macOS, and any scriptable application for Mac OS v7.1 or later. A script created with AppleScript 2.0 can be used by any version of AppleScript back to version 1.1, provided it does not use features of AppleScript, scripting additions, or scriptable applications that are unavailable in that version."],["body","\n"],["body","本文档中术语的描述和示例已使用 OS X v10.5 (Leopard) 中的AppleScript 2.0进行了测试。除了在Leopard中被称为新术语外，大多数描述和示例都可以与以前的系统版本一起使用，但尚未针对所有这些版本进行测试。如果您需要有关先前系统和AppleScript版本的详细信息，请参阅 * AppleScript发行说明 (OS X v10.4及更早版本) *。"],["body","\n\n"],["headingLink","what-is-applescript"],["heading","What Is AppleScript?"],["body","\n\n"],["body","\n"],["body","AppleScript是苹果公司创建的脚本语言，它允许用户直接控制可编写脚本的Macintosh应用程序，以及macOS本身的一部分。"],["body","\n"],["body","\n"],["body","\n"],["body","您可以创建脚本-书面指令集-自动执行重复任务，组合来自多个可编写脚本的应用程序的功能，并创建复杂的工作流"],["body","\n"],["body","\n"],["body","\n"],["body","注意:  Apple还提供了Automator应用程序，该应用程序允许用户通过在图形环境中连接现成的动作来自动执行常见任务。 , see Automator Documentation."],["body","\n"],["body","\n\n"],["body","可编写脚本的应用程序是可以由脚本控制的应用程序，对于AppleScript，这意味着响应当脚本命令以应用程序为目标时发送的称为 Apple events 的应用程序间消息。(也可以直接从其他应用程序和macOS发送Apple事件。)"],["body","\n"],["body","AppleScript本身提供了非常少量的命令，但是它提供了一个框架，您可以在其中插入许多特定于任务的命令-由可脚本应用程序和macOS的可脚本部分提供的命令。"],["body","\n"],["body","本指南中的大多数脚本示例和脚本片段使用Finder应用程序的可编写脚本的功能，macOS的可编写脚本的部分或随macOS一起分发的可编写脚本的应用程序，例如TextEdit (位于 '/applications' 中)。"],["body","\n"],["headingLink","who-should-read-this-document"],["heading","Who Should Read This Document?"],["body","\n"],["body","You should use this document if you write or modify AppleScript scripts, or if you create scriptable applications and need to know how scripts should work."],["body","\n"],["body","AppleScript Language Guide assumes you are familiar with the high-level information about AppleScript found in AppleScript Overview."],["body","\n"],["headingLink","organization-of-this-document"],["heading","Organization of This Document"],["body","\n"],["body","本指南在一系列章节和附录中描述了AppleScript语言。"],["body","\n"],["body","前五章介绍了该语言的组成部分和使用它的基本概念，然后提供了有关使用脚本对象和处理程序例程的其他概述:"],["body","\n\n"],["body","AppleScript Lexical Conventions 描述在AppleScript脚本中组成语句的字符、符号、关键字和其他语言元素."],["body","\n"],["body","AppleScript Fundamentals 描述本指南其余部分涵盖的术语和规则的基本概念。"],["body","\n"],["body","Variables and Properties 描述使用变量和属性的常见问题，包括如何声明它们以及作用范围."],["body","\n"],["body","Script Objects 描述如何定义，初始化，向其发送命令以及如何使用脚本对象的继承."],["body","\n"],["body","About Handlers  提供有关使用处理程序 (AppleScript中可用的一种功能) 对代码进行重构和重用的信息。"],["body","\n\n"],["body","以下章节为AppleScript语言提供参考:"],["body","\n\n"],["body","\n"],["body","Class Reference 描述为常用的内置类。"],["body","\n"],["body","\n"],["body","\n"],["body","Commands Reference 描述可用于任何脚本的命令."],["body","\n"],["body","\n"],["body","\n"],["body","Reference Forms 描述用于在应用程序或其他容器中指定对象或对象组的语法。"],["body","\n"],["body","\n"],["body","\n"],["body","Operators Reference 提供AppleScript支持的运算符和使用它们的规则的列表，以及为常用运算符提供其他详细信息的部分。"],["body","\n"],["body","\n"],["body","\n"],["body","Control Statements Reference 描述控制其他语句何时以及如何执行的语句。它涵盖了标准条件语句，以及错误处理和其他操作中使用的语句。"],["body","\n"],["body","\n"],["body","\n"],["body","Handler Reference 显示定义和调用处理程序的语法，并描述与处理程序一起使用的其他语句。"],["body","\n"],["body","\n\n"],["body","下面的章节描述了macOS的一个与AppleScript相关的特性:"],["body","\n\n"],["body","Folder Actions Reference 描述如何将脚本处理程序编写和附加到特定文件夹，以便在修改文件夹时调用处理程序。"],["body","\n\n"],["body","以下附录提供了有关AppleScript语言以及如何处理脚本中的错误的其他信息:"],["body","\n\n"],["body","AppleScript Keywords 列出AppleScript语言的关键字，为每个关键字提供简要说明，并指向相关信息。"],["body","\n"],["body","Error Numbers and Error Messages 描述在使用AppleScript脚本时可能会看到的错误编号和错误消息。"],["body","\n"],["body","Working with Errors provides detailed examples of handling errors with try Statements and error Statements."],["body","\n"],["body","Double Angle Brackets describes when you are likely to see double angle brackets (or chevrons—«») in scripts and how you can work with them."],["body","\n"],["body","Libraries using Load Script 保存handler作为库：describes how to save libraries of handlers and access them from other scripts."],["body","\n"],["body","Unsupported Terms lists terms that are no longer supported in AppleScript."],["body","\n\n"],["headingLink","conventions-used-in-this-guide"],["heading","Conventions Used in This Guide"],["body","\n"],["body","术语表以定义的 黑体字 显示。"],["body","\n"],["body","The following conventions are used in syntax descriptions:"],["body","\n"],["body","\n"],["body","language element"],["body","Plain computer font indicates an element that you type exactly as shown. If there are special symbols (for example, + or &), you also type them exactly as shown."],["body","\n"],["body","placeholder"],["body","Italic text indicates a placeholder that you replace with an appropriate value."],["body","\n"],["body","[optional]"],["body","Brackets indicate that the enclosed language element or elements are optional."],["body","\n"],["body","(a group)"],["body","Parentheses group elements together.However, the parentheses shown in Handler Syntax (Positional Parameters) are part of the syntax."],["body","\n"],["body","[optional]..."],["body","Three ellipsis points (...) after a group defined by brackets indicate that you can repeat the group of elements within brackets 0 or more times."],["body","\n"],["body","a | b | c"],["body","Vertical bars separate elements in a group from which you must choose a single element. The elements are often grouped within parentheses or brackets."],["body","\n"],["body","Filenames shown in scripts"],["body","Most filenames shown in examples in this document include extensions, such as rtf for a TextEdit document. Use of extensions in scripts is generally dependent on the “Show all file extensions” setting in the Advanced pane of Finder Preferences.To work with the examples on your computer, you may need to modify either that setting or the filenames."],["body","\n\n\n"],["headingLink","see-also"],["heading","See Also"],["body","\n"],["body","These Apple documents provide additional information for working with AppleScript:"],["body","\n\n"],["body","See Getting Started with AppleScript for a guided quick start, useful to both scripters and developers."],["body","\n"],["body","See AppleScript Overview, including the chapter Scripting with AppleScript, for a high-level overview of AppleScript and its related technologies."],["body","\n"],["body","See Getting Started With Scripting & Automation for information on the universe of scripting technologies available in macOS."],["body","\n"],["body","See AppleScript Terminology and Apple Event Codes for a list of many of the scripting terms defined by Apple."],["body","\n\n"],["body","For additional information on working with the AppleScript language and creating scripts, see one of the comprehensive third-party documents available in bookstores and online."],["body","\n\n\n\n"],["body","\n\n                    "],["body","\n\n                    \n                \n            \n\n            \n\n        \n\n\n\n\n        \n\n\n\n        \n        \n        \n\n        \n\n\n    \n    \n"]],[["_relative_fp","6.AppleScript/6.ClassReference/17.text.html"],["title","text - 各项编程语言"],["body","\n    \n        \n        \n\n        \n        \n\n        \n        \n\n        \n        \n\n        \n\n        \n\n            \n                                \n                \n                    \n                        "],["body","\n                            \n                        "],["body","\n                        "],["body","\n                            \n                        "],["body","\n                        \n                            "],["body","Light"],["body","\n                            "],["body","Rust"],["body","\n                            "],["body","Coal"],["body","\n                            "],["body","Navy"],["body","\n                            "],["body","Ayu"],["body","\n                        \n                    \n\n                    "],["heading","各项编程语言"],["body","\n\n                    \n\n                    \n                \n\n\n                \n                \n\n                \n                    "],["body","\n                        \n\n"],["body","\n"],["body","\n\n"],["headingLink","text"],["heading","text"],["body","\n\n"],["body","Unicode字符的有序系列。"],["body","\n"],["body","从AppleScript 2.0开始，AppleScript完全基于Unicode"],["body","\n"],["body","Unicode和非Unicode文本之间不再有区别。"],["body","\n"],["body","脚本中的注释和文本常量可能包含任何Unicode字符，并且所有文本处理都在Unicode中完成，因此无论用户的语言偏好如何，所有字符都被正确保留。"],["body","\n\n"],["body","例如，以下脚本在AppleScript 2.0中正常工作，而在以前的版本中是没有的:"],["body","\n"],["body","set jp to \"日本語\"\nset ru to \"Русский\"\njp & \" and \" & ru -- returns \"日本語 and Русский\"\n"],["body","\n"],["body","有关与以前的AppleScript版本兼容的信息，包括使用 “string” 和 “unicode text” 作为 “text” 的同义词，请参阅特殊注意事项部分。"],["body","\n"],["headingLink","properties-of-text-objects"],["heading","Properties of text objects"],["body","\n"],["body","class\n \tAccess:\tread-only\n \tClass:\tclass\n \tThe class identifier for the object. The value of this property is always text.\n \t\nid\n \tAccess:\tread-only\n \tClass:\tinteger or list of integer\n \tA value (or list of values) representing the Unicode code point (or code points) for the character (or characters) in the text object. (A Unicode code point is a unique number that represents a character and allows it to be represented in an abstract way, independent of how it is rendered. A character in a text object may be composed of one or more code points.)\n \tThis property, added in AppleScript 2.0, can also be used as an address, which allows mapping between Unicode code point values and the characters at those code points. For example, id of \"A\" returns 65, and character id 65 returns \"A\".\n \tThe id of text longer than one code point is a list of integers, and vice versa: for example, id of \"hello\" returns {104, 101, 108, 108, 111}, and string id {104, 101, 108, 108, 111} returns \"hello\". (Because of a bug, text id ... does not work; you must use one of string, Unicode text, or character.)\n \tThese uses of the id property obsolete the older ASCII character and ASCII number commands, since, unlike those, they cover the full Unicode character range and will return the same results regardless of the user's language preferences.\nlength\n \tAccess:\tread only\n \tClass:\tinteger\n \tThe number of characters in the text.\nquoted form\n \tAccess:\tread only\n \tClass:\ttext\n \tA representation of the text that is safe from further interpretation by the shell, no matter what its contents are. Mainly useful for passing a text string to the do shell script command\n"],["body","\n"],["headingLink","elements-of-text-objects"],["heading","Elements of text objects"],["body","\n"],["body","'text' 对象可以包含这些元素 (其行为可能与应用程序中使用的类似元素不同):"],["body","\n"],["body","\n"],["body","character"],["body","\n"],["body","Specify by:"],["body","Arbitrary, Every, Index, Middle, Range"],["body","\n"],["body","One or more Unicode characters that make up the text.Starting in AppleScript 2.0, elements of text object count a combining character cluster (also known as a Unicode grapheme cluster) as a single character. (This relates to a feature of Unicode that is unlikely to have an impact on most scripters: some “characters” may be represented as either a single entity or as a base character plus a series of combining marks.For example, “é” may be encoded as either U+00E9 (LATIN SMALL LETTER E WITH ACUTE) or as U+0065 (LATIN SMALL LETTER E), U+0301 (COMBINING ACUTE ACCENT). Nonetheless, AppleScript 2.0 will count both as one character, where older versions counted the base character and combining mark separately."],["body","\n\n\n"],["headingLink","operators"],["heading","Operators"],["body","\n\n"],["body","\n"],["body","The operators that can have text objects as operands are &, =, ≠, >, ≥, <, ≤, starts with, ends with, contains, is contained by, and as."],["body","\n"],["body","\n"],["body","\n"],["body","In text comparisons, you can specify whether white space should be considered or ignored. For more information, see considering and ignoring Statements."],["body","\n"],["body","\n"],["body","\n"],["body","For detailed explanations and examples of how AppleScript operators treat text objects, see Operators Reference."],["body","\n"],["body","\n\n"],["headingLink","special-string-characters"],["heading","Special String Characters"],["body","\n\n"],["body","反斜杠 ('') 和双引号 ('\"') 字符在文本中具有特殊含义"],["body","\n"],["body","AppleScript将文本包含在双引号字符中，并使用反斜杠字符表示返回 ('\\ r') 、制表符 (' \\ t') 和换行符 (\\ n) 字符 (如下所述)。"],["body","\n"],["body","因此，如果要在 “文本” 对象中包含实际的反斜杠或双引号字符，您必须使用等效的两个字符序列。为了方便起见，AppleScript还提供了文本常量 'quote'，它具有值 '\\ \"'。"],["body","\n\n"],["body","Character"],["body","To insert in text"],["body","\n"],["body","Backslash character (\\)"],["body","\\\\"],["body","\n"],["body","Double quote (\")"],["body","\\\"``quote (text constant)"],["body","\n\n\n"],["body","要声明一个 'text' 对象，显示时看起来像这样:"],["body","\n"],["body","They said \"Use the '\\' character.\"\n"],["body","\n"],["body","you can use the following:"],["body","\n"],["body","\"They said \\\"Use the '\\\\' character.\\\"\"\n"],["body","\n"],["body","空白是指显示为垂直或水平空间的文本字符，AppleScript定义空白常量 'return'，'linefeed'，'space' 和 'tab' 分别表示返回字符，换行字符，空格字符和制表符。('linefeed' 常量在AppleScript 2.0中可用。)"],["body","\n"],["body","尽管您有效地将这些值用作文本常量，但它们实际上被定义为全局常量 'AppleScript' 的属性。"],["body","\n"],["body","Constant"],["body","Value"],["body","\n"],["body","space"],["body","\" \""],["body","\n"],["body","tab"],["body","\"\\t\""],["body","\n"],["body","return"],["body","\"\\r\""],["body","\n"],["body","linefeed"],["body","\"\\n”"],["body","\n\n\n"],["body","要在字符串中输入空白，您只需键入字符-即，您可以按空格键插入空格，按Tab键插入制表符，或按返回键插入返回。在后一种情况下，字符串将出现在脚本中的两行上，如下所示:"],["body","\n"],["body","display dialog \"Hello\" & \"\n\" & \"Goodbye\"\n"],["body","\n\n"],["body","当您运行此脚本时，“Hello” 出现在对话框中的 “Goodbye” 上方。"],["body","\n"],["body","您还可以输入具有等效两个字符序列的选项卡、返回或换行符。当向用户显示包含两个字符序列中的任何一个的 “文本” 对象时，序列将被转换。例如，如果在 “显示对话框” 命令中使用以下 “text” 对象:"],["body","\n\n"],["body","display dialog \"item 1\\t1\\ritem 2\\t2\"\n"],["body","\n"],["body","它是这样显示的 (除非您在脚本编辑器首选项的编辑选项卡中启用 “字符串中的转义选项卡和换行符”):"],["body","\n"],["body","item 1      1\nitem 2      2\n"],["body","\n"],["body","要使用空格常量，请使用concatenation运算符将多个 “文本” 对象连接在一起，如下面的示例所示:"],["body","\n"],["body","\"Year\" & tab & tab & \"Units sold\" & return & \"2006\" & tab ¬\n   & tab & \"300\" & return & \"2007\" & tab & tab & \"453\"\n"],["body","\n"],["body","When passed to display dialog, this text is displayed as follows:"],["body","\n"],["body","Year       Units sold"],["body","\n"],["body","2006            300"],["body","\n"],["body","2007            453"],["body","\n\n\n"],["headingLink","coercions-supported"],["heading","Coercions Supported"],["body","\n"],["body","AppleScript支持将 “文本” 对象强制转换为单个项目 “列表”。如果 “文本” 对象表示适当的数字，则AppleScript支持将 “文本” 对象强制转换为整数或实数。"],["body","\n"],["headingLink","examples"],["heading","Examples"],["body","\n"],["body","You can define a text object in a script by surrounding text characters with quotation marks, as in these examples:"],["body","\n"],["body","set theObject to \"some text\"\nset clientName to \"Mr. Smith\"\ndisplay dialog \"This is a text object.\"\n"],["body","\n"],["body","假设您使用以下语句来获取名为 'docText' 的 'text' 对象，该对象包含从特定文档中提取的所有文本:"],["body","\n"],["body","set docText to text of document \"MyFavoriteFish.rtf\" of application \"TextEdit\"\n"],["body","\n"],["body","以下语句显示了使用 'text' 对象 'docText' 的各种方法:"],["body","\n"],["body","class of docText --result: text\nfirst character of docText --result: a character\nevery paragraph of docText --result: a list containing all paragraphs\nparagraphs 2 thru 3 of docText --result: a list containing two paragraphs\n"],["body","\n"],["body","下一个示例准备一个 'text' 对象以与 'display dialog' 命令一起使用"],["body","\n"],["body","它使用 'quote' 常量将 '\\ \"' 插入文本。当此文本显示在对话框中 (文本输入字段上方) 时，它看起来像这样: '以引号输入文本 (“ 引号中的文本 ”):'"],["body","\n"],["body","set promptString to \"Enter the text in quotes (\" & quote ¬\n    & \"text in quotes\" & quote & \"): \"\ndisplay dialog promptString default answer \"\"\n"],["body","\n"],["body","下面的示例获取到所选文件夹的POSIX路径，并使用 'quoted form' 属性来确保正确引用生成的字符串以用于shell命令:"],["body","\n"],["body","set folderName to quoted form of POSIX path of (choose folder)\n"],["body","\n"],["body","假设您在 “应用程序” 文件夹中选择名为 “iwork '08” 的文件夹。前面的语句将返回以下结果，该结果可以正确处理文件夹名称中嵌入的单引号和空格字符:"],["body","\n"],["body","\"'/Applications/iWork '\\\\''08/'\"\n"],["body","\n"],["headingLink","discussion"],["heading","Discussion"],["body","\n"],["body","To get a contiguous range of characters within a text object, use the text element. For example, the value of the following statement is the text object \"y thi\":"],["body","\n"],["body","要获取 “text” 对象内连续的字符范围，请使用 “文本” 元素。例如，以下语句的值是 'text' 对象 '\"y thi\"':"],["body","\n"],["body","`get text 3 thru 7 of \"Try this at home\"`\n`--result: \"y thi\"`\n"],["body","\n"],["body","使用字符元素而不是文本元素的类似语句的结果是一个列表:"],["body","\n"],["body","get characters 3 thru 7 of \"Try this at home\"\n`--result: {\"y\", \" \", \"t\", \"h\", \"i\"}`\n"],["body","\n"],["body","您无法设置 'text' 对象的元素的值。"],["body","\n"],["body","set myName to \"Boris\"\nset character 1 of myName to \"D\"\n--result: error: you cannot set the values of elements of text objects\n"],["body","\n"],["body","但是，您可以通过获取最后四个字符并将它们与 “D” 连接来实现相同的结果:"],["body","\n"],["body","set myName to \"boris\"\nset myName to \"D\" & (get text 2 through 5 of myName)\n--result: \"Doris\n"],["body","\n"],["body","此示例实际上并未修改现有的 'text' 对象-它将变量 'myName' 设置为引用具有不同值的新 'text' 对象。"],["body","\n"],["headingLink","special-considerations"],["heading","Special Considerations"],["body","\n"],["body","为了与AppleScript 2.0之前的版本兼容，strings 和 “unicode文本” 仍被定义，但被认为是 “文本” 的同义词。例如，这三个语句都具有相同的效果:"],["body","\n"],["body","someObject as text\nsomeObject as string\nsomeObject as Unicode text\n"],["body","\n\n"],["body","\n"],["body","此外，'text' 、 'string' 和 'Unicode text' 都将比较为相等。例如，即使 “foo” 类返回 “文本”，“foo” 类也为 “真”。但是，应用程序仍然可以区分三种不同的类型，即使AppleScript本身没有。"],["body","\n"],["body","\n"],["body","\n"],["body","从AppleScript 2.0开始，没有使用 'text' 对象存储的样式信息。"],["body","\n"],["body","\n"],["body","\n"],["body","因为所有文本都是Unicode文本，所以脚本现在总是获得Unicode文本行为。"],["body","\n"],["body","\n"],["body","\n"],["body","对于某些依赖于区域设置的操作，尤其是 “word” 元素，这可能与以前的 “strings” 行为不同。若要获得与2.0和pre-2.0相同的行为，请添加显式的 as Unicode text强制装换，例如，words of (someText as Unicode text)"],["body","\n"],["body","\n"],["body","\n"],["body","由于 text item delimiters(described in text item delimiters)  关于 AppleScript 2.0中的 “considering” 和 “ignoring” 属性，默认情况下，分隔符不区分大小写。以前，它们总是区分大小写。要强制执行先前的行为，请添加显式的 considering case 语句。"],["body","\n"],["body","\n"],["body","\n"],["body","因为AppleScript 2.0脚本将所有文本存储为Unicode，所以任何文本常量都算作以前的 “Unicode文本” 类的使用，该类将与AppleScript的任何版本一起使用，返回到版本1.3。包含仅Unicode字符 (例如阿拉伯语或泰语) 的脚本将运行，但使用AppleScript 2.0之前的版本无法正确编辑: 仅Unicode字符将丢失。"],["body","\n"],["body","\n\n\n\n\n"],["body","\n\n                    "],["body","\n\n                    \n                \n            \n\n            \n\n        \n\n\n\n\n        \n\n\n\n        \n        \n        \n\n        \n\n\n    \n    \n"]],[["_relative_fp","6.AppleScript/6.ClassReference/8.integer.html"],["title","integer - 各项编程语言"],["body","\n    \n        \n        \n\n        \n        \n\n        \n        \n\n        \n        \n\n        \n\n        \n\n            \n                                \n                \n                    \n                        "],["body","\n                            \n                        "],["body","\n                        "],["body","\n                            \n                        "],["body","\n                        \n                            "],["body","Light"],["body","\n                            "],["body","Rust"],["body","\n                            "],["body","Coal"],["body","\n                            "],["body","Navy"],["body","\n                            "],["body","Ayu"],["body","\n                        \n                    \n\n                    "],["heading","各项编程语言"],["body","\n\n                    \n\n                    \n                \n\n\n                \n                \n\n                \n                    "],["body","\n                        \n\n"],["body","\n"],["body","\n\n"],["headingLink","integer"],["heading","integer"],["body","\n"],["body","A number without a fractional part."],["body","\n"],["headingLink","properties-of-integer-objects"],["heading","Properties of integer objects"],["body","\n"],["body","class\n \tAccess:\tread-only\n \tClass:\tclass\n \tThe class identifier for the object. The value of this property is always integer.\n\n\n\n"],["body","\n"],["headingLink","operators"],["heading","Operators"],["body","\n\n"],["body","\n"],["body","The operators that can have integer values as operands are +, -, *, ÷ (or /), div, mod, ^, =, ≠, >, ≥, <, and ≤."],["body","\n"],["body","\n"],["body","\n"],["body","The div operator always returns an integer value as its result. The +, –, *, mod, and ^ operators return values of type integer or real."],["body","\n"],["body","\n\n"],["headingLink","coercions-supported"],["heading","Coercions Supported"],["body","\n"],["body","AppleScript supports coercion of an integer value to a single-item list, a real number, or a text object."],["body","\n"],["body","Coercion of an integer to a number does nothing:"],["body","\n"],["body","set myCount to 7 as number\nclass of myCount --result: integer\n"],["body","\n"],["headingLink","examples"],["heading","Examples"],["body","\n"],["body","1\nset myResult to 3 - 2\n-1\n1000\n"],["body","\n"],["headingLink","discussion"],["heading","Discussion"],["body","\n\n"],["body","\n"],["body","The biggest value (positive or negative) that can be expressed as an integer in AppleScript is ±536870911, which is equal to ±(2^29 – 1)."],["body","\n"],["body","\n"],["body","\n"],["body","Larger integers are converted to real numbers, expressed in exponential notation, when scripts are compiled."],["body","\n"],["body","\n"],["body","\n"],["body","Note: The smallest possible integer value is actually -536870912 (-2^29), but it can only be generated as a result of an expression. If you enter it directly into a script, it will be converted to a real when you compile."],["body","\n"],["body","\n\n\n\n\n"],["body","\n\n                    "],["body","\n\n                    \n                \n            \n\n            \n\n        \n\n\n\n\n        \n\n\n\n        \n        \n        \n\n        \n\n\n    \n    \n"]],[["_relative_fp","6.AppleScript/6.ClassReference/16.script.html"],["title","script - 各项编程语言"],["body","\n    \n        \n        \n\n        \n        \n\n        \n        \n\n        \n        \n\n        \n\n        \n\n            \n                                \n                \n                    \n                        "],["body","\n                            \n                        "],["body","\n                        "],["body","\n                            \n                        "],["body","\n                        \n                            "],["body","Light"],["body","\n                            "],["body","Rust"],["body","\n                            "],["body","Coal"],["body","\n                            "],["body","Navy"],["body","\n                            "],["body","Ayu"],["body","\n                        \n                    \n\n                    "],["heading","各项编程语言"],["body","\n\n                    \n\n                    \n                \n\n\n                \n                \n\n                \n                    "],["body","\n                        \n\n"],["body","\n"],["body","\n\n"],["headingLink","script"],["heading","script"],["body","\n\n"],["body","\n"],["body","可以作为组执行的AppleScript声明和语句的集合。"],["body","\n"],["body","\n"],["body","\n"],["body","The syntax for a script object is described in Defining Script Objects."],["body","\n"],["body","\n\n"],["headingLink","properties-of-script-objects"],["heading","Properties of script objects"],["body","\n"],["body","class\n \tAccess:\tread-only\n \tClass:\tclass\n \tThe class identifier for the object. The value of this property is always script.\n \t\n \t\nname\n \tAccess:\tread-only\n \tClass:\ttext\n \tThe name of the script object, implicitly defined in AppleScript 2.3 and later. For top-level scripts, this is the name of the file the script is saved in, unless explicitly defined otherwise using a property, or, for a top-level script saved as a script bundle, using the Info.plist key CFBundleName. Script Editor’s Bundle Contents drawer includes a “Name” field to set this value. For other script objects, it is the name the script was defined with, as text.\n \t\n \t\nid\n \tAccess:\tread-only\n \tClass:\ttext\n \tThe unique identifier of the script object, implicitly defined in AppleScript 2.3 and later. Its value is missing value unless explicitly defined using a property, or, for a top-level script saved as a script bundle, using the Info.plist key CFBundleIdentifier. Script Editor’s Bundle Contents drawer includes an “Identifier” field to set this value.\n \t\n \t\nversion\n \tAccess:\tread-only\n \tClass:\ttext\n \tThe version of the script object, implicitly defined in AppleScript 2.3 and later. For top-level scripts, its value is \"1.0\" unless explicitly defined using a property, or, for a script bundle, using the Info.plist key CFBundleShortVersionString. Script Editor’s Bundle Contents drawer includes a “Short Version” field to set this value. For other script objects, its default value is missing value. While the version may resemble a number, it is actually of type text. For best results, compare version strings using considering numeric strings.\n"],["body","\n"],["headingLink","commands-handled"],["heading","Commands Handled"],["body","\n"],["body","You can copy a script object with the copy command or create a reference to it with the set command."],["body","\n"],["headingLink","coercions-supported"],["heading","Coercions Supported"],["body","\n"],["body","AppleScript supports coercion of a script object to a single-item list."],["body","\n"],["headingLink","examples"],["heading","Examples"],["body","\n"],["body","下面的示例显示一个简单的 “脚本” 对象，该对象显示一个对话框。它后面是一个语句，显示如何运行脚本:"],["body","\n"],["body","script helloScript\n    display dialog \"Hello.\"\nend script\nrun helloScript -- invoke the script\n"],["body","\n"],["headingLink","discussion"],["heading","Discussion"],["body","\n\n"],["body","\n"],["body","'script' 对象可以包含其他 'script' 对象，称为子脚本，并且可以具有父对象。"],["body","\n"],["body","\n"],["body","\n"],["body","For additional information, including more detailed examples, see Script Objects."],["body","\n"],["body","\n"],["body","\n"],["body","The name, id, and version properties are automatically defined in OS X Mavericks v10.9 (AppleScript 2.3) and later, and are used to identify scripts used as libraries, as described in Script Objects."],["body","\n"],["body","\n\n\n\n\n"],["body","\n\n                    "],["body","\n\n                    \n                \n            \n\n            \n\n        \n\n\n\n\n        \n\n\n\n        \n        \n        \n\n        \n\n\n    \n    \n"]],[["_relative_fp","6.AppleScript/6.ClassReference/5.constant.html"],["title","constant - 各项编程语言"],["body","\n    \n        \n        \n\n        \n        \n\n        \n        \n\n        \n        \n\n        \n\n        \n\n            \n                                \n                \n                    \n                        "],["body","\n                            \n                        "],["body","\n                        "],["body","\n                            \n                        "],["body","\n                        \n                            "],["body","Light"],["body","\n                            "],["body","Rust"],["body","\n                            "],["body","Coal"],["body","\n                            "],["body","Navy"],["body","\n                            "],["body","Ayu"],["body","\n                        \n                    \n\n                    "],["heading","各项编程语言"],["body","\n\n                    \n\n                    \n                \n\n\n                \n                \n\n                \n                    "],["body","\n                        \n\n"],["body","\n"],["body","\n\n"],["headingLink","constant"],["heading","constant"],["body","\n\n"],["body","\n"],["body","具有预定义值的单词。"],["body","\n"],["body","\n"],["body","\n"],["body","Constants are generally used for enumerated types. You cannot define constants in scripts; constants can be defined only by applications and by AppleScript. "],["body","\n"],["body","\n"],["body","\n"],["body","See Global Constants in AppleScript for more information."],["body","\n"],["body","\n\n"],["headingLink","properties-of-constant-objects"],["heading","Properties of constant objects"],["body","\n"],["body","class\n \tAccess:\tread-only\n \tClass:\tclass\n \tThe class identifier for the object. The value of this property is always constant.\n\n"],["body","\n"],["headingLink","operators"],["heading","Operators"],["body","\n"],["body","The operators that take constant objects as operands are &, =, ≠, and as."],["body","\n"],["headingLink","coercions-supported"],["heading","Coercions Supported"],["body","\n"],["body","AppleScript supports coercion of a constant object to a single-item list or a text object."],["body","\n"],["headingLink","examples"],["heading","Examples"],["body","\n"],["body","您使用AppleScript定义的常量的一个地方是在使用 “considering” 或 “ignoring” 语句执行的文本比较中"],["body","\n"],["body","(described in considering / ignoring (text comparison)). For example, in the following script statements, punctuation, hyphens, and white space are constants:"],["body","\n"],["body","连字符：hyphens， white space：空格符，标点符号：punctuation"],["body","\n"],["body","considering punctuation but ignoring hyphens and white space\n    \"bet-the farm,\" = \"BetTheFarm,\" --result: true\nend considering\nclass of hyphens --result: constant\n"],["body","\n"],["body","The final statement shows that the class of hyphens is constant."],["body","\n"],["headingLink","discussion"],["heading","Discussion"],["body","\n\n"],["body","\n"],["body","常量不是文本字符串，它们不能被引号包围。"],["body","\n"],["body","\n"],["body","\n"],["body","Literal constants are defined in Literals and Constants."],["body","\n"],["body","\n"],["body","\n"],["body","除了AppleScript定义的常量之外，应用程序还经常定义用于命令参数或属性值的枚举类型，例如，iTunes “搜索” 命令定义了这些常量，用于指定搜索区域:"],["body","\n"],["body","\n\n"],["body","例如，iTunes “搜索” 命令定义了这些常量，用于指定搜索区域:"],["body","\n"],["body","albums\nall\nartists\ncomposers\ndisplayed\nsongs\n"],["body","\n\n\n\n"],["body","\n\n                    "],["body","\n\n                    \n                \n            \n\n            \n\n        \n\n\n\n\n        \n\n\n\n        \n        \n        \n\n        \n\n\n    \n    \n"]],[["_relative_fp","6.AppleScript/6.ClassReference/3.boolean.html"],["title","boolean - 各项编程语言"],["body","\n    \n        \n        \n\n        \n        \n\n        \n        \n\n        \n        \n\n        \n\n        \n\n            \n                                \n                \n                    \n                        "],["body","\n                            \n                        "],["body","\n                        "],["body","\n                            \n                        "],["body","\n                        \n                            "],["body","Light"],["body","\n                            "],["body","Rust"],["body","\n                            "],["body","Coal"],["body","\n                            "],["body","Navy"],["body","\n                            "],["body","Ayu"],["body","\n                        \n                    \n\n                    "],["heading","各项编程语言"],["body","\n\n                    \n\n                    \n                \n\n\n                \n                \n\n                \n                    "],["body","\n                        \n\n"],["body","\n"],["body","\n\n"],["headingLink","boolean"],["heading","boolean"],["body","\n\n"],["body","\n"],["body","A logical truth value."],["body","\n"],["body","\n"],["body","\n"],["body","A boolean object evaluates to one of the AppleScript constants true or false. A Boolean expression contains one or more boolean objects and evaluates to true or false."],["body","\n"],["body","\n\n"],["headingLink","properties-of-boolean-objects"],["heading","Properties of boolean objects"],["body","\n"],["body","class\n \tAccess:\tread only\n \tClass:\tclass\n \tThe class identifier for the object. The value is always boolean.\n"],["body","\n"],["headingLink","operators"],["heading","Operators"],["body","\n\n"],["body","以 'boolean' 对象为操作数的运算符是  and, or, not, &, =, and ≠, as well as their text equivalents: is equal to, is not equal to, equals, "],["body","\n"],["body","一元 'not '运算符将 'true' 值更改为 'false' 或将 'false' 值更改为 'true'。"],["body","\n"],["body","concatenation运算符 ('&') 创建一个列表，其中包含在其两侧的两个布尔值; 例如:"],["body","\n\n"],["body","true & false --result: {true, false}\n"],["body","\n"],["body","For additional information on these operators, see Operators Reference."],["body","\n"],["headingLink","coercions-supported"],["heading","Coercions Supported"],["body","\n"],["body","AppleScript supports coercion of a boolean object to a single-item list, a text object, or an integer."],["body","\n"],["headingLink","examples"],["heading","Examples"],["body","\n"],["body","The following are simple Boolean expressions:"],["body","\n"],["body","true\nfalse\nparagraphCount > 2\n"],["body","\n"],["body","AppleScript提供布尔常数 “true” 和 “false” 作为评估布尔操作的结果。但是脚本很少需要显式使用这些文字，因为布尔表达式本身的计算结果是布尔值。例如，考虑以下两个脚本片段:"],["body","\n"],["body","if companyName is equal to \"Acme Baking\" then\n    return true\nelse\n    return false\nend if\n \nreturn companyName is equal to \"Acme Baking\"\n"],["body","\n"],["headingLink","discussion"],["heading","Discussion"],["body","\n"],["body","When you pass a Boolean value as a parameter to a command, the form may change when you compile the command. For example, the following line"],["body","\n"],["body","当您将布尔值作为参数传递给命令时，在编译命令时，表单可能会发生变化。例如，下面的行"],["body","\n"],["body","choose folder showing package contents true\n"],["body","\n"],["body","is converted to this when compiled by AppleScript:"],["body","\n"],["body","choose folder with showing package contents\n"],["body","\n"],["body","AppleScript从布尔形式编译参数表达式是标准的  (such as showing package contents true or invisibles false) into the with form (with showing package contents or without invisibles, respectively)."],["body","\n\n\n\n"],["body","\n\n                    "],["body","\n\n                    \n                \n            \n\n            \n\n        \n\n\n\n\n        \n\n\n\n        \n        \n        \n\n        \n\n\n    \n    \n"]],[["_relative_fp","6.AppleScript/6.ClassReference/4.class.html"],["title","class - 各项编程语言"],["body","\n    \n        \n        \n\n        \n        \n\n        \n        \n\n        \n        \n\n        \n\n        \n\n            \n                                \n                \n                    \n                        "],["body","\n                            \n                        "],["body","\n                        "],["body","\n                            \n                        "],["body","\n                        \n                            "],["body","Light"],["body","\n                            "],["body","Rust"],["body","\n                            "],["body","Coal"],["body","\n                            "],["body","Navy"],["body","\n                            "],["body","Ayu"],["body","\n                        \n                    \n\n                    "],["heading","各项编程语言"],["body","\n\n                    \n\n                    \n                \n\n\n                \n                \n\n                \n                    "],["body","\n                        \n\n"],["body","\n"],["body","\n\n"],["headingLink","class"],["heading","class"],["body","\n\n"],["body","\n"],["body","Specifies the class of an object or value."],["body","\n"],["body","\n"],["body","\n"],["body","All classes have a class property that specifies the class type. The value of the class property is an identifier."],["body","\n"],["body","\n\n"],["headingLink","properties-of-class-objects"],["heading","Properties of class objects"],["body","\n"],["body","class\n \tAccess:\tread only\n \tClass:\tclass\n \tThe class identifier for the object. The value of this property is always class.\n"],["body","\n"],["headingLink","operators"],["heading","Operators"],["body","\n"],["body","The operators that take class identifier values as operands are &, =, ≠, and as."],["body","\n"],["body","The coercion operator as takes an object of one class type and coerces it to an object of a type specified by a class identifier. For example, the following statement coerces a text object into a corresponding real:"],["body","\n"],["body","\"1.5\" as real --result: 1.5\n"],["body","\n"],["headingLink","coercions-supported"],["heading","Coercions Supported"],["body","\n"],["body","AppleScript supports coercion of a class identifier to a single-item list or a text object."],["body","\n"],["headingLink","examples"],["heading","Examples"],["body","\n"],["body","Asking for the class of a type such as integer results in a value of class:"],["body","\n"],["body","class of text --result: class\nclass of integer --result: class\n"],["body","\n"],["body","Here is the class of a boolean literal:"],["body","\n"],["body","class of true --result: boolean\n"],["body","\n"],["body","And here are some additional examples:"],["body","\n"],["body","class of \"Some text\" --result: text\nclass of {1, 2, \"hello\"} --result: list\n\n"],["body","\n\n\n\n"],["body","\n\n                    "],["body","\n\n                    \n                \n            \n\n            \n\n        \n\n\n\n\n        \n\n\n\n        \n        \n        \n\n        \n\n\n    \n    \n"]],[["_relative_fp","6.AppleScript/6.ClassReference/12.real.html"],["title","real - 各项编程语言"],["body","\n    \n        \n        \n\n        \n        \n\n        \n        \n\n        \n        \n\n        \n\n        \n\n            \n                                \n                \n                    \n                        "],["body","\n                            \n                        "],["body","\n                        "],["body","\n                            \n                        "],["body","\n                        \n                            "],["body","Light"],["body","\n                            "],["body","Rust"],["body","\n                            "],["body","Coal"],["body","\n                            "],["body","Navy"],["body","\n                            "],["body","Ayu"],["body","\n                        \n                    \n\n                    "],["heading","各项编程语言"],["body","\n\n                    \n\n                    \n                \n\n\n                \n                \n\n                \n                    "],["body","\n                        \n\n"],["body","\n"],["body","\n\n"],["headingLink","real"],["heading","real"],["body","\n"],["body","可以包括小数部分的数字，例如3.14159和1.0。"],["body","\n"],["headingLink","properties-of-real-objects"],["heading","Properties of real objects"],["body","\n"],["body","class\n \tAccess:\tread-only\n \tClass:\tclass\n \tThe class identifier for the object. The value of this property is always real.\n\n"],["body","\n"],["headingLink","operators"],["heading","Operators"],["body","\n"],["body","The operators that can have real values as operands are +, -, *, ÷ (or /), div, mod, ^, =, ≠, >, ≥, <, and ≤."],["body","\n"],["body","The ÷ and / operators always return real values as their results. The +, -, *, mod, and ^ operators return real values if either of their operands is a real value."],["body","\n"],["headingLink","coercions-supported"],["heading","Coercions Supported"],["body","\n"],["body","AppleScript supports coercion of a real value to an integer value, rounding any fractional part."],["body","\n"],["body","AppleScript also supports coercion of a real value to a single-item list or a text object. Coercion to text uses the decimal separator specified in Numbers in the Formats pane in International preferences."],["body","\n"],["headingLink","examples"],["heading","Examples"],["body","\n"],["body","10.2579432\n1.0\n1.\n"],["body","\n"],["body","As shown in the third example, a decimal point indicates a real number, even if there is no fractional part."],["body","\n"],["body","Real numbers can also be written using exponential notation. A letter e is preceded by a real number (without intervening spaces) and followed by an integer exponent (also without intervening spaces). The exponent can be either positive or negative. To obtain the value, the real number is multiplied by 10 to the power indicated by the exponent, as in these examples:"],["body","\n"],["body","1.0e5 --equivalent to 1.0 * 10^5, or 100000\n1.0e+5 --same as 1.0e5\n1.0e-5 --equivalent to 1.0 * 10^-5, or .00001\n"],["body","\n"],["headingLink","discussion"],["heading","Discussion"],["body","\n"],["body","Real numbers that are greater than or equal to 10,000.0 or less than or equal to 0.0001 are converted to exponential notation when scripts are compiled. The largest value that can be evaluated (positive or negative) is 1.797693e+308."],["body","\n\n\n\n"],["body","\n\n                    "],["body","\n\n                    \n                \n            \n\n            \n\n        \n\n\n\n\n        \n\n\n\n        \n        \n        \n\n        \n\n\n    \n    \n"]],[["_relative_fp","6.AppleScript/6.ClassReference/index.html"],["title","6.ClassReference - 各项编程语言"],["body","\n    \n        \n        \n\n        \n        \n\n        \n        \n\n        \n        \n\n        \n\n        \n\n            \n                                \n                \n                    \n                        "],["body","\n                            \n                        "],["body","\n                        "],["body","\n                            \n                        "],["body","\n                        \n                            "],["body","Light"],["body","\n                            "],["body","Rust"],["body","\n                            "],["body","Coal"],["body","\n                            "],["body","Navy"],["body","\n                            "],["body","Ayu"],["body","\n                        \n                    \n\n                    "],["heading","各项编程语言"],["body","\n\n                    \n\n                    \n                \n\n\n                \n                \n\n                \n                    "],["body","\n                        \n\n"],["body","\n"],["body","\n\n"],["headingLink","class-reference"],["heading","Class Reference"],["body","\n\n"],["body","\n"],["body","一个 class 是共享特征的对象的类别。AppleScript为脚本中使用的常见对象定义类，如别名、布尔值、整数、文本等。"],["body","\n"],["body","\n"],["body","\n"],["body","脚本中的每个对象都是特定类的实例，具有相同的属性 (包括 “类” 属性)，可以包含相同类型的元素，并且支持与该类型的其他对象相同类型的操作和强制。"],["body","\n"],["body","\n"],["body","\n"],["body","作为AppleScript类型实例的对象可以在脚本中的任何位置使用-它们不需要位于指定应用程序的 tell 块中。"],["body","\n"],["body","\n"],["body","\n"],["body","可编写脚本的应用程序还定义自己的类，例如windows和文档，这些类通常包含基于本章中描述的许多基本AppleScript类的属性和元素"],["body","\n"],["body","\n"],["body","\n"],["body","脚本在定义它们的应用程序的上下文中获取这些对象。有关应用程序通常支持的类类型的更多信息，请参阅技术说明TN2106，脚本接口指南 中的 “标准类”。"],["body","\n"],["body","\n\n\n\n\n"],["body","\n\n                    "],["body","\n\n                    \n                \n            \n\n            \n\n        \n\n\n\n\n        \n\n\n\n        \n        \n        \n\n        \n\n\n    \n    \n"]],[["_relative_fp","6.AppleScript/6.ClassReference/9.list.html"],["title","list - 各项编程语言"],["body","\n    \n        \n        \n\n        \n        \n\n        \n        \n\n        \n        \n\n        \n\n        \n\n            \n                                \n                \n                    \n                        "],["body","\n                            \n                        "],["body","\n                        "],["body","\n                            \n                        "],["body","\n                        \n                            "],["body","Light"],["body","\n                            "],["body","Rust"],["body","\n                            "],["body","Coal"],["body","\n                            "],["body","Navy"],["body","\n                            "],["body","Ayu"],["body","\n                        \n                    \n\n                    "],["heading","各项编程语言"],["body","\n\n                    \n\n                    \n                \n\n\n                \n                \n\n                \n                    "],["body","\n                        \n\n"],["body","\n"],["body","\n\n"],["headingLink","list"],["heading","list"],["body","\n\n"],["body","值的有序集合。列表中包含的值称为项目。每个项目都可以属于任何一个类。"],["body","\n"],["body","列表在脚本中显示为大括号中包含的一系列表达式，并用逗号分隔。"],["body","\n"],["body","空列表是不包含任何项目的列表"],["body","\n"],["body","It is represented by a pair of empty braces: {}."],["body","\n\n"],["headingLink","properties-of-list-objects"],["heading","Properties of list objects"],["body","\n"],["body","class\n \tAccess:\tread-only\n \tClass:\tclass\n \tThe class identifier for the object. The value of this property is always list.\nlength\n \tAccess:\tread only\n \tClass:\tinteger\n \tSpecifies the number of items in the list.\nrest\n \tAccess:\tread only\n \tClass:\tlist\n \tA list containing all items in the list except the first item.\nreverse\n \tAccess:\tread only\n \tClass:\tlist\n \tA list containing all items in the list, but in the opposite order\n"],["body","\n"],["headingLink","elements-of-list-objects"],["heading","Elements of list objects"],["body","\n"],["body","item\n \t\nA value contained in the list. Each value contained in a list is an item and an item may itself be another list. You can refer to values by their item numbers. For example, item 2 of {\"soup\", 2, \"nuts\"} is the integer 2.\n\nYou can also refer to indexed list items by class. For example, integer 1 of {\"oatmeal\", 42, \"new\"} returns 42\n"],["body","\n"],["headingLink","operators"],["heading","Operators"],["body","\n\n"],["body","\n"],["body","The operators that can have list values as operands are &, =, ≠, starts with, ends with, contains, and is contained by."],["body","\n"],["body","\n"],["body","\n"],["body","For detailed explanations and examples of how AppleScript operators treat lists, see Operators Reference."],["body","\n"],["body","\n\n"],["headingLink","commands-handled"],["heading","Commands Handled"],["body","\n"],["body","You can count the items in a list or the elements of a specific class in a list with the count command. You can also use the length property of a list:"],["body","\n"],["body","`count {\"a\", \"b\", \"c\", 1, 2, 3} --result: 6`\n`length of {\"a\", \"b\", \"c\", 1, 2, 3} --result: 6`\n"],["body","\n"],["headingLink","coercions-supported"],["heading","Coercions Supported"],["body","\n\n"],["body","AppleScript supports coercion of a single-item list to any class to which the item can be coerced if it is not part of a list."],["body","\n"],["body","AppleScript支持将单个项目列表强制执行到可以强制执行该项目的任何类 (如果它不是列表的一部分)。"],["body","\n"],["body","如果可以将列表中的每个项目强制为 “文本” 对象，则AppleScript还支持将整个列表强制为 “文本” 对象，如以下示例所示:"],["body","\n\n"],["body","{5, \"George\", 11.43, \"Bill\"} as text --result: \"5George11.43Bill\"\n"],["body","\n\n"],["body","\n"],["body","生成的 “文本” 对象连接所有项目，由AppleScript属性  text item delimiters  的当前值分隔。"],["body","\n"],["body","\n"],["body","\n"],["body","此属性默认为空字符串，因此将项目简单地连接起来, see text item delimiters."],["body","\n"],["body","\n"],["body","\n"],["body","列表中的单个项目可以是任何类，AppleScript支持将任何值强制包含单个项目的列表."],["body","\n"],["body","\n\n"],["headingLink","examples"],["heading","Examples"],["body","\n"],["body","The following statement defines a list that contains a text object, an integer, and a Boolean value:"],["body","\n"],["body","{ \"it's\", 2, true }\n"],["body","\n"],["body","Each list item can be any valid expression. The following list has the same value as the previous list:"],["body","\n"],["body","{ \"it\" & \"'s\", 1 + 1, 4 > 3 }\n"],["body","\n"],["body","以下语句与列表一起工作; 请注意，连接运算符 ('&') 将两个列表合并为一个列表:"],["body","\n"],["body","class of {\"this\", \"is\", \"a\", \"list\"} --result: list\nitem 3 of {\"this\", \"is\", \"a\", \"list\"} --result: \"a\"\nitems 2 thru 3 of {\"soup\", 2, \"nuts\"} --result: {2, \"nuts\"}\n{\"This\"} & {\"is\", \"a\", \"list\"} --result: {\"This\", \"is\", \"a\", \"list\"}\n"],["body","\n\n"],["body","\n"],["body","对于大型列表，在将大量项目插入列表时使用 a reference to operator 更有效，而不是直接访问列表"],["body","\n"],["body","\n"],["body","\n"],["body","例如，使用直接访问，以下脚本大约需要10秒来创建10,000整数列表 (结果会因计算机和其他因素而异):"],["body","\n"],["body","\n"],["body","\n"],["body","set bigList to {}\nset numItems to 10000\nset t to (time of (current date)) --Start timing operations\nrepeat with n from 1 to numItems\n    copy n to the end of bigList\n    -- DON'T DO THE FOLLOWING--it's even slower!\n    -- set bigList to bigList & n\nend\nset total to (time of (current date)) - t --End timing\n"],["body","\n"],["body","\n\n"],["body","But the following script, which uses the a reference to operator, creates a list of 100,000 integers (ten times the size) in just a couple of seconds (again, results may vary):"],["body","\n"],["body","set bigList to {}\nset bigListRef to a reference to bigList\nset numItems to 100000\nset t to (time of (current date)) --Start timing operations\nrepeat with n from 1 to numItems\n    copy n to the end of bigListRef\nend\nset total to (time of (current date)) - t --End timing\n"],["body","\n"],["body","同样，使用 a reference to 访问先前创建的列表中的项目要快得多-以下仅需几秒钟:"],["body","\n"],["body","set t to (time of (current date)) --Start timing\nrepeat with n from 1 to numItems -- where numItems = 100,000\n    item n of bigListRef\nend repeat\nset total to (time of (current date)) - t --End timing\n"],["body","\n"],["body","但是，直接访问列表 (即使仅用于4,000项目) 也可能需要一分钟以上的时间:"],["body","\n"],["body","set numItems to 4000\nset t to (time of (current date)) --Start timing\nrepeat with n from 1 to numItems\n    item n of bigList\nend repeat\nset total to (time of (current date)) - t --End timing\n"],["body","\n\n\n\n"],["body","\n\n                    "],["body","\n\n                    \n                \n            \n\n            \n\n        \n\n\n\n\n        \n\n\n\n        \n        \n        \n\n        \n\n\n    \n    \n"]],[["_relative_fp","6.AppleScript/6.ClassReference/11.POSIXfile.html"],["title","POSIXfile - 各项编程语言"],["body","\n    \n        \n        \n\n        \n        \n\n        \n        \n\n        \n        \n\n        \n\n        \n\n            \n                                \n                \n                    \n                        "],["body","\n                            \n                        "],["body","\n                        "],["body","\n                            \n                        "],["body","\n                        \n                            "],["body","Light"],["body","\n                            "],["body","Rust"],["body","\n                            "],["body","Coal"],["body","\n                            "],["body","Navy"],["body","\n                            "],["body","Ayu"],["body","\n                        \n                    \n\n                    "],["heading","各项编程语言"],["body","\n\n                    \n\n                    \n                \n\n\n                \n                \n\n                \n                    "],["body","\n                        \n\n"],["body","\n"],["body","\n\n"],["headingLink","posix-file"],["heading","POSIX file"],["body","\n\n"],["body","与 'file' 类等效的伪类。"],["body","\n"],["body","从来没有一个对象的类是 'POSIX file '；"],["body","\n"],["body","评估 POSIX文件说明符的结果是一个 “文件” 对象"],["body","\n"],["body","“文件” 和 “posix文件” 对象之间的区别在于它们如何解释名称说明符"],["body","\n"],["body","a POSIX file object interprets \"name\" as a POSIX path, while a file object interprets it as an HFS path."],["body","\n"],["body","For related information, see alias and file. For a description of the format for a POSIX path, see Aliases and Files."],["body","\n\n"],["headingLink","properties-of-posix-file-objects"],["heading","Properties of POSIX file objects"],["body","\n"],["body","See file."],["body","\n"],["headingLink","coercions-supported"],["heading","Coercions Supported"],["body","\n"],["body","See file."],["body","\n"],["headingLink","examples"],["heading","Examples"],["body","\n"],["body","The following example asks the user to specify a file name, starting in the temporary directory /tmp, which is difficult to specify using a file specifier:"],["body","\n"],["body","set fileName to choose file name default location (POSIX file \"/tmp\")\n    -result: dialog starts in /tmp folder\n"],["body","\n\n\n\n"],["body","\n\n                    "],["body","\n\n                    \n                \n            \n\n            \n\n        \n\n\n\n\n        \n\n\n\n        \n        \n        \n\n        \n\n\n    \n    \n"]],[["_relative_fp","6.AppleScript/6.ClassReference/18.unitTypes.html"],["title","unitTypes - 各项编程语言"],["body","\n    \n        \n        \n\n        \n        \n\n        \n        \n\n        \n        \n\n        \n\n        \n\n            \n                                \n                \n                    \n                        "],["body","\n                            \n                        "],["body","\n                        "],["body","\n                            \n                        "],["body","\n                        \n                            "],["body","Light"],["body","\n                            "],["body","Rust"],["body","\n                            "],["body","Coal"],["body","\n                            "],["body","Navy"],["body","\n                            "],["body","Ayu"],["body","\n                        \n                    \n\n                    "],["heading","各项编程语言"],["body","\n\n                    \n\n                    \n                \n\n\n                \n                \n\n                \n                    "],["body","\n                        \n\n"],["body","\n"],["body","\n\n"],["headingLink","unit-types"],["heading","unit types"],["body","\n\n"],["body","用于测量长度，面积，立方和液体体积，质量和温度。"],["body","\n"],["body","单元类型类 支持简单的对象，这些对象不包含其他值，并且只有一个属性，即 'class' 属性。"],["body","\n\n"],["headingLink","properties-of-unit-type-objects"],["heading","Properties of unit type objects"],["body","\n"],["body","class\n \tAccess:\tread only\n \tClass:\t(varies; listed below)\n \tThe class identifier for the object. These are the available classes:\n \tLength: centimetres, centimeters, feet, inches, kilometres, kilometers, metres, meters, miles, yards\n \tArea: square feet, square kilometres, square kilometers, square metres, square meters, square miles, square yards\n \tCubic volume: cubic centimetres, cubic centimeters, cubic feet, cubic inches, cubic metres, cubic meters, cubic yards\n \tLiquid volume: gallons, litres, liters, quarts\n \tWeight: grams, kilograms, ounces, pounds\n \tTemperature: degrees Celsius, degrees Fahrenheit, degrees Kelvin\n\n"],["body","\n"],["headingLink","operators"],["heading","Operators"],["body","\n"],["body","None. You must explicitly coerce a unit type to a number type before you can perform operations with it."],["body","\n"],["headingLink","coercions-supported"],["heading","Coercions Supported"],["body","\n"],["body","You can coerce a unit type object to integer, single-item list, real, or text. You can also coerce between unit types in the same category, such as inches to kilometers (length) or gallons to liters (liquid volume). As you would expect, there is no coercion between categories, such as from gallons to degrees Centigrade."],["body","\n"],["headingLink","examples"],["heading","Examples"],["body","\n"],["body","以下语句计算半径为7码的圆的面积，然后将面积强制为平方英尺:"],["body","\n"],["body","set circleArea to (pi * 7 * 7) as square yards --result: square yards 153.9380400259\ncircleArea as square feet --result: square feet 1385.4423602331\n"],["body","\n"],["body","以下语句将变量设置为5.0平方公里，然后将其强制为其他各种面积单位:"],["body","\n"],["body","set theArea to 5.0 as square kilometers --result: square kilometers 5.0\ntheArea as square miles --result: square miles 1.930510792712\ntheArea as square meters --result: square meters 5.0E+6\n"],["body","\n"],["body","但是，您不能将面积度量强制转换为不同类别中的单位类型:"],["body","\n"],["body","set theArea to 5.0 as square meters --result: square meters 5.0\ntheArea as cubic meters --result: error\ntheArea as degrees Celsius --result: error\n"],["body","\n"],["body","以下语句演示了将单元类型强制到 “文本” 对象:"],["body","\n"],["body","set myPounds to 2.2 as pounds --result: pounds 2.2\nset textValue to myPounds as text --result: \"2.2\"\n"],["body","\n\n\n\n"],["body","\n\n                    "],["body","\n\n                    \n                \n            \n\n            \n\n        \n\n\n\n\n        \n\n\n\n        \n        \n        \n\n        \n\n\n    \n    \n"]],[["_relative_fp","6.AppleScript/6.ClassReference/6.date.html"],["title","date - 各项编程语言"],["body","\n    \n        \n        \n\n        \n        \n\n        \n        \n\n        \n        \n\n        \n\n        \n\n            \n                                \n                \n                    \n                        "],["body","\n                            \n                        "],["body","\n                        "],["body","\n                            \n                        "],["body","\n                        \n                            "],["body","Light"],["body","\n                            "],["body","Rust"],["body","\n                            "],["body","Coal"],["body","\n                            "],["body","Navy"],["body","\n                            "],["body","Ayu"],["body","\n                        \n                    \n\n                    "],["heading","各项编程语言"],["body","\n\n                    \n\n                    \n                \n\n\n                \n                \n\n                \n                    "],["body","\n                        \n\n"],["body","\n"],["body","\n\n"],["headingLink","date"],["heading","Date"],["body","\n"],["body","Specifies the day of the week, the date (month, day of the month, and year), and the time (hours, minutes, and seconds)."],["body","\n"],["body","To get the current date, use the command current date:"],["body","\n"],["body","set theDate to current date\n--result: \"Friday, November 9, 2007 11:35:50 AM\"\n"],["body","\n\n"],["body","\n"],["body","您可以通过下面描述的日期和时间属性获取并设置 “日期” 对象的不同部分。"],["body","\n"],["body","\n"],["body","\n"],["body","编译脚本时，AppleScript会根据系统首选项中指定的格式显示日期和时间值"],["body","\n"],["body","\n\n"],["headingLink","properties-of-date-objects"],["heading","Properties of date objects"],["body","\n"],["body","class\n \tAccess:\tread only\n \tClass:\tclass\n \tThe class identifier for the object. The value of this property is always date.\n \t\n \t\nday\n \tAccess:\tread/write\n \tClass:\tinteger\n \tSpecifies the day of the month of a date object.\nweekday\n \tAccess:\tread only\n \tClass:\tconstant\n \tSpecifies the day of the week of a date object, with one of these constants: Monday, Tuesday, Wednesday, Thursday, Friday, Saturday, or Sunday.\nmonth\n \tAccess:\tread/write\n \tClass:\tconstant\n \tSpecifies the month of the year of a date object, with one of the constants January, February, March, April, May, June, July, August, September, October, November, or December.\nyear\n \tAccess:\tread/write\n \tClass:\tinteger\n \tSpecifies the year of a date object; for example, 2004.\ntime\n \tAccess:\tread/write\n \tClass:\tinteger\n \tSpecifies the number of seconds since midnight of a date object; for example, 2700 is equivalent to 12:45 AM (2700 / 60 seconds = 45 minutes).\ndate string\n \tAccess:\tread only\n \tClass:\ttext\n \tA text object that specifies the date portion of a date object; for example, \"Friday, November 9, 2007\".\n \tTo obtain a compact version of the date, use short date string . For example, short date string of (current date) --result: \"1/27/08\".\ntime string\n \tAccess:\tread only\n \tClass:\ttext\n \tA text object that specifies the time portion of a date object; for example, \"3:20:24 PM\".\n\n"],["body","\n"],["headingLink","operators"],["heading","Operators"],["body","\n\n"],["body","\n"],["body","The operators that take date object as operands are &, +, –, =, ≠, >, ≥, <, ≤, comes before, comes after, and as. "],["body","\n"],["body","\n"],["body","\n"],["body","In expressions containing >, ≥, <, ≤, comes before, or comes after, a later time is greater than an earlier time."],["body","\n"],["body","\n"],["body","\n"],["body","AppleScript supports the following operations on date objects with the + and – operators:"],["body","\n\n"],["body","\n"],["body","date + timeDifference\n--result: date\ndate - date\n--result: timeDifference\ndate - timeDifference\n--result: date\n"],["body","\n"],["body","\n\n"],["body","\n"],["body","\n"],["body","其中 'timeDifference' 是一个 'integer' 值，指定以秒为单位的时间差。为了简化时间差的表示法，您还可以使用这些常数中的一个或多个:"],["body","\n\n"],["body","\n"],["body","minutes\n    60\nhours\n    60 * minutes\ndays\n    24 * hours\nweeks\n    7 * days\n"],["body","\n"],["body","\n"],["body","\n"],["body","date \"Friday, November 9, 2007\" + 4 * days + 3 * hours + 2 *  minutes\n--result: date \"Tuesday, November 13, 2007 3:02:00 AM\"\n"],["body","\n"],["body","\n"],["body","\n"],["body","To express a time difference in more convenient form, divide the number of seconds by the appropriate constant:"],["body","\n\n"],["body","\n"],["body","31449600 / weeks --result: 52.0\n"],["body","\n"],["body","\n"],["body","\n"],["body","要获得小时数、天数等的整数，请使用div运算符:"],["body","\n"],["body","151200 div days --result: 1\n"],["body","\n"],["body","\n"],["body","\n"],["body","To get the difference, in seconds, between the current time and Greenwich mean time, use the time to GMT command."],["body","\n"],["body","\n\n"],["body","\n\n"],["body","\n\n"],["headingLink","coercions-supported"],["heading","Coercions Supported"],["body","\n"],["body","AppleScript supports coercion of a date object to a single-item list or a text object."],["body","\n"],["headingLink","examples"],["heading","Examples"],["body","\n"],["body","下面的表达式显示了一些指定日期的选项，以及编译语句的结果。"],["body","\n"],["body","如果仅使用部分信息构造日期，则AppleScript会用默认值填充缺失的部分"],["body","\n"],["body","实际格式基于系统首选项中的设置。"],["body","\n"],["body","date \"8/9/2007, 17:06\"\n     --result: date \"Thursday, August 9, 2007 5:06:00 PM\"\ndate \"7/16/70\"\n     --result: date \"Wednesday, July 16, 2070 12:00:00 AM\"\ndate \"12:06\" -- specifies a time on the current date\n     --result: date \"Friday, November 9, 2007 12:06:00 PM\"\ndate \"Sunday, December 12, 1954 12:06 pm\"\n     --result: date \"Sunday, December 12, 1954 12:06:00 PM\"\n"],["body","\n"],["body","以下语句访问各种日期属性 (结果取决于语句执行的日期):"],["body","\n"],["body","set theDate to current date --using current date command\n--result: date \"Friday, November 9, 2007 11:58:38 AM\"\nweekday of theDate --result: Friday\nday of theDate --result: 9\nmonth of theDate --result: November\nyear of theDate --result: 2007\ntime of theDate --result: 43118 (seconds since 12:00:00 AM)\ntime string of theDate --result: \"11:58:38 AM\"\ndate string of theDate --result: \"Friday, November 9, 2007\"\n"],["body","\n"],["body","如果要指定相对于日期的时间，可以使用 'of' 、 'relative to' 或 'in' 来指定，如下面的示例所示。"],["body","\n"],["body","date \"2:30 am\" of date \"Jan 1, 2008\"\n    --result: date \"Tuesday, January 1, 2008 2:30:00 AM\"\ndate \"2:30 am\" of date \"Sun Jan 27, 2008\"\n    --result: date \"Sunday, January 27, 2008 2:30:00 AM\"\ndate \"Nov 19, 2007\" relative to date \"3PM\"\n    --result: date \"Monday, November 19, 2007 3:00:00 PM\"\ndate \"1:30 pm\" in date \"April 1, 2008\"\n    --result: date \"Tuesday, April 1, 2008 1:30:00 PM\"\n"],["body","\n"],["headingLink","special-considerations"],["heading","Special Considerations"],["body","\n"],["body","您可以使用遵循 “International preferences.” 中的 “格式” 窗格中指定的日期格式的字符串创建日期对象。例如，在美国英语中:"],["body","\n"],["body","set myDate to date \"3/4/2008\"\n\n# When you compile this statement, it is converted to the following:\n\nset myDate to date \"Tuesday, March 4, 2008 12:00:00 AM\"\n"],["body","\n\n\n\n"],["body","\n\n                    "],["body","\n\n                    \n                \n            \n\n            \n\n        \n\n\n\n\n        \n\n\n\n        \n        \n        \n\n        \n\n\n    \n    \n"]],[["_relative_fp","6.AppleScript/6.ClassReference/14.reference.html"],["title","reference - 各项编程语言"],["body","\n    \n        \n        \n\n        \n        \n\n        \n        \n\n        \n        \n\n        \n\n        \n\n            \n                                \n                \n                    \n                        "],["body","\n                            \n                        "],["body","\n                        "],["body","\n                            \n                        "],["body","\n                        \n                            "],["body","Light"],["body","\n                            "],["body","Rust"],["body","\n                            "],["body","Coal"],["body","\n                            "],["body","Navy"],["body","\n                            "],["body","Ayu"],["body","\n                        \n                    \n\n                    "],["heading","各项编程语言"],["body","\n\n                    \n\n                    \n                \n\n\n                \n                \n\n                \n                    "],["body","\n                        \n\n"],["body","\n"],["body","\n\n"],["headingLink","reference"],["heading","reference"],["body","\n\n"],["body","\n"],["body","封装对象说明符的对象。"],["body","\n"],["body","\n"],["body","\n"],["body","a reference to 运算符的结果是 reference 对象，从应用程序命令返回的对象说明符隐式地变成 引用”对象。"],["body","\n"],["body","\n"],["body","\n"],["body","A reference object “wraps” an object specifier. "],["body","\n"],["body","\n"],["body","\n"],["body","如果对 reference对象  使用 “get” 命令，则该命令将返回 “引用” 对象本身。"],["body","\n"],["body","\n"],["body","\n"],["body","如果请求 reference 对象的 contents 属性 它返内部的对象说明符"],["body","\n"],["body","\n"],["body","\n"],["body","对 引用 对象的所有其他请求都转发到其内部的对象说明符"],["body","\n"],["body","\n"],["body","\n"],["body","For example, if you ask for the class of a reference object, you get the class of the object specified by its object specifier.For related information, see Object Specifiers."],["body","\n"],["body","\n\n"],["headingLink","properties-of-reference-objects"],["heading","Properties of reference objects"],["body","\n"],["body","除了 “contents” 属性之外，所有其他属性请求都将转发到随附的对象说明符，因此引用对象似乎具有引用对象的所有属性。"],["body","\n"],["body","contents\n \tAccess:\tdepends on the referenced object or objects\n \tClass:\tdepends on the referenced object or objects\n \tThe enclosed object specifier.\n\n\n\n"],["body","\n"],["headingLink","operators"],["heading","Operators"],["body","\n\n"],["body","\n"],["body","所有运算符都转发到封闭的对象说明符，因此引用对象似乎支持引用对象的所有运算符。"],["body","\n"],["body","\n"],["body","\n"],["body","The a reference to operator returns a reference object as its result."],["body","\n"],["body","\n\n"],["headingLink","coercions-supported"],["heading","Coercions Supported"],["body","\n"],["body","All coercions are forwarded to the enclosed object specifier, so the reference object appears to support all the coercions of referenced object."],["body","\n"],["headingLink","examples"],["heading","Examples"],["body","\n"],["body","引用对象最常用于指定应用程序对象。下面的示例在TextEdit应用程序中创建一个对窗口的引用:"],["body","\n"],["body","set myWindow to a ref to window \"top.rtf\" of application \"TextEdit\"\n--result: window \"top.rtf\" of application \"TextEdit\"\n"],["body","\n"],["body","在随后的脚本语句中，您可以使用变量 mywindow 代替应用程序 “TextEdit” 的较长的术语： window \"top.rtf\" of application \"TextEdit\"."],["body","\n"],["body","因为除了contents of之外的所有属性请求都被转发到其封闭的说明符，所以 引用对象似乎具有被引用对象的所有属性。例如，以下示例中的两个 'class of '语句都返回 'window':"],["body","\n"],["body","set myRef to a reference to window 1\nclass of contents of myRef  -- explicit dereference using \"contents of\"\nclass of myRef  -- implicit dereference\n"],["body","\n"],["body","For additional examples, see the a reference to operator."],["body","\n\n\n\n"],["body","\n\n                    "],["body","\n\n                    \n                \n            \n\n            \n\n        \n\n\n\n\n        \n\n\n\n        \n        \n        \n\n        \n\n\n    \n    \n"]],[["_relative_fp","6.AppleScript/6.ClassReference/10.number.html"],["title","number - 各项编程语言"],["body","\n    \n        \n        \n\n        \n        \n\n        \n        \n\n        \n        \n\n        \n\n        \n\n            \n                                \n                \n                    \n                        "],["body","\n                            \n                        "],["body","\n                        "],["body","\n                            \n                        "],["body","\n                        \n                            "],["body","Light"],["body","\n                            "],["body","Rust"],["body","\n                            "],["body","Coal"],["body","\n                            "],["body","Navy"],["body","\n                            "],["body","Ayu"],["body","\n                        \n                    \n\n                    "],["heading","各项编程语言"],["body","\n\n                    \n\n                    \n                \n\n\n                \n                \n\n                \n                    "],["body","\n                        \n\n"],["body","\n"],["body","\n\n"],["headingLink","number"],["heading","number"],["body","\n\n"],["body","可以表示 “整数” 或 “实数” 的抽象类。"],["body","\n"],["body","从来没有一个对象的类是 “number”; “number” 对象的实际类始终是更具体的类型之一，“整数” 或 “实数”。"],["body","\n\n"],["headingLink","properties-of-number-objects"],["heading","Properties of number objects"],["body","\n"],["body","class\n \tAccess:\tread-only\n \tClass:\tclass\n \tThe class identifier for the object. The value of this property is always either integer or real.\n\n\n\n"],["body","\n"],["headingLink","operators"],["heading","Operators"],["body","\n"],["body","Because values identified as values of class number are really values of either class integer or class real, the operators available are the operators described in the definitions of the integer or real classes."],["body","\n"],["headingLink","coercions-supported"],["heading","Coercions Supported"],["body","\n"],["body","Coercing an object to number results in an integer object if the result of the coercion is an integer, or a real object if the result is a non-integer number."],["body","\n"],["headingLink","examples"],["heading","Examples"],["body","\n"],["body","Any valid literal expression for an integer or a real value is also a valid literal expression for a number value:"],["body","\n"],["body","1\n2\n-1\n1000\n10.2579432\n1.0\n1.\n\n"],["body","\n\n\n\n"],["body","\n\n                    "],["body","\n\n                    \n                \n            \n\n            \n\n        \n\n\n\n\n        \n\n\n\n        \n        \n        \n\n        \n\n\n    \n    \n"]],[["_relative_fp","6.AppleScript/6.ClassReference/2.application.html"],["title","application - 各项编程语言"],["body","\n    \n        \n        \n\n        \n        \n\n        \n        \n\n        \n        \n\n        \n\n        \n\n            \n                                \n                \n                    \n                        "],["body","\n                            \n                        "],["body","\n                        "],["body","\n                            \n                        "],["body","\n                        \n                            "],["body","Light"],["body","\n                            "],["body","Rust"],["body","\n                            "],["body","Coal"],["body","\n                            "],["body","Navy"],["body","\n                            "],["body","Ayu"],["body","\n                        \n                    \n\n                    "],["heading","各项编程语言"],["body","\n\n                    \n\n                    \n                \n\n\n                \n                \n\n                \n                    "],["body","\n                        \n\n"],["body","\n"],["body","\n\n"],["headingLink","application"],["heading","application"],["body","\n\n"],["body","本地计算机或可用服务器上的应用程序。"],["body","\n"],["body","脚本中的应用程序对象具有此处描述的所有属性，这些属性由AppleScript处理。它可能具有额外的属性，这取决于它所指的特定应用。"],["body","\n\n"],["headingLink","properties-of-application-objects"],["heading","Properties of application objects"],["body","\n"],["body","class\n \tAccess:\tread only\n \tClass:\tclass\n\t对象的类标识符。值始终是application。\n \t\n \t\nfrontmost\n \tAccess:\tread only\n \tClass:\tboolean\n \tIs the application frontmost?:应用程序是最前面的吗？\n \tStarting in AppleScript 2.0, accessing an application’s frontmost property returns a Boolean value without launching the application or sending it an event.\n \tThe value of frontmost for background-only applications, UI element applications such as System Events, and applications that are not running is always false.\nid\n \tAccess:\tread only\n \tClass:\ttext\n \tThe application’s bundle identifier (the default) or its four-character signature code. (New in AppleScript 2.0.)\n \tFor example, the bundle identifier for the TextEdit application is \"com.apple.TextEdit\". Its four-character signature code is 'ttxt'. If you ask for an application object’s id property, you will get the bundle identifier version, unless the application does not have a bundle identifier and does have a signature code.\nname\n \tAccess:\tread only\n \tClass:\ttext\n \tThe application’s name.\n \tStarting in AppleScript 2.0, accessing an application’s name property returns the application name as text without launching the application or sending it an event.\nrunning\n \tAccess:\tread only\n \tClass:\tboolean\n \tIs the application running? (New in AppleScript 2.0.)\n \tAccessing an application’s running property returns a Boolean value without launching the application or sending it an event.\n \tYou can also ask the System Events utility application whether an application is running. While it requires more lines in your script to do so, that option is available in earlier versions of the Mac OS.\nversion\n \tAccess:\tread only\n \tClass:\ttext\n \tThe application’s version.\n \tStarting in AppleScript 2.0, accessing this property returns the application version as text without launching the application or sending it an event.\n"],["body","\n"],["headingLink","coercions-supported"],["heading","Coercions Supported"],["body","\n"],["body","AppleScript supports coercion of an application object to a single-item list."],["body","\n"],["headingLink","examples"],["heading","Examples"],["body","\n"],["body","您可以确定当前计算机上的应用程序是否正在运行而不启动它 (如果您的目标在远程计算机上，这将不起作用):"],["body","\n"],["body","tell application \"iTunes\" -- doesn't automatically launch app\n    if it is running then\n        pause\n    end if\nend tell\n"],["body","\n"],["body","You can also use this format:"],["body","\n"],["body","if application \"iTunes\" is running\n    tell application \"iTunes\" to pause\nend if\n"],["body","\n"],["body","以下语句分别通过其签名、捆绑包id和到特定版本的TextEdit的POSIX路径来指定TextEdit应用程序:"],["body","\n"],["body","application id \"ttxt\"\napplication id \"com.apple.TextEdit\"\napplication \"/Applications/TextEdit.app\"\n"],["body","\n"],["body","您可以使用 'tell' 语句来定位远程应用程序。有关详细信息，请参阅 “远程应用程序”。"],["body","\n"],["headingLink","special-considerations"],["heading","Special Considerations"],["body","\n"],["body","从OS X v10.5开始，应用程序行为有几个变化:"],["body","\n\n"],["body","\n"],["body","应用程序启动隐藏"],["body","\n\n"],["body","AppleScript始终会在需要时启动应用程序以向它们发送命令"],["body","\n"],["body","总是明显的启动、这具有视觉破坏性"],["body","\n"],["body","AppleScript现在启动应用程序 默认隐藏. 除非脚本明确表示使用 “activate”，否则它们将不可见。"],["body","\n\n"],["body","\n"],["body","\n"],["body","Applications are located lazily."],["body","\n\n"],["body","\n"],["body","运行脚本时，AppleScript不会尝试定位应用程序，直到它需要发送命令。"],["body","\n"],["body","\n"],["body","\n"],["body","这意味着编译后的脚本或脚本应用程序可能包含对用户系统上不存在的应用程序的引用，但是AppleScript不会询问丢失的应用程序在哪里，直到遇到相关的 “telling” 块"],["body","\n"],["body","\n"],["body","\n"],["body","以前版本的AppleScript将尝试在运行脚本之前找到每个引用的应用程序。"],["body","\n"],["body","\n"],["body","\n"],["body","打开脚本进行编辑时，AppleScript将尝试在整个脚本中找到所有引用的应用程序，这可能意味着询问其中一个应用程序在哪里"],["body","\n"],["body","\n"],["body","\n"],["body","按下取消按钮只会取消对该应用程序的搜索; 该脚本将继续正常打开，尽管该应用程序的自定义术语将显示为原始代码，在较旧的版本中，按 “取消” 将取消打开脚本。."],["body","\n"],["body","\n\n"],["body","\n"],["body","\n"],["body","Applications are located and re-located dynamically."],["body","\n"],["body","Object specifiers that refer to applications, including those in tell blocks, are evaluated every time a script runs. This alleviates problems with scripts getting “stuck” to a particular copy of an application."],["body","\n"],["body","\n\n"],["body","In prior versions of AppleScript, use of the new built-in application properties will fall back to sending an event to the application, but the application may not handle these properties in the same way, or handle them at all. (Most applications will handle name, version, and frontmost; id and running are uncommon.) The other new features described above require AppleScript 2.0"],["body","\n\n\n\n"],["body","\n\n                    "],["body","\n\n                    \n                \n            \n\n            \n\n        \n\n\n\n\n        \n\n\n\n        \n        \n        \n\n        \n\n\n    \n    \n"]],[["_relative_fp","6.AppleScript/6.ClassReference/13.record.html"],["title","record - 各项编程语言"],["body","\n    \n        \n        \n\n        \n        \n\n        \n        \n\n        \n        \n\n        \n\n        \n\n            \n                                \n                \n                    \n                        "],["body","\n                            \n                        "],["body","\n                        "],["body","\n                            \n                        "],["body","\n                        \n                            "],["body","Light"],["body","\n                            "],["body","Rust"],["body","\n                            "],["body","Coal"],["body","\n                            "],["body","Navy"],["body","\n                            "],["body","Ayu"],["body","\n                        \n                    \n\n                    "],["heading","各项编程语言"],["body","\n\n                    \n\n                    \n                \n\n\n                \n                \n\n                \n                    "],["body","\n                        \n\n"],["body","\n"],["body","\n\n"],["headingLink","record"],["heading","record"],["body","\n\n"],["body","\n"],["body","标记属性的无序集合"],["body","\n"],["body","\n"],["body","\n"],["body","唯一支持用户定义属性的AppleScript类： record and script."],["body","\n"],["body","\n"],["body","\n"],["body","record 作为大括号中包含的一系列属性定义出现在脚本中，并用逗号分隔"],["body","\n"],["body","\n"],["body","\n"],["body","每个属性定义由标签、冒号和属性的值组成。"],["body","\n"],["body","\n"],["body","\n"],["body","例如，这是一个具有两个属性的记录: {product:\"pen\", price:2.34}."],["body","\n"],["body","\n"],["body","\n"],["body","记录中的每个属性都有一个唯一的标签，将其与集合中的其他属性区分开来"],["body","\n"],["body","\n"],["body","\n"],["body","分配给属性的值可以属于任何类，您可以简单地通过分配属于另一个类的值来更改属性的类。"],["body","\n"],["body","\n\n"],["headingLink","properties-of-record-objects"],["heading","Properties of record objects"],["body","\n"],["body","class\n \tAccess:\tread/write\n \tClass:\tclass\n \tThe class identifier for the record. By default, the value is record.\n \tIf you define a class property explicitly in a record, the value you define replaces the implicit class value. In the following example, the class is set to integer:\n \tset myRecord to {class:integer, min:1, max:10}\n \tclass of myRecord --result: integer\nlength\n \tAccess:\tread only\n \tClass:\tinteger\n \tSpecifies the number of properties in the record.\n"],["body","\n"],["headingLink","operators"],["heading","Operators"],["body","\n\n"],["body","\n"],["body","The operators that can have records as operands are &, =, ≠, contains, and is contained by."],["body","\n"],["body","\n"],["body","\n"],["body","For detailed explanations and examples of how AppleScript operators treat records, see Operators Reference."],["body","\n"],["body","\n\n"],["headingLink","commands-handled"],["heading","Commands Handled"],["body","\n"],["body","You can count the properties in a record with the count command:"],["body","\n"],["body","count {name:\"Robin\", mileage:400} --result: 2\n"],["body","\n"],["headingLink","coercions-supported"],["heading","Coercions Supported"],["body","\n"],["body","AppleScript supports coercion of records to lists; however, all labels are lost in the coercion and the resulting list cannot be coerced back to a record."],["body","\n"],["headingLink","examples"],["heading","Examples"],["body","\n"],["body","The following example shows how to change the value of a property in a record:"],["body","\n"],["body","set myRecord to {product:\"pen\", price:2.34}\nproduct of myRecord -- result: \"pen\"\n \nset product of myRecord to \"pencil\"\nproduct of myRecord -- result: \"pencil\"\n"],["body","\n"],["body","AppleScript在其他表达式中使用记录之前，先对记录中的表达式进行评估。例如，以下两个记录是等价的:"],["body","\n"],["body","{ name:\"Steve\", height:76 - 1.5, weight:150 + 20 }\n{ name:\"Steve\", height:74.5, weight:170 }\n"],["body","\n"],["body","不能通过数字索引引用记录中的属性。例如，下面的对象说明符 (在记录上使用索引引用形式) 无效。"],["body","\n"],["body","item 2 of { name:\"Rollie\", IQ:186, city:\"Unknown\" } --result: error\n"],["body","\n"],["body","您可以访问记录的length属性来计算它包含的属性:"],["body","\n"],["body","length of {name:\"Chris\", mileage:1957, city:\"Kalamazoo\"} --result: 3\n"],["body","\n"],["body","您可以使用 'count' 命令获得相同的值:"],["body","\n"],["body","count {name:\"Chris\", mileage:1957, city:\"Kalamazoo\"} --result: 3\n"],["body","\n"],["headingLink","discussion"],["heading","Discussion"],["body","\n"],["body","After you define a record, you cannot add additional properties to it. You can, however, concatenate records. For more information, see & (concatenation)."],["body","\n"],["body","定义记录后，无法向其添加其他属性。但是，您可以连接记录。有关更多信息，请参见 '& (连接)'。"],["body","\n\n\n\n"],["body","\n\n                    "],["body","\n\n                    \n                \n            \n\n            \n\n        \n\n\n\n\n        \n\n\n\n        \n        \n        \n\n        \n\n\n    \n    \n"]],[["_relative_fp","6.AppleScript/6.ClassReference/15.RGBcolor.html"],["title","RGBcolor - 各项编程语言"],["body","\n    \n        \n        \n\n        \n        \n\n        \n        \n\n        \n        \n\n        \n\n        \n\n            \n                                \n                \n                    \n                        "],["body","\n                            \n                        "],["body","\n                        "],["body","\n                            \n                        "],["body","\n                        \n                            "],["body","Light"],["body","\n                            "],["body","Rust"],["body","\n                            "],["body","Coal"],["body","\n                            "],["body","Navy"],["body","\n                            "],["body","Ayu"],["body","\n                        \n                    \n\n                    "],["heading","各项编程语言"],["body","\n\n                    \n\n                    \n                \n\n\n                \n                \n\n                \n                    "],["body","\n                        \n\n"],["body","\n"],["body","\n\n"],["headingLink","rgb-color"],["heading","RGB color"],["body","\n"],["body","A type definition for a three-item list of integer values, from 0 to 65535, that specify the red, green, and blue components of a color."],["body","\n"],["body","Otherwise, behaves exactly like a list object."],["body","\n"],["headingLink","examples"],["heading","Examples"],["body","\n"],["body","set whiteColor to {65535, 65535, 65535} -- white\nset yellowColor to {65535, 65535, 0} -- yellow\nyellowColor as string --result: \"65535655350\"\nset redColor to {65535, 0, 0} -- red\nset userColor to choose color default color redColor\n"],["body","\n\n\n\n"],["body","\n\n                    "],["body","\n\n                    \n                \n            \n\n            \n\n        \n\n\n\n\n        \n\n\n\n        \n        \n        \n\n        \n\n\n    \n    \n"]],[["_relative_fp","6.AppleScript/6.ClassReference/7.file.html"],["title","file - 各项编程语言"],["body","\n    \n        \n        \n\n        \n        \n\n        \n        \n\n        \n        \n\n        \n\n        \n\n            \n                                \n                \n                    \n                        "],["body","\n                            \n                        "],["body","\n                        "],["body","\n                            \n                        "],["body","\n                        \n                            "],["body","Light"],["body","\n                            "],["body","Rust"],["body","\n                            "],["body","Coal"],["body","\n                            "],["body","Navy"],["body","\n                            "],["body","Ayu"],["body","\n                        \n                    \n\n                    "],["heading","各项编程语言"],["body","\n\n                    \n\n                    \n                \n\n\n                \n                \n\n                \n                    "],["body","\n                        \n\n"],["body","\n"],["body","\n\n"],["headingLink","file"],["heading","file"],["body","\n\n"],["body","\n"],["body","对文件系统中文件、文件夹或卷的引用. "],["body","\n"],["body","\n"],["body","\n"],["body","“文件” 对象与 “别名” 对象具有完全相同的属性，此外，它还可以引用不存在的项目。"],["body","\n"],["body","\n"],["body","\n"],["body","有关相关信息，请参见 “别名” 和 “posix文件”。有关文件路径格式的说明，请参阅 [别名和文件](https://developer.apple.com/library/archive/documentation/AppleScript/Conceptual/AppleScriptLangGuide/conceptual/ASLR_fundamentals.html # // apple_ref/doc/uid/TP40000983-CH218-SW28)。"],["body","\n"],["body","\n\n"],["headingLink","coercions-supported"],["heading","Coercions Supported"],["body","\n"],["body","AppleScript supports coercion of a file object to a text object or single-item list."],["body","\n"],["headingLink","examples"],["heading","Examples"],["body","\n"],["body","set fp to open for access file \"Leopard:Users:myUser:NewFile\"\nclose access fp\n"],["body","\n"],["headingLink","discussion"],["heading","Discussion"],["body","\n\n"],["body","您可以创建一个 “文件” 对象，该对象引用不存在的文件或文件夹。"],["body","\n"],["body","例如，您可以使用 “choose file name” 命令为当前不需要的文件获取 “文件” 对象"],["body","\n\n\n\n\n"],["body","\n\n                    "],["body","\n\n                    \n                \n            \n\n            \n\n        \n\n\n\n\n        \n\n\n\n        \n        \n        \n\n        \n\n\n    \n    \n"]],[["_relative_fp","6.AppleScript/6.ClassReference/1.alias.html"],["title","alias - 各项编程语言"],["body","\n    \n        \n        \n\n        \n        \n\n        \n        \n\n        \n        \n\n        \n\n        \n\n            \n                                \n                \n                    \n                        "],["body","\n                            \n                        "],["body","\n                        "],["body","\n                            \n                        "],["body","\n                        \n                            "],["body","Light"],["body","\n                            "],["body","Rust"],["body","\n                            "],["body","Coal"],["body","\n                            "],["body","Navy"],["body","\n                            "],["body","Ayu"],["body","\n                        \n                    \n\n                    "],["heading","各项编程语言"],["body","\n\n                    \n\n                    \n                \n\n\n                \n                \n\n                \n                    "],["body","\n                        \n\n"],["body","\n"],["body","\n\n"],["headingLink","alias"],["heading","alias"],["body","\n\n"],["body","\n"],["body","对文件系统中现有文件、文件夹或卷的持久引用。"],["body","\n"],["body","\n"],["body","\n"],["body","For related information, see file, POSIX file, and Aliases and Files."],["body","\n"],["body","\n\n"],["headingLink","properties-of-alias-objects"],["heading","Properties of alias objects"],["body","\n"],["body","class\n \tAccess:\tread only\n \tClass:\tclass\n \tThe class identifier for the object. The value is always alias.\nPOSIX path\n \tAccess:\tread only\n \tClass:\ttext\n \tThe POSIX-style path to the object.\n"],["body","\n"],["headingLink","coercions-supported"],["heading","Coercions Supported"],["body","\n"],["body","AppleScript 支持将 别名 对象强制转换为 “文本” 对象或单项 列表。"],["body","\n"],["headingLink","examples"],["heading","Examples"],["body","\n"],["body","set zApp to choose application as alias -- (then choose Finder.app)\n--result: alias \"Leopard:System:Library:CoreServices:Finder.app:\"\nclass of zApp --result: alias\nzApp as text --result: \"Leopard:System:Library:CoreServices:Finder.app:\"\nzApp as list --result: {alias \"Leopard:System:Library:CoreServices:Finder.app:\"}\n"],["body","\n"],["body","You can use the POSIX path property to obtain a POSIX-style path to the item referred to by an alias:"],["body","\n"],["body","POSIX path of zApp --result: \"/System/Library/CoreServices/Finder.app/\"\n"],["body","\n"],["headingLink","discussion"],["heading","Discussion"],["body","\n"],["body","You can only create an alias to a file or folder that already exists."],["body","\n"],["headingLink","special-considerations"],["heading","Special Considerations"],["body","\n"],["body","AppleScript 2.0 attempts to resolve aliases only when you run a script. However, in earlier versions, AppleScript attempts to resolve aliases at compile time."],["body","\n\n\n\n"],["body","\n\n                    "],["body","\n\n                    \n                \n            \n\n            \n\n        \n\n\n\n\n        \n\n\n\n        \n        \n        \n\n        \n\n\n    \n    \n"]],[["_relative_fp","6.AppleScript/7.CommandsReference/index.html"],["title","7.CommandsReference - 各项编程语言"],["body","\n    \n        \n        \n\n        \n        \n\n        \n        \n\n        \n        \n\n        \n\n        \n\n            \n                                \n                \n                    \n                        "],["body","\n                            \n                        "],["body","\n                        "],["body","\n                            \n                        "],["body","\n                        \n                            "],["body","Light"],["body","\n                            "],["body","Rust"],["body","\n                            "],["body","Coal"],["body","\n                            "],["body","Navy"],["body","\n                            "],["body","Ayu"],["body","\n                        \n                    \n\n                    "],["heading","各项编程语言"],["body","\n\n                    \n\n                    \n                \n\n\n                \n                \n\n                \n                    "],["body","\n                        \n\n"],["body","\n"],["body","\n\n"],["headingLink","commands-reference"],["heading","Commands Reference"],["body","\n\n"],["body","\n"],["body","本章描述可用于执行AppleScript脚本中的操作的命令。"],["body","\n"],["body","\n"],["body","\n"],["body","For information on how commands work, see Commands Overview."],["body","\n"],["body","\n"],["body","\n"],["body","本章中描述的命令可用于任何脚本-它们要么内置到AppleScript语言中，要么通过标准脚本添加添加到 (described in Scripting Additions)."],["body","\n"],["body","\n"],["body","\n"],["body","Note: 在下面的命令描述中, 如果参数列表中的第一项不包括参数名称，则它是命令的直接参数 (described in Direct Parameter)."],["body","\n"],["body","\n"],["body","\n"],["body","下列表格 根据其所属的命令套件 (或相关组) 列出了每个命令，并提供了简要说明。详细的命令说明按字母顺序排列."],["body","\n"],["body","\n\n"],["body","Command"],["body","Description"],["body","\n"],["body","AppleScript suite"],["body","\n"],["body","activate"],["body","把应用程序带到前面 并打开它，如果它在本地计算机上并且尚未运行."],["body","\n"],["body","log"],["body","In Script Editor, displays a value in the Event Log History window or in the Event Log pane of a script window."],["body","\n"],["body","Clipboard Commands suite"],["body","\n"],["body","clipboard info"],["body","Returns information about the clipboard."],["body","\n"],["body","set the clipboard to"],["body","Places data on the clipboard."],["body","\n"],["body","the clipboard"],["body","Returns the contents of the clipboard."],["body","\n"],["body","File Commands suite"],["body","\n"],["body","info for"],["body","返回文件或文件夹的信息。"],["body","\n"],["body","list disks"],["body","返回当前挂载的卷的列表.Deprecated Use tell application \"System Events\" to get the name of every disk."],["body","\n"],["body","list folder"],["body","Returns the contents of a specified folder.Deprecated Use tell application \"System Events\" to get the name of every disk item of ...."],["body","\n"],["body","mount volume"],["body","Mounts the specified AppleShare volume."],["body","\n"],["body","path to (application)"],["body","Returns the full path to the specified application."],["body","\n"],["body","path to (folder)"],["body","Returns the full path to the specified folder."],["body","\n"],["body","path to resource"],["body","Returns the full path to the specified resource."],["body","\n"],["body","File Read/Write suite"],["body","\n"],["body","close access"],["body","Closes a file that was opened for access."],["body","\n"],["body","get eof"],["body","Returns the length, in bytes, of a file."],["body","\n"],["body","open for access"],["body","Opens a disk file for the read and write commands."],["body","\n"],["body","read"],["body","Reads data from a file that has been opened for access."],["body","\n"],["body","set eof"],["body","Sets the length, in bytes, of a file."],["body","\n"],["body","write"],["body","Writes data to a file that was opened for access with write permission."],["body","\n"],["body","Internet suite"],["body","\n"],["body","open location"],["body","Opens a URL with the appropriate program."],["body","\n"],["body","Miscellaneous Commands suite(杂项命令套件)"],["body","\n"],["body","current date"],["body","Returns the current date and time."],["body","\n"],["body","do shell script"],["body","Executes a shell script using the sh shell."],["body","\n"],["body","get volume settings"],["body","Returns the sound output and input volume settings."],["body","\n"],["body","random number"],["body","Generates a random number."],["body","\n"],["body","round"],["body","Rounds a number to an integer."],["body","\n"],["body","set volume"],["body","Sets the sound output and/or input volume."],["body","\n"],["body","system attribute"],["body","Gets environment variables or attributes of this computer."],["body","\n"],["body","system info"],["body","Returns information about the system."],["body","\n"],["body","time to GMT"],["body","Returns the difference between local time and GMT (Universal Time)."],["body","\n"],["body","Scripting suite"],["body","\n"],["body","load script"],["body","Returns a script object loaded from a file."],["body","\n"],["body","run script"],["body","Runs a script or script file"],["body","\n"],["body","scripting components"],["body","Returns a list of all scripting components."],["body","\n"],["body","store script"],["body","Stores a script object into a file."],["body","\n"],["body","Standard suite"],["body","\n"],["body","copy"],["body","Copies one or more values into variables."],["body","\n"],["body","count"],["body","Counts the number of elements in an object."],["body","\n"],["body","get"],["body","Returns the value of a script expression or an application object."],["body","\n"],["body","launch"],["body","Launches the specified application without sending it a run command."],["body","\n"],["body","run"],["body","For an application, launches it. For a script application, launches it and sends it the run command. For a script script object, executes its run handler."],["body","\n"],["body","set"],["body","Assigns one or more values to one or more script variables or application objects."],["body","\n"],["body","String Commands suite"],["body","\n"],["body","ASCII character"],["body","Converts a number to a character.Deprecated starting in AppleScript 2.0. Use the id property of the text class instead."],["body","\n"],["body","ASCII number"],["body","Converts a character to its numeric value.Deprecated starting in AppleScript 2.0. Use the id property of the text class instead."],["body","\n"],["body","localized string"],["body","Returns the localized string for the specified key."],["body","\n"],["body","offset"],["body","Finds one piece of text inside another."],["body","\n"],["body","summarize"],["body","Summarizes the specified text or text file."],["body","\n"],["body","User Interaction suite"],["body","\n"],["body","beep"],["body","Beeps one or more times."],["body","\n"],["body","choose application"],["body","Allows the user to choose an application."],["body","\n"],["body","choose color"],["body","Allows the user to choose a color."],["body","\n"],["body","choose file"],["body","Allows the user to choose a file."],["body","\n"],["body","choose file name"],["body","Allows the user to specify a new file reference."],["body","\n"],["body","choose folder"],["body","Allows the user to choose a folder."],["body","\n"],["body","choose from list"],["body","Allows the user to choose one or more items from a list."],["body","\n"],["body","choose remote application"],["body","Allows the user to choose a running application on a remote machine."],["body","\n"],["body","choose URL"],["body","Allows the user to specify a URL."],["body","\n"],["body","delay"],["body","Pauses for a fixed amount of time."],["body","\n"],["body","display alert"],["body","Displays an alert."],["body","\n"],["body","display dialog"],["body","Displays a dialog box, optionally requesting user input."],["body","\n"],["body","display notification"],["body","Displays a notification."],["body","\n"],["body","say"],["body","Speaks the specified text."],["body","\n\n\n\n\n"],["body","\n\n                    "],["body","\n\n                    \n                \n            \n\n            \n\n        \n\n\n\n\n        \n\n\n\n        \n        \n        \n\n        \n\n\n    \n    \n"]],[["_relative_fp","6.AppleScript/9.OperatorsReference/index.html"],["title","9.OperatorsReference - 各项编程语言"],["body","\n    \n        \n        \n\n        \n        \n\n        \n        \n\n        \n        \n\n        \n\n        \n\n            \n                                \n                \n                    \n                        "],["body","\n                            \n                        "],["body","\n                        "],["body","\n                            \n                        "],["body","\n                        \n                            "],["body","Light"],["body","\n                            "],["body","Rust"],["body","\n                            "],["body","Coal"],["body","\n                            "],["body","Navy"],["body","\n                            "],["body","Ayu"],["body","\n                        \n                    \n\n                    "],["heading","各项编程语言"],["body","\n\n                    \n\n                    \n                \n\n\n                \n                \n\n                \n                    "],["body","\n                        \n\n"],["body","\n"],["body","\n\n"],["headingLink","operators-reference"],["heading","Operators Reference"],["body","\n\n"],["body","本章介绍AppleScript运算符，运算符 是从另一个值或一对值派生一个值的符号，单词或短语"],["body","\n"],["body","操作 是对包含运算符的表达式的求值。"],["body","\n"],["body","操作数 是一个表达式，运算符从中产生一个值"],["body","\n"],["body","AppleScript提供逻辑和数学运算符，以及用于包含，串联和获取对对象的引用的运算符"],["body","\n"],["body","对两个值进行操作的运算符称为 二元运算符，而对单个值进行操作的运算符称为 *一元运算符 *。"],["body","\n"],["body","本章的第一部分包含两个表: 表9-1总结了AppleScript使用的所有运算符,  [表9-2](https://developer.apple.com/library/archive/documentation/AppleScript/Conceptual/AppleScriptLangGuide/reference/ASLR_operators.html # // apple_ref/doc/uid/TP40000983-CH5g-SW3) 显示了AppleScript计算表达式中的运算符的顺序，本章的其余部分展示了AppleScript如何评估脚本表达式中的代表性运算符。"],["body","\n\n"],["body","AppleScript operator"],["body","Description"],["body","\n"],["body","and"],["body","逻辑连词.结合两个布尔值的二元逻辑运算符。短路特性"],["body","\n"],["body","or"],["body","Logical disjunction.结合两个布尔值的二元逻辑运算符. 短路特性"],["body","\n"],["body","&"],["body","Concatenation.连接两个值的二元运算符. 如果左侧操作数是 text对象, 结果就是text对象 (并且仅在这种情况下，AppleScript才尝试强制转换右侧操作数的值与左侧操作数的值匹配).如果左操作数是record对象, 结果是记录.如果左侧的操作数属于任何其他类，则结果是一个列表"],["body","\n"],["body","="],["body","is equal"],["body","equals"],["body","[is] equal to"],["body","Equality.如果两个操作数具有相同的值，则产生 “true” 的二元比较运算符"],["body","\n"],["body","≠ (Option-equal sign on U.S. keyboard)"],["body","is not"],["body","isn't"],["body","isn't equal [to]"],["body","is not equal [to]"],["body","doesn't equal"],["body","does not equal"],["body","Inequality.。一个二元比较运算符，如果它的两个操作数具有不同的值，则结果为 “true”   see equal, is not equal to."],["body","\n"],["body",">"],["body","[is] greater than"],["body","comes after"],["body","is not less than or equal [to]"],["body","isn't less than or equal [to]"],["body","Greater than.二元比较运算符，如果左侧操作数的值大于右侧操作数的值，则结果为 “true”.两个操作数都必须评估为同一类的值。如果没有，AppleScript会尝试将右操作数强制转换为左操作数的类。 see greater than, less than.Class of operands: date, integer, real, textClass of result: boolean"],["body","\n"],["body","<"],["body","[is] less than"],["body","comes before"],["body","is not greater than or equal [to]"],["body","isn't greater than or equal [to]"],["body","Less than.A binary comparison operator that results in true if the value of the left-hand operand is less than the value of the right-hand operand.Both operands must evaluate to values of the same class. If they don’t, AppleScript attempts to coerce the right-hand operand to the class of the operand to the left.For more information, see greater than, less than.Class of operands: date, integer, real, textClass of result: boolean"],["body","\n"],["body","≥ (Option-period on U.S. keyboard)"],["body",">="],["body","[is] greater than or equal [to]"],["body","is not less than"],["body","isn't less than"],["body","does not come before"],["body","doesn't come before"],["body","Greater than or equal to.A binary comparison operator that results in true if the value of the left-hand operand is greater than or equal to the value of the right-hand operand.Both operands must evaluate to values of the same class. If they don’t, AppleScript attempts to coerce the right-hand operand to the class of the operand to the left.The method AppleScript uses to determine which value is greater depends on the class of the operands.Class of operands: date, integer, real, textClass of result: boolean"],["body","\n"],["body","≤ (Option-comma on U.S. keyboard)"],["body","<="],["body","[is] less than or equal [to]"],["body","is not greater than"],["body","isn't greater than"],["body","does not come after"],["body","doesn't come after"],["body","Less than or equal to.A binary comparison operator that results in true if the value of the left-hand operand is less than or equal to the value of the right-hand operand.Both operands must evaluate to values of the same class. If they don’t, AppleScript attempts to coerce the right-hand operand to the class of the operand to the left.The method AppleScript uses to determine which value is greater depends on the class of the operands.Class of operands: date, integer, real, textClass of result: boolean"],["body","\n"],["body","start[s] with``begin[s] with"],["body","Starts with.A binary containment operator that results in true if the list or text object to its right matches the beginning of the list or text object to its left.Both operands must evaluate to values of the same class. If they don’t, AppleScript attempts to coerce the right-hand operand to the class of the operand to the left.For more information, see starts with, ends with.Class of operands: list, textClass of result: boolean"],["body","\n"],["body","end[s] with"],["body","Ends with.A binary containment operator that results in true if the list or text object to its right matches the end of the list or text object to its left.Both operands must evaluate to values of the same class. If they don’t, AppleScript attempts to coerce the right-hand operand to the class of the operand to the left.For more information, see starts with, ends with.Class of operands: list, textClass of result: boolean"],["body","\n"],["body","contain[s]"],["body","Containment.A binary containment operator that results in true if the list, record, or text object to its right matches any part of the list, record, or text object to its left.Both operands must evaluate to values of the same class. If they don’t, AppleScript attempts to coerce the right-hand operand to the class of the operand to the left.For more information, see contains, is contained by.Class of operands: list, record, textClass of result: boolean"],["body","\n"],["body","does not contain"],["body","doesn't contain"],["body","Non-containment.A binary containment operator that results in true if the list, record, or text object to its right does not match any part of the list, record, or text object to its left.Both operands must evaluate to values of the same class. If they don’t, AppleScript attempts to coerce the right-hand operand to the class of the left-hand operand.For more information, see contains, is contained by.Class of operands: list, record, textClass of result: boolean"],["body","\n"],["body","is in"],["body","is contained by"],["body","Containment.A binary containment operator that results in true if the list, record, or text object to its left matches any part of the list, record, or text object to its right.Both operands must evaluate to values of the same class. If they don’t, AppleScript attempts to coerce the left-hand operand to the class of the right-hand operand.For more information, see contains, is contained by.Class of operands: list, record, textClass of result: boolean"],["body","\n"],["body","is not in"],["body","is not contained by"],["body","isn't contained by"],["body","Non-containment.A binary containment operator that results in true if the list, record, or text object to its left does not match any part of the list, record, or text object to its right.Both operands must evaluate to values of the same class. If they don’t, AppleScript attempts to coerce the left-hand operand to the class of the right-hand operand.For more information, see contains, is contained by.Class of operands: list, record, textClass of result: boolean"],["body","\n"],["body","*"],["body","Multiplication.A binary arithmetic operator that multiplies the number to its left and the number to its right.Class of operands: integer, realClass of result: integer, real"],["body","\n"],["body","+"],["body","Addition.A binary arithmetic operator that adds the number or date to its left and the number or date to its right. Only integers can be added to dates. AppleScript interprets such an integer as a number of seconds.As a unary operator, + has no effect and is removed on compile.Class of operands: date, integer, realClass of result: date, integer, real"],["body","\n"],["body","–"],["body","Subtraction.A binary or unary arithmetic operator.The binary operator subtracts the number to its right from the number or date to its left.The unary operator makes the number to its right negative.Only integers can be subtracted from dates. AppleScript interprets such an integer as a number of seconds.Class of operands: date, integer, realClass of result: date, integer, real"],["body","\n"],["body","/ "],["body","÷ (Option-slash on U.S. keyboard)"],["body","Division.A binary arithmetic operator that divides the number to its left by the number to its right.Class of operands: integer, realClass of result: real"],["body","\n"],["body","div"],["body","Integral division.A binary arithmetic operator that divides the number to its left by the number to its right and returns the integral part of the answer as its result.Class of operands: integer, realClass of result: integer"],["body","\n"],["body","mod"],["body","Remainder.A binary arithmetic operator that divides the number to its left by the number to its right and returns the remainder as its result.Class of operands: integer, realClass of result: integer, real"],["body","\n"],["body","^"],["body","Exponentiation.A binary arithmetic operator that raises the number to its left to the power of the number to its right.Class of operands: integer, realClass of result: real"],["body","\n"],["body","as"],["body","Coercion (or object conversion).A binary operator that converts the left-hand operand to the class listed to its right.Not all values can be coerced to all classes. The coercions that AppleScript can perform are listed in Coercion (Object Conversion). The additional coercions, if any, that an application can perform is listed in its dictionary.Class of operands: The right-hand operand must be a class identifier or list of class identifiers; the left-hand operand must be a value that can be converted to that class or one of the listed classes.Class of result: The class specified by the class identifier to the right of the operator"],["body","\n"],["body","not"],["body","Negation.A unary logical operator that results in true if the operand to its right is false, and false if the operand is true.Class of operand: booleanClass of result: boolean"],["body","\n"],["body","[a] (ref [to] | reference to)"],["body","A reference to.A unary operator that causes AppleScript to return a reference object that specifies the location of the operand to its right. A reference is evaluated at run time, not at compile time.See a reference to for more information.Class of operand: any class typeClass of result: reference"],["body","\n\n\n"],["body","When evaluating expressions, AppleScript uses operator precedence to determine which operations are evaluated first. In the following expression, for example, AppleScript does not simply perform operations from left to right—it performs the multiplication operation 2 * 5 first, because multiplication has higher precedence than addition."],["body","\n"],["body","12 + 2 * 5 --result: 22\n"],["body","\n"],["body","Table 9-2 shows the order in which AppleScript performs operations. The column labeled “Associativity” indicates the order in the case where there are two or more operands of the same precedence in an expression. The word “None” in the Associativity column indicates that you cannot have multiple consecutive occurrences of the operation in an expression. For example, the expression 3 = 3 = 3 is not legal because the associativity for the equal operator is “none.”"],["body","\n"],["body","To evaluate expressions with multiple unary operators of the same order, AppleScript applies the operator closest to the operand first, then applies the next closest operator, and so on. For example, the expression not not not true is evaluated as not (not (not true))."],["body","\n"],["body","You can enforce the order in which AppleScript performs operations by grouping expressions in parentheses, which are evaluated first, starting with the innermost pair of parentheses."],["body","\n"],["body","Order"],["body","Operators"],["body","Associativity"],["body","Type of operator"],["body","\n"],["body","1"],["body","( )"],["body","Innermost to outermost"],["body","Grouping"],["body","\n"],["body","2"],["body","+``–"],["body","Unary"],["body","Plus or minus sign for numbers"],["body","\n"],["body","3"],["body","^"],["body","Right to left"],["body","Exponentiation(note that this is different from standard math, in which exponentiation takes precedence over unary plus or minus)"],["body","\n"],["body","4"],["body","*``/``div``mod"],["body","Left to right"],["body","Multiplication and division"],["body","\n"],["body","5"],["body","+``–"],["body","Left to right"],["body","Addition and subtraction"],["body","\n"],["body","6"],["body","&"],["body","Left to right"],["body","Concatenation"],["body","\n"],["body","7"],["body","as"],["body","Left to right"],["body","Coercion"],["body","\n"],["body","8"],["body","<``≤``>``≥"],["body","None"],["body","Comparison"],["body","\n"],["body","9"],["body","=``≠"],["body","None"],["body","Equality and inequality"],["body","\n"],["body","10"],["body","not"],["body","Unary"],["body","Logical negation"],["body","\n"],["body","11"],["body","and"],["body","Left to right"],["body","Logical and"],["body","\n"],["body","12"],["body","or"],["body","Left to right"],["body","Logical or"],["body","\n\n\n"],["body","以下部分提供了有关AppleScript如何评估表达式中的运算符的其他详细信息:"],["body","\n\n"],["body","& (concatenation)"],["body","\n"],["body","a reference to"],["body","\n"],["body","Para"],["body","\n"],["body","contains, is contained by"],["body","\n"],["body","equal, is not equal to"],["body","\n"],["body","greater than, less than"],["body","\n"],["body","starts with, ends with"],["body","\n\n"],["body","​\t"],["body","\n\n\n\n"],["body","\n\n                    "],["body","\n\n                    \n                \n            \n\n            \n\n        \n\n\n\n\n        \n\n\n\n        \n        \n        \n\n        \n\n\n    \n    \n"]],[["_relative_fp","6.AppleScript/4.ScriptObjects/2.InitializingScriptObjects.html"],["title","InitializingScriptObjects - 各项编程语言"],["body","\n    \n        \n        \n\n        \n        \n\n        \n        \n\n        \n        \n\n        \n\n        \n\n            \n                                \n                \n                    \n                        "],["body","\n                            \n                        "],["body","\n                        "],["body","\n                            \n                        "],["body","\n                        \n                            "],["body","Light"],["body","\n                            "],["body","Rust"],["body","\n                            "],["body","Coal"],["body","\n                            "],["body","Navy"],["body","\n                            "],["body","Ayu"],["body","\n                        \n                    \n\n                    "],["heading","各项编程语言"],["body","\n\n                    \n\n                    \n                \n\n\n                \n                \n\n                \n                    "],["body","\n                        \n\n"],["body","\n"],["body","\n\n"],["headingLink","initializing-script-objects"],["heading","Initializing Script Objects"],["body","\n"],["body","定义 script 对象时，它可以包含属性，处理程序和嵌套的 “脚本” 对象定义"],["body","\n"],["body","当您执行包含它的脚本时，AppleScript会创建一个具有定义的属性、处理程序和嵌套的 “脚本” 对象"],["body","\n"],["body","从定义创建 “脚本” 对象实例的过程称为初始化，“脚本” 对象必须先初始化，然后才能响应命令。"],["body","\n"],["body","每次执行脚本的 run handler，都会初始化顶级的 “脚本” 对象。"],["body","\n"],["body","同样，如果在处理程序中定义脚本，则每次调用处理程序时，AppleScript都会初始化 “脚本” 对象"],["body","\n"],["body","处理程序定义中的参数变量成为 'script' 对象的局部变量。"],["body","\n"],["body","例如，以下脚本中的 makePoint 处理程序包含 script 对象 'thePoint' 的 'script' 对象定义:"],["body","\n"],["body","on makePoint(x, y)\n    script thePoint\n        property xCoordinate:x\n        property yCoordinate:y\n    end script\n    return thePoint\nend makePoint\n \nset myPoint to makePoint(10,20)\nget xCoordinate of myPoint  --result: 10\nget yCoordinate of myPoint  --result: 20\n"],["body","\n"],["body","AppleScript initializes the script object thePoint when it executes the makePoint command. "],["body","\n"],["body","AppleScript 在执行 makepoint 命令时初始化 “脚本” 对象 “point”。"],["body","\n"],["body","set myOtherPoint to makePoint(30,50)\n"],["body","\n"],["body","'makePoint' 脚本是一种构造函数，用于创建表示点的 'script' 对象。"],["body","\n\n\n\n"],["body","\n\n                    "],["body","\n\n                    \n                \n            \n\n            \n\n        \n\n\n\n\n        \n\n\n\n        \n        \n        \n\n        \n\n\n    \n    \n"]],[["_relative_fp","6.AppleScript/4.ScriptObjects/1.DefiningScriptObjects.html"],["title","DefiningScriptObjects - 各项编程语言"],["body","\n    \n        \n        \n\n        \n        \n\n        \n        \n\n        \n        \n\n        \n\n        \n\n            \n                                \n                \n                    \n                        "],["body","\n                            \n                        "],["body","\n                        "],["body","\n                            \n                        "],["body","\n                        \n                            "],["body","Light"],["body","\n                            "],["body","Rust"],["body","\n                            "],["body","Coal"],["body","\n                            "],["body","Navy"],["body","\n                            "],["body","Ayu"],["body","\n                        \n                    \n\n                    "],["heading","各项编程语言"],["body","\n\n                    \n\n                    \n                \n\n\n                \n                \n\n                \n                    "],["body","\n                        \n\n"],["body","\n"],["body","\n\n"],["headingLink","defining-script-objects"],["heading","Defining Script Objects"],["body","\n"],["body","script定义"],["body","\n"],["body","每个 script 对象定义 (顶层 script 对象除外) 都以关键字 'script' 开头，后跟变量名，并以关键字 'end' (或 'end script') 结尾。中间的语句可以是属性定义、处理程序定义、嵌套的 'script' 对象定义和其他AppleScript语句的任意组合。"],["body","\n"],["body","script 对象定义的语法如下:"],["body","\n"],["body","script variableName\n\n  [ ( property | prop ) parent : parentSpecifier ]\n\n  [ ( property | prop ) propertyLabel : initialValue ]...\n\n  [ handlerDefinition ]...\n\n  [ statement ]...\n\nend [ script ]\n"],["body","\n\n"],["body","\n"],["body","variableName"],["body","\n"],["body","脚本的变量标识符。您可以在脚本中的其他地方通过此名称来引用脚本对象。"],["body","\n"],["body","\n"],["body","\n"],["body","parentSpecifier"],["body","\n"],["body","Specifies the parent of the script object, typically another script object.For more information, see Inheritance in Script Objects."],["body","\n"],["body","继承"],["body","\n"],["body","\n"],["body","\n"],["body","propertyLabel"],["body","\n"],["body","在 script 对象中唯一的标识符，它指定对象的特征; 等效于实例变量。"],["body","\n"],["body","\n"],["body","\n"],["body","initialValue"],["body","\n"],["body","The value that is assigned to the property each time the script object is initialized. script objects are initialized when compiled. initialValue is required in property definitions."],["body","\n"],["body","\n"],["body","\n"],["body","handlerDefinition"],["body","\n"],["body","script 对象中 可以响应的命令的处理程序; 等效于方法。有关更多信息，see About Handlers and Handler Reference."],["body","\n"],["body","\n"],["body","\n"],["body","statement"],["body","\n"],["body","任何AppleScript语句。处理程序和属性定义以外的语句被视为 “运行” 命令的隐式处理程序定义的一部分; 当 “脚本” 对象接收到 “运行” 命令时执行它们"],["body","\n"],["body","\n\n"],["body","这是一个简单的 “脚本” 对象定义"],["body","\n"],["body","script John\n    property HowManyTimes : 0\n    to sayHello to someone\n        set HowManyTimes to HowManyTimes + 1\n        return \"Hello \" & someone\n    end sayHello\n    \nend script\n"],["body","\n\n"],["body","\n"],["body","它定义了一个可以处理 sayhello 命令的 script 对象。"],["body","\n"],["body","\n"],["body","\n"],["body","它将 script 对象分配给变量 John。"],["body","\n"],["body","\n"],["body","\n"],["body","该定义包括 “sayhello” 命令的handler"],["body","\n"],["body","\n"],["body","\n"],["body","它还包括一个属性，称为 howmanytimes，这表示 sayhello 命令被调用了多少次"],["body","\n"],["body","\n"],["body","\n"],["body","脚本 对象定义中的 handler 遵循与任何其他 handler 相同的语法规则。"],["body","\n"],["body","\n"],["body","\n"],["body","您可以使用 'tell' 语句将命令发送到 script 对象"],["body","\n"],["body","\n\n"],["body","例如，下面的语句发送 sayHello 命令，上面定义的 'script' 对象。"],["body","\n"],["body","tell John to sayHello to \"Herb\" --result: \"Hello Herb\"\n"],["body","\n"],["body","您可以通过使用 get 命令获取属性的值，并使用 'set' 或 'copy' 命令更改值来操作 'script' 对象的属性。属性的值是持久的-每次编译脚本时都会重置，但运行时不会重置。"],["body","\n\n\n\n"],["body","\n\n                    "],["body","\n\n                    \n                \n            \n\n            \n\n        \n\n\n\n\n        \n\n\n\n        \n        \n        \n\n        \n\n\n    \n    \n"]],[["_relative_fp","6.AppleScript/4.ScriptObjects/4.ScriptLibraries.html"],["title","ScriptLibraries - 各项编程语言"],["body","\n    \n        \n        \n\n        \n        \n\n        \n        \n\n        \n        \n\n        \n\n        \n\n            \n                                \n                \n                    \n                        "],["body","\n                            \n                        "],["body","\n                        "],["body","\n                            \n                        "],["body","\n                        \n                            "],["body","Light"],["body","\n                            "],["body","Rust"],["body","\n                            "],["body","Coal"],["body","\n                            "],["body","Navy"],["body","\n                            "],["body","Ayu"],["body","\n                        \n                    \n\n                    "],["heading","各项编程语言"],["body","\n\n                    \n\n                    \n                \n\n\n                \n                \n\n                \n                    "],["body","\n                        \n\n"],["body","\n"],["body","\n\n"],["headingLink","script-libraries"],["heading","Script Libraries"],["body","\n"],["body","保存在脚本库文件夹中的顶级 “脚本” 对象成为其他脚本可用的 脚本库。库使您可以共享和重用处理程序，将大型脚本重组为一组更易于管理的较小的库，并从更简单的库中构建更丰富，更高级别的功能。"],["body","\n"],["body","Note: OS X Mavericks v10.9 (AppleScript 2.3) 和更高版本支持库. "],["body","\n"],["body","要在先前操作系统版本的脚本之间共享属性和处理程序，请使用 “加载脚本” 命令，如 [库使用加载脚本](https://developer.apple.com/library/archive/documentation/AppleScript/Conceptual/AppleScriptLangGuide/reference/ASLR_load_script.html # // apple_ref/doc/uid/TP40000983-CH227-SW1) 中所述。"],["body","\n"],["headingLink","creating-a-library"],["heading","Creating a Library"],["body","\n"],["body","脚本成为脚本库的基本要求是其位置: 它必须是以下文件夹之一中的  ''脚本库'' 文件夹中的脚本文档。搜索库时，按列出的顺序搜索位置，并使用第一个匹配脚本:"],["body","\n\n"],["body","脚本的bundleResources: 如果引用库的脚本是捆绑包（bundle），则脚本的  bundle Resources  目录。这意味着脚本可以与它们使用的库一起打包和分发"],["body","\n"],["body","应用程序的bundleResources:如果运行脚本的应用程序是bundle ，则应用程序的捆绑包 “资源” 目录。这意味着脚本应用程序 (“小程序” 和 “小滴”) 可以与它们使用的库一起打包和分发。它还使运行脚本的应用程序能够提供库供这些脚本使用。"],["body","\n"],["body","OSA_LIBRARY_PATH指定的路径: Any folders specified in the environment variable OSA_LIBRARY_PATH. This allows using a library without installing it in one of the usual locations. The value of this variable is a colon-separated list of paths, such as /opt/local/Script Libraries:/usr/local/Script Libraries. Unlike the other library locations, paths specified in OSA_LIBRARY_PATH are used exactly as-is, without appending “Script Libraries”. Supported in OS X v10.11 and later."],["body","\n"],["body","HOME路径：The Library folder in the user’s home directory, ~/Library. This is the location to install libraries for use by a single user, and is the recommended location during library development."],["body","\n"],["body","跟路径：The computer Library folder, /Library. Libraries located here are available to all users of the computer."],["body","\n"],["body","The network Library folder, /Network/Library. Libraries located here are available to multiple computers on a network."],["body","\n"],["body","The system Library folder, /System/Library. These are libraries provided by macOS."],["body","\n"],["body","Any installed application bundle, in the application’s bundle Library directory. This allows distributing libraries that are associated with an application, or creating applications that exist solely to distribute libraries. Supported in OS X v10.11 and later."],["body","\n\n"],["body","Script libraries also have name, id, and version properties. It is recommended that you define all three, especially for libraries you plan to distribute publicly: doing so allows clients to unambiguously identify particular versions of libraries that have the functionality they need. These properties may be defined either as property definitions within the script itself, or, for script bundles, in the Info.plist file, which can be edited using the Bundle Contents drawer in Script Editor. For details, see the script class reference."],["body","\n"],["body","A script library may be a single-file (scpt) or bundle format (scptd). If a library is a bundle, it may define its own terminology."],["body","\n"],["headingLink","defining-scripting-terminology"],["heading","Defining Scripting Terminology"],["body","\n"],["body","Libraries may define scripting terminology, including commands, properties and enumerated values, by supplying a Scripting Definition (sdef) file in their bundle. Like applications, this terminology is available to client scripts when they target the library with tell or use, and to the library script itself."],["body","\n"],["body","To define terminology, create an sdef file as described in the Cocoa Scripting Guide under Preparing a Scripting Definition File. Then, copy the file to the bundle’s Resources directory and set the Info.plist key OSAScriptingDefinition to the base name of the sdef file (that is, the file name without the “.sdef” extension). Script Editor’s Bundle Contents drawer can do this for you: drag the file into the “Resources” list to copy the file into the bundle, and enter the base name of the sdef file in the “Scripting Definition” field."],["body","\n"],["headingLink","using-a-library"],["heading","Using a Library"],["body","\n"],["body","脚本库 定义了一个脚本对象，然后客户端脚本可以引用该脚本对象，然后向其发送命令，如 [向脚本对象发送命令](https://developer.apple.com/library/archive/documentation/AppleScript/Conceptual/AppleScriptLangGuide/conceptual/ASLR_script_objects.html # // apple_ref/doc/uid/TP40000983-CH207-SW3) 中所述。库按名称标识:"],["body","\n"],["body","script \"My Library\"\n"],["body","\n\n"],["body","AppleScript将搜索各个脚本库文件夹，如上所述 [创建库](https://developer.apple.com/library/archive/documentation/AppleScript/Conceptual/AppleScriptLangGuide/conceptual/ASLR_script_objects.html # // apple_ref/doc/uid/TP40000983-CH207-SW13)，并创建库脚本的实例"],["body","\n"],["body","与 load script 的结果不同，此实例是共享的，并且至少在客户端脚本的生存期内持续存在，因此您不必将其保存在变量中，并且在客户端脚本运行时状态将被保留。例如，给定这个库脚本:"],["body","\n\n"],["body","property name : \"Counter\"\nproperty nextNumberProperty : 0\non nextNumber()\n    set my nextNumberProperty to my nextNumberProperty + 1\n    return my nextNumberProperty\nend nextNumber\n"],["body","\n"],["body","This client script, despite referencing the library in full both times, will log “1” and then “2”:"],["body","\n"],["body","尽管两次都引用了该库，但此客户端脚本将记录 “1”，然后记录 “2”:"],["body","\n"],["body","tell script \"Counter\" to log its nextNumber() -- logs \"1\"\ntell script \"Counter\" to log its nextNumber() -- logs \"2\"\n"],["body","\n"],["body","注意:  库脚本实例对于加载它们的AppleScript解释器是唯一的，并且在其生命周期内是持久的。脚本编辑器、脚本菜单和文件夹操作都使用每个脚本的单独解释器运行其脚本; Applet和AppleScriptObjC应用程序对整个应用程序使用单个解释器; 其他应用程序也可以这样做。如果您正在设计一个库，请尽量不要依赖库脚本本身中的持久状态，因为它的生命周期会因客户端脚本的运行方式而异。"],["body","\n\n\n\n"],["body","\n\n                    "],["body","\n\n                    \n                \n            \n\n            \n\n        \n\n\n\n\n        \n\n\n\n        \n        \n        \n\n        \n\n\n    \n    \n"]],[["_relative_fp","6.AppleScript/4.ScriptObjects/3.SendingCommandsToScriptObjects.html"],["title","SendingCommandsToScriptObjects - 各项编程语言"],["body","\n    \n        \n        \n\n        \n        \n\n        \n        \n\n        \n        \n\n        \n\n        \n\n            \n                                \n                \n                    \n                        "],["body","\n                            \n                        "],["body","\n                        "],["body","\n                            \n                        "],["body","\n                        \n                            "],["body","Light"],["body","\n                            "],["body","Rust"],["body","\n                            "],["body","Coal"],["body","\n                            "],["body","Navy"],["body","\n                            "],["body","Ayu"],["body","\n                        \n                    \n\n                    "],["heading","各项编程语言"],["body","\n\n                    \n\n                    \n                \n\n\n                \n                \n\n                \n                    "],["body","\n                        \n\n"],["body","\n"],["body","\n\n"],["headingLink","sending-commands-to-script-objects"],["heading","Sending Commands to Script Objects"],["body","\n"],["body","您可以使用 'tell' 语句向 'script' 对象发送命令。"],["body","\n"],["body","For example, the following tell statement sends two sayHello commands to the script object John (defined below):"],["body","\n"],["body","例如，下面的 'tell' 语句将两个 'sayHello' 命令发送到 'script' 对象 'John' (定义如下):"],["body","\n"],["body","tell John\n    sayHello to \"Herb\"\n    sayHello to \"Grace\"\nend tell\n"],["body","\n"],["body","为了使 “脚本” 对象响应 “tell” 语句中的命令，“脚本” 对象或其父对象必须具有该命令的处理程序。有关父对象的更多信息，请参见 [脚本对象中的继承](https://developer.apple.com/library/archive/documentation/AppleScript/Conceptual/AppleScriptLangGuide/conceptual/ASLR_script_objects.html # // apple_ref/doc/uid/TP40000983-CH207-SW5)。"],["body","\n"],["body","脚本 对象定义可能包括一个隐式的 “运行” 处理程序，该处理程序由任何处理程序或嵌套的 “脚本” 对象之外的所有可执行语句组成，或者它可能包括一个以 “运行” 开头的显式 “运行” 处理程序，但它可能不包含两者-这样的脚本不会编译。"],["body","\n"],["body","如果脚本没有运行处理程序 (例如，作为处理程序库的脚本，如 [参数规范](https://developer.apple.com/library/archive/documentation/AppleScript/Conceptual/AppleScriptLangGuide/conceptual/ASLR_about_handlers.html # // apple_ref/doc/uid/TP40000983-CH206-SW12) 中所述)，则执行脚本不会执行任何操作。但是，向它发送显式的 “运行” 命令会导致错误。有关更多信息，请参见 [运行处理程序](https://developer.apple.com/library/archive/documentation/AppleScript/Conceptual/AppleScriptLangGuide/conceptual/ASLR_about_handlers.html # // apple_ref/doc/uid/TP40000983-CH206-SW15)。"],["body","\n"],["body","The display dialog command in the following script object definition is the only executable statement at the top level, so it constitutes the script object’s implicit run handler and is executed when the script sends a run command to script object John, with the statement tell John to run."],["body","\n"],["body","script John\n    property HowManyTimes : 0\n    to sayHello to someone\n        set HowManyTimes to HowManyTimes + 1\n        return \"Hello \" & someone\n    end sayHello\n    display dialog \"John received the run command\"\nend script\n \ntell John to run\n\n"],["body","\n"],["body","您还可以使用 possessive 向 “脚本” 对象发送命令。例如，以下两种形式中的任何一种都将 'sayHello' 命令发送到脚本 'John' (第一个版本编译为第二个版本):"],["body","\n"],["body","John's sayHello to \"Jake\" --result: \"Hello Jake\"\nsayHello of John to \"Jake\" --result: \"Hello Jake\"\n"],["body","\n\n\n\n"],["body","\n\n                    "],["body","\n\n                    \n                \n            \n\n            \n\n        \n\n\n\n\n        \n\n\n\n        \n        \n        \n\n        \n\n\n    \n    \n"]],[["_relative_fp","6.AppleScript/4.ScriptObjects/index.html"],["title","4.ScriptObjects - 各项编程语言"],["body","\n    \n        \n        \n\n        \n        \n\n        \n        \n\n        \n        \n\n        \n\n        \n\n            \n                                \n                \n                    \n                        "],["body","\n                            \n                        "],["body","\n                        "],["body","\n                            \n                        "],["body","\n                        \n                            "],["body","Light"],["body","\n                            "],["body","Rust"],["body","\n                            "],["body","Coal"],["body","\n                            "],["body","Navy"],["body","\n                            "],["body","Ayu"],["body","\n                        \n                    \n\n                    "],["heading","各项编程语言"],["body","\n\n                    \n\n                    \n                \n\n\n                \n                \n\n                \n                    "],["body","\n                        \n\n"],["body","\n"],["body","\n\n"],["headingLink","script-objects"],["heading","Script Objects"],["body","\n\n"],["body","本章介绍了script 对象，该对象用于实现所有AppleScript脚本。在阅读本章之前，您应该熟悉 [AppleScript和Objects](https://developer.apple.com/library/archive/documentation/AppleScript/Conceptual/AppleScriptLangGuide/conceptual/ASLR_fundamentals.html # // apple_ref/doc/uid/TP40000983-CH218-SW1) 中的信息。"],["body","\n"],["body","脚本对象 是用户定义的对象，可以将数据 (以属性的形式) 和操作 (以handler 和其他 脚本对象的形式) 组合在一起。"],["body","\n"],["body","脚本对象支持继承，允许您定义共享属性和处理程序的对象的层次结构。"],["body","\n"],["body","当从另一个 script 对象调用 handler 时，您还可以扩展或修改它在一个 'script' 对象中的行为:重写"],["body","\n"],["body","顶级 script 对象是 实现您正在处理的整体脚本的对象"],["body","\n"],["body","任何 script 对象都可以包含嵌套的 script 对象，每个对象的定义都像顶级 script 对象一样，只是嵌套的 'script' 对象带有标记其开头和结尾的语句."],["body","\n\n"],["body","本章在以下各节中描述 script objects"],["body","\n\n"],["body","Defining Script Objects shows the syntax for defining script objects and includes a simple example ."],["body","\n"],["body","Initializing Script Objects describes how AppleScript creates a script object with the properties and handlers you have defined."],["body","\n"],["body","Sending Commands to Script Objects describes how you use tell statements to send commands to script objects."],["body","\n"],["body","Script Libraries describes script libraries and how to use them from other scripts."],["body","\n"],["body","Inheritance in Script Objects describes inheritance works and how you can use it to share functionality in the script objects you define."],["body","\n\n\n\n\n"],["body","\n\n                    "],["body","\n\n                    \n                \n            \n\n            \n\n        \n\n\n\n\n        \n\n\n\n        \n        \n        \n\n        \n\n\n    \n    \n"]],[["_relative_fp","6.AppleScript/4.ScriptObjects/5.InheritanceInScriptObjects.html"],["title","InheritanceInScriptObjects - 各项编程语言"],["body","\n    \n        \n        \n\n        \n        \n\n        \n        \n\n        \n        \n\n        \n\n        \n\n            \n                                \n                \n                    \n                        "],["body","\n                            \n                        "],["body","\n                        "],["body","\n                            \n                        "],["body","\n                        \n                            "],["body","Light"],["body","\n                            "],["body","Rust"],["body","\n                            "],["body","Coal"],["body","\n                            "],["body","Navy"],["body","\n                            "],["body","Ayu"],["body","\n                        \n                    \n\n                    "],["heading","各项编程语言"],["body","\n\n                    \n\n                    \n                \n\n\n                \n                \n\n                \n                    "],["body","\n                        \n\n"],["body","\n"],["body","\n\n"],["headingLink","inheritance-in-script-objects"],["heading","Inheritance in Script Objects"],["body","\n\n"],["body","可以使用AppleScript继承机制来相互定义相关的 “脚本” 对象。这允许您在许多 “脚本” 对象之间共享属性和处理程序定义，而无需重复共享定义"],["body","\n\n"],["body","继承在以下几节中进行了描述:"],["body","\n\n"],["body","The AppleScript Inheritance Chain"],["body","\n"],["body","Defining Inheritance Through the parent Property"],["body","\n"],["body","Some Examples of Inheritance"],["body","\n"],["body","Using the continue Statement in Script Objects"],["body","\n\n"],["headingLink","the-applescript-inheritance-chain"],["heading","The AppleScript Inheritance Chain"],["body","\n\n"],["body","\n"],["body","顶级 script 对象是所有其他 script 对象的父对象，尽管任何 script 对象都可以指定不同的父对象，顶级 script 对象本身也有一个父AppleScript (AppleScript组件)。"],["body","\n"],["body","\n"],["body","\n"],["body","甚至AppleScript 也有一个父-当前的应用程序，该应用程序的名称 (通常是 script Editor) 可以通过全局常数 current application 获得。"],["body","\n"],["body","\n"],["body","\n"],["body","此层次结构定义 继承链，AppleScript搜索以查找命令的目标或术语的定义"],["body","\n"],["body","\n"],["body","\n"],["body","每个script 对象都可以访问其定义的属性，处理程序和脚本对象，以及其父对象定义的属性，处理程序和脚本对象以及继承链中任何其他对象 (包括AppleScript) 的属性，处理程序和脚本对象，这就是为什么任何脚本都可以使用 [AppleScript中的全局常量](https://developer.apple.com/library/archive/documentation/AppleScript/Conceptual/AppleScriptLangGuide/conceptual/ASLR_fundamentals.html # // apple_ref/doc/uid/TP40000983-CH218-BAJBDEJI) 中描述的常量和属性。"],["body","\n"],["body","\n\n"],["body","Note: 有一个例外. 显式的 “本地” 变量可以 屏蔽 (或阻止访问) 具有相同名称的 “全局” 变量或属性，从而在处理程序或 “脚本” 对象的范围内无法访问全局版本. 详见： Scope of Variables and Properties."],["body","\n"],["headingLink","defining-inheritance-through-the-parent-property"],["heading","Defining Inheritance Through the parent Property"],["body","\n\n"],["body","\n"],["body","使用 脚本 对象时，继承 是子 “脚本” 对象具有父对象的属性和处理程序的能力。您使用 parent 属性指定继承。"],["body","\n"],["body","\n"],["body","\n"],["body","父属性定义中列出的对象称为父对象。包含 父属性的 脚本对象称为 子脚本对象"],["body","\n"],["body","\n"],["body","\n"],["body","父属性不是必需的，但如果未指定，则每个脚本都是顶级脚本的子，as described in The AppleScript Inheritance Chain.脚本对象可以有许多子对象，但是子脚本对象只能有一个父对象。父对象可以是任何对象，例如 “列表” 或 “应用程序” 对象，但它通常是另一个 “脚本” 对象。"],["body","\n"],["body","\n\n"],["body","定义父对象的语法是"],["body","\n"],["body","(property | prop )parent : *variable*"],["body","\n\n"],["body","variable: An identifier for a variable that refers to the parent object."],["body","\n\n"],["body","必须先初始化 脚本 对象，然后才能将其分配为另一个 “脚本” 对象的父对象。这意味着父 脚本 对象的定义 (或调用创建父 “脚本” 对象的函数的命令) 必须在同一脚本中的子项定义之前。"],["body","\n"],["headingLink","some-examples-of-inheritance"],["heading","Some Examples of Inheritance"],["body","\n"],["body","熟悉C++或其他面向对象编程语言的人应该熟悉脚本对象之间的继承关系。继承其父级中定义的处理程序和属性的子脚本 对象就像C++类一样，它从其父级中继承方法和实例变量。如果子级没有自己的属性或处理程序定义，则使用继承的属性或处理程序。如果子级具有自己对特定属性或处理程序的定义，则它将忽略 (或覆盖) 继承的属性或处理程序。"],["body","\n"],["body","显示名为 “alex” 的父 “脚本” 对象和名为 “alexjunior” 的子 “脚本” 对象的定义。"],["body","\n"],["body","script Alex\n    on sayHello()\n        return \"Hello, \" & getName()\n    end sayHello\n    on getName()\n        return \"Alex\"\n    end getName\nend script\n \nscript AlexJunior\n    property parent : Alex\n    on getName()\n        return \"Alex Jr\"\n    end getName\nend script\n \n-- Sample calls to handlers in the script objects:\ntell Alex to sayHello() --result: \"Hello, Alex\"\ntell AlexJunior to sayHello() --result: \"Hello, Alex Jr.\"\n \ntell Alex to getName() --result: \"Alex\"\ntell AlexJunior to getName() --result: \"Alex Jr\"\n\n"],["body","\n\n"],["body","每个 script 对象定义一个 getName()处理程序来返回其名称。script 对象 Alex 还定义了 sayHello()处理程序。因为 AlexJunior 声明Alex是它的父对象，所以它继承了 sayHello()处理程序。"],["body","\n"],["body","使用 tell 语句调用 script 对象 Alex 的sayHello()处理程序返回 Hello，Alex。调用 script 对象 AlexJunior 的相同处理程序返回 Hello，Alex Jr 尽管在 Alex 中执行相同的 sayHello()处理程序，当该处理程序调用 getName() 时，执行的是 AlexJunior 中的 getName()。 "],["body","\n\n"],["body","改变父对象的父属性也会影响其继承的子对象"],["body","\n"],["body","父脚本对象与其子脚本对象之间的关系是动态的。如果父级的属性发生变化，则子级的继承属性也会发生变化。例如，以下脚本中的script 对象'JohnSon从script对象John继承其vegetable` 属性。"],["body","\n\n"],["body","\n"],["body","script John\n    property vegetable : \"Spinach\"\nend script\nscript JohnSon\n    property parent : John\nend script\nset vegetable of John to \"Swiss chard\"\nvegetable of JohnSon\n--result: \"Swiss chard\"\n"],["body","\n"],["body","\n\n"],["body","当您使用 set 命令更改 script 对象 John 的 vegetable 属性时，您还将更改子 script 对象 Simple 的vegetable 属性。剧本最后一行的结果是 '\"Swiss chard\"'。"],["body","\n"],["body","改变子对象中的父属性"],["body","\n"],["body","同样，如果子项更改了其继承的属性之一，则父对象中的值也会更改。例如，以下脚本中的 'script' 对象 'JohnSon' 从 'script' 对象 'John' 继承 'vegetable' 属性。"],["body","\n"],["body","script John\n    property vegetable : \"Spinach\"\nend script\nscript JohnSon\n    property parent : John\n    on changeVegetable()\n        set my vegetable to \"Zucchini\"\n    end changeVegetable\nend script\ntell JohnSon to changeVegetable()\nvegetable of John\n--result: \"Zucchini\"\n"],["body","\n"],["body","前面的示例演示了关于继承属性的一个重要观点: 要从子 “脚本” 对象中引用继承属性，必须使用保留字 “我” 或 “我的” 来指示您要引用的值是当前 “脚本” 对象的属性。(您也可以使用  of parent 一词来指示该值是父 “脚本” 对象的属性。)如果你不这样做，AppleScript假设值是一个局部变量。"],["body","\n"],["body","For example, if you refer to vegetable instead of my vegetable in the changeVegetable handler in the previous example, the result is \"Spinach\". For related information, see The it and me Keywords."],["body","\n"],["headingLink","using-the-continue-statement-in-script-objects"],["heading","Using the continue Statement in Script Objects"],["body","\n"],["body","在子脚本对象中，您可以定义与其父对象中定义的处理程序名称相同的处理程序。在实现子处理程序时，您有几个选项:"],["body","\n\n"],["body","子脚本对象中的处理程序可以独立于其父对象中的处理程序。这允许您根据需要调用任一处理程序。"],["body","\n"],["body","子级中的处理程序可以简单地调用其父级中的处理程序。这允许子对象利用父对象的实现 (as shown in the script objects below that contain a on identify handler)."],["body","\n"],["body","子级中的处理程序可以调用其父级中的处理程序，更改传递给它的值或在调用父级处理程序之前或之后执行其他语句。这允许子对象修改或添加到其父对象的行为，但仍可以利用父对象的实现。"],["body","\n\n"],["body","通常，如果子脚本对象及其父对象都具有用于同一命令的处理程序，则该子对象使用其自己的处理程序。但是，子 “脚本” 对象中的处理程序可以首先处理命令，然后使用 “continue” 语句调用父级中相同命令的处理程序。"],["body","\n"],["body","将控制权移交给另一个对象称为 委托（delegation）。通过将命令委派给父 “脚本” 对象，子程序可以扩展父程序中包含的处理程序的行为，而不必重复整个处理程序定义。父级处理命令后，AppleScript继续执行 “continue” 语句的子级位置。"],["body","\n"],["body","以下脚本包括两个 “脚本” 对象定义，即 “伊丽莎白” 和 “childofelizabeth”。"],["body","\n"],["body","script Elizabeth\n    property HowManyTimes : 0\n    to sayHello to someone\n        set HowManyTimes to HowManyTimes + 1\n        return \"Hello \" & someone\n    end sayHello\nend script\n \nscript ChildOfElizabeth\n    property parent : Elizabeth\n    on sayHello to someone\n        if my HowManyTimes > 3 then\n            return \"No, I'm tired of saying hello.\"\n        else\n            continue sayHello to someone\n        end if\n    end sayHello\nend script\ntell Elizabeth to sayHello to \"Matt\"\n--result: \"Hello Matt\", no matter how often the tell is executed\ntell ChildOfElizabeth to sayHello to \"Bob\"\n--result: \"Hello Bob\", the first four times the tell is executed;\n--   after the fourth time: \"No, I’m tired of saying hello.\"\n"],["body","\n"],["body","Continue 语句可以在委派命令之前更改命令的参数。"],["body","\n"],["body","例如，假设以下 script 对象在与前面示例相同的脚本中定义。第一个 'continue' 语句将 'sayHello' 命令的直接参数从 '“Bill”' 更改为 '“William”'。它通过指定值 '\"William\"' 而不是参数变量 'someone' 来做到这一点。"],["body","\n"],["body","script AnotherChildOfElizabeth\n\tproperty parent : Elizabeth\n\ton sayHello to someone1\n\t\tif someone1 = \"Bill\" then\n\t\t\tcontinue sayHello to \"William\"\n\t\telse\n\t\t\tcontinue sayHello to someone1\n\t\tend if\n\tend sayHello\nend script\n\ntell AnotherChildOfElizabeth to sayHello to \"Matt\"\n--result: \"Hello Matt\"\n\ntell AnotherChildOfElizabeth to sayHello to \"Bill\"\n--result: \"Hello William\"\n"],["body","\n"],["body","如果以这种方式覆盖父级的处理程序，则父级处理程序中的保留字 “我” 和 “我” 将不再引用父级，如下例所示。"],["body","\n"],["body","script Hugh\n    on identify()\n        me\n    end identify\nend script\n\nscript Andrea\n    property parent : Hugh\n    on identify()\n        continue identify()\n    end identify\nend script\n \ntell Hugh to identify()\n--result: «script Hugh»\n \ntell Andrea to identify()\n--result: «script Andrea»\n"],["body","\n\n\n\n"],["body","\n\n                    "],["body","\n\n                    \n                \n            \n\n            \n\n        \n\n\n\n\n        \n\n\n\n        \n        \n        \n\n        \n\n\n    \n    \n"]],[["_relative_fp","6.AppleScript/2.AppleScriptFundamentals/7.AliasesAndFiles.html"],["title","AliasesAndFiles - 各项编程语言"],["body","\n    \n        \n        \n\n        \n        \n\n        \n        \n\n        \n        \n\n        \n\n        \n\n            \n                                \n                \n                    \n                        "],["body","\n                            \n                        "],["body","\n                        "],["body","\n                            \n                        "],["body","\n                        \n                            "],["body","Light"],["body","\n                            "],["body","Rust"],["body","\n                            "],["body","Coal"],["body","\n                            "],["body","Navy"],["body","\n                            "],["body","Ayu"],["body","\n                        \n                    \n\n                    "],["heading","各项编程语言"],["body","\n\n                    \n\n                    \n                \n\n\n                \n                \n\n                \n                    "],["body","\n                        \n\n"],["body","\n"],["body","\n\n"],["headingLink","aliases-and-files"],["heading",".Aliases and Files"],["body","\n\n"],["body","\n"],["body","要引用macOS文件系统中的项目和位置，请使用  alias  对象和 file  对象。"],["body","\n"],["body","\n"],["body","\n"],["body","alias 对象是对现有文件系统对象的动态引用，因为它是动态的，所以即使该对象被移动或重命名，它也可以维护指向其指定文件系统对象的链接."],["body","\n"],["body","\n"],["body","\n"],["body","file 对象表示文件系统中特定位置的特定文件，可以指目前不存在的条目，例如要创建的文件的名称和位置， file  对象不是动态的，即使将其他项目移到该位置，也始终引用相同的位置。"],["body","\n"],["body","\n"],["body","\n"],["body","Posix file 伪类与file大致同义: POSIX FILE 说明符评估为 file 对象，但它们对名称使用不同的语义，as described in Specifying Paths."],["body","\n"],["body","\n\n"],["body","以下是这些类型的推荐用法:"],["body","\n\n"],["body","Use an alias object to refer to existing file system objects."],["body","\n"],["body","Use a file object to refer to a file that does not yet exist."],["body","\n"],["body","Use a POSIX file specifier 如果要使用POSIX路径指定文件。"],["body","\n\n"],["body","以下各节介绍如何按路径指定文件系统对象，以及如何在脚本中使用它们。"],["body","\n"],["headingLink","specifying-paths"],["heading","Specifying Paths"],["body","\n\n"],["body","您可以通过提供名称说明符来创建 “别名” 对象和 “文件” 对象，其中名称是文件系统中项目的路径。"],["body","\n"],["body","对于别名和文件说明符，路径是HFS路径  以如下形式\n\n"],["body","\"disk:item:subitem:subsubitem:...:item\". "],["body","\n"],["body","`Hard_Disk:Applications:Mail.app\" 是邮件应用程序的HFS路径 "],["body","\n"],["body","带有前导冒号的HFS路径 例如 \":folder:file\", 是相对于HFS工作目录解析的 . "],["body","\n"],["body","但是，不鼓励使用它们，因为HFS工作目录的位置未指定，并且无法从AppleScript对其进行控制。"],["body","\n\n"],["body","\n"],["body","对于POSIX文件说明符，路径是POSIX路径，其形式为 \"/item/subitem/subsubitem/.../item\" \"/Applications/Mail.app\"\n\n"],["body","您可以在Finder中获取信息窗口的Where字段中看到项目的POSIX路径。尽管有名称，POSIX文件说明符可能引用文件夹或磁盘。不支持使用 '\"~\"' 指定主目录。"],["body","\n"],["body","没有前导斜杠的POSIX路径，如 '\"文件夹/文件\"'，是相对于POSIX工作目录解析的"],["body","\n\n"],["body","\n\n"],["headingLink","working-with-aliases"],["heading","Working With Aliases"],["body","\n\n"],["body","\n"],["body","AppleScript定义了 “alias” 类来表示别名"],["body","\n"],["body","\n"],["body","\n"],["body","别名可以存储在变量中，并在整个脚本中使用。"],["body","\n"],["body","\n"],["body","\n"],["body","以下脚本首先在变量 'notesAlias' 中创建一个现有文件的别名，然后在打开文件的 'tell' 语句中使用该变量"],["body","\n"],["body","\n"],["body","\n"],["body","它使用 “try” 语句在创建别名之前检查别名的存在，因此即使重复运行脚本，别名也只能创建一次。"],["body","\n"],["body","\n\n"],["body","try\n notesAlias -- see if we've created the alias yet\n on error\n  -- if not, create it in the error branch\n  set notesAlias to alias \"Hard_Disk:Users:myUser:Feb_Notes.rtf\"\nend try\n-- now open the file from the alias:\n\ntell application \"TextEdit\" to open notesAlias\n"],["body","\n\n"],["body","查找别名引用的对象称为 解析 别名,AppleScript 2.0仅在运行脚本时尝试解析别名。但是，在早期版本中，AppleScript尝试在编译时解析别名。"],["body","\n"],["body","一旦您运行了前面的示例，创建别名，脚本将能够在您再次运行原始文件时找到它，即使文件名或位置发生了变化"],["body","\n"],["body","您可以通过强制将别名转换为文本来获取HFS路径:"],["body","\n\n"],["body","notesAlias as text --result: \"Hard_Disk:Users:myUser:Feb_Notes.rtf\"\n"],["body","\n"],["body","您可以使用 'POSIX PATH' 属性来获取别名引用的项目的POSIX样式路径:"],["body","\n"],["body","POSIX path of notesAlias --result: \"/Feb_Notes.rtf\"\n"],["body","\n\n"],["body","如果别名未引用现有的文件系统对象，则它将被破坏. "],["body","\n"],["body","您不能为不存在的对象创建别名，例如您计划创建的文件"],["body","\n"],["body","为此，您使用 “文件” 对象，将在下一节中进行介绍。"],["body","\n"],["body","有关示例脚本，该脚本显示了当用户在其上删除一个或多个文件图标时，脚本应用程序如何处理其接收的别名列表，请参阅 [打开处理程序](https://developer.apple.com/library/archive/documentation/AppleScript/Conceptual/AppleScriptLangGuide/conceptual/ASLR_about_handlers.html # // apple_ref/doc/uid/TP40000983-CH206-SW16)。"],["body","\n\n"],["headingLink","working-with-files"],["heading","Working With Files"],["body","\n\n"],["body","AppleScript使用file 对象来表示脚本中的文件。"],["body","\n"],["body","file  对象可以存储在变量中，并在整个脚本中使用。"],["body","\n"],["body","下面的脚本首先为变量 'notesFile' 中的现有文件创建一个 'file' 对象，"],["body","\n\n"],["body","then uses the variable in a tell statement that opens the file:"],["body","\n"],["body","set notesFile to POSIX file \"/Users/myUser/Feb_Meeting_Notes.rtf\"\ntell application \"TextEdit\" to open notesFile\n"],["body","\n"],["body","You can use a file object to specify a name and location for a file that may not exist:"],["body","\n"],["body","set newFile to POSIX file \"/Users/myUser/BrandNewFile.rtf\"\n"],["body","\n\n"],["body","\n"],["body","同样，您可以让用户使用 choose file name 命令指定一个新文件，然后使用返回的 file对象创建文件。"],["body","\n"],["body","\n"],["body","\n"],["body","在下面的示例中，如果用户取消了  choose file name  对话框，则脚本的其余部分不会执行。"],["body","\n"],["body","\n"],["body","\n"],["body","如果用户确实提供了文件名，脚本将打开文件，并在必要时创建文件，然后使用try 语句来确保在完成对文件的写入后将其关闭。"],["body","\n"],["body","\n"],["body","\n"],["body","set theFile to choose file name\nset referenceNumber to open for access theFile with write permission\ntry\n  -- statements to write to the file\n  on error\n   close access referenceNumber\nend try\nclose access referenceNumber\n"],["body","\n"],["body","\n"],["body","\n"],["body","通常，当您将  file 对象传递给某个命令，这个命令 使用它对文件系统中的新项目或现有项目进行操作时，路径的组件必须存在才能使命令成功。"],["body","\n"],["body","\n\n\n\n\n"],["body","\n\n                    "],["body","\n\n                    \n                \n            \n\n            \n\n        \n\n\n\n\n        \n\n\n\n        \n        \n        \n\n        \n\n\n    \n    \n"]],[["_relative_fp","6.AppleScript/2.AppleScriptFundamentals/8.RemoteApplications.html"],["title","RemoteApplications - 各项编程语言"],["body","\n    \n        \n        \n\n        \n        \n\n        \n        \n\n        \n        \n\n        \n\n        \n\n            \n                                \n                \n                    \n                        "],["body","\n                            \n                        "],["body","\n                        "],["body","\n                            \n                        "],["body","\n                        \n                            "],["body","Light"],["body","\n                            "],["body","Rust"],["body","\n                            "],["body","Coal"],["body","\n                            "],["body","Navy"],["body","\n                            "],["body","Ayu"],["body","\n                        \n                    \n\n                    "],["heading","各项编程语言"],["body","\n\n                    \n\n                    \n                \n\n\n                \n                \n\n                \n                    "],["body","\n                        \n\n"],["body","\n"],["body","\n\n"],["headingLink","remote-applications"],["heading","Remote Applications"],["body","\n"],["body","如果在远程计算机上启用了远程应用程序，并且脚本使用epc样式的说明符指定了该计算机，则该脚本可以针对该远程计算机上的应用程序。"],["body","\n"],["headingLink","enabling-remote-applications"],["heading","Enabling Remote Applications"],["body","\n"],["body","要使脚本向远程应用程序发送命令，必须满足以下条件:"],["body","\n\n"],["body","包含应用程序的计算机和运行脚本的计算机必须通过网络相互连接。"],["body","\n"],["body","必须在远程计算机上启用远程Apple事件 (set in the Sharing preferences pane)，并且必须提供用户访问权限 (您可以允许所有用户或仅允许指定用户访问)。"],["body","\n"],["body","如果指定的远程应用程序未运行，则必须运行它."],["body","\n"],["body","编译或运行脚本时，必须以admin身份进行身份验证。"],["body","\n\n"],["headingLink","eppc-style-specifiers"],["heading","eppc-Style Specifiers"],["body","\n"],["body","Epc样式的说明符采用以下格式:"],["body","\n"],["body","eppc://[user[:password]@]IP_address\n"],["body","\n\n"],["body","\n"],["body","ip_address"],["body","\n"],["body","Either a numeric IP address in dotted decimal form (four numbers, from 0 to 255, separated by periods; for example, 123.23.23.123) or a hostname. A hostname can be a Bonjour name."],["body","\n"],["body","\n\n"],["body","The following are examples of valid eppc-style specifiers. If you supply the user name and password, no authentication is required. If you do not supply it, authentication may be required."],["body","\n"],["body","\n"],["body","\"eppc://myCoolMac.local\" -- hostname, no user or pwd"],["body","\n"],["body","\"eppc://myUserName:pwd@myCoolMac.local\" -- user, pwd, and hostname"],["body","\n"],["body","\"eppc://123.23.23.123\" -- IP address, no user or pwd"],["body","\n"],["body","\"eppc://myUserName:pwd@123.23.23.123\" -- user, pwd, and IP address"],["body","\n"],["body","\"eppc://myUserName@server.company.com\" -- server address, user"],["body","\n\n\n"],["body","Important: 如果epc样式说明符的一部分包含non-UTF-8字符或空白，则必须对其进行URL编码: 例如，这里是一个包含空格的用户名:"],["body","\n"],["body","John%20Smith."],["body","\n"],["headingLink","targeting-remote-applications"],["heading","Targeting Remote Applications"],["body","\n\n"],["body","\n"],["body","您可以定位在远程计算机上运行的应用程序，并且可以在当前未运行的远程计算机上启动应用程序."],["body","\n"],["body","\n"],["body","\n"],["body","下面的示例使用epc样式的说明符来定位远程计算机上的Finder"],["body","\n"],["body","\n"],["body","\n"],["body","它包括用户名和密码，因此不需要身份验证。"],["body","\n"],["body","\n"],["body","\n"],["body","set remoteMachine to \"eppc://userName:pwd@MacName.local\"\ntell app \"Finder\" of machine remoteMachine to close front window\n"],["body","\n"],["body","\n\n"],["body","Important: 如果编译错误的epc样式的地址，则必须退出并重新启动脚本编辑器，以使对该地址的更改生效。"],["body","\n\n"],["body","\n"],["body","在某些情况下，您需要使用  using terms from  语句来告诉AppleScript针对应用程序的本地版本进行编译。"],["body","\n"],["body","\n"],["body","\n"],["body","下面的示例使用该技术告诉remote Finder应用程序打开TextEdit应用程序:"],["body","\n"],["body","\n"],["body","\n"],["body","set remoteFinder to application \"Finder\" of machine ¬\n \"eppc://myUserName:pwd@123.23.23.123\"\n \nusing terms from application \"Finder\"\n\ttell remoteFinder\n  \topen application file id \"com.apple.TextEdit\"\n\tend tell\nend using terms from\n\n"],["body","\n"],["body","\n"],["body","\n"],["body","如果您在前一个脚本中省略了密码 ('pwd')，则在运行脚本时必须进行身份验证。"],["body","\n"],["body","\n\n\n\n\n"],["body","\n\n                    "],["body","\n\n                    \n                \n            \n\n            \n\n        \n\n\n\n\n        \n\n\n\n        \n        \n        \n\n        \n\n\n    \n    \n"]],[["_relative_fp","6.AppleScript/2.AppleScriptFundamentals/10.DebuggingAppleScripts.html"],["title","DebuggingAppleScripts - 各项编程语言"],["body","\n    \n        \n        \n\n        \n        \n\n        \n        \n\n        \n        \n\n        \n\n        \n\n            \n                                \n                \n                    \n                        "],["body","\n                            \n                        "],["body","\n                        "],["body","\n                            \n                        "],["body","\n                        \n                            "],["body","Light"],["body","\n                            "],["body","Rust"],["body","\n                            "],["body","Coal"],["body","\n                            "],["body","Navy"],["body","\n                            "],["body","Ayu"],["body","\n                        \n                    \n\n                    "],["heading","各项编程语言"],["body","\n\n                    \n\n                    \n                \n\n\n                \n                \n\n                \n                    "],["body","\n                        \n\n"],["body","\n"],["body","\n\n"],["headingLink","debugging-applescript-scripts"],["heading","\\Debugging AppleScript Scripts"],["body","\n"],["body","AppleScript不包含内置调试器，但它确实提供了几种简单的机制来帮助您调试脚本或只是观察它们的工作方式。"],["body","\n"],["headingLink","feedback-from-your-script"],["heading","Feedback From Your Script"],["body","\n"],["body","您可以在脚本中插入各种语句以指示当前位置和其他信息"],["body","\n"],["body","在最简单的情况下，您可以在感兴趣的位置插入蜂鸣声命令:"],["body","\n"],["body","beep 3 -- three beeps; a very important part of the script!\n"],["body","\n"],["body","display dialog 命令可以显示有关脚本中发生的事情的信息，并且像断点一样，它会停止执行，直到您将其关闭 (或直到超时，取决于您传递的参数)。以下示例显示当前脚本位置和变量的值"],["body","\n"],["body","display dialog \"In factorial routine; x = \" & (x as string)\n"],["body","\n"],["body","“say” 命令可以通过说出指定的文本来引起您的注意。在下面的示例中，'currentClient' 是一个存储客户端名称的 'text' 对象:"],["body","\n"],["body","say \"I'm in the clientName handler. The client is \" & currentClient\n"],["body","\n"],["headingLink","logging"],["heading","Logging"],["body","\n\n"],["body","脚本编辑器可以显示在执行脚本期间发送的Apple事件的日志"],["body","\n"],["body","在脚本编辑器首选项中，您还可以选择保留最近结果或事件日志的历史记录。"],["body","\n"],["body","此外，您可以在脚本中插入 “日志” 语句。日志输出显示在脚本窗口的事件日志窗格中，如果已打开，也显示在事件日志历史窗口中。"],["body","\n\n"],["body","The following simple example logs the current word in a repeat with loopVariable (in list) statement:"],["body","\n"],["body","set wordList to words in \"Where is the hammer?\"\nrepeat with currentWord in wordList\n  log currentWord\n\tif contents of currentWord is equal to \"hammer\" then\n   display dialog \"I found the hammer!\"\n  end if\nend repeat\n"],["body","\n"],["body","下面显示脚本运行时，单词在日志中的显示方式:"],["body","\n"],["body","    (*Where*)\n    (*is*)\n    (*the*)\n    (*hammer*)\n"],["body","\n"],["headingLink","third-party-debuggers"],["heading","Third Party Debuggers"],["body","\n"],["body","If you need full-featured debugging capabilities, there are powerful, third-party AppleScript debuggers available."],["body","\n\n\n\n"],["body","\n\n                    "],["body","\n\n                    \n                \n            \n\n            \n\n        \n\n\n\n\n        \n\n\n\n        \n        \n        \n\n        \n\n\n    \n    \n"]],[["_relative_fp","6.AppleScript/2.AppleScriptFundamentals/index.html"],["title","2.AppleScriptFundamentals - 各项编程语言"],["body","\n    \n        \n        \n\n        \n        \n\n        \n        \n\n        \n        \n\n        \n\n        \n\n            \n                                \n                \n                    \n                        "],["body","\n                            \n                        "],["body","\n                        "],["body","\n                            \n                        "],["body","\n                        \n                            "],["body","Light"],["body","\n                            "],["body","Rust"],["body","\n                            "],["body","Coal"],["body","\n                            "],["body","Navy"],["body","\n                            "],["body","Ayu"],["body","\n                        \n                    \n\n                    "],["heading","各项编程语言"],["body","\n\n                    \n\n                    \n                \n\n\n                \n                \n\n                \n                    "],["body","\n                        \n\n"],["body","\n"],["body","\n\n"],["headingLink","applescript-fundamentals"],["heading","AppleScript Fundamentals"],["body","\n"],["body","本章介绍了基本概念，这些概念是本指南其余部分涵盖的术语和规则的基础。"],["body","\n\n"],["body","Script Editor Application"],["body","\n"],["body","AppleScript and Objects"],["body","\n"],["body","Object Specifiers"],["body","\n"],["body","Coercion (Object Conversion)"],["body","\n"],["body","Scripting Additions"],["body","\n"],["body","Commands Overview"],["body","\n"],["body","AppleScript Error Handling"],["body","\n"],["body","Global Constants in AppleScript"],["body","\n"],["body","The it and me Keywords"],["body","\n"],["body","Aliases and Files"],["body","\n"],["body","Remote Applications"],["body","\n"],["body","Debugging AppleScript Scripts"],["body","\n\n"],["headingLink","script-editor-application"],["heading","Script Editor Application"],["body","\n\n"],["body","\n"],["body","The Script Editor application is located in /Applications/Utilities."],["body","\n"],["body","\n"],["body","\n"],["body","它提供了编辑、编译和执行脚本、显示应用程序脚本术语以及保存各种格式的脚本的能力，例如已编译的脚本、应用程序和纯文本。"],["body","\n"],["body","\n"],["body","\n"],["body","脚本编辑器可以显示执行AppleScript脚本的结果，并可以显示在执行脚本期间发送的Apple事件的日志"],["body","\n"],["body","\n"],["body","\n"],["body","在脚本编辑器首选项中，您还可以选择保留最近结果或事件日志的历史记录."],["body","\n"],["body","\n"],["body","\n"],["body","脚本编辑器对各种类型的脚本文本具有文本格式首选项，例如语言关键字，注释等"],["body","\n"],["body","\n"],["body","\n"],["body","您还可以打开或关闭脚本助手，这是一个代码完成工具，可以在您键入时建议和填写脚本术语"],["body","\n"],["body","\n"],["body","\n"],["body","此外，脚本编辑器提供了一个上下文菜单，用于插入许多类型的样板脚本语句，如条件、注释和错误处理程序"],["body","\n"],["body","\n\n\n"],["body","字典 是可编写脚本的应用程序的一部分，它指定它支持的脚本术语"],["body","\n"],["body","您可以在脚本编辑器中选择 “文件”> “打开字典”，以在计算机上显示可脚本应用程序或脚本添加的字典。或者，您可以将应用程序图标拖到脚本编辑器图标上以显示其字典 (如果有的话)。"],["body","\n"],["body","要显示仅包含macOS提供的可编写脚本的应用程序和脚本添加的列表 choose Window > Library. Double-click an item in the list to display its dictionary. "],["body","\n"],["body","The dictionary is labeled as “Finder.sdef”. The sdef format, along with other terminology formats, is described in “Specifying Scripting Terminology” in AppleScript Overview."],["body","\n\n"],["headingLink","applescript-and-objects"],["heading","AppleScript and Objects"],["body","\n"],["body","AppleScript是一种面向对象的语言。当你编写、编译和执行脚本时，你工作的一切都是一个对象。 object 是类定义的实例化，它可以包括属性和操作。AppleScript为您最常使用的对象定义类，从顶层 “script” 对象开始，该对象是您正在使用的整体脚本。"],["body","\n"],["body","在 “script” 对象中，您可以使用其他对象，包括:"],["body","\n\n"],["body","\n"],["body","AppleScript objects:"],["body","\n"],["body","AppleScript defines classes for boolean values, scripts, text, numbers, and other kinds of objects for working in scripts; for a complete list, see Class Reference."],["body","\n"],["body","\n"],["body","\n"],["body","macOS objects:"],["body","\n"],["body","Scriptable parts of macOS and applications distributed with it, such as Finder, System Events, and Database Events (located in /System/Library/CoreServices), define many useful classes."],["body","\n"],["body","\n"],["body","\n"],["body","Application objects:"],["body","\n"],["body","Third-party scriptable applications define classes that support a wide variety of features."],["body","\n"],["body","\n\n"],["body","The following sections provide more detail about objects:"],["body","\n\n"],["body","What Is in a Script Object"],["body","\n"],["body","Properties"],["body","\n"],["body","Elements"],["body","\n\n"],["headingLink","what-is-in-a-script-object"],["heading","What Is in a Script Object"],["body","\n\n"],["body","当您在脚本编辑器的脚本窗口中输入AppleScript语句时，您正在使用顶级 “script” 对象"],["body","\n"],["body","所有 “script” 对象定义都遵循相同的语法，除了顶级 “脚本” 对象没有标记其开始和结束的语句。"],["body","\n\n"],["body","“script” 对象可以包含以下内容:"],["body","\n\n"],["body","\n"],["body","Property definitions (optional): 属性定义"],["body","\n"],["body","A property is a labeled container in which to store a value."],["body","\n"],["body","\n"],["body","\n"],["body","An explicit run handler (optional): 显示的run handler "],["body","\n"],["body","A run handler contains statements AppleScript executes when the script is run. (For more information, see run Handlers.)"],["body","\n"],["body","\n"],["body","\n"],["body","An implicit run handler (optional):隐式的 run handler "],["body","\n"],["body","An implicit run handler consists of any statements outside of any contained handlers or script objects."],["body","\n"],["body","任何除了 handlers、scripts objecsts 之外的 语句 即是 隐式运行的 handler"],["body","\n"],["body","\n"],["body","\n"],["body","Additional handlers (optional):"],["body","\n"],["body","A handler is the equivalent of a subroutine. (For details, see About Handlers.)"],["body","\n"],["body","\n"],["body","\n"],["body","Additional script objects (optional):"],["body","\n"],["body","A script object can contain nested script objects, each of which is defined just like a top-level script object, except that a nested script object is bracketed with statements that mark its beginning and end. (For details, see Script Objects.)"],["body","\n"],["body","\n\n"],["body","Here is an example of a simple script with one property, one handler, one nested script object, and an implicit run handler with two statements:"],["body","\n"],["body","property defaultClientName : \"Mary Smith\"\non greetClient(nameOfClient)`\n    display dialog (\"Hello \" & nameOfClient & \"!\")\nend greetClient\n\nscript testGreet\n    greetClient(defaultClientName)\nend script\n\nrun testGreet --result: \"Hello Mary Smith!\"\n\ngreetClient(\"Joe Jones\") --result: \"Hello Joe Jones!\"\n"],["body","\n"],["body","The first statement in the run handler is run testGreet, which runs the nested script object testGreet. That script object calls the handler greetClient(), passing the property defaultClientName. The handler displays a dialog, greeting the default client, Mary Smith."],["body","\n"],["body","The second statement in the run handler calls greetClient() directly, passing the string \"Joe Jones\"."],["body","\n"],["headingLink","properties"],["heading","Properties"],["body","\n\n"],["body","对象的 属性是具有单个值和标签的特性，例如窗口的 'name' 属性或日期的 'month' 属性"],["body","\n"],["body","任何AppleScript类的定义都包括其每个属性的名称和类"],["body","\n"],["body","属性名称在类中必须是唯一的。属性值可以是读/写或只读"],["body","\n"],["body","例如，AppleScript 'date' 类定义了读/写和只读属性。"],["body","\n"],["body","其中包括只读的 “weekday” 属性，以及读/写的 “month”，“day” 和 “year” 属性"],["body","\n"],["body","这是因为 “weekday” 属性的值取决于其他属性-您不能为实际日期设置任意工作日"],["body","\n"],["body","属性的类可以是简单的类，例如 'boolean' 或 'integer'，复合类，例如 'point' 类 (由两个整数组成)，或者更复杂的类"],["body","\n"],["body","大多数类只支持预定义的属性。但是，对于 'script' 类，AppleScript允许您定义其他属性. "],["body","\n"],["body","For information on how to do this, see Defining Properties. You can also define properties for record objects."],["body","\n\n"],["headingLink","elements"],["heading","Elements"],["body","\n\n"],["body","\n"],["body","元素是包含在另一个对象中的对象"],["body","\n"],["body","\n"],["body","\n"],["body","任何AppleScript类的定义都包括它可以包含的元素类型 . "],["body","\n"],["body","\n"],["body","\n"],["body","一个对象通常可以包含其每个元素中的零个或多个."],["body","\n"],["body","\n"],["body","\n"],["body","对于给定的元素类型，一个对象可以包含许多元素，也可以不包含任何元素，并且它包含的元素数量可能会随时间变化"],["body","\n"],["body","\n"],["body","\n"],["body","是否可以向对象添加元素或从对象中删除元素取决于类和元素"],["body","\n"],["body","\n"],["body","\n"],["body","例如，“文本” 对象是不可变的-创建对象后，您无法添加或删除文本。"],["body","\n"],["body","\n"],["body","\n"],["body","对于 “列表” 对象，您不能删除项目，但是可以使用 “设置” 命令将项目添加到开头或结尾:"],["body","\n"],["body","\n"],["body","\n"],["body","set myList to {1, \"what\", 3} --result: {1, \"what\", 3}\nset beginning of myList to 0\nset end of myList to \"four\"\nmyList --result: {0, 1, \"what\", 3, \"four\"}\n"],["body","\n"],["body","\n\n"],["body","https://developer.apple.com/library/archive/documentation/AppleScript/\n"],["body","\n\n\n\n"],["body","\n\n                    "],["body","\n\n                    \n                \n            \n\n            \n\n        \n\n\n\n\n        \n\n\n\n        \n        \n        \n\n        \n\n\n    \n    \n"]],[["_relative_fp","6.AppleScript/2.AppleScriptFundamentals/2.Coercion(ObjectConversion).html"],["title","Coercion(ObjectConversion) - 各项编程语言"],["body","\n    \n        \n        \n\n        \n        \n\n        \n        \n\n        \n        \n\n        \n\n        \n\n            \n                                \n                \n                    \n                        "],["body","\n                            \n                        "],["body","\n                        "],["body","\n                            \n                        "],["body","\n                        \n                            "],["body","Light"],["body","\n                            "],["body","Rust"],["body","\n                            "],["body","Coal"],["body","\n                            "],["body","Navy"],["body","\n                            "],["body","Ayu"],["body","\n                        \n                    \n\n                    "],["heading","各项编程语言"],["body","\n\n                    \n\n                    \n                \n\n\n                \n                \n\n                \n                    "],["body","\n                        \n\n"],["body","\n"],["body","\n\n"],["headingLink","coercion-object-conversion"],["heading","Coercion (Object Conversion)"],["body","\n\n"],["body","\n"],["body","强制 (也称为 对象转换) 是将对象从一个类转换为另一个类的过程。"],["body","\n"],["body","\n"],["body","\n"],["body","在以下两种情况下，AppleScript将对象转换为不同的类:"],["body","\n\n"],["body","\n"],["body","in response to the as operator"],["body","\n"],["body","\n"],["body","\n"],["body","当对象的类与特定命令或操作的预期类不同时，自动"],["body","\n"],["body","\n\n"],["body","\n\n\n"],["body","\n"],["body","并非所有类都可以强制使用所有其他类类型."],["body","\n"],["body","\n"],["body","\n"],["body","表2-1总结了AppleScript支持常用类的强制"],["body","\n"],["body","\n"],["body","\n"],["body","For more information about each coercion, see the corresponding class definition in Class Reference."],["body","\n"],["body","\n"],["body","\n"],["body","AppleScript提供了许多强制，要么作为语言的内置部分，要么通过标准添加脚本添加"],["body","\n"],["body","\n"],["body","\n"],["body","您可以在脚本中的 “tell” 块之外使用这些强制"],["body","\n"],["body","\n"],["body","\n"],["body","但是，应用程序类类型的强制可能取决于应用程序，并且需要 指定应用程序的 “tell” 块。"],["body","\n"],["body","\n"],["body","\n"],["body","“As” 运算符指定特定的强制或一组强制。"],["body","\n"],["body","\n\n"],["body","例如，以下语句在将整数 “2” 存储到变量 “mytext” 之前，将其强制转换为文本“ 2 ”:"],["body","\n"],["body","set myText to 2 as text\n"],["body","\n"],["body","如果提供了错误类的命令参数或操作数，如果可能，AppleScript会自动将操作数或参数强制转换为预期的类。如果无法执行转换，AppleScript会报告错误。"],["body","\n\n"],["body","将 “文本” 字符串强制转换为 “interger”，“number” 或 “real” 的值时，反之亦然，AppleScript使用 “国际首选项” 中的 “格式” 窗格中的当前数字设置来确定要在字符串中使用哪些分隔符。"],["body","\n"],["body","将字符串强制转换为 “日期” 类的值，反之亦然，AppleScript将使用  Formats pane. 中的当前日期设置。"],["body","\n\n"],["body","Convert from class"],["body","To class"],["body","Notes"],["body","\n"],["body","alias"],["body","list (single-item)text"],["body","\n"],["body","application"],["body","list (single-item)"],["body","This is both an AppleScript class and an application class."],["body","\n"],["body","boolean"],["body","integer``list (single-item)text"],["body","\n"],["body","class"],["body","list (single-item)text"],["body","\n"],["body","constant"],["body","list (single-item)text"],["body","\n"],["body","date"],["body","list (single-item)text"],["body","\n"],["body","file"],["body","list (single-item)text"],["body","\n"],["body","integer"],["body","list (single-item)real``text"],["body","Coercing an integer to a number does not change its class."],["body","\n"],["body","list (single-item)"],["body","any class to which the item can be coerced if it is not part of a list"],["body","\n"],["body","list (multiple-item)"],["body","text, if each of the items in the list can be coerced to a text object"],["body","\n"],["body","number"],["body","integer``list (single-item)real``text"],["body","Values identified as values of class number are really values of either class integer or class real."],["body","\n"],["body","POSIX file"],["body","see file"],["body","POSIX file is a pseudo-class equivalent to the file class."],["body","\n"],["body","real"],["body","integer``list (single-item)"],["body","In coercing to integer, any fractional part is rounded.Coercing a real to a number does not change its class."],["body","\n"],["body","record"],["body","list"],["body","All labels are lost in the coercion and the resulting list cannot be coerced back to a record."],["body","\n"],["body","reference"],["body","any class to which the referenced object can be coerced"],["body","\n"],["body","script"],["body","list (single-item)"],["body","\n"],["body","text"],["body","integer``list (single-item)real"],["body","Can coerce to integer or real only if the text object represents an appropriate number."],["body","\n"],["body","unit types"],["body","integer``list (single-item)real``text"],["body","Can coerce between unit types in the same category, such as inches to kilometers (length) or gallons to liters (liquid volume)."],["body","\n\n\n\n\n"],["body","\n\n                    "],["body","\n\n                    \n                \n            \n\n            \n\n        \n\n\n\n\n        \n\n\n\n        \n        \n        \n\n        \n\n\n    \n    \n"]],[["_relative_fp","6.AppleScript/2.AppleScriptFundamentals/6.ITAndMe.html"],["title","ITAndMe - 各项编程语言"],["body","\n    \n        \n        \n\n        \n        \n\n        \n        \n\n        \n        \n\n        \n\n        \n\n            \n                                \n                \n                    \n                        "],["body","\n                            \n                        "],["body","\n                        "],["body","\n                            \n                        "],["body","\n                        \n                            "],["body","Light"],["body","\n                            "],["body","Rust"],["body","\n                            "],["body","Coal"],["body","\n                            "],["body","Navy"],["body","\n                            "],["body","Ayu"],["body","\n                        \n                    \n\n                    "],["heading","各项编程语言"],["body","\n\n                    \n\n                    \n                \n\n\n                \n                \n\n                \n                    "],["body","\n                        \n\n"],["body","\n"],["body","\n\n"],["headingLink","the-it-and-me-keywords"],["heading","The it and me Keywords"],["body","\n\n"],["body","\n"],["body","AppleScript定义关键字 'me' 来引用 current script"],["body","\n"],["body","\n"],["body","\n"],["body","和关键字 it 指的是当前目标. "],["body","\n"],["body","\n"],["body","\n"],["body","当前脚本  是当前正在执行的脚本; 当前目标  是当前命令默认目标的对象"],["body","\n"],["body","\n"],["body","\n"],["body","It also defines my as a synonym for of me and its as a synonym for of it."],["body","\n"],["body","\n"],["body","\n"],["body","它还将 my 定义为 of me 的同义词，将 its 定义为of it 的同义词。"],["body","\n"],["body","\n"],["body","\n"],["body","如果脚本没有针对任何目标，则 it 和 me 指的是同一件事-script-如以下示例所示:"],["body","\n\n"],["body","\n"],["body","-- At the top-level of the script:\nme --result: «script» (the top-level script object)\nit --result: «script» (same as it, since no target set yet)\n"],["body","\n"],["body","\n\n"],["body","2.tell 语句指定默认目标。在下面的示例中，默认目标是Finder应用程序:"],["body","\n"],["body","-- Within a tell block:\ntell application \"Finder\" -- sets target\nme --result: «script» (still the top-level script object)\nit --result: application \"Finder\" (target of the tell statement)\nend tell\n"],["body","\n"],["body","\n\n"],["body","You can use the words of me or my to indicate that the target of a command is the current script and not the target of the tell statement. "],["body","\n"],["body","tell application \"Finder\"\nset fileCount to count files in front window\n set myCount to my minimumValue(fileCount, 100)\n --do something with up to the first 100 files…\n end tell\n"],["body","\n\n"],["body","\n"],["body","还可以使用of me 或  my 来区分脚本属性和对象属性"],["body","\n"],["body","\n"],["body","\n"],["body","Suppose there is a TextEdit document open named “Simple.rtf”:"],["body","\n"],["body","\n\n"],["body","tell document 1 of application \"TextEdit\"\n name --result: \"Simple.rtf\" (implicitly uses target of tell)\n name of it --result: \"Simple.rtf\" (specifies target of tell)\n me --result: «script» (top-level script object, not target of tell)\n end tell\n"],["body","\n\n"],["body","\n"],["body","下面的示例演示如何在Finder 'tell' 语句中指定不同的 'version' 属性。"],["body","\n"],["body","\n"],["body","\n"],["body","Finder是默认目标，但是使用 version of me，my version 或 applescript of version 可以指定顶级 “脚本” 对象的版本"],["body","\n"],["body","\n"],["body","\n"],["body","The top-level script object returns the AppleScript version, because it inherits from AppleScript, as described in The AppleScript Inheritance Chain."],["body","\n"],["body","\n"],["body","\n"],["body","顶级 script 对象返回 AppleScript版本，因为它从AppleScript继承，如 [AppleScript继承链](https://developer.apple.com/library/archive/documentation/AppleScript/Conceptual/AppleScriptLangGuide/conceptual/ASLR_script_objects.html # // apple_ref/doc/uid/TP40000983-CH207-SW15) 中所述。"],["body","\n"],["body","\n"],["body","\n"],["body","tell application \"Finder\"\n version --result: \"10.5.1\" (Finder version is the default in tell block)\n its version --result: \"10.5.1\" (specifically asks for Finder version)\n version of me --result: \"2.0\" (AppleScript version)\n my version --result: \"2.0\" (AppleScript version)\n version of AppleScript --result: \"2.0\" (AppleScript version)\nend tell\n"],["body","\n"],["body","\n"],["body","\n"],["body","有关在过滤器引用中使用 “it” 的信息，请参阅 [过滤器](https://developer.apple.com/library/archive/documentation/AppleScript/Conceptual/AppleScriptLangGuide/reference/ASLR_reference_forms.html # // apple_ref/doc/uid/TP40000983-CH4g-BAJJHEFE)  reference form 的讨论部分。"],["body","\n"],["body","\n\n\n\n\n"],["body","\n\n                    "],["body","\n\n                    \n                \n            \n\n            \n\n        \n\n\n\n\n        \n\n\n\n        \n        \n        \n\n        \n\n\n    \n    \n"]],[["_relative_fp","6.AppleScript/2.AppleScriptFundamentals/9.ErrorHanding.html"],["title","ErrorHanding - 各项编程语言"],["body","\n    \n        \n        \n\n        \n        \n\n        \n        \n\n        \n        \n\n        \n\n        \n\n            \n                                \n                \n                    \n                        "],["body","\n                            \n                        "],["body","\n                        "],["body","\n                            \n                        "],["body","\n                        \n                            "],["body","Light"],["body","\n                            "],["body","Rust"],["body","\n                            "],["body","Coal"],["body","\n                            "],["body","Navy"],["body","\n                            "],["body","Ayu"],["body","\n                        \n                    \n\n                    "],["heading","各项编程语言"],["body","\n\n                    \n\n                    \n                \n\n\n                \n                \n\n                \n                    "],["body","\n                        \n\n"],["body","\n"],["body","\n\n"],["headingLink","applescript-error-handling"],["heading","AppleScript Error Handling"],["body","\n\n"],["body","\n"],["body","在脚本执行期间，由于与macOS的交互，应用程序脚本命令中遇到的问题或脚本本身中的语句引起的问题，可能会发生错误。"],["body","\n"],["body","\n"],["body","\n"],["body","发生错误时，AppleScript会在当前位置停止执行，发出错误信号，并在调用链中查找可以处理错误的脚本语句。也就是说，它查找围绕错误发生位置的最近的错误处理代码块。"],["body","\n"],["body","\n"],["body","\n"],["body","脚本可以通过在 try 语句中包含可能遇到错误的语句来处理错误。try 语句包括 on error section，如果发生错误，该部分将被调用。AppleScript将有关错误的信息 (包括错误号和错误消息) 传递到 on error 部分。这允许脚本检查错误号并显示有关它的信息。"],["body","\n"],["body","\n"],["body","\n"],["body","如果错误发生在不提供 try 语句的处理程序中，AppleScript将在调用处理程序的位置查找封闭的 try 语句。如果调用链中没有一个调用包含在 “try” 语句中，AppleScript将停止脚本的执行并显示错误消息 (对于-128以外的任何错误号，如下所述)。"],["body","\n"],["body","\n"],["body","\n"],["body","脚本可以使用  error 语句直接发出错误信号。这样做会调用AppleScript错误处理机制，该机制会寻找一个封闭的 'try' 语句来处理错误。"],["body","\n"],["body","\n"],["body","\n"],["body","一些 “错误” 是命令正常运行的结果：例如，display dialog 和 choose file  等命令发出 error –128 (User canceled) 如果用户点击取消按钮。"],["body","\n"],["body","\n"],["body","\n"],["body","脚本按惯例应处理用户取消的错误，以确保正常运行"],["body","\n"],["body","\n"],["body","\n"],["body","有关如何执行此操作的示例，请参见 display dialog 命令的示例部分，如果脚本中没有 try 语句处理-128错误，AppleScript会停止执行脚本，而不会显示任何错误消息。"],["body","\n"],["body","\n"],["body","\n"],["body","For related information, see Results, error Statements, try Statements, Error Numbers and Error Messages, and Working with Errors."],["body","\n"],["body","\n\n\n\n\n"],["body","\n\n                    "],["body","\n\n                    \n                \n            \n\n            \n\n        \n\n\n\n\n        \n\n\n\n        \n        \n        \n\n        \n\n\n    \n    \n"]],[["_relative_fp","6.AppleScript/2.AppleScriptFundamentals/3.ScriptingAdditions.html"],["title","ScriptingAdditions - 各项编程语言"],["body","\n    \n        \n        \n\n        \n        \n\n        \n        \n\n        \n        \n\n        \n\n        \n\n            \n                                \n                \n                    \n                        "],["body","\n                            \n                        "],["body","\n                        "],["body","\n                            \n                        "],["body","\n                        \n                            "],["body","Light"],["body","\n                            "],["body","Rust"],["body","\n                            "],["body","Coal"],["body","\n                            "],["body","Navy"],["body","\n                            "],["body","Ayu"],["body","\n                        \n                    \n\n                    "],["heading","各项编程语言"],["body","\n\n                    \n\n                    \n                \n\n\n                \n                \n\n                \n                    "],["body","\n                        \n\n"],["body","\n"],["body","\n\n"],["headingLink","scripting-additions"],["heading","Scripting Additions"],["body","\n\n"],["body","\n"],["body","脚本添加是一个文件或捆绑包，提供处理程序，您可以在脚本中使用它来执行命令和强制."],["body","\n"],["body","\n"],["body","\n"],["body","本指南中描述的许多命令都是在macOS中的标准添加脚本添加中定义的 这些命令存储在文件中 StandardAdditions.osax in /System/Library/ScriptingAdditions, 并且可用于任何脚本。您可以通过在脚本编辑器中打开此文件来检查标准添加项的术语。"],["body","\n"],["body","\n"],["body","\n"],["body","注意: 脚本可以使用此脚本语句获取标准添加项的位置，该语句使用 “ path to (folder)  ” 命令:"],["body","\n"],["body","\n"],["body","\n"],["body","path to scripting additions as text\n    --result: \"Hard_Disk:System:Library:ScriptingAdditions:\"\n"],["body","\n"],["body","\n"],["body","\n"],["body","脚本添加 可以嵌入捆绑的脚本小程序中，方法是将它们放在一个名为 “Scripting Additions” 的文件夹中 (注意 “Scripting” 和 “Additions” 之间的空格)，在捆绑的 “Contents/Resources/ ” 文件夹中。"],["body","\n"],["body","\n"],["body","\n"],["body","Note that Script Editor does not look for embedded scripting additions when editing bundled applets"],["body","\n"],["body","\n"],["body","\n"],["body","During script development, any required scripting additions must be properly installed in /System/ScriptingAdditions, /Library/ScriptingAdditions, or ~/Library/ScriptingAdditions so that Script Editor can find them."],["body","\n"],["body","\n"],["body","\n"],["body","Developers can create their own scripting additions, as described in Technical Note TN1164, Scripting Additions for Mac OS X. For related conceptual information, see AppleScript Overview, particularly the section “Extending AppleScript with Coercions, Scripting Additions, and Faceless Background Applications” in the chapter Open Scripting Architecture."],["body","\n"],["body","\n\n\n\n\n"],["body","\n\n                    "],["body","\n\n                    \n                \n            \n\n            \n\n        \n\n\n\n\n        \n\n\n\n        \n        \n        \n\n        \n\n\n    \n    \n"]],[["_relative_fp","6.AppleScript/2.AppleScriptFundamentals/5.GlobalConstantsInAppleScript.html"],["title","GlobalConstantsInAppleScript - 各项编程语言"],["body","\n    \n        \n        \n\n        \n        \n\n        \n        \n\n        \n        \n\n        \n\n        \n\n            \n                                \n                \n                    \n                        "],["body","\n                            \n                        "],["body","\n                        "],["body","\n                            \n                        "],["body","\n                        \n                            "],["body","Light"],["body","\n                            "],["body","Rust"],["body","\n                            "],["body","Coal"],["body","\n                            "],["body","Navy"],["body","\n                            "],["body","Ayu"],["body","\n                        \n                    \n\n                    "],["heading","各项编程语言"],["body","\n\n                    \n\n                    \n                \n\n\n                \n                \n\n                \n                    "],["body","\n                        \n\n"],["body","\n"],["body","\n\n"],["headingLink","global-constants-in-applescript"],["heading","Global Constants in AppleScript"],["body","\n"],["body","AppleScript定义了许多全局常量，您可以在脚本中的任何位置使用它们。"],["body","\n"],["headingLink","applescript-constant"],["heading","AppleScript Constant"],["body","\n\n"],["body","\n"],["body","全局常量 'AppleScript' 提供对您可以在整个脚本中使用的属性的访问"],["body","\n"],["body","\n"],["body","\n"],["body","您可以使用 'AppleScript' 标识符本身来区分AppleScript属性与具有相同名称的当前目标的属性，如节中所示"],["body","\n"],["body","\n\n"],["headingLink","pi"],["heading","pi"],["body","\n\n"],["body","这个 “数学” 值表示圆的周长与直径之比"],["body","\n"],["body","It is defined as a real number with the value 3.14159265359."],["body","\n"],["body","For example, the following statement computes the area of a circle with radius 7:"],["body","\n\n"],["body","set circleArea to pi * 7 * 7 --result: 153.9380400259\n"],["body","\n"],["headingLink","result"],["heading","result"],["body","\n\n"],["body","执行语句时，AppleScript将结果值 (如果有) 存储在预定义的属性 “result” 中。"],["body","\n"],["body","该值保持在那里，直到执行另一个生成值的语句"],["body","\n"],["body","在执行产生结果的语句之前，“结果” 的值是未定义的"],["body","\n"],["body","您可以通过在 “脚本” 窗口的 “结果” 窗格中查看 “脚本编辑器” 中的结果."],["body","\n"],["body","注意: 当脚本执行过程中发生错误时，AppleScript会发出错误信号. 它不会在 'result' 属性中返回错误信息. For more information, see AppleScript Error Handling."],["body","\n\n"],["headingLink","text-constants"],["heading","Text Constants"],["body","\n\n"],["body","\n"],["body","AppleScript定义文本属性 space, tab, return, linefeed, and quote. "],["body","\n"],["body","\n"],["body","\n"],["body","您可以有效地将这些属性用作文本常量来表示空格或双引号 ('“') 字符. "],["body","\n"],["body","\n"],["body","\n"],["body","它们在 'text' 类的特殊字符串字符部分中进行了描述."],["body","\n"],["body","\n\n"],["headingLink","text-item-delimiters"],["heading","text item delimiters"],["body","\n\n"],["body","AppleScript provides the text item delimiters property for use in processing text. "],["body","\n"],["body","此属性包含 一系列 列表strings。 由AppleScript将  列表强制转换为文本或从文本字符串获取文本项时  用作分隔符"],["body","\n"],["body","When getting text items of text, all of the strings are used as separators. When coercing a list to text, the first item is used as a separator."],["body","\n\n"],["body","Note: Prior to OS X Snow Leopard v10.6, AppleScript only used the first delimiter in the list when getting text items."],["body","\n\n"],["body","\n"],["body","Because text item delimiters respect considering and ignoring attributes in AppleScript 2.0, delimiters are case-insensitive by default. Formerly, they were always case-sensitive. To enforce the previous behavior, add an explicit considering case statement."],["body","\n"],["body","\n"],["body","\n"],["body","获取 text item delimiters属性的值。通常情况下，AppleScript不使用任何分隔符。例如，如果未明确更改文本分隔符，则该语句返回如下结果"],["body","\n"],["body","\n\n"],["body","{\"bread\", \"milk\", \"butter\", 10.45}  as string\n"],["body","\n"],["body","returns the following:"],["body","\n"],["body","\"breadmilkbutter10.45\"\n"],["body","\n"],["body","For printing or display purposes, it is usually preferable to set text item delimiters to something that’s easier to read. For example, the script"],["body","\n"],["body","set AppleScript's text item delimiters to {\", \"}"],["body","\n"],["body","{\"bread\", \"milk\", \"butter\", 10.45}  as string"],["body","\n\n\n"],["body","returns this result:"],["body","\n"],["body","\"bread, milk, butter, 10.45\"\n"],["body","\n"],["body","“text item delimiters” 属性可用于从路径名中提取单个名称。例如，脚本"],["body","\n"],["body","set AppleScript's text item delimiters to {\":\"}\nget last text item of \"Hard Disk:CD Contents:Release Notes\"\n"],["body","\n"],["body","returns the result \"Release Notes\"."],["body","\n"],["body","如果发生错误，脚本通常使用错误处理程序将 text item delimiters 属性重置为其以前的值 (有关处理错误的更多信息，请参见 [AppleScript错误处理](https://developer.apple.com/library/archive/documentation/AppleScript/Conceptual/AppleScriptLangGuide/conceptual/ASLR_fundamentals.html # // apple_ref/doc/uid/TP40000983-CH218-SW10):"],["body","\n"],["body","set savedDelimiters to AppleScript's text item delimiters\ntry\n  set AppleScript's text item delimiters to {\"**\"}\n      --other script statements...\n      --now reset the text item delimiters:\n  set AppleScript's text item delimiters to savedDelimiters\n  on error m number n\n  --also reset text item delimiters in case of an error:\n  set AppleScript's text item delimiters to savedDelimiters\n\t--and resignal the error:\n  error m number n\nend try\n"],["body","\n"],["headingLink","version"],["heading","version"],["body","\n\n"],["body","\n"],["body","此属性提供AppleScript的当前版本"],["body","\n"],["body","\n"],["body","\n"],["body","下面的脚本显示了如何检查大于或等于 1.9的版本. "],["body","\n"],["body","\n"],["body","\n"],["body","The if statement is wrapped in a considering numeric strings statement "],["body","\n"],["body","\n"],["body","\n"],["body","so that an AppleScript version such as 1.10.6 compares as larger than, say, version 1.9."],["body","\n"],["body","\n"],["body","\n"],["body","considering numeric strings\n if version of AppleScript as string ≥ \"1.9\" then\n-- Perform operations that depend on version 1.9 or greater\nelse\n-- Handle case where version is not high enough\nend if\nend considering\n"],["body","\n"],["body","\n"],["body","\n"],["body","应用程序可以具有自己的 “版本” 属性，因此要显式访问AppleScript版本，请使用短语  version of AppleScript. 。"],["body","\n"],["body","\n"],["body","\n"],["body","这将在针对另一个应用程序的 “tell” 块中工作，例如:"],["body","\n"],["body","\n\n"],["body","tell application \"Finder\"\n  version --result: \"10.5.1\"\n  version of AppleScript --result: \"2.0\"\nend tell\n"],["body","\n"],["headingLink","current-application-constant"],["heading","current application Constant"],["body","\n\n"],["body","\n"],["body","current application 常量是指正在执行当前AppleScript脚本的应用程序 (例如，scriptEditor)"],["body","\n"],["body","\n"],["body","\n"],["body","因为当前应用程序是AppleScript的父 (see The AppleScript Inheritance Chain), 它有机会处理当前脚本或AppleScript未处理的命令。"],["body","\n"],["body","\n"],["body","\n"],["body","The current application constant is an object specifier—if you ask AppleScript for its value, the result is the object specifier:"],["body","\n"],["body","\n\n"],["body","get current application --result: current application\n"],["body","\n"],["body","However, if you ask for name of current application, AppleScript resolves the object specifier and returns the current application’s name:"],["body","\n"],["body","name of current application --result: \"Script Editor\"\n"],["body","\n"],["headingLink","missing-value-constant"],["heading","missing value Constant"],["body","\n\n"],["body","\n"],["body","missing value 常量是缺失或未初始化信息的占位符。"],["body","\n"],["body","\n"],["body","\n"],["body","For example, the following statements use the missing value constant to determine if a variable has changed:"],["body","\n"],["body","\n\n"],["body","set myVariable to missing value\nif myVariable is equal to missing value then\n -- the value of the variable never changed\n else\n -- the value of the variable did change\nend if\n"],["body","\n"],["headingLink","true-false-constants"],["heading","true, false Constants"],["body","\n"],["body","AppleScript defines the Boolean constants true and false. These constants are described with the boolean class."],["body","\n\n\n\n"],["body","\n\n                    "],["body","\n\n                    \n                \n            \n\n            \n\n        \n\n\n\n\n        \n\n\n\n        \n        \n        \n\n        \n\n\n    \n    \n"]],[["_relative_fp","6.AppleScript/2.AppleScriptFundamentals/4.CommandsOverview.html"],["title","CommandsOverview - 各项编程语言"],["body","\n    \n        \n        \n\n        \n        \n\n        \n        \n\n        \n        \n\n        \n\n        \n\n            \n                                \n                \n                    \n                        "],["body","\n                            \n                        "],["body","\n                        "],["body","\n                            \n                        "],["body","\n                        \n                            "],["body","Light"],["body","\n                            "],["body","Rust"],["body","\n                            "],["body","Coal"],["body","\n                            "],["body","Navy"],["body","\n                            "],["body","Ayu"],["body","\n                        \n                    \n\n                    "],["heading","各项编程语言"],["body","\n\n                    \n\n                    \n                \n\n\n                \n                \n\n                \n                    "],["body","\n                        \n\n"],["body","\n"],["body","\n\n"],["headingLink","commands-overview"],["heading","Commands Overview"],["body","\n\n"],["body","命令是AppleScript语句中用于请求操作的单词 或一系列单词"],["body","\n"],["body","每个命令都指向一个目标，它是响应该命令的对象."],["body","\n"],["body","目标通常是 应用程序对象  (存储在应用程序或其文档中并由应用程序管理的对象，例如窗口或文档) 或macOS中的对象"],["body","\n"],["body","但是，它也可以是 “脚本” 对象或当前脚本中的值。"],["body","\n\n"],["body","命令经常返回结果."],["body","\n\n"],["body","例如，“显示对话框” 命令返回一条可能包含文本的记录、a button name, and other information. "],["body","\n"],["body","您的脚本可以检查此记录以确定下一步要做什么。您可以将命令的结果分配给您定义的变量，或者通过预定义的AppleScript 'result' 变量访问它。"],["body","\n\n"],["headingLink","types-of-commands"],["heading","Types of Commands"],["body","\n"],["body","脚本可以使用以下类型的命令:"],["body","\n\n"],["body","\n"],["body","AppleScript命令 是内置在AppleScript语言中的命令. 目前有五个这样的命令"],["body","\n\n"],["body","get , set, count, copy, and run. "],["body","\n"],["body","Except for copy , 这些命令中的每一个也可以由应用程序实现 也就是说，有一个适用于AppleScript对象的命令的AppleScript版本,,但是应用程序可以定义自己的版本，该版本可以在其定义的对象类型上工作。"],["body","\n\n"],["body","\n"],["body","\n"],["body","A scripting addition command is one that is implemented through the mechanism described in Scripting Additions). Although anyone can create a scripting addition (see Technical Note TN1164, Scripting Additions for Mac OS X), this guide documents only the scripting addition commands from the Standard Additions, supplied by Apple as part of macOS. These commands are available to all scripts."],["body","\n"],["body","\n"],["body","\n"],["body","A user-defined command is one that is implemented by a handler defined in a script object. To invoke a user-defined command outside of a tell statement, simply use its name and supply values for any parameters it requires. The command will use the current script as its target."],["body","\n"],["body","To invoke a user-defined command inside a tell statement, see Calling Handlers in a tell Statement."],["body","\n"],["body","\n"],["body","\n"],["body","An application command is one that is defined by scriptable application to provide access to a scriptable feature. They are typically enclosed in a tell statement that targets the application. You can determine which commands an application supports by examining its dictionary in Script Editor."],["body","\n"],["body","Scriptable applications that ship with macOS, such as the Finder and System Events applications (located in /System/Library/CoreServices), provide many useful scripting commands."],["body","\n"],["body","Third-party scriptable applications also provide commands you can use in scripts. Many support all or a subset of the Standard commands, described in Technical Note TN2106, Scripting Interface Guidelines. These include commands such as delete, duplicate, exists, and move, as well as application implementations of AppleScript commands, such as get and set."],["body","\n"],["body","\n\n"],["headingLink","target"],["heading","Target"],["body","\n"],["body","有两种方法可以显式地将对象指定为命令的目标: "],["body","\n\n"],["body","通过提供它作为命令的直接参数 (described in the next section) "],["body","\n"],["body","或通过将其指定为包含命令的 “tell” 语句的目标. 如果脚本没有用 “tell” 语句显式指定目标, 它不是由脚本中的处理程序或AppleScript本身处理的, "],["body","\n"],["body","it is sent to the next object in the inheritance chain (see The AppleScript Inheritance Chain)."],["body","\n\n"],["body","In the following script, the target of the get command is the object specifier name of first window. Because the enclosing tell statement specifies the Finder application, the full specifier is name of first window of application \"Finder\", and it is the Finder application which obtains and returns the requested information."],["body","\n"],["body","tell application \"Finder\"\n    get name of first window\nend tell\n"],["body","\n"],["body","当命令以应用程序为目标时，结果可能是应用程序对象，如果是这样，则将针对结果对象的后续语句发送到应用程序。"],["body","\n"],["body","脚本还可以通过使用使用Note语句导入的应用程序命令隐式指定目标"],["body","\n"],["body","A script may also implicitly specify a target by using an application command imported using a Note statement. For example, the extract address command in the following script targets the Mail application because the command was imported from Mail:"],["body","\n"],["body","use application \"Mail\"\nextract address from \"John Doe <jdoe@example.com>\"\n"],["body","\n"],["headingLink","direct-parameter"],["heading","Direct Parameter"],["body","\n\n"],["body","直接参数 是一个值，通常是对象说明符，它紧接着出现在命令旁边，并指定命令的目标"],["body","\n"],["body","并非所有命令都有一个直接参数。如果命令可以具有直接参数，则在命令的定义中注明"],["body","\n\n"],["body","In the following statement, the object specifier last file of window 1 of application \"Finder\" is the direct parameter of the duplicate command:"],["body","\n"],["body","duplicate last file of window 1 of application \"Finder\"\n"],["body","\n"],["body","The direct parameter usually appears immediately after the command, but may also appear immediately before it. This can be easier to read for some commands, such as exists in this example:"],["body","\n"],["body","if file \"semaphore\" of application \"Finder\" exists then\n   -- continue processing...\nend if`\n"],["body","\n"],["body","'tell' 语句为其中包含的所有命令指定默认目标，因此direct参数是可选的。"],["body","\n"],["body","以下示例与上一个示例具有相同的结果"],["body","\n"],["body","tell last file of window 1 of application \"Finder\"\n    duplicate\nend tell\n"],["body","\n"],["headingLink","parameters-that-specify-locations"],["heading","Parameters That Specify Locations"],["body","\n\n"],["body","\n"],["body","许多命令都有指定位置的参数。"],["body","\n"],["body","\n"],["body","\n"],["body","位置可以是插入点或其他对象。"],["body","\n"],["body","\n"],["body","\n"],["body","插入点 是可以添加对象的位置。"],["body","\n"],["body","\n\n"],["body","在下面的示例中，'to' 参数指定将第一段移动到的位置。'duplicate' 命令的 'to' 参数的值是相对对象说明符 '在第4段之前'，这是一个插入点。"],["body","\n"],["body","AppleScript用 “tell” 语句的目标 “应用程序的前端文档‘TextEdit’ 来完成说明符。"],["body","\n"],["body","tell front document of application \"TextEdit\"\n    duplicate paragraph 1 to before paragraph 4\nend tell\n"],["body","\n"],["body","The phrases paragraph 1 and before paragraph 4 are called index and relative references, respectively. For more information, see Reference Forms."],["body","\n\n\n\n"],["body","\n\n                    "],["body","\n\n                    \n                \n            \n\n            \n\n        \n\n\n\n\n        \n\n\n\n        \n        \n        \n\n        \n\n\n    \n    \n"]],[["_relative_fp","6.AppleScript/2.AppleScriptFundamentals/1.ObjectSpecifiers.html"],["title","ObjectSpecifiers - 各项编程语言"],["body","\n    \n        \n        \n\n        \n        \n\n        \n        \n\n        \n        \n\n        \n\n        \n\n            \n                                \n                \n                    \n                        "],["body","\n                            \n                        "],["body","\n                        "],["body","\n                            \n                        "],["body","\n                        \n                            "],["body","Light"],["body","\n                            "],["body","Rust"],["body","\n                            "],["body","Coal"],["body","\n                            "],["body","Navy"],["body","\n                            "],["body","Ayu"],["body","\n                        \n                    \n\n                    "],["heading","各项编程语言"],["body","\n\n                    \n\n                    \n                \n\n\n                \n                \n\n                \n                    "],["body","\n                        \n\n"],["body","\n"],["body","\n\n"],["headingLink","object-specifiers"],["heading","Object Specifiers"],["body","\n\n"],["body","对象说明符根据其中包含的对象指定查找另一个对象所需的信息"],["body","\n"],["body","对象说明符可以引用应用程序对象 (例如窗口或文件)，也可以引用AppleScript对象 (例如列表中的项目或记录中的属性)。"],["body","\n"],["body","仅在运行时才对对象说明符进行完全评估 (或解析)，而不是在编译脚本时"],["body","\n"],["body","脚本可以包含有效的对象说明符\n\n"],["body","third document of application \"TextEdit\" "],["body","\n"],["body","在执行脚本时会导致错误 (例如，打开的文档可能少于三个)"],["body","\n\n"],["body","\n"],["body","应用程序通常会响应命令，返回对象说明符\n\n"],["body","例如，如果您向Finder询问窗口，它将返回指定脚本要求的窗口对象 (如果存在) 的信息。"],["body","\n"],["body","对象说明符中的顶级容器通常是应用程序本身"],["body","\n"],["body","每次脚本使用描述对象或属性路径的短语时，您都会创建一个对象说明符，例如 。 name of window 1 of application \"Finder\". "],["body","\n"],["body","当您使用 ’a referemce to' 运算符时，它会创建一个包装对象说明符的 “引用” 对象。"],["body","\n"],["body","对象说明符和它所指的对象之间的区别就像建筑物地址和建筑物本身之间的区别"],["body","\n"],["body","地址是一系列单词和数字，例如 “2121 Oak Street，San Francisco，CA”，用于标识位置 (在街道上，城市中，州中)。它与建筑物本身不同。如果该位置的建筑物被拆除并替换为新建筑物，地址保持仍不变"],["body","\n\n"],["body","\n\n"],["headingLink","what-is-in-an-object-specifier"],["heading","What Is in an Object Specifier"],["body","\n"],["body","对象说明符描述对象类型，位置以及如何将对象与该位置中的其他相同类型的对象区分开。"],["body","\n"],["body","这三种类型的信息"],["body","\n\n"],["body","\n"],["body","the type, or class; "],["body","\n"],["body","\n"],["body","\n"],["body","the location, or container; "],["body","\n"],["body","\n"],["body","\n"],["body","and the distinguishing information, or reference form—allow you to specify any object."],["body","\n"],["body","\n"],["body","\n"],["body","In the following example, the class of the object is paragraph. "],["body","\n"],["body","\n"],["body","\n"],["body","The container is the phrase of document 1. Because this phrase is inside a tell statement, the tell statement provides the top-level container, of application \"TextEdit\". The distinguishing information (the reference form) is the combination of the class, paragraph, and an index value, 1, which together indicate the first paragraph."],["body","\n"],["body","\n"],["body","\n"],["body","tell application \"TextEdit\"\n    paragraph 1 of document 1\nend tell\n"],["body","\n"],["body","\n"],["body","\n"],["body","注意：如果您检查TextEdit应用程序的字典，你可能认为这个脚本应该说： paragraph 1 of text of document 1,但是，在含义明确的情况下，某些应用程序允许脚本员从对象说明符中省略容器 TextEdit在为文档中的文本提供 隐式指定的子容器 时使用此功能。也就是说，如果对象说明符标识包含在文档文本中的对象 (例如单词或段落)，则TextEdit会自动提供对象说明符的 “Text” 部分。区别信息 (the reference form) 是类 “paragraph” 和索引值 “1” 的组合，它们一起表示第一段。"],["body","\n"],["body","\n"],["body","\n"],["body","In addition to the index reference form, you can specify objects in a container by name, by range, by ID, and by the other forms described in Reference Forms."],["body","\n"],["body","\n\n"],["headingLink","containers"],["heading","Containers"],["body","\n\n"],["body","\n"],["body","容器是包含一个或多个对象或属性的对象。"],["body","\n"],["body","\n"],["body","\n"],["body","在对象说明符中，容器指定在哪里找到对象或属性。"],["body","\n"],["body","\n"],["body","\n"],["body","针对容器对象使用：of、in 找到属性"],["body","\n"],["body","\n\n"],["body","folder \"Applications\" of startup disk\n"],["body","\n"],["body","容器可以是一个对象或一系列对象，从最里面到最外面的包含对象列出，如下所示:"],["body","\n"],["body","tell application \"Finder\"\n    first item of first folder of first disk\nend tell\n"],["body","\n\n"],["body","\n"],["body","You can also use the possessive form ('s) to specify containers. "],["body","\n"],["body","\n"],["body","\n"],["body","In the following example, the innermost container is first window and the object it contains is a name property:"],["body","\n"],["body","\n\n"],["body","tell application \"TextEdit\"\n    first window's name\nend tell\n"],["body","\n"],["body","In this example, the target of the tell statement (\"TextEdit\") is the outer container for the object specifier."],["body","\n"],["headingLink","absolute-and-relative-object-specifiers"],["heading","Absolute and Relative Object Specifiers"],["body","\n\n"],["body","绝对对象说明符具有足够的信息来唯一地标识一个或多个对象。它可以在脚本中的任何地方明确使用"],["body","\n"],["body","要使对应用程序对象的引用是绝对的，其最外层容器必须是应用程序本身，如:"],["body","\n\n"],["body","version of application \"Finder\" --result: \"10.5.1\"\n"],["body","\n"],["body","相反，相对对象说明符 没有指定足够的信息来唯一地标识一个或多个对象; 例如:"],["body","\n"],["body","name of item 1 of disk 2\n"],["body","\n\n"],["body","\n"],["body","当AppleScript在 'tell' 语句中遇到相对对象说明符时，它会尝试使用该语句指定的默认目标来完成对象说明符。"],["body","\n"],["body","\n"],["body","\n"],["body","尽管通常不需要它，但是可以使用关键字 “it' 来显式指定此隐式目标， which is described in The it and me Keywords."],["body","\n"],["body","\n"],["body","\n"],["body","'tell' 语句的默认目标是在未指定其他对象的情况下接收命令的对象"],["body","\n"],["body","\n"],["body","\n"],["body","例如，下面的 'tell' 语句告诉Finder使用上一个相对对象说明符获取名称."],["body","\n\n"],["body","\n"],["body","tell application \"Finder\"\n    name of item 1 of disk 2\nend tell\n"],["body","\n"],["body","\n\n"],["body","\n"],["body","\n"],["body","当AppleScript在任何 “tell” 状态之外遇到相对对象说明符时，它试图通过查找 [脚本对象中的继承](https://developer.apple.com/library/archive/documentation/AppleScript/Conceptual/AppleScriptLangGuide/conceptual/ASLR_script_objects.html # // apple_ref/doc/uid/TP40000983-CH207-SW5) 中描述的继承链来完成对象说明符。"],["body","\n"],["body","\n\n"],["headingLink","object-specifiers-in-reference-objects"],["heading","Object Specifiers in Reference Objects"],["body","\n"],["body","当您可以使用 a reference to  运算符创建 “引用” 对象时，它包含一个对象说明符。例如:"],["body","\n"],["body","tell application \"TextEdit\"`\n    set docRef to a reference to the first document\n    --result: document 1 of application \"TextEdit\"\n        -- an object specifier\n    name of docRef --result: \"New Report.rtf\"\n        -- name of the specified object\nend tell\n"],["body","\n\n"],["body","在此脚本中，变量 'docRef' 是一个引用，其对象说明符引用了应用程序TextEdit的第一个文档"],["body","\n"],["body","在这种情况下。然而，“docref” 所指的对象可以改变，如果您打开第二个名为 “第二个报告.rtf” 的TextEdit文档，使其窗口位于前一个文档的前面，然后再次运行此脚本"],["body","\n\n"],["body","您可以使用更具体的对象说明符创建引用:"],["body","\n"],["body","tell application \"TextEdit\"\n    set docRef to a reference to document \"未命名\"\n    --result: document \"New Report.rtf\" of application \"TextEdit\"\n    name of docRef --result: \"New Report.rtf\"\nend tell\n"],["body","\n\n"],["body","使用 “引用” 运算符创建 “引用” 对象后，可以使用 “Content” 属性获取其引用的对象的值。"],["body","\n"],["body","也就是说，使用 “内容” 属性会导致对引用的对象说明符进行评估。"],["body","\n"],["body","例如，在下面的脚本中，变量 'myWindow' 的内容就是窗口引用本身。"],["body","\n\n"],["body","set myWindow to a ref to window \"Q1.rtf\" of application \"TextEdit\"\nmyWindow\n    -- result: window \"Q1.rtf\" of application \"TextEdit\" (object specifier)\ncontents of myWindow\n    --result: window id 283 of application \"TextEdit\" (an evaluated window)\nget myWindow\n    -- result: window \"Q1.rtf\" of application \"TextEdit\" (object specifier)\n"],["body","\n"],["body","请注意，'get' 命令的结果是返回引用的对象说明符，而不是将说明符解析为它指定的对象。"],["body","\n"],["body","如果可以，AppleScript将隐式取消引用引用对象 (不使用 'contents' 属性)，如下面的示例所示:"],["body","\n"],["body","`set myWindow to a ref to window 1 of application \"TextEdit\"`\n`name of myWindow --result: \"Q1.rtf\" (if that is the first window's name)`\n"],["body","\n"],["body","For related information, see the Discussion section for the reference class."],["body","\n\n\n\n"],["body","\n\n                    "],["body","\n\n                    \n                \n            \n\n            \n\n        \n\n\n\n\n        \n\n\n\n        \n        \n        \n\n        \n\n\n    \n    \n"]],[["_relative_fp","6.AppleScript/1.AppleScriptLexicalConventions/index.html"],["title","1.AppleScriptLexicalConventions - 各项编程语言"],["body","\n    \n        \n        \n\n        \n        \n\n        \n        \n\n        \n        \n\n        \n\n        \n\n            \n                                \n                \n                    \n                        "],["body","\n                            \n                        "],["body","\n                        "],["body","\n                            \n                        "],["body","\n                        \n                            "],["body","Light"],["body","\n                            "],["body","Rust"],["body","\n                            "],["body","Coal"],["body","\n                            "],["body","Navy"],["body","\n                            "],["body","Ayu"],["body","\n                        \n                    \n\n                    "],["heading","各项编程语言"],["body","\n\n                    \n\n                    \n                \n\n\n                \n                \n\n                \n                    "],["body","\n                        \n\n"],["body","\n"],["body","\n\n"],["headingLink","applescript-lexical-conventions"],["heading","AppleScript Lexical Conventions"],["body","\n"],["body","\n"],["body","词汇约定"],["body","\n"],["body","\n\n"],["body","\n"],["body","本章概述了AppleScript语言的词汇和惯例。它从字符集开始，引入了越来越复杂的元素。"],["body","\n"],["body","\n"],["body","\n"],["body","阅读本章后，您应该对用于构造AppleScript表达式和语句的基本语言组件有所了解。"],["body","\n"],["body","\n\n"],["body","AppleScript词汇约定包含以下部分:"],["body","\n\n"],["body","Character Set"],["body","\n"],["body","Identifiers"],["body","\n"],["body","Keywords"],["body","\n"],["body","Comments"],["body","\n"],["body","The Continuation Character"],["body","\n"],["body","Literals and Constants"],["body","\n"],["body","Operators"],["body","\n"],["body","Variables"],["body","\n"],["body","Expressions"],["body","\n"],["body","Statements"],["body","\n"],["body","Commands"],["body","\n"],["body","Results"],["body","\n"],["body","Raw Codes"],["body","\n\n"],["headingLink","character-set"],["heading","Character Set"],["body","\n\n"],["body","\n"],["body","从OS X v10.5 (AppleScript 2.0) 开始，AppleScript的字符集是Unicode。AppleScript在全球范围内正确保存所有字符，脚本中的注释和文本常量可能包含任何Unicode字符。"],["body","\n"],["body","\n"],["body","\n"],["body","AppleScript语法使用几个非ASCII字符，可以使用特殊的组合键来键入"],["body","\n"],["body","\n"],["body","\n"],["body","有关AppleScript特别对待的字符的信息，see the sections Identifiers, Comments, Text, The Continuation Character, and Raw Codes in this chapter, as well as Table 9-1 in Operators Reference."],["body","\n"],["body","\n\n"],["headingLink","identifiers"],["heading","Identifiers"],["body","\n"],["body","\n"],["body","标识符"],["body","\n"],["body","\n\n"],["body","标识符必须以字母开头，并且可以包含以下任何字符:"],["body","\n"],["body","大小写不敏感"],["body","\n"],["body","AppleScript会记住并强制执行标识符的第一个大写字母。\n\n"],["body","So if it first encounters an identifier as myAccount, it will later, during compilation, change versions such as MyAccount and myaccount to myAccount."],["body","\n\n"],["body","\n\n"],["body","ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789_\n"],["body","\n"],["body","The following are examples of valid identifiers: `areaOfCircle`, `Agent007`, `axis_of_rotation`.\n\nThe following are not valid identifiers: `C-`, `back&forth`, `999`, `Why^Not`.\n\n\n"],["body","\n\n"],["body","\n"],["body","AppleScript提供了上述规则的漏洞"],["body","\n\n"],["body","\n"],["body","第一个字符和最后一个字符为竖线 (|) 的标识符可以包含任何字符。前导垂直条和尾随垂直条不被视为标识符的一部分。"],["body","\n"],["body","\n"],["body","\n"],["body","使用垂直条会使脚本难以阅读，因此不建议使用。"],["body","\n"],["body","\n"],["body","\n"],["body","The following are legal identifiers: |back&forth|, |Right*Now!|."],["body","\n"],["body","\n"],["body","\n"],["body","An identifier can contain additional vertical bars preceded by a backslash () character, as in the identifier |This\\|Or\\|That|. 反斜杠字符的使用将在 “文本” 类的 “特殊字符串字符” 部分中进一步描述。"],["body","\n"],["body","\n\n"],["body","\n\n"],["headingLink","keywords"],["heading","Keywords"],["body","\n\n"],["body","\n"],["body","A keyword  是AppleScript语言中的保留字。关键字由小写字母组成: 'abcdefghijklmnopqrstuvwxyz'"],["body","\n"],["body","\n"],["body","\n"],["body","在少数情况下，例如 “aside from”，它们成对出现。"],["body","\n"],["body","\n\n"],["body","Table 1-1 lists the keywords reserved in AppleScript 2.0 (which are the same as those used in AppleScript 1.x). For additional information, see Table A-1, which provides a brief description for each keyword and points to related information, where available."],["body","\n"],["body","\n"],["body","about"],["body","above"],["body","after"],["body","against"],["body","and"],["body","apart from"],["body","\n"],["body","around"],["body","as"],["body","aside from"],["body","at"],["body","back"],["body","before"],["body","\n"],["body","beginning"],["body","behind"],["body","below"],["body","beneath"],["body","beside"],["body","between"],["body","\n"],["body","but"],["body","by"],["body","considering"],["body","contain"],["body","contains"],["body","contains"],["body","\n"],["body","continue"],["body","copy"],["body","div"],["body","does"],["body","eighth"],["body","else"],["body","\n"],["body","end"],["body","equal"],["body","equals"],["body","error"],["body","every"],["body","exit"],["body","\n"],["body","false"],["body","fifth"],["body","first"],["body","for"],["body","fourth"],["body","from"],["body","\n"],["body","front"],["body","get"],["body","given"],["body","global"],["body","if"],["body","ignoring"],["body","\n"],["body","in"],["body","instead of"],["body","into"],["body","is"],["body","it"],["body","its"],["body","\n"],["body","last"],["body","local"],["body","me"],["body","middle"],["body","mod"],["body","my"],["body","\n"],["body","ninth"],["body","not"],["body","of"],["body","on"],["body","onto"],["body","or"],["body","\n"],["body","out of"],["body","over"],["body","prop"],["body","property"],["body","put"],["body","ref"],["body","\n"],["body","reference"],["body","repeat"],["body","return"],["body","returning"],["body","script"],["body","second"],["body","\n"],["body","set"],["body","seventh"],["body","since"],["body","sixth"],["body","some"],["body","tell"],["body","\n"],["body","tenth"],["body","that"],["body","the"],["body","then"],["body","third"],["body","through"],["body","\n"],["body","thru"],["body","timeout"],["body","times"],["body","to"],["body","transaction"],["body","true"],["body","\n"],["body","try"],["body","until"],["body","where"],["body","while"],["body","whose"],["body","with"],["body","\n"],["body","without"],["body","``"],["body","``"],["body","``"],["body","``"],["body","``"],["body","\n\n\n"],["headingLink","comments"],["heading","Comments"],["body","\n"],["body","注释 是执行脚本时AppleScript忽略的文本。您可以使用注释来描述脚本中发生的事情或进行其他类型的注释。注释有三种:"],["body","\n\n"],["body","\n"],["body","A block comment（块注释） "],["body","\n\n"],["body","begins with the characters (* and ends with the characters *). "],["body","\n"],["body","块注释必须放在其他语句之间。"],["body","\n"],["body","这意味着它们可以放在语句开头或结尾的同一行上，但不能嵌入简单的 (单行) 语句中。"],["body","\n\n"],["body","\n"],["body","\n"],["body","An end-of-line comment begins with the characters -- (two hyphens) and ends with the end of the line:"],["body","\n"],["body","--end-of-line comments extend to the end of the line"],["body","\n"],["body","\n"],["body","\n"],["body","Starting in version 2.0, AppleScript also supports use of the # symbol as an end-of-line comment. This allows you to make a plain AppleScript script into a Unix executable by beginning it with the following line and giving it execute permission:"],["body","\n"],["body","#!/usr/bin/osascript"],["body","\n"],["body","Compiled scripts that use # will run normally on pre-2.0 systems, and if edited will display using --. Executable text scripts using #!/usr/bin/osascript will not run on pre-2.0 systems, since the # will be considered a syntax error."],["body","\n"],["body","\n\n"],["body","You can nest comments—that is, comments can contain other comments, as in this example:"],["body","\n"],["body","(*  Here are some"],["body","\n"],["body","    --nested comments"],["body","\n"],["body","    (* another comment within a comment *)"],["body","\n"],["body","*)"],["body","\n\n\n"],["headingLink","the-continuation-character"],["heading","The Continuation Character"],["body","\n"],["body","\n"],["body","接续符"],["body","\n"],["body","\n\n"],["body","通常必须在一行上输入简单的AppleScript语句"],["body","\n"],["body","您可以通过以 continuation 字符 结尾将语句扩展到下一行"],["body","\n"],["body","You can extend a statement to the next line by ending it with the continuation character, ¬. With a U.S. keyboard, you can enter this character by typing Option-l (lower-case L). In Script Editor, you can type Option-Return, which inserts the continuation character and moves the insertion point to the next line."],["body","\n\n"],["body","Here is a single statement displayed on two lines:"],["body","\n"],["body","`display dialog \"This is just a test.\" buttons {\"Great\", \"OK\"} ¬`\n`default button \"OK\" giving up after 3`\n"],["body","\n"],["body","引用文本字符串中的 连续字符与其他任何字符一样对待。"],["body","\n"],["headingLink","literals-and-constants"],["heading","Literals and Constants"],["body","\n\n"],["body","literal是对其本身进行评估的值-也就是说，它的解释与编写时一样"],["body","\n"],["body","例如，在AppleScript中，“Hello” 是文本文字 的一个 常量具有预定义值的单词. "],["body","\n"],["body","For example, AppleScript defines a number of enumerated constants for use with the path to (folder) command, each of which specifies a location for which to obtain the path."],["body","\n\n"],["headingLink","boolean"],["heading","Boolean"],["body","\n"],["body","AppleScript defines the Boolean values true and false and supplies the boolean class."],["body","\n"],["headingLink","constant"],["heading","Constant"],["body","\n"],["body","Global Constants in AppleScript describes constants that can be used throughout your scripts. For related information, see the constant class."],["body","\n"],["headingLink","list"],["heading","List"],["body","\n"],["body","如脚本所示，列表由大括号中包含的一系列表达式组成，并用逗号分隔，例如:"],["body","\n"],["body","{1, 7, \"Beethoven\", 4.5}\n"],["body","\n\n"],["body","\n"],["body","一个列表可以包含其他列表。空列表 (不包含任何项目) 由一对空括号表示: “{}”。"],["body","\n"],["body","\n"],["body","\n"],["body","AppleScript provides the list class for working with lists."],["body","\n"],["body","\n\n"],["headingLink","number"],["heading","Number"],["body","\n"],["body","数字文字 是数字序列，可能包括其他字符，例如一元减号，点号 (in reals)) 或 “E+” (以指数表示)。以下是一些数字文字:"],["body","\n"],["body","\n"],["body","-94596"],["body","\n"],["body","3.1415"],["body","\n"],["body","9.9999999999E+10"],["body","\n\n\n"],["body","AppleScript defines classes for working with real and integer values, as well as the number class, which serves as a synonym for either real or integer."],["body","\n"],["headingLink","record"],["heading","Record"],["body","\n\n"],["body","记录是标记属性的无序集合"],["body","\n"],["body","记录作为大括号中包含的一系列属性定义出现在脚本中，并用逗号分隔"],["body","\n"],["body","Each property definition consists of a unique label, a colon, and a value for the property. For example, the following is a record with two properties:"],["body","\n\n"],["body","{product:\"pen\", price:2.34}\n"],["body","\n"],["headingLink","text"],["heading","Text"],["body","\n"],["body","A text literal consists of a series of Unicode characters enclosed in a pair of double quote marks, as in the following example:"],["body","\n"],["body","\"A basic string.\"\n"],["body","\n"],["body","AppleScript text objects are instances of the text class, which provides mechanisms for working with text. The Special String Characters section of that class describes how to use white space, backslash characters, and double quotes in text."],["body","\n"],["headingLink","operators"],["heading","Operators"],["body","\n\n"],["body","运算符 是从另一个值或一对值派生一个值的符号，单词或短语。"],["body","\n"],["body","例如，乘法运算符 ('*') 乘以两个数字操作数，而串联运算符 ('&') 连接两个对象 (如文本字符串)。'is equal' 运算符对两个布尔值执行测试。"],["body","\n"],["body","For detailed information on AppleScript’s operators, see Operators Reference."],["body","\n\n"],["headingLink","variables"],["heading","Variables"],["body","\n\n"],["body","\n"],["body","A variable is a named container in which to store a value. "],["body","\n"],["body","\n"],["body","\n"],["body","Its name, which you specify when you create the variable, follows the rules described in Identifiers. You can declare and initialize a variable at the same time with a copy or set command. For example:"],["body","\n"],["body","\n\n"],["body","\n"],["body","set myName to \"John\""],["body","\n"],["body","copy 33 to myAge"],["body","\n\n\n\n"],["body","\n"],["body","将值赋值给变量的语句称为 赋值语句 "],["body","\n"],["body","\n"],["body","\n"],["body","当AppleScript遇到变量时，它通过获取其值来评估变量。变量包含在脚本中，当您关闭包含该变量的脚本时，其值通常会丢失。"],["body","\n"],["body","\n"],["body","\n"],["body","AppleScript变量可以保存任何类的值。例如，您可以将整数值 '17' 分配给变量，然后稍后将布尔值 'true' 分配给同一变量。"],["body","\n"],["body","\n"],["body","\n"],["body","For more information, see Variables and Properties."],["body","\n"],["body","\n\n"],["headingLink","expressions"],["heading","Expressions"],["body","\n\n"],["body","\n"],["body","表达式是具有值的任何一系列词汇元素。"],["body","\n"],["body","\n"],["body","\n"],["body","表达式在脚本中用于表示或导出值. "],["body","\n"],["body","\n"],["body","\n"],["body","最简单的表达式，称为字面表达式，是脚本中值的表示. "],["body","\n"],["body","\n"],["body","\n"],["body","更复杂的表达式通常结合文字、变量、运算符和对象说明符."],["body","\n"],["body","\n\n"],["body","运行脚本时，AppleScript将其表达式转换为值。这个过程被称为 * 评估 *。例如，当求值以下简单表达式时，结果为21:"],["body","\n"],["body","3 * 7 --result: 21\n"],["body","\n"],["body","对象说明符指定查找另一个对象所需的部分或全部信息。例如，以下对象说明符指定命名文档:"],["body","\n"],["body","document named \"FavoritesList\"\n"],["body","\n"],["body","For more information, see Object Specifiers."],["body","\n"],["headingLink","statements"],["heading","Statements"],["body","\n\n"],["body","\n"],["body","语句 是遵循特定AppleScript语法的一系列词汇元素。语句可以包括关键字、变量、运算符、常量、表达式等。"],["body","\n"],["body","\n"],["body","\n"],["body","每个脚本都由语句组成。当AppleScript执行脚本时，它会按顺序读取语句并执行其指令"],["body","\n"],["body","\n"],["body","\n"],["body","控制语句 是确定何时以及如何执行其他语句的语句。"],["body","\n\n"],["body","使用 if repeat while 语句 执行标准控制流 详见： Control Statements Reference."],["body","\n\n"],["body","\n"],["body","\n"],["body","简单语句是可以写在一行上的语句:"],["body","\n"],["body","\n\n"],["body","set averageTemp to 63 as degrees Fahrenheit\n"],["body","\n"],["body","Note: You can use a continuation character (¬) to extend a simple statement onto a second line."],["body","\n"],["body","一个 复合语句写在多行上,可以包含其他语句，并在其最后一行中有单词 “end” (可选地，后面是语句的第一个单词)。"],["body","\n"],["body","例如，以下是复合的 “tell” 语句"],["body","\n"],["body","tell application \"Finder\"\n    set savedName to name of front window\n    close window savedName\nend tell\n"],["body","\n"],["body","复合语句可以包含其他复合语句。"],["body","\n"],["headingLink","commands"],["heading","Commands"],["body","\n\n"],["body","命令 是AppleScript语句中用于请求操作的单词或一系列单词"],["body","\n"],["body","每个命令都指向一个 目标，它是响应该命令的对象"],["body","\n"],["body","目标通常是应用程序对象或macOS中的对象，但也可以是 “脚本” 对象或当前脚本中的值。"],["body","\n\n\n"],["body","下面的语句使用AppleScript的 'get' 命令来获取窗口的名称"],["body","\n"],["body","目标是Finder应用程序的前窗口:"],["body","\n\n"],["body","get name of front window of application \"Finder\"\n"],["body","\n"],["body","For more information on command types, parameters, and targets, see Commands Overview."],["body","\n"],["headingLink","results"],["heading","Results"],["body","\n\n"],["body","语句的result是执行语句时生成的值 (如果有)"],["body","\n"],["body","例如，执行语句 “3+4” 会得到值 “7”. "],["body","\n"],["body","The result of the statement set myText to \"keyboard\" is the text object \"keyboard\". "],["body","\n"],["body","A result can be of any class. AppleScript stores the result in the globally available property result, described in AppleScript Constant."],["body","\n\n"],["headingLink","raw-codes"],["heading","Raw Codes"],["body","\n"],["body","When you open, compile, edit, or run scripts with a script editor, you may occasionally see terms enclosed in double angle brackets, or chevrons («»), in a script window or in another window. These terms are called raw format or raw codes, because they represent the underlying Apple event codes that AppleScript uses to represent scripting terms."],["body","\n"],["body","For compatibility with Asian national encodings, “《” and “》” are allowed as synonyms for “«” and “»” ( (Option- \\ and Option-Shift- , respectively, on a U.S. keyboard), since the latter do not exist in some Asian encodings."],["body","\n"],["body","For more information on raw codes, see Double Angle Brackets."],["body","\n\n\n\n"],["body","\n\n                    "],["body","\n\n                    \n                \n            \n\n            \n\n        \n\n\n\n\n        \n\n\n\n        \n        \n        \n\n        \n\n\n    \n    \n"]],[["_relative_fp","6.AppleScript/5.AboutHandlers/index.html"],["title","5.AboutHandlers - 各项编程语言"],["body","\n    \n        \n        \n\n        \n        \n\n        \n        \n\n        \n        \n\n        \n\n        \n\n            \n                                \n                \n                    \n                        "],["body","\n                            \n                        "],["body","\n                        "],["body","\n                            \n                        "],["body","\n                        \n                            "],["body","Light"],["body","\n                            "],["body","Rust"],["body","\n                            "],["body","Coal"],["body","\n                            "],["body","Navy"],["body","\n                            "],["body","Ayu"],["body","\n                        \n                    \n\n                    "],["heading","各项编程语言"],["body","\n\n                    \n\n                    \n                \n\n\n                \n                \n\n                \n                    "],["body","\n                        \n\n"],["body","\n"],["body","\n\n"],["headingLink","about-handlers"],["heading","About Handlers"],["body","\n"],["body","当脚本开发人员想要 重构和重用他们的代码时，他们可以转向处理程序。处理程序是可以通过名称调用的语句的集合。处理程序也称为函数、子程序或方法。"],["body","\n"],["body","本章将在以下几节中介绍如何使用处理程序:"],["body","\n\n"],["body","Handler Basics"],["body","\n"],["body","Handlers in Script Applications"],["body","\n"],["body","For detailed reference information, see Handler Reference."],["body","\n\n\n\n\n"],["body","\n\n                    "],["body","\n\n                    \n                \n            \n\n            \n\n        \n\n\n\n\n        \n\n\n\n        \n        \n        \n\n        \n\n\n    \n    \n"]],[["_relative_fp","6.AppleScript/5.AboutHandlers/1.HandlerBasics.html"],["title","HandlerBasics - 各项编程语言"],["body","\n    \n        \n        \n\n        \n        \n\n        \n        \n\n        \n        \n\n        \n\n        \n\n            \n                                \n                \n                    \n                        "],["body","\n                            \n                        "],["body","\n                        "],["body","\n                            \n                        "],["body","\n                        \n                            "],["body","Light"],["body","\n                            "],["body","Rust"],["body","\n                            "],["body","Coal"],["body","\n                            "],["body","Navy"],["body","\n                            "],["body","Ayu"],["body","\n                        \n                    \n\n                    "],["heading","各项编程语言"],["body","\n\n                    \n\n                    \n                \n\n\n                \n                \n\n                \n                    "],["body","\n                        \n\n"],["body","\n"],["body","\n\n"],["headingLink","handler-basics"],["heading","Handler Basics"],["body","\n\n"],["body","处理程序是可以通过名称调用的语句的集合。处理程序在多个地方执行相同操作的脚本中很有用。您可以将执行特定任务的语句打包为处理程序，为其赋予描述性名称，并从脚本中的任何位置调用它。这使得脚本更短，更易于维护。"],["body","\n"],["body","脚本可以包含一个或多个处理程序。但是，您不能在另一个处理程序中嵌套处理程序定义 (尽管在处理程序中定义的脚本对象可以包含其他处理程序)。"],["body","\n"],["body","处理程序的定义指定其使用的参数 (如果有)，并且可以为参数指定一个或多个类和默认值。"],["body","\n"],["body","调用处理程序时，必须根据其定义中指定的方式列出其参数"],["body","\n"],["body","处理程序可能具有标记、位置或交错的参数，如后续章节所述。如果参数具有指定的类，则AppleScript会像使用 “as” 运算符一样将实际值强制转换为该类。如果参数具有默认值，则可以省略该参数。"],["body","\n"],["body","一个处理程序定义可以包含变量声明和语句。它可能使用 'return' 语句 (在 'return' 中详细描述) 来返回值并退出处理程序。"],["body","\n\n"],["body","以下sections 提供了有关使用处理程序的其他信息:"],["body","\n\n"],["body","Defining a Simple Handler"],["body","\n"],["body","Handlers with Labeled Parameters"],["body","\n"],["body","Handlers with Positional Parameters"],["body","\n"],["body","Handlers with Patterned Positional Parameters"],["body","\n"],["body","Recursive Handlers"],["body","\n"],["body","Errors in Handlers"],["body","\n"],["body","Passing by Reference Versus Passing by Value"],["body","\n"],["body","Calling Handlers in a tell Statement"],["body","\n\n"],["headingLink","defining-a-simple-handler"],["heading","Defining a Simple Handler"],["body","\n"],["body","以下是一个简单处理程序的定义，该处理程序采用可以显示为文本的任何参数值 (大概是表示日期的一个)，并将其显示在对话框中。处理程序名称为 'rock'; 其参数为 'around The clock '，其中 'around' 为参数标签，'clock '为参数名称 ((the is an AppleScript filler for readability):"],["body","\n"],["body","on rock around the clock\n    display dialog (clock as text)\nend rock\n\n"],["body","\n"],["body","此处理程序允许类似英语的调用语句:"],["body","\n"],["body","rock around the current date -- call handler to display current date\n"],["body","\n"],["body","处理程序可以没有参数。要指示处理程序没有参数，请在处理程序定义和处理程序调用中的处理程序名称之后包含一对空括号。例如，下面的 'helloWorld' 脚本没有参数。"],["body","\n"],["body","on helloWorld()\n    display dialog \"Hello World\"\nend\n\nhelloWorld() -- Call the handler\n"],["body","\n"],["headingLink","handlers-with-labeled-parameters"],["heading","Handlers with Labeled Parameters"],["body","\n"],["body","Handler Syntax (Labeled Parameters)"],["body","\n"],["body","处理程序是可以通过名称调用的语句的集合。本节介绍使用标记参数的处理程序的语法。"],["body","\n"],["body","带标签的参数由其标签标识，并且可以以任何顺序列出。"],["body","\n"],["headingLink","syntax"],["heading","Syntax"],["body","\n"],["body","( on | to ) handlerName \n\t[ [ of | in ] directParamName ] \n\t[ ASLabel userParamName ]... \n\t[ given userLabel:userParamName [, userLabel:userParamName ]...]      \n\t[ statement ]\n\t...\n\tend [ handlerName ]\n"],["body","\n"],["headingLink","placeholders"],["heading","Placeholders"],["body","\n\n"],["body","\n"],["body","handlerName"],["body","\n"],["body","An identifier that names the handler."],["body","\n"],["body","\n"],["body","\n"],["body","directParamName"],["body","\n\n"],["body","直接参数变量的标识符. "],["body","\n"],["body","如果包含，则必须在命令名称之后立即列出 directParamName. "],["body","\n"],["body","The word of or in before directParamName is required in user-defined handlers, "],["body","\n"],["body","在用户定义的处理程序中，directParamName 之前的单词 “of” 或 “in” 是必需的"],["body","\n"],["body","但是在术语定义的处理程序中是可选的(例如，由应用程序定义的那些)."],["body","\n"],["body","如果用户定义的处理程序包括直接参数，则该处理程序还必须包括至少一个可变参数."],["body","\n\n"],["body","\n"],["body","\n"],["body","ASLabel"],["body","\n\n"],["body","AppleScript定义的标签. "],["body","\n"],["body","可用的标签是: about, above, against, apart from, around, aside from, at, below, beneath, beside, between, by, for, from, instead of, into, on, onto, out of, over, since, thru (or through), under. "],["body","\n"],["body","这些是唯一可以在没有特殊标签 “given” 的情况下使用的标签。"],["body","\n"],["body","每个标签在处理程序的标签中必须是唯一的 (也就是说，不能对多个参数使用相同的标签)。"],["body","\n\n"],["body","\n"],["body","\n"],["body","userLabel"],["body","\n\n"],["body","用户定义标签的标识符，与用户定义参数相关联"],["body","\n"],["body","Each label must be unique.The first userLabel-userParamName pair must follow the word given; any additional pairs are separated by commas."],["body","\n"],["body","每个标签必须是唯一的。第一个 userLabel userParamName pair 必须跟随单词 'given'; "],["body","\n"],["body","任何额外的pair 用逗号分隔。"],["body","\n\n"],["body","\n"],["body","\n"],["body","userParamName"],["body","\n"],["body","An identifier for a parameter variable."],["body","\n"],["body","\n"],["body","\n"],["body","statement"],["body","\n"],["body","Any AppleScript statement. These statements can include definitions of script objects, each of which, like any script object, can contain handlers and other script objects. However, you cannot declare another handler within a handler, except within a script object.Handlers often contain a return statement."],["body","\n"],["body","\n\n"],["body","要定义带有标记参数的处理程序，请列出在调用处理程序时要使用的标签以及在调用时要执行的语句。 (The syntax is shown in Handler Syntax (Labeled Parameters).)"],["body","\n"],["body","带有标记参数的处理程序也可以具有直接参数。除了直接参数 (必须直接跟随处理程序名称) 之外，带标签的参数可以以任何顺序出现，处理程序定义中的标签标识参数值。 "],["body","\n"],["body","This includes parameters listed in given, with, and without clauses (of which there can be any number)."],["body","\n"],["body","以下示例中的 'findNumbers' 处理程序使用特殊标签 'given' 定义带有标签 'given round的参数。"],["body","\n"],["body","to findNumbers of numberList above minLimit given rounding:roundBoolean\n        set resultList to {}\n        repeat with i from 1 to (count items of numberList)\n            set x to item i of numberList\n            if roundBoolean then -- round the number\n                -- Use copy so original list isn’t modified.\n                copy (round x) to x\n            end if\n            if x > minLimit then\n                set end of resultList to x\n            end if\n        end repeat\n        return resultList\nend findNumbers\n"],["body","\n"],["body","The next statements show how to call findNumbers by passing a predefined list variable:"],["body","\n"],["body","set myList to {2, 5, 19.75, 99, 1}\nfindNumbers of myList above 19 given rounding:true\n    --result: {20, 99}\nfindNumbers of myList above 19 given rounding:false\n    --result: {19.75, 99}\n"],["body","\n"],["body","You can also specify the value of the rounding parameter by using a with or without clause to indicate true or false. (In fact, when you compile the previous examples, AppleScript automatically converts given rounding:true to with rounding and given rounding:false to without rounding.) These examples pass a list object directly, rather than using a list variable as in the previous case:"],["body","\n"],["body","findNumbers of {5.1, 20.1, 20.5, 33} above 20 with rounding\n    --result: {33}\n \nfindNumbers of {5.1, 20.1, 20.5, 33.7} above 20 without rounding\n    --result: {20.1, 20.5, 33.7}\n\n"],["body","\n"],["body","Here is another handler that uses parameter labels:"],["body","\n"],["body","to check for yourNumber from startRange thru endRange\n    if startRange ≤ yourNumber and yourNumber ≤ endRange then\n        display dialog \"Congratulations! Your number is included.\"\n    end if\nend check\n"],["body","\n"],["body","The following statement calls the handler, causing it to display the \"Congratulations!\" message"],["body","\n"],["body","check for 8 from 7 thru 10 -- call the handler\n"],["body","\n"],["headingLink","handlers-with-positional-parameters"],["heading","Handlers with Positional Parameters"],["body","\n"],["body","带有位置参数的处理程序的定义显示了在调用处理程序时列出参数的顺序以及在调用处理程序时要执行的语句。"],["body","\n"],["body","定义必须包括括号，即使它不包括任何参数. The syntax is shown in Handler Syntax (Positional Parameters)."],["body","\n"],["body","在下面的示例中，'minimumValue' 例程返回两个值中较小的一个:"],["body","\n"],["body","on minimumValue(x, y)\n    if x < y then\n        return x\n    else\n        return y\n    end if\nend minimumValue\n \n-- To call minimumValue:\nminimumValue(5, 105) --result: 5\n"],["body","\n"],["body","'minimumValue' 处理程序的第一行指定处理程序的参数。要使用位置参数调用处理程序，请按照与处理程序定义中指定的参数相同的顺序列出参数。"],["body","\n"],["body","如果处理程序调用是表达式的一部分，则AppleScript使用处理程序返回的值来评估表达式。例如，要计算以下表达式，AppleScript首先调用 “minimumvalue”，然后计算表达式的其余部分。"],["body","\n"],["body","minimumValue(5, 105) + 50 --result: 55\n"],["body","\n"],["headingLink","handlers-with-patterned-positional-parameters"],["heading","Handlers with Patterned Positional Parameters"],["body","\n"],["body","您可以创建一个处理程序，该处理程序的位置参数定义了在调用该处理程序时要匹配的模式。例如，以下处理程序采用单个参数，其模式由列表中的两个项目组成:"],["body","\n"],["body","on displayPoint({x, y})\n    display dialog (\"x = \" & x & \", y = \" & y)\nend displayPoint\n \n-- Calling the handler:\nset testPoint to {3, 8}\ndisplayPoint(testPoint)\n"],["body","\n"],["body","参数模式可能比单个列表复杂得多。下一个示例中的处理程序采用两个数字和一个记录，其属性包括边界列表。处理程序显示一个对话框，汇总一些传递的信息。"],["body","\n"],["body","on hello(a, b, {length:l, bounds:{x, y, w, h}, name:n})\n    set q to a + b\n \n    set response to \"Hello \" & n & \", you  are \" & l & ¬\n        \" inches tall and occupy position (\" & x &  \", \" & y & \").\"\n \n    display dialog response\n \nend hello\n \nset thing to {bounds:{1, 2, 4, 5}, name:\"George\", length:72}\nhello (2, 3, thing)\n--result: A dialog displaying “Hello George, you are 72 inches  tall\n--          and occupy position (1,2).”\n\n"],["body","\n"],["body","传递给具有 patterned parameters  的处理程序的记录的属性不必按照处理程序定义中给出的相同顺序给出，只要满足模式所需的所有属性都存在即可。"],["body","\n"],["body","下面对 'minimumValue' 的调用使用从处理程序调用到 'maximumValue' 的值作为其第二个参数。'maximumValue' 处理程序 (未显示) 返回两个传递的数值中的较大者。"],["body","\n"],["body","minimumValue(20, maximumValue(1, 313)) --result: 20\n"],["body","\n"],["headingLink","handlers-with-interleaved-parameters"],["heading","Handlers with Interleaved Parameters"],["body","\n"],["body","具有交错参数(Interleaved Parameters)的处理程序是具有位置参数的处理程序的特殊情况。"],["body","\n"],["body","定义显示了调用处理程序时列出参数的顺序，以及调用处理程序时要执行的语句，但是处理程序的名称被分解成碎片，并与参数交织在一起，这样可以使它更容易阅读。具有交错参数的处理程序可以在任何脚本中使用，但是对于桥接Objective-C方法特别有用，因为它们自然类似于Objective-C语法。 The syntax is shown in Handler Syntax (Interleaved Parameters)."],["body","\n"],["body","具有交错参数的处理程序可能只有一个参数，如在本例中:"],["body","\n"],["body","on areaOfCircleWithRadius:radius\n    return radius ^ 2 * pi\nend areaOfCircleWithRadius:\n"],["body","\n"],["body","Or more than one, as in this example:"],["body","\n"],["body","on areaOfRectangleWithWidth:w height:h\n    return w * h\nend areaOfRectangleWithWidth:height:\n"],["body","\n"],["body","To call a handler with interleaved parameters, list the parameters in the same order as they are specified in the handler definition. Despite the resemblance to labeled "],["body","\n"],["body","parameters, the parameters may not be reordered. Also, the call must be explicitly sent to an object, even if the target object is the default, it. For example:"],["body","\n"],["body","its foo:5 bar:105 --this works\ntell it to foo:5 bar:105 --as does this\nfoo:5 bar:105 --syntax error.\n"],["body","\n"],["body","Note: 交错参数处理程序的实际名称是所有带有下划线的名称部分，等效于使用该名称和位置参数定义的处理程序。例如，这两个处理程序声明是等价的:"],["body","\n"],["body","on tableView:t objectValueForTableColumn:c row:r\non tableView_objectValueForTableColumn_row_(t, c, r)\n"],["body","\n"],["body","Given a compiled script, AppleScript will automatically translate between the two forms depending on whether or not the current system version supports interleaved parameters."],["body","\n"],["body","给定已编译的脚本，AppleScript会根据当前系统版本是否支持交错参数，自动在两种形式之间进行转换。"],["body","\n"],["headingLink","parameter-specifications"],["heading","Parameter Specifications"],["body","\n"],["body","Note: 在OS X Yosemite v10.10及更高版本中支持Parameter Specifications。"],["body","\n"],["body","处理程序定义中的参数 “name” 可以是简单的名称，如上所示，或者它可以另外指定所需的类，并且对于标记的参数，可以指定默认值。要指定必需的类，请在名称后面加上 “as” * class * 或 “as {'* class *'，'…'}”。例如，您可以将参数声明为特定的整数，如下所示:"],["body","\n"],["body","on factorial(x as integer)\n"],["body","\n"],["body","如果将实际值强制为整数失败，则AppleScript会引发适当的错误，该错误可能会被 “try” 块捕获。类可以是类的列表，如 [运算符参考](https://developer.apple.com/library/archive/documentation/AppleScript/Conceptual/AppleScriptLangGuide/reference/ASLR_operators.html # // apple_ref/doc/uid/TP40000983-CH5g-124070) 中所述。"],["body","\n"],["body","通过在形式参数名称后面加上 ':' * literal *，可以用默认值声明带标签的参数。这样做使参数在调用时可选。例如，这声明了一个 'make' 处理程序，该处理程序具有 “与数据” 参数的默认值:"],["body","\n"],["body","on make new theClass with data theData : missing value\n"],["body","\n"],["body","现在可以在不提供 “with data” 参数的情况下调用此处理程序; 处理程序将看到 “数据” 设置为指定的默认 “missing value”，然后可以对其进行测试并适当处理。"],["body","\n"],["body","参数可以同时使用类型规范和默认值。例如，这声明了一个 'make' 处理程序，该处理程序具有 with properties 参数，该参数必须是记录，并且具有空记录的默认值:"],["body","\n"],["body","on make new theClass with properties theProperties as record : {}\n"],["body","\n"],["headingLink","recursive-handlers"],["heading","Recursive Handlers"],["body","\n"],["body","递归处理程序 是调用自身的处理程序。例如，这个递归处理程序生成阶乘。(一个数的阶乘是从1到该数的所有正整数的乘积，例如4阶乘等于123*4，或24，0的阶乘是1。)"],["body","\n"],["body","on factorial(x)\n    if x > 0 then\n        return x * factorial(x - 1)\n    else\n        return 1\n    end if\nend factorial\n \n-- To call factorial:\nfactorial(10)   --result: 3628800\n"],["body","\n"],["body","当您调用递归处理程序时，AppleScript会跟踪原始 (部分执行) 处理程序中的变量和挂起语句，直到递归处理程序完成。因为每个调用都使用一些内存，所以挂起处理程序的最大数量受到可用内存的限制。结果，递归处理程序可能会在递归调用完成之前生成错误。"],["body","\n"],["body","此外，递归处理程序可能不是解决问题的最有效方法。例如，上面显示的阶乘处理程序可以重写为使用 'repeat' 语句而不是递归调用， repeat with loopVariable (from startValue to stopValue)."],["body","\n"],["headingLink","errors-in-handlers"],["heading","Errors in Handlers"],["body","\n"],["body","与任何可能遇到错误的AppleScript语句一样，您可以使用 'try' 语句来处理处理程序中可能出现的错误。“try” 语句包括两个语句集合: 一个在一般情况下执行，第二个仅在发生错误时执行。"],["body","\n"],["body","通过将一个或多个 “try” 语句与处理程序一起使用，您可以在一个包中结合重用和错误处理的优势。有关演示此方法的详细示例，请参见 [处理错误](https://developer.apple.com/library/archive/documentation/AppleScript/Conceptual/AppleScriptLangGuide/reference/ASLR_error_xmpls.html # // apple_ref/doc/uid/TP40000983-CH221-SW1)。"],["body","\n"],["headingLink","passing-by-reference-versus-passing-by-value"],["heading","Passing by Reference Versus Passing by Value"],["body","\n"],["body","在处理程序中，每个参数都像一个变量，提供对传递的信息的访问。AppleScript通过引用传递所有参数，这意味着在处理程序和调用者之间共享一个传递的变量，就像处理程序使用 'set' 命令创建了一个变量一样。但是，重要的是要记住Using the copy and set Commands: 中提出的一点: 只有可变对象 才能被改变"],["body","\n"],["body","因此，参数的类类型确定信息是通过值还是通过引用有效传递:"],["body","\n\n"],["body","\n"],["body","对于可变对象 (those whose class is date, list, record, or script), information is passed by reference:"],["body","\n"],["body","如果处理程序更改了此类型的参数的值，则会更改原始对象。"],["body","\n"],["body","\n"],["body","\n"],["body","For all other class types, information is effectively passed by value:\n尽管AppleScript 传递了对原始对象的引用，但该对象无法更改。如果 处理程序为此类型的参数分配新值，则原始对象不变。"],["body","\n"],["body","\n\n"],["body","如果 你想 引用传值，但传值类型 不是 date, list, record, or script，可以使用 reference 对象引用"],["body","\n"],["body","尽管处理程序只能访问refrence object 对象的副本，但指定的对象将是相同的"],["body","\n"],["body","对处理程序中指定对象的更改将更改原始对象，尽管对 reference object 本身的更改不会。"],["body","\n"],["headingLink","calling-handlers-in-a-tell-statement"],["heading","Calling Handlers in a tell Statement"],["body","\n"],["body","要从 tell 语句中调用处理程序，您必须使用保留字 of me 或 my 来指示该处理程序是脚本的一部分，而不是应该发送到 “tell” 语句的目标的命令。"],["body","\n"],["body","例如，以下脚本从 “tell” 语句中调用 [具有位置参数的处理程序](https://developer.apple.com/library/archive/documentation/AppleScript/Conceptual/AppleScriptLangGuide/conceptual/ASLR_about_handlers.html # // apple_ref/doc/uid/TP40000983-CH206-SW13) 中定义的 “极小值” 处理程序。如果此调用未包含 “我的” 一词，则会导致错误，因为AppleScript会将 “minimumvalue” 命令发送到TextEdit，后者无法理解该消息。"],["body","\n"],["body","tell front document of application \"TextEdit\"\n    minimumValue(12, 400) of me\n    set paragraph 1 to result as text\nend tell\n--result: The handler call is successful.\n"],["body","\n"],["body","Instead of using the words of me, you could insert the word my before the handler call:"],["body","\n"],["body","my minimumValue(12, 400)\n"],["body","\n\n\n\n"],["body","\n\n                    "],["body","\n\n                    \n                \n            \n\n            \n\n        \n\n\n\n\n        \n\n\n\n        \n        \n        \n\n        \n\n\n    \n    \n"]],[["_relative_fp","6.AppleScript/5.AboutHandlers/3.CallingAScriptApplicationFromAScript.html"],["title","CallingAScriptApplicationFromAScript - 各项编程语言"],["body","\n    \n        \n        \n\n        \n        \n\n        \n        \n\n        \n        \n\n        \n\n        \n\n            \n                                \n                \n                    \n                        "],["body","\n                            \n                        "],["body","\n                        "],["body","\n                            \n                        "],["body","\n                        \n                            "],["body","Light"],["body","\n                            "],["body","Rust"],["body","\n                            "],["body","Coal"],["body","\n                            "],["body","Navy"],["body","\n                            "],["body","Ayu"],["body","\n                        \n                    \n\n                    "],["heading","各项编程语言"],["body","\n\n                    \n\n                    \n                \n\n\n                \n                \n\n                \n                    "],["body","\n                        \n\n"],["body","\n"],["body","\n\n"],["headingLink","calling-a-script-application-from-a-script"],["heading","Calling a Script Application From a Script"],["body","\n"],["body","A script can send commands to a script application just as it can to other applications. To launch a non-stay-open application and run its script, use a launch command followed by a run command, like this:"],["body","\n"],["body","脚本可以将命令发送到脚本应用程序，就像它可以发送到其他应用程序一样。要启动非stay-open应用程序并运行其脚本，请使用 “启动” 命令，然后使用 “运行” 命令，如下所示:"],["body","\n"],["body","launch application \"NonStayOpen\"\nrun application \"NonStayOpen\"\n"],["body","\n"],["body","“launch” 命令启动脚本应用程序，而不向它发送隐式的 run 命令。当 run 命令发送到脚本应用程序时，它会处理该命令，并在必要时发回回复，然后退出。"],["body","\n"],["body","同样，要启动一个非 stay-open 应用程序并运行其 'stringTest' 处理程序 (将 'text' 对象作为参数)，请使用 'launch' 命令，后跟 'stringTest' 命令，如下所示:"],["body","\n"],["body","tell application \"NonStayOpen\"\n    launch\n    stringTest(\"Some example text.\")\nend tell\n"],["body","\n"],["body","For information on how to create script applications, see Handlers in Script Applications."],["body","\n\n\n\n"],["body","\n\n                    "],["body","\n\n                    \n                \n            \n\n            \n\n        \n\n\n\n\n        \n\n\n\n        \n        \n        \n\n        \n\n\n    \n    \n"]],[["_relative_fp","6.AppleScript/5.AboutHandlers/2.HandlersInScriptApplications.html"],["title","HandlersInScriptApplications - 各项编程语言"],["body","\n    \n        \n        \n\n        \n        \n\n        \n        \n\n        \n        \n\n        \n\n        \n\n            \n                                \n                \n                    \n                        "],["body","\n                            \n                        "],["body","\n                        "],["body","\n                            \n                        "],["body","\n                        \n                            "],["body","Light"],["body","\n                            "],["body","Rust"],["body","\n                            "],["body","Coal"],["body","\n                            "],["body","Navy"],["body","\n                            "],["body","Ayu"],["body","\n                        \n                    \n\n                    "],["heading","各项编程语言"],["body","\n\n                    \n\n                    \n                \n\n\n                \n                \n\n                \n                    "],["body","\n                        \n\n"],["body","\n"],["body","\n\n"],["headingLink","handlers-in-script-applications"],["heading","Handlers in Script Applications"],["body","\n\n"],["body","script application 是一个应用程序，其唯一功能是运行与其关联的脚本。脚本应用程序包含允许它们响应命令的处理程序。"],["body","\n"],["body","例如，许多脚本应用程序可以响应 run 命令和 open 命令。脚本应用程序在启动时会收到一个run 命令，而在Finer中的图标上放下另一个图标时会收到一个 “打开” 命令。"],["body","\n"],["body","它还可以包含其他处理程序来响应诸如 “quit” 或 “print” 之类的命令。"],["body","\n"],["body","在脚本编辑器中保存脚本时，可以通过从文件格式选项中选择应用程序或 应用程序包来创建脚本应用程序\n\n"],["body","保存为应用程序的结果是与Mac OS 9兼容的简单格式"],["body","\n"],["body","保存为应用程序捆绑包会导致使用现代捆绑包格式的应用程序，其指定的目录结构支持返回OS X v10.3"],["body","\n"],["body","创建脚本应用程序时，您还可以指定在应用程序运行其脚本之前是否应出现启动屏幕，无论您在脚本编辑器中的脚本窗口的描述窗格中编写的内容都显示在启动屏幕中"],["body","\n"],["body","您还可以在脚本编辑器中指定脚本应用程序在运行后是否应保持打开状态，默认为脚本运行后立即退出。"],["body","\n"],["body","您可以像其他任何应用程序一样从Finder运行脚本应用程序。如果具有启动屏幕，则用户必须在脚本实际运行之前单击运行按钮或按返回键"],["body","\n\n"],["body","\n\n"],["body","考虑以下简单脚本"],["body","\n"],["body","tell application \"Finder\"\n    close front window\nend tell\n"],["body","\n"],["body","此脚本作为脚本应用程序的作用取决于您在保存时指定的内容。如果您没有指定启动屏幕或告诉它保持打开状态，它将自动执行一次，closing the front Finder window, and then quit."],["body","\n"],["body","如果脚本应用程序修改了属性的值，则更改后的值将在应用程序的启动期间持续存在。有关相关信息，请参见 [变量和属性的范围](https://developer.apple.com/library/archive/documentation/AppleScript/Conceptual/AppleScriptLangGuide/conceptual/ASLR_variables.html # // apple_ref/doc/uid/TP40000983-CH223-SW1)。"],["body","\n"],["body","有关某些通用脚本应用程序处理程序的信息，请参见以下部分:"],["body","\n\n"],["body","run Handlers"],["body","\n"],["body","open Handlers"],["body","\n"],["body","idle and quit Handlers for Stay-Open Applications"],["body","\n\n"],["body","See Handler Reference for syntax information."],["body","\n"],["headingLink","run-handlers"],["heading","run Handlers"],["body","\n"],["body","当您运行脚本或启动脚本应用程序时，将调用其 run 处理程序。脚本的run 处理程序以以下两种方式之一定义:"],["body","\n\n"],["body","作为隐式的 run 处理程序，它由在脚本中的任何处理程序或嵌套的 “脚本” 对象之外声明的所有语句组成。\n\n"],["body","在这种情况下，属性和 “全局” 变量的声明不被视为语句-也就是说，它们不被视为隐式 “运行” 处理程序的一部分。"],["body","\n\n"],["body","\n"],["body","作为显式的 'run' 处理程序，它包含在 'on run' 和 'end' 语句中，类似于其他处理程序."],["body","\n\n\n"],["body","不允许同时使用隐式和显式 “运行” 处理程序，并在编译过程中导致语法错误"],["body","\n"],["body","如果脚本没有运行处理程序 (例如，作为处理程序库的脚本，如 [参数规范](https://developer.apple.com/library/archive/documentation/AppleScript/Conceptual/AppleScriptLangGuide/conceptual/ASLR_about_handlers.html # // apple_ref/doc/uid/TP40000983-CH206-SW12) 中所述)，则执行脚本不会执行任何操作。但是，向它发送显式的 “运行” 命令会导致错误"],["body","\n\n"],["body","下面的脚本演示了一个隐式的 `运行” 处理程序。该脚本由调用 'sayHello' 处理程序的语句和处理程序本身的定义组成:"],["body","\n"],["body","sayHello()\n \non sayHello()\n    display dialog \"Hello\"\nend sayHello\n"],["body","\n"],["body","此脚本的隐式 'run' 处理程序由语句 'sayHello()'组成，这是处理程序之外的唯一语句。如果将此脚本保存为脚本应用程序，然后运行该应用程序，则该脚本会收到一个 'run' 命令，该命令会导致它执行隐式 'run' 处理程序中的一条语句。"],["body","\n"],["body","您可以重写以前的脚本，以提供与显式 'run' 处理程序完全相同的行为:"],["body","\n"],["body","on run\n    sayHello()\nend run\n \non sayHello()\n    display dialog \"Hello\"\nend sayHello\n"],["body","\n"],["body","无论是将脚本保存为脚本应用程序还是已编译脚本，在运行脚本时都会调用其  run handler。您还可以从另一个脚本调用脚本应用程序中的 “运行” 处理程序。有关如何执行此操作的信息，请参见 [从脚本调用脚本应用程序](https://developer.apple.com/library/archive/documentation/AppleScript/Conceptual/AppleScriptLangGuide/conceptual/ASLR_about_handlers.html # // apple_ref/doc/uid/TP40000983-CH206-SW17)。"],["body","\n"],["headingLink","open-handlers"],["heading","open Handlers"],["body","\n\n"],["body","\n"],["body","无论何时用户将文件、文件夹或磁盘图标放在应用程序的Finder图标上，包括脚本应用程序在内的Mac应用程序都会收到 打开 命令，即使应用程序已经在运行。"],["body","\n"],["body","\n"],["body","\n"],["body","如果脚本应用程序中的脚本包含 open 处理程序，则在应用程序接收 open 命令时执行该处理程序。“open” 处理程序采用一个参数，该参数提供了要打开的所有项目的列表。列表中的每个项目都是一个 'alias' 对象。"],["body","\n"],["body","\n\n"],["body","例如，以下 打开 处理程序列出了脚本应用程序图标上所有项目的路径名，并将其保存在最前面的TextEdit文档中:"],["body","\n"],["body","on open names\n    set pathNamesString to \"\" -- Start with empty text string.\n    repeat with i in names\n        -- In this loop, you can perform operations on each dropped item.\n        -- For now, just get the name and append a return character.\n        set iPath to (i as text)\n        set pathNamesString to pathNamesString & iPath & return\n    end repeat\n    -- Store list in open document, to verify what was dropped.\n    tell application \"TextEdit\"\n        set paragraph 1 of front document to pathNamesString\n    end tell\n    return\nend open\n"],["body","\n"],["body","文件，文件夹或磁盘仅通过将它们放在脚本应用程序上而不会以任何方式移动，复制或影响它们。但是，脚本应用程序的处理程序可以告诉Finder移动，复制或以其他方式操作项目。有关使用Finder项目的示例，请参阅 [文件夹操作参考](https://developer.apple.com/library/archive/documentation/AppleScript/Conceptual/AppleScriptLangGuide/reference/ASLR_folder_actions.html # // apple_ref/doc/uid/TP40000983-CH219-SW2)。"],["body","\n"],["body","您还可以通过向脚本应用程序发送 open 命令来运行 “打开” 处理程序。有关详细信息，请参见 [从脚本调用脚本应用程序](https://developer.apple.com/library/archive/documentation/AppleScript/Conceptual/AppleScriptLangGuide/conceptual/ASLR_about_handlers.html # // apple_ref/doc/uid/TP40000983-CH206-SW17)。"],["body","\n"],["headingLink","idle-and-quit-handlers-for-stay-open-applications"],["heading","idle and quit Handlers for Stay-Open Applications"],["body","\n"],["body","默认情况下，接收 “run” 或 “open” 命令的脚本应用程序处理该单个命令，然后退出。相反，保持打开的脚本应用程序 (在脚本编辑器中保存为保持打开) 在启动后保持打开状态。"],["body","\n"],["body","一个保持开放的脚本应用程序可能是有用的，原因有几个:"],["body","\n\n"],["body","保持打开的脚本应用程序可以接收和处理除了 run 和 open 之外的其他命令。这使您可以将脚本应用程序用作脚本服务器，该脚本服务器在运行时提供了可以由任何其他脚本调用的处理程序集合。"],["body","\n"],["body","保持开放脚本应用程序可以执行周期性的动作，即使在后台，只要脚本应用程序正在运行。"],["body","\n\n"],["body","保持打开脚本应用程序通常提供的两个特定处理程序是 idle 处理程序和 exit 处理程序。"],["body","\n"],["headingLink","idle-handlers"],["heading","idle Handlers"],["body","\n\n"],["body","\n"],["body","如果保持打开的脚本应用程序包含 idle 处理程序，则AppleScript会发送脚本应用程序定期 idle 命令 (默认情况下，每30秒一次)，允许其在不执行其他操作时执行后台任务。"],["body","\n"],["body","\n"],["body","\n"],["body","如果 idle 处理程序返回一个正数，则该数字将成为调用该处理程序的速率 (以秒为单位)。如果处理程序返回非数字值，则不会更改速率。您可以返回0来保持30秒的默认延迟。"],["body","\n"],["body","\n"],["body","\n"],["body","例如，当保存为保持开放的应用程序时，以下脚本每5秒发出哔哔声:"],["body","\n"],["body","\n"],["body","\n"],["body","on idle\n    beep\n    return 5\nend idle\n"],["body","\n"],["body","\n\n"],["body","从处理程序返回的结果只是最后一条语句的结果，即使它不包括单词 'return' 显式。(有关更多信息，请参见 “返回”。)例如，此处理程序每分钟调用一次，因为最后一条语句的值为60:"],["body","\n"],["body","on idle\n    set x to 10\n    beep\n    set x to x * 6  -- The handler returns the result (60).\nend idle\n"],["body","\n"],["headingLink","quit-handlers"],["heading","quit Handlers"],["body","\n\n"],["body","\n"],["body","每当用户选择退出菜单命令或在应用程序处于活动状态时按command-Q时，AppleScript都会向保持打开状态的脚本应用程序发送 exit 命令。如果脚本包含 “退出” 处理程序，则处理程序中的语句将在应用程序退出之前运行。"],["body","\n"],["body","\n"],["body","\n"],["body","'quit' 处理程序可用于设置脚本属性，告诉另一个应用程序执行某些操作，显示对话框或执行几乎任何其他任务。如果处理程序包含 “continue quit” 语句，则将调用脚本应用程序的默认退出行为并退出。如果 'quit' 处理程序在遇到 'continue quit' 语句之前返回，则应用程序不会退出。"],["body","\n"],["body","\n\n"],["body","Note: The continue statement passes control back to the application’s default quit handler. For more information, see continue."],["body","\n"],["body","例如，此处理程序在允许应用程序退出之前与用户进行检查:"],["body","\n"],["body","on quit\n    display dialog \"Really quit?\" ¬\n        buttons {\"No\", \"Quit\"} default button  \"Quit\"\n    if the button returned of the result is \"Quit\" then\n        continue quit\n    end if\n    -- Without the continue statement, the application doesn't quit.\nend quit\n"],["body","\n"],["body","Warning: 如果AppleScript在执行 'on quit' 处理程序时没有遇到 'continue quit' 语句，则似乎无法退出应用程序。 "],["body","\n"],["body","例如，如果上面显示的处理程序在 'continue quit' 语句之前出现错误，则应用程序不会退出。如有必要，您可以使用Force Quit (Command-Option-Esc) 停止应用程序。"],["body","\n\n\n\n"],["body","\n\n                    "],["body","\n\n                    \n                \n            \n\n            \n\n        \n\n\n\n\n        \n\n\n\n        \n        \n        \n\n        \n\n\n    \n    \n"]]]