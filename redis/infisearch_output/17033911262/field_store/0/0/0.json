[[["_relative_fp","1.RedissionLUA_RateLimit.html"],["title","RateLimit.md - REDIS学习笔记"],["body","\n    \n        \n        \n\n        \n        \n\n        \n        \n\n        \n\n        \n        \n\n        \n\n        \n        \n\n        \n\n            \n                                \n                \n                    \n                        "],["body","\n                            \n                        "],["body","\n                        "],["body","\n                            \n                        "],["body","\n                        \n                            "],["body","Light"],["body","\n                            "],["body","Rust"],["body","\n                            "],["body","Coal"],["body","\n                            "],["body","Navy"],["body","\n                            "],["body","Ayu"],["body","\n                        \n                    \n\n                    "],["heading","REDIS学习笔记"],["body","\n\n                    \n\n                    \n                \n\n\n                \n                \n\n                \n                    "],["body","\n                        \n\n"],["body","\n"],["body","\n\n"],["headingLink","redissionlua命令解析"],["heading","RedissionLUA命令解析"],["body","\n"],["headingLink","限流算法"],["heading","限流算法"],["body","\n"],["body","# 入参说明\n\n## keys[1] 原始限流配置:Limit::RateLimiter::default::1::1::all::20/1SECONDS}\n\n\n## keys[2] (全局限流额度)global_value: {Limit::RateLimiter::default::1::1::all::20/1SECONDS}:value\n## keys[3] (客户端限流额度)clent_value:{Limit::RateLimiter::default::1::1::all::20/1SECONDS}:value:789f53b1-8120-4527-b535-4273a018b74c\n\n## KEYS[4] global_permists:{Limit::RateLimiter::default::1::1::all::20/1SECONDS}:permits\n## KEYS[5] client_permits:{Limit::RateLimiter::default::1::1::all::20/1SECONDS}:permits:789f53b1-8120-4527-b535-4273a018b74c\n\n## ARGV[1] 获取许可证的数量：1\n## ARGV[2] 时间戳\n## ARGV[3] 16为随机字节数组\n\n## 限流次数\nlocal rate = redis.call('hget', KEYS[1], 'rate');\n## 限流时间间隔 毫秒单位\nlocal interval = redis.call('hget', KEYS[1], 'interval');\n## 限流类型 1:每客户端限流 2:全局限流\nlocal type = redis.call('hget', KEYS[1], 'type');\n\n# 校验KEYS[1]是否存在\nassert(rate ~= false and interval ~= false and type ~= false, 'RateLimiter is not initialized')\n\nlocal valueName = KEYS[2];\nlocal permitsName = KEYS[4];\n\n## type = 1 \nif type == '1' then \n    valueName = KEYS[3];\n    permitsName = KEYS[5];\nend;\n\nassert(tonumber(rate) >= tonumber(ARGV[1]), 'Requested permits amount could not exceed defined rate');\n\n# 获取当前值的数量\nlocal currentValue = redis.call('get', valueName);\nlocal res;\n\nif currentValue ~= false then\n    local expiredValues = redis.call('zrangebyscore', permitsName, 0, tonumber(ARGV[2]) - interval);\n    \n    local released = 0;\n\n    for i, v in ipairs(expiredValues) do \n        local random, permits = struct.unpack('Bc0I', v);\n        released = released + permits;\n    end;\n    \n\n    # 释放许可证并调整可用额度\n    if released > 0 then \n        # 移除过期的许可证\n        redis.call('zremrangebyscore', permitsName, 0, tonumber(ARGV[2]) - interval);\n        # 如果超出限流次数了，则重新调整限流次数\n        if tonumber(currentValue) + released > tonumber(rate) then\n            # 当前可用额度值 = 总可用次数 - 已经使用过的许可证\n            currentValue = tonumber(rate) - redis.call('zcard', permitsName);\n        else\n            # 直接相加\n            currentValue = tonumber(currentValue) + released;\n        end;\n        redis.call('set', valueName, currentValue);\n    end;\n\n    # 如果当前可用额度值小于请求的许可证数量，则返回需要等待的时间\n    if tonumber(currentValue) < tonumber(ARGV[1]) then \n        # 获取第一个最早许可证的时间戳\n        local firstValue = redis.call('zrange', permitsName, 0, 0, 'withscores');\n        # 计算需要等待的时间 = 3ms+限流时间间隔 - (当前时间戳 - 第一个最早许可证的时间戳)\n        res = 3 + interval - (tonumber(ARGV[2]) - tonumber(firstValue[2]));\n    else \n        # 加入到队列中。len(byte array) argv[3] argv[1]\n        redis.call('zadd', permitsName, ARGV[2], struct.pack('Bc0I', string.len(ARGV[3]), ARGV[3], ARGV[1]));\n        # 值自减1\n        redis.call('decrby', valueName, ARGV[1]);\n        # 返回空\n        res = nil;\n    end;\nelse \n    # 没拿到当前值，说明是新建\n    redis.call('set', valueName, rate);\n    # 添加成员\n    redis.call('zadd', permitsName, ARGV[2], struct.pack('Bc0I', string.len(ARGV[3]), ARGV[3], ARGV[1]));\n    # 自增\n    redis.call('decrby', valueName, ARGV[1]);\n    res = nil;\nend;\n\n# 同步当前KEYS[1]的剩余TTL\n\nlocal ttl = redis.call('pttl', KEYS[1]);\nif ttl > 0 then\n    redis.call('pexpire', valueName, ttl);\n    redis.call('pexpire', permitsName, ttl);\nend;\n\nreturn res;\n\n"],["body","\n\n\n\n"],["body","\n\n                    "],["body","\n\n                    \n                \n            \n\n            \n\n        \n\n\n\n\n        \n\n\n\n        \n        \n        \n\n        \n\n\n    \n    \n\n"]],[["_relative_fp","index.html"],["title","RateLimit.md - REDIS学习笔记"],["body","\n    \n        \n        \n\n        \n        \n\n        \n        \n\n        \n\n        \n        \n\n        \n\n        \n        \n\n        \n\n            \n                                \n                \n                    \n                        "],["body","\n                            \n                        "],["body","\n                        "],["body","\n                            \n                        "],["body","\n                        \n                            "],["body","Light"],["body","\n                            "],["body","Rust"],["body","\n                            "],["body","Coal"],["body","\n                            "],["body","Navy"],["body","\n                            "],["body","Ayu"],["body","\n                        \n                    \n\n                    "],["heading","REDIS学习笔记"],["body","\n\n                    \n\n                    \n                \n\n\n                \n                \n\n                \n                    "],["body","\n                        \n\n"],["body","\n"],["body","\n\n"],["headingLink","redissionlua命令解析"],["heading","RedissionLUA命令解析"],["body","\n"],["headingLink","限流算法"],["heading","限流算法"],["body","\n"],["body","# 入参说明\n\n## keys[1] 原始限流配置:Limit::RateLimiter::default::1::1::all::20/1SECONDS}\n\n\n## keys[2] (全局限流额度)global_value: {Limit::RateLimiter::default::1::1::all::20/1SECONDS}:value\n## keys[3] (客户端限流额度)clent_value:{Limit::RateLimiter::default::1::1::all::20/1SECONDS}:value:789f53b1-8120-4527-b535-4273a018b74c\n\n## KEYS[4] global_permists:{Limit::RateLimiter::default::1::1::all::20/1SECONDS}:permits\n## KEYS[5] client_permits:{Limit::RateLimiter::default::1::1::all::20/1SECONDS}:permits:789f53b1-8120-4527-b535-4273a018b74c\n\n## ARGV[1] 获取许可证的数量：1\n## ARGV[2] 时间戳\n## ARGV[3] 16为随机字节数组\n\n## 限流次数\nlocal rate = redis.call('hget', KEYS[1], 'rate');\n## 限流时间间隔 毫秒单位\nlocal interval = redis.call('hget', KEYS[1], 'interval');\n## 限流类型 1:每客户端限流 2:全局限流\nlocal type = redis.call('hget', KEYS[1], 'type');\n\n# 校验KEYS[1]是否存在\nassert(rate ~= false and interval ~= false and type ~= false, 'RateLimiter is not initialized')\n\nlocal valueName = KEYS[2];\nlocal permitsName = KEYS[4];\n\n## type = 1 \nif type == '1' then \n    valueName = KEYS[3];\n    permitsName = KEYS[5];\nend;\n\nassert(tonumber(rate) >= tonumber(ARGV[1]), 'Requested permits amount could not exceed defined rate');\n\n# 获取当前值的数量\nlocal currentValue = redis.call('get', valueName);\nlocal res;\n\nif currentValue ~= false then\n    local expiredValues = redis.call('zrangebyscore', permitsName, 0, tonumber(ARGV[2]) - interval);\n    \n    local released = 0;\n\n    for i, v in ipairs(expiredValues) do \n        local random, permits = struct.unpack('Bc0I', v);\n        released = released + permits;\n    end;\n    \n\n    # 释放许可证并调整可用额度\n    if released > 0 then \n        # 移除过期的许可证\n        redis.call('zremrangebyscore', permitsName, 0, tonumber(ARGV[2]) - interval);\n        # 如果超出限流次数了，则重新调整限流次数\n        if tonumber(currentValue) + released > tonumber(rate) then\n            # 当前可用额度值 = 总可用次数 - 已经使用过的许可证\n            currentValue = tonumber(rate) - redis.call('zcard', permitsName);\n        else\n            # 直接相加\n            currentValue = tonumber(currentValue) + released;\n        end;\n        redis.call('set', valueName, currentValue);\n    end;\n\n    # 如果当前可用额度值小于请求的许可证数量，则返回需要等待的时间\n    if tonumber(currentValue) < tonumber(ARGV[1]) then \n        # 获取第一个最早许可证的时间戳\n        local firstValue = redis.call('zrange', permitsName, 0, 0, 'withscores');\n        # 计算需要等待的时间 = 3ms+限流时间间隔 - (当前时间戳 - 第一个最早许可证的时间戳)\n        res = 3 + interval - (tonumber(ARGV[2]) - tonumber(firstValue[2]));\n    else \n        # 加入到队列中。len(byte array) argv[3] argv[1]\n        redis.call('zadd', permitsName, ARGV[2], struct.pack('Bc0I', string.len(ARGV[3]), ARGV[3], ARGV[1]));\n        # 值自减1\n        redis.call('decrby', valueName, ARGV[1]);\n        # 返回空\n        res = nil;\n    end;\nelse \n    # 没拿到当前值，说明是新建\n    redis.call('set', valueName, rate);\n    # 添加成员\n    redis.call('zadd', permitsName, ARGV[2], struct.pack('Bc0I', string.len(ARGV[3]), ARGV[3], ARGV[1]));\n    # 自增\n    redis.call('decrby', valueName, ARGV[1]);\n    res = nil;\nend;\n\n# 同步当前KEYS[1]的剩余TTL\n\nlocal ttl = redis.call('pttl', KEYS[1]);\nif ttl > 0 then\n    redis.call('pexpire', valueName, ttl);\n    redis.call('pexpire', permitsName, ttl);\nend;\n\nreturn res;\n\n"],["body","\n\n\n\n"],["body","\n\n                    "],["body","\n\n                    \n                \n            \n\n            \n\n        \n\n\n\n\n        \n\n\n\n        \n        \n        \n\n        \n\n\n    \n    \n\n"]]]