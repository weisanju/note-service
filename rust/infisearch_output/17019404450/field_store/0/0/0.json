[[["_relative_fp","7宏.html"],["title","宏.md - RUST学习笔记"],["body","\n    \n        \n        \n\n        \n        \n\n        \n        \n\n        \n\n        \n        \n\n        \n\n        \n        \n\n        \n\n            \n                                \n                \n                    \n                        "],["body","\n                            \n                        "],["body","\n                        "],["body","\n                            \n                        "],["body","\n                        \n                            "],["body","Light"],["body","\n                            "],["body","Rust"],["body","\n                            "],["body","Coal"],["body","\n                            "],["body","Navy"],["body","\n                            "],["body","Ayu"],["body","\n                        \n                    \n\n                    "],["heading","RUST学习笔记"],["body","\n\n                    \n\n                    \n                \n\n\n                \n                \n\n                \n                    "],["body","\n                        \n\n"],["body","\n"],["body","\n\n"],["headingLink","宏"],["heading","宏"],["body","\n"],["body","\n"],["body","宏（Macro）指的是 Rust 中一系列的功能"],["body","\n"],["body","\n"],["headingLink","声明declarative宏"],["heading","声明（Declarative）宏"],["body","\n"],["headingLink","定义宏-macro_rules"],["heading","定义宏 macro_rules!"],["body","\n"],["headingLink","实例"],["heading","实例"],["body","\n"],["body","vec! 实现"],["body","\n"],["body","#![allow(unused)]\n\nfn main() {\n#[macro_export]\nmacro_rules! vec {\n    ( $( $x:expr ),* ) => {\n        {\n            let mut temp_vec = Vec::new();\n            $(\n                temp_vec.push($x);\n            )*\n            temp_vec\n        }\n    };\n}\n}"],["body","\n"],["headingLink","三种-过程procedural宏"],["heading","三种 过程（Procedural）宏"],["body","\n"],["body","自定义派生（derive）"],["body","\n"],["body","类属性"],["body","\n"],["body","类函数"],["body","\n"],["headingLink","宏原理"],["heading","宏原理"],["body","\n"],["headingLink","源分析"],["heading","源分析"],["body","\n"],["headingLink","tokenisation"],["heading","tokenisation"],["body","\n\n"],["body","\n"],["body","编译的第一个阶段就是 词汇化(tokenisation)"],["body","\n"],["body","\n"],["body","\n"],["body","将源代码转换为一系列不可分割的 词语单元"],["body","\n"],["body","\n"],["body","\n"],["body","rust的各种各样的词法单元"],["body","\n\n"],["body","自定义标识符  foo, Bambous, self, we_can_dance, LaCaravane, …"],["body","\n"],["body","整型字面量 : 42, 72u32, 0_______0, …"],["body","\n"],["body","关键字: _, fn, self, match, yield, macro, …"],["body","\n"],["body","申明周期标识符: 'a, 'b, 'a_rare_long_lifetime_name, …"],["body","\n"],["body","字符串字面量: \"\", \"Leicester\", r##\"venezuelan beaver\"##, …"],["body","\n"],["body","符号: [, :, ::, ->, @, <-, …"],["body","\n\n"],["body","\n\n"],["headingLink","parsing"],["heading","parsing"],["body","\n"],["body","下一个阶段是转换 将一系列的 tokens 转换成 AST(Abstract Syntax Tree)"],["body","\n\n"],["body","会在内存中 构建 程序 的语法结构"],["body","\n"],["body","例如 1+2 在内存中的结构如下"],["body","\n"],["body","AST结构 包含了整个程序"],["body","\n\n"],["body","┌─────────┐   ┌─────────┐\n│ BinOp   │ ┌╴│ LitInt  │\n│ op: Add │ │ │ val: 1  │\n│ lhs: ◌  │╶┘ └─────────┘\n│ rhs: ◌  │╶┐ ┌─────────┐\n└─────────┘ └╴│ LitInt  │\n              │ val: 2  │\n              └─────────┘\n"],["body","\n"],["headingLink","token-trees"],["heading","Token trees"],["body","\n\n"],["body","token tree 是介于 tokens 和 AST 之间的一种结构"],["body","\n"],["body","首先,大部分token都是 toeknTree 中的叶子结点 "],["body","\n"],["body","唯一不是叶子结点的 token 是 (...), [...], and {...} 又 称 grouping ,它们是 token tree 的内部 非叶子结点"],["body","\n"],["body","例如"],["body","\n\n"],["body","a + b + (c + d[0]) + e\n"],["body","\n"],["body","would be parsed into the following token trees:"],["body","\n"],["body","«a» «+» «b» «+» «(   )» «+» «e»\n          ╭────────┴──────────╮\n           «c» «+» «d» «[   ]»\n                        ╭─┴─╮\n                         «0»\n"],["body","\n"],["body","Note that this has no relationship to the AST the expression would produce; instead of a single root node, there are nine token trees at the root level. For reference, the AST would be:"],["body","\n"],["body","              ┌─────────┐\n              │ BinOp   │\n              │ op: Add │\n            ┌╴│ lhs: ◌  │\n┌─────────┐ │ │ rhs: ◌  │╶┐ ┌─────────┐\n│ Var     │╶┘ └─────────┘ └╴│ BinOp   │\n│ name: a │                 │ op: Add │\n└─────────┘               ┌╴│ lhs: ◌  │\n              ┌─────────┐ │ │ rhs: ◌  │╶┐ ┌─────────┐\n              │ Var     │╶┘ └─────────┘ └╴│ BinOp   │\n              │ name: b │                 │ op: Add │\n              └─────────┘               ┌╴│ lhs: ◌  │\n                            ┌─────────┐ │ │ rhs: ◌  │╶┐ ┌─────────┐\n                            │ BinOp   │╶┘ └─────────┘ └╴│ Var     │\n                            │ op: Add │                 │ name: e │\n                          ┌╴│ lhs: ◌  │                 └─────────┘\n              ┌─────────┐ │ │ rhs: ◌  │╶┐ ┌─────────┐\n              │ Var     │╶┘ └─────────┘ └╴│ Index   │\n              │ name: c │               ┌╴│ arr: ◌  │\n              └─────────┘   ┌─────────┐ │ │ ind: ◌  │╶┐ ┌─────────┐\n                            │ Var     │╶┘ └─────────┘ └╴│ LitInt  │\n                            │ name: d │                 │ val: 0  │\n                            └─────────┘                 └─────────┘\n"],["body","\n"],["body","tokenTree 与 AST 的差别 要理解"],["body","\n"],["body","写宏时会涉及到这两个结构"],["body","\n"],["body","方括号,括号,花括号 必须要配对"],["body","\n"],["headingLink","ast中的宏"],["heading","AST中的宏"],["body","\n"],["body","宏处理发生在AST构建好之后"],["body","\n"],["body","宏使用语法"],["body","\n\n"],["body","# [ $arg ]; e.g. #[derive(Clone)], #[no_mangle], …"],["body","\n"],["body","# ! [ $arg ]; e.g. #![allow(dead_code)], #![crate_name=\"blang\"], …"],["body","\n"],["body","$name ! $arg; e.g. println!(\"Hi!\"), concat!(\"a\", \"b\"), …"],["body","\n"],["body","$name ! $arg0 $arg1; e.g. macro_rules! dummy { () => {}; }."],["body","\n\n"],["body","头两个是 attribute,目前暂无法定义这两种形式"],["body","\n"],["body","最后一种 只有  macro_rules!宏 是这种形式"],["body","\n"],["body","只考虑第三种"],["body","\n"],["body","bitflags! {\n    flags Color: u8 {\n        const RED    = 0b0001,\n        const GREEN  = 0b0010,\n        const BLUE   = 0b0100,\n        const BRIGHT = 0b1000,\n    }\n}\n\nlazy_static! {\n    static ref FIB_100: u32 = {\n        fn fib(a: u32) -> u32 {\n            match a {\n                0 => 0,\n                1 => 1,\n                a => fib(a-1) + fib(a-2)\n            }\n        }\n\n        fib(100)\n    };\n}\n\nfn main() {\n    let colors = vec![RED, GREEN, BLUE];\n    println!(\"Hello, World!\");\n}\n"],["body","\n"],["body","Although the above invocations may look like they contain various kinds of Rust code, the parser simply sees a collection of meaningless token trees. To make this clearer, we can replace all these syntactic \"black boxes\" with ⬚, leaving us with:"],["body","\n"],["body","bitflags! ⬚\n\nlazy_static! ⬚\n\nfn main() {\n    let colors = vec! ⬚;\n    println! ⬚;\n}\n"],["body","\n"],["body","重点是:"],["body","\n\n"],["body","rust有各种各样的语法扩展, 现在只讨论  macro_rules! 定义的约定"],["body","\n"],["body","$name! $arg 这种形式可能不是 宏, 而是某种形式的语法扩展"],["body","\n"],["body","对 宏的输入 是一个 单一的 非叶子结点的 token tree"],["body","\n\n"],["body","宏只能出现在 明确定义支持的地方"],["body","\n\n"],["body","Patterns , 模式匹配"],["body","\n"],["body","Statements 语句"],["body","\n"],["body","Expressions 表达式"],["body","\n"],["body","Items "],["body","\n"],["body","impl Items"],["body","\n\n"],["headingLink","展开"],["heading","展开"],["body","\n"],["body","遍历AST, 定位 宏 然后展开"],["body","\n"],["body","let eight = 2 * four!();\n"],["body","\n"],["body","We can visualise this partial AST as follows:"],["body","\n"],["body","┌─────────────┐\n│ Let         │\n│ name: eight │   ┌─────────┐\n│ init: ◌     │╶─╴│ BinOp   │\n└─────────────┘   │ op: Mul │\n                ┌╴│ lhs: ◌  │\n     ┌────────┐ │ │ rhs: ◌  │╶┐ ┌────────────┐\n     │ LitInt │╶┘ └─────────┘ └╴│ Macro      │\n     │ val: 2 │                 │ name: four │\n     └────────┘                 │ body: ()   │\n                                └────────────┘\n"],["body","\n"],["body","从上下文得知, 宏展开成一个 表达式"],["body","\n"],["body","┌─────────────┐\n│ Let         │\n│ name: eight │   ┌─────────┐\n│ init: ◌     │╶─╴│ BinOp   │\n└─────────────┘   │ op: Mul │\n                ┌╴│ lhs: ◌  │\n     ┌────────┐ │ │ rhs: ◌  │╶┐ ┌─────────┐\n     │ LitInt │╶┘ └─────────┘ └╴│ BinOp   │\n     │ val: 2 │                 │ op: Add │\n     └────────┘               ┌╴│ lhs: ◌  │\n                   ┌────────┐ │ │ rhs: ◌  │╶┐ ┌────────┐\n                   │ LitInt │╶┘ └─────────┘ └╴│ LitInt │\n                   │ val: 1 │                 │ val: 3 │\n                   └────────┘                 └────────┘\n"],["body","\n"],["body","This can be written out like so:"],["body","\n"],["body","let eight = 2 * (1 + 3);\n"],["body","\n\n"],["body","宏展开会被当成语法 一个 AST的 node"],["body","\n"],["body","宏还可以展开成 宏 , 递归宏 展开是有限度的, 默认最大32 #![recursion_limit=\"…\"]"],["body","\n\n"],["headingLink","macro_rules"],["heading","macro_rules!"],["body","\n"],["headingLink","语法"],["heading","语法"],["body","\n"],["body","macro_rules! 是自身的一个语法扩展, 不是rust的语法"],["body","\n"],["body","macro_rules! $name {\n    $rule0 ;\n    $rule1 ;\n    // …\n    $ruleN ;\n}\n"],["body","\n"],["body","至少有一个rule 最后一个rule 的分号可以省略"],["body","\n"],["body","每一个rule的定义为"],["body","\n"],["body","    ($pattern) => {$expansion}\n"],["body","\n"],["body","pattern周围的 () 和 expression 的 {} 是用来分组的, 可以任意替换使用"],["body","\n"],["headingLink","matching"],["heading","Matching"],["body","\n"],["body","空模式"],["body","\n"],["body","#![allow(unused)]\nfn main() {\nmacro_rules! four {\n    () => {1 + 3};\n}\n//four!(), four![] or four!{} 都行\n}"],["body","\n"],["body","匹配时不会考虑, 分组符号"],["body","\n"],["body","模式同样能包好 字面 tokenTree ,必须精确匹配,通过简单正常编写 token tree 来完成"],["body","\n"],["body","#![allow(unused)]\nfn main() {\n//例如\nmacro_rules! gibberish {\n    (4 fn ['spang \"whammo\"] @_@) => {...};\n}\n}"],["body","\n"],["headingLink","captures"],["heading","Captures"],["body","\n"],["body","捕获标识 用  $self_variable: type"],["body","\n"],["body","type只能是以下几种"],["body","\n\n"],["body","item: an item, like a function, struct, module, etc."],["body","\n"],["body","block: a block (i.e. a block of statements and/or an expression, surrounded by braces)"],["body","\n"],["body","stmt: a statement"],["body","\n"],["body","pat: a pattern"],["body","\n"],["body","expr: an expression"],["body","\n"],["body","ty: a type"],["body","\n"],["body","ident: an identifier"],["body","\n"],["body","path: a path (e.g. foo, ::std::mem::replace, transmute::<_, int>, …)"],["body","\n"],["body","meta: a meta item; the things that go inside #[...] and #![...] attributes"],["body","\n"],["body","tt: a single token tree"],["body","\n\n"],["body","For example, here is a macro which captures its input as an expression:"],["body","\n"],["body","macro_rules! one_expression {\n    ($e:expr) => {...};\n}\n"],["body","\n"],["body","A capture $name:kind can be substituted into the expansion by writing $name. For example:"],["body","\n"],["body","macro_rules! times_five {\n    ($e:expr) => {5 * $e};\n}\n"],["body","\n"],["body","多捕获"],["body","\n"],["body","macro_rules! multiply_add {\n    ($a:expr, $b:expr, $c:expr) => {$a * ($b + $c)};\n}\n"],["body","\n"],["headingLink","repetitions"],["heading","Repetitions"],["body","\n"],["body","重复标识"],["body","\n"],["body","These allow a sequence of tokens to be matched. These have the general form"],["body","\n"],["body","$ ( ... ) sep rep"],["body","\n\n"],["body","$ is a literal dollar token."],["body","\n"],["body","( ... ) is the paren-grouped pattern being repeated."],["body","\n"],["body","sep is an optional separator token. Common examples are ,, and ;."],["body","\n"],["body","rep is   *  或者 +"],["body","\n\n"],["body","macro_rules! vec_strs {\n    (\n        // Start a repetition:\n        $(\n            // Each repeat must contain an expression...\n            $element:expr\n        )\n        // ...separated by commas...\n        ,\n        // ...zero or more times.\n        *\n    ) => {\n        // Enclose the expansion in a block so that we can use\n        // multiple statements.\n        {\n            let mut v = Vec::new();\n\n            // Start a repetition:\n            $(\n                // Each repeat will contain the following statement, with\n                // $element replaced with the corresponding expression.\n                v.push(format!(\"{}\", $element));\n            )*\n\n            v\n        }\n    };\n}\n"],["body","\n"],["headingLink","captures-and-expansion-redux"],["heading","Captures and Expansion Redux"],["body","\n"],["headingLink","第二个规则永远也不会匹配"],["heading","第二个规则永远也不会匹配"],["body","\n"],["body","因为一个ident也是也是一个expr"],["body","\n"],["body","macro_rules! dead_rule {\n    ($e:expr) => { ... };\n    ($i:ident +) => { ... };\n}\n"],["body","\n"],["body","规则匹配的广度"],["body","\n\n"],["body","item: anything."],["body","\n"],["body","block: anything."],["body","\n"],["body","stmt: => , ;"],["body","\n"],["body","pat: => , = if in"],["body","\n"],["body","expr: => , ;"],["body","\n"],["body","ty: , => : = > ; as"],["body","\n"],["body","ident: anything."],["body","\n"],["body","path: , => : = > ; as"],["body","\n"],["body","meta: anything."],["body","\n"],["body","tt: anything."],["body","\n\n"],["body","Additionally, macro_rules! generally forbids a repetition to be followed by another repetition, even if the contents do not conflict."],["body","\n"],["headingLink","捕获之后无法重新被捕获"],["heading","捕获之后无法重新被捕获"],["body","\n"],["body","One aspect of substitution that often surprises people is that substitution is not token-based, despite very much looking like it. Here is a simple demonstration:"],["body","\n"],["body","macro_rules! capture_expr_then_stringify {\n    ($e:expr) => {\n        stringify!($e)\n    };\n}\n\nfn main() {\n    println!(\"{:?}\", stringify!(dummy(2 * (1 + (3)))));\n    println!(\"{:?}\", capture_expr_then_stringify!(dummy(2 * (1 + (3)))));\n}\n"],["body","\n"],["body","Note that stringify! is a built-in syntax extension which simply takes all tokens it is given and concatenates them into one big string."],["body","\n"],["body","The output when run is:"],["body","\n"],["body","\"dummy ( 2 * ( 1 + ( 3 ) ) )\"\n\"dummy(2 * (1 + (3)))\"\n"],["body","\n"],["body","Note that despite having the same input, the output is different. This is because the first invocation is stringifying a sequence of token trees, whereas the second is stringifying an AST expression node."],["body","\n"],["body","To visualise the difference another way, here is what the stringify! macro gets invoked with in the first case:"],["body","\n"],["body","«dummy» «(   )»\n   ╭───────┴───────╮\n    «2» «*» «(   )»\n       ╭───────┴───────╮\n        «1» «+» «(   )»\n                 ╭─┴─╮\n                  «3»\n"],["body","\n"],["body","…and here is what it gets invoked with in the second case:"],["body","\n"],["body","« »\n │ ┌─────────────┐\n └╴│ Call        │\n   │ fn: dummy   │   ┌─────────┐\n   │ args: ◌     │╶─╴│ BinOp   │\n   └─────────────┘   │ op: Mul │\n                   ┌╴│ lhs: ◌  │\n        ┌────────┐ │ │ rhs: ◌  │╶┐ ┌─────────┐\n        │ LitInt │╶┘ └─────────┘ └╴│ BinOp   │\n        │ val: 2 │                 │ op: Add │\n        └────────┘               ┌╴│ lhs: ◌  │\n                      ┌────────┐ │ │ rhs: ◌  │╶┐ ┌────────┐\n                      │ LitInt │╶┘ └─────────┘ └╴│ LitInt │\n                      │ val: 1 │                 │ val: 3 │\n                      └────────┘                 └────────┘\n"],["body","\n"],["body","As you can see, there is exactly one token tree, which contains the AST which was parsed from the input to the capture_expr_then_stringify! invocation. Hence, what you see in the output is not the stringified tokens, it's the stringified AST node."],["body","\n"],["body","This has further implications. Consider the following:"],["body","\n"],["body","macro_rules! capture_then_match_tokens {\n    ($e:expr) => {match_tokens!($e)};\n}\n\nmacro_rules! match_tokens {\n    ($a:tt + $b:tt) => {\"got an addition\"};\n    (($i:ident)) => {\"got an identifier\"};\n    ($($other:tt)*) => {\"got something else\"};\n}\n\nfn main() {\n    println!(\"{}\\n{}\\n{}\\n\",\n        match_tokens!((caravan)),\n        match_tokens!(3 + 6),\n        match_tokens!(5));\n    println!(\"{}\\n{}\\n{}\",\n        capture_then_match_tokens!((caravan)),\n        capture_then_match_tokens!(3 + 6),\n        capture_then_match_tokens!(5));\n}\n"],["body","\n"],["body","The output is:"],["body","\n"],["body","got an identifier\ngot an addition\ngot something else\n\ngot something else\ngot something else\ngot something else\n"],["body","\n"],["body","By parsing the input into an AST node, the substituted result becomes un-destructible; i.e. you cannot examine the contents or match against it ever again."],["body","\n"],["body","Here is another example which can be particularly confusing:"],["body","\n"],["body","macro_rules! capture_then_what_is {\n    (#[$m:meta]) => {what_is!(#[$m])};\n}\n\nmacro_rules! what_is {\n    (#[no_mangle]) => {\"no_mangle attribute\"};\n    (#[inline]) => {\"inline attribute\"};\n    ($($tts:tt)*) => {concat!(\"something else (\", stringify!($($tts)*), \")\")};\n}\n\nfn main() {\n    println!(\n        \"{}\\n{}\\n{}\\n{}\",\n        what_is!(#[no_mangle]),\n        what_is!(#[inline]),\n        capture_then_what_is!(#[no_mangle]),\n        capture_then_what_is!(#[inline]),\n    );\n}\n"],["body","\n"],["body","The output is:"],["body","\n"],["body","no_mangle attribute\ninline attribute\nsomething else (# [ no_mangle ])\nsomething else (# [ inline ])\n"],["body","\n"],["body","The only way to avoid this is to capture using the tt or ident kinds. Once you capture with anything else, the only thing you can do with the result from then on is substitute it directly into the output."],["body","\n\n\n\n                    "],["body","\n\n                    \n                \n            \n\n            \n\n        \n\n\n\n\n        \n\n\n\n        \n        \n        \n\n        \n\n\n    \n    \n\n"]],[["_relative_fp","7Rust数据类型.html"],["title","Rust数据类型.md - RUST学习笔记"],["body","\n    \n        \n        \n\n        \n        \n\n        \n        \n\n        \n\n        \n        \n\n        \n\n        \n        \n\n        \n\n            \n                                \n                \n                    \n                        "],["body","\n                            \n                        "],["body","\n                        "],["body","\n                            \n                        "],["body","\n                        \n                            "],["body","Light"],["body","\n                            "],["body","Rust"],["body","\n                            "],["body","Coal"],["body","\n                            "],["body","Navy"],["body","\n                            "],["body","Ayu"],["body","\n                        \n                    \n\n                    "],["heading","RUST学习笔记"],["body","\n\n                    \n\n                    \n                \n\n\n                \n                \n\n                \n                    "],["body","\n                        \n\n"],["body","\n"],["body","\n\n"],["headingLink","usize"],["heading","Usize"],["body","\n"],["body","usize 是 Rust 中的一个内置类型，表示无符号整数的大小，其大小取决于当前平台的位数。在 32 位平台上，usize 的大小为 32 位，而在 64 位平台上，usize 的大小为 64 位。"],["body","\n"],["body","usize 类型通常用于表示索引、长度和内存地址等非负整数值。它在 Rust 中被广泛应用于数组和切片的索引、循环计数等场景。"],["body","\n"],["body","usize 类型的取值范围是从 0 到 2^N-1，其中 N 是 usize 的位数。在 32 位平台上，usize 的取值范围是 0 到 2^32-1，而在 64 位平台上，usize 的取值范围是 0 到 2^64-1。"],["body","\n"],["body","usize 类型在 Rust 中通常与 isize 类型一起使用，isize 表示有符号整数的大小，与 usize 类似，其大小也取决于当前平台的位数。"],["body","\n"],["body","总的来说，usize 是 Rust 中用于表示无符号整数大小的类型，其大小随着平台的位数而变化，在实际开发中常用于索引、长度和内存地址等场景。"],["body","\n\n\n\n                    "],["body","\n\n                    \n                \n            \n\n            \n\n        \n\n\n\n\n        \n\n\n\n        \n        \n        \n\n        \n\n\n    \n    \n\n"]],[["_relative_fp","18rust执行shell命令.html"],["title","rust执行shell命令.md - RUST学习笔记"],["body","\n    \n        \n        \n\n        \n        \n\n        \n        \n\n        \n\n        \n        \n\n        \n\n        \n        \n\n        \n\n            \n                                \n                \n                    \n                        "],["body","\n                            \n                        "],["body","\n                        "],["body","\n                            \n                        "],["body","\n                        \n                            "],["body","Light"],["body","\n                            "],["body","Rust"],["body","\n                            "],["body","Coal"],["body","\n                            "],["body","Navy"],["body","\n                            "],["body","Ayu"],["body","\n                        \n                    \n\n                    "],["heading","RUST学习笔记"],["body","\n\n                    \n\n                    \n                \n\n\n                \n                \n\n                \n                    "],["body","\n                        \n\n"],["body","\n"],["body","\n\n"],["headingLink","struct-stdprocesscommand"],["heading","Struct std::process::[Command]"],["body","\n"],["body","流程构建器，提供对应如何生成新流程的细粒度控制。"],["body","\n"],["body","可以使用Command::new(program)生成默认配置，其中"],["body","\n\n"],["body","program 给出要执行的程序的路径。"],["body","\n"],["body","其他构建器方法允许在生成之前更改配置 (例如，通过添加参数):"],["body","\n"],["body","继承当前进程的环境"],["body","\n"],["body","继承当前进程的工作目录"],["body","\n"],["body","Inherit stdin/stdout/stderr for spawn or status, but create pipes for output"],["body","\n\n"],["body","use std::process::Command;\n\nlet output = if cfg!(target_os = \"windows\") {\n    Command::new(\"cmd\")\n            .args([\"/C\", \"echo hello\"])\n            .output()\n            .expect(\"failed to execute process\")\n} else {\n    Command::new(\"sh\")\n            .arg(\"-c\")\n            .arg(\"echo hello\")\n            .output()\n            .expect(\"failed to execute process\")\n};\n\nlet hello = output.stdout;\n"],["body","\n"],["body","命令可以重复使用以产生多个进程"],["body","\n"],["body","use std::process::Command;\n\nlet mut echo_hello = Command::new(\"sh\");\necho_hello.arg(\"-c\")\n          .arg(\"echo hello\");\nlet hello_1 = echo_hello.output().expect(\"failed to execute process\");\nlet hello_2 = echo_hello.output().expect(\"failed to execute process\");\n"],["body","\n"],["body","生成进程后调用方法"],["body","\n"],["body","use std::process::Command;\n\nlet mut list_dir = Command::new(\"ls\");\n\n// Execute `ls` in the current directory of the program.\nlist_dir.status().expect(\"process failed to execute\");\n\nprintln!();\n\n// Change `ls` to execute in the root directory.\nlist_dir.current_dir(\"/\");\n\n// And then execute `ls` again but in the root directory.\nlist_dir.status().expect(\"process failed to execute\");\n"],["body","\n"],["body","use std::process::Command;\n\nCommand::new(\"sh\")\n        .spawn()\n        .expect(\"sh command failed to start\");\n"],["body","\n"],["headingLink","api"],["heading","API"],["body","\n"],["headingLink","new"],["heading","new"],["body","\n"],["body","pub fn new<S: AsRef<OsStr>>(program: S) -> Command\n"],["body","\n"],["headingLink","arg"],["heading","arg"],["body","\n"],["body",".arg(\"-C /path/to/repo\")\n\n.arg(\"-C\")\n.arg(\"/path/to/repo\")\n"],["body","\n"],["headingLink","args"],["heading","args"],["body","\n"],["body","use std::process::Command;\n\nCommand::new(\"ls\")\n        .args([\"-l\", \"-a\"])\n        .spawn()\n        .expect(\"ls command failed to start\");\n"],["body","\n"],["headingLink","env"],["heading","env"],["body","\n"],["body","插入或者更新环境变量"],["body","\n"],["body","use std::process::Command;\n\nCommand::new(\"ls\")\n        .env(\"PATH\", \"/bin\")\n        .spawn()\n        .expect(\"ls command failed to start\");\n"],["body","\n"],["headingLink","envs"],["heading","envs"],["body","\n"],["body","use std::process::{Command, Stdio};\nuse std::env;\nuse std::collections::HashMap;\n\nlet filtered_env : HashMap<String, String> =\n    env::vars().filter(|&(ref k, _)|\n        k == \"TERM\" || k == \"TZ\" || k == \"LANG\" || k == \"PATH\"\n    ).collect();\n\nCommand::new(\"printenv\")\n        .stdin(Stdio::null())\n        .stdout(Stdio::inherit())\n        .env_clear()\n        .envs(&filtered_env)\n        .spawn()\n        .expect(\"printenv failed to start\");\n"],["body","\n"],["headingLink","env_remove"],["heading","env_remove"],["body","\n"],["body","use std::process::Command;\n\nCommand::new(\"ls\")\n        .env_remove(\"PATH\")\n        .spawn()\n        .expect(\"ls command failed to start\");\n"],["body","\n"],["headingLink","env_clear"],["heading","Env_clear"],["body","\n"],["body","use std::process::Command;\n\nCommand::new(\"ls\")\n        .env_clear()\n        .spawn()\n        .expect(\"ls command failed to start\");\n"],["body","\n"],["headingLink","current_dir"],["heading","current_dir"],["body","\n"],["body","use std::process::Command;\n\nCommand::new(\"ls\")\n        .current_dir(\"/bin\")\n        .spawn()\n        .expect(\"ls command failed to start\");\n"],["body","\n"],["headingLink","stdin"],["heading","stdin"],["body","\n"],["body","子进程的标准输入 (stdin) 句柄的配置。"],["body","\n"],["body","use std::process::{Command, Stdio};\n\nCommand::new(\"ls\")\n        .stdin(Stdio::null())\n        .spawn()\n        .expect(\"ls command failed to start\");\n"],["body","\n"],["headingLink","stdout"],["heading","stdout"],["body","\n"],["body","use std::process::{Command, Stdio};\n\nCommand::new(\"ls\")\n        .stdout(Stdio::null())\n        .spawn()\n        .expect(\"ls command failed to start\");\n"],["body","\n"],["headingLink","stderr"],["heading","stderr"],["body","\n"],["body","use std::process::{Command, Stdio};\n\nCommand::new(\"ls\")\n        .stderr(Stdio::null())\n        .spawn()\n        .expect(\"ls command failed to start\");\n"],["body","\n"],["headingLink","spawn"],["heading","spawn"],["body","\n"],["body","use std::process::Command;\n\nCommand::new(\"ls\")\n        .spawn()\n        .expect(\"ls command failed to start\");\n"],["body","\n\n"],["body","\n"],["body","将命令作为子进程执行，并返回一个句柄。"],["body","\n"],["body","\n"],["body","\n"],["body","默认情况下，stdin、stdouts和stderr是从父级继承的。"],["body","\n"],["body","\n\n"],["headingLink","output"],["heading","output"],["body","\n"],["body","将命令作为子进程执行，等待它完成并收集其所有输出。"],["body","\n"],["body","默认情况下，stdot和stderr被捕获 (并用于提供结果输出)。Stdin不会从父级继承，并且子进程尝试从stdin流读取的任何尝试都会导致流立即关闭。"],["body","\n"],["body","use std::process::Command;\nuse std::io::{self, Write};\nlet output = Command::new(\"/bin/cat\")\n                     .arg(\"file.txt\")\n                     .output()\n                     .expect(\"failed to execute process\");\n\nprintln!(\"status: {}\", output.status);\nio::stdout().write_all(&output.stdout).unwrap();\nio::stderr().write_all(&output.stderr).unwrap();\n\nassert!(output.status.success());\n"],["body","\n"],["headingLink","status"],["heading","status"],["body","\n\n"],["body","作为子进程执行命令，等待它完成并收集其状态。"],["body","\n"],["body","默认情况下，stdin、stdouts和stderr是从父级继承的。"],["body","\n\n"],["body","use std::process::Command;\n\nlet status = Command::new(\"/bin/cat\")\n                     .arg(\"file.txt\")\n                     .status()\n                     .expect(\"failed to execute process\");\n\nprintln!(\"process finished with: {status}\");\n\nassert!(status.success());\n"],["body","\n"],["headingLink","get_program"],["heading","get_program"],["body","\n"],["body","返回给程序路径。"],["body","\n"],["body","use std::process::Command;\n\nlet cmd = Command::new(\"echo\");\nassert_eq!(cmd.get_program(), \"echo\");\n"],["body","\n"],["headingLink","get_args"],["heading","get_args"],["body","\n\n"],["body","返回参数迭代器"],["body","\n"],["body","这不包括程序的路径作为第一个参数; 它只包括  Command::arg  指定的参数"],["body","\n\n"],["headingLink","get_envs"],["heading","get_envs"],["body","\n\n"],["body","返回设置子进程的迭代器"],["body","\n"],["body","元素是(&OsStr, Option<&OsStr>)\n\n"],["body","其中第一个值是键，第二个值是值，"],["body","\n"],["body","如果要显式删除环境变量，则该值为None。"],["body","\n\n"],["body","\n"],["body","这仅包括使用 Command::env，Command::envs和Command::env_remove显式设置的环境变量。"],["body","\n"],["body","它不包括将由子进程继承的环境变量。"],["body","\n\n"],["headingLink","get_current_dir"],["heading","get_current_dir"],["body","\n"],["body","use std::path::Path;\nuse std::process::Command;\n\nlet mut cmd = Command::new(\"ls\");\nassert_eq!(cmd.get_current_dir(), None);\ncmd.current_dir(\"/bin\");\nassert_eq!(cmd.get_current_dir(), Some(Path::new(\"/bin\")));\n"],["body","\n"],["body","参考链接"],["body","\n\n\n\n                    "],["body","\n\n                    \n                \n            \n\n            \n\n        \n\n\n\n\n        \n\n\n\n        \n        \n        \n\n        \n\n\n    \n    \n\n"]],[["_relative_fp","14Rust中的Sizedness.html"],["title","Rust中的Sizedness.md - RUST学习笔记"],["body","\n    \n        \n        \n\n        \n        \n\n        \n        \n\n        \n\n        \n        \n\n        \n\n        \n        \n\n        \n\n            \n                                \n                \n                    \n                        "],["body","\n                            \n                        "],["body","\n                        "],["body","\n                            \n                        "],["body","\n                        \n                            "],["body","Light"],["body","\n                            "],["body","Rust"],["body","\n                            "],["body","Coal"],["body","\n                            "],["body","Navy"],["body","\n                            "],["body","Ayu"],["body","\n                        \n                    \n\n                    "],["heading","RUST学习笔记"],["body","\n\n                    \n\n                    \n                \n\n\n                \n                \n\n                \n                    "],["body","\n                        \n\n"],["body","\n"],["body","\n\n"],["headingLink","介绍"],["heading","介绍"],["body","\n"],["body","本文将会探讨 从  已知大小类型(sized type)、未知大小类型(unsized type)、在到 零大小类型(zero type)等各种类型的 sizedness，并同时对他们的优点 、缺点、痛点、以及解决方法进行评估"],["body","\n"],["body","以下是文中的术语表格"],["body","\n"],["body","术语"],["body","含义"],["body","\n"],["body","sizedness"],["body","不同大小类型的特性"],["body","\n"],["body","sized type"],["body","编译期可以确定大小的类型"],["body","\n"],["body","unsized type or DST"],["body","动态大小类型"],["body","\n"],["body","?sized type"],["body","可能确定也可能不确定的大小类型"],["body","\n"],["body","unsized coercion"],["body","从确定大小类型转换为 不确定大小类型"],["body","\n"],["body","zst"],["body","零大小类型"],["body","\n"],["body","width"],["body","指针的宽度的单位"],["body","\n"],["body","thin point|single width point"],["body","1个宽度的指针"],["body","\n"],["body","fat point | double-width point"],["body","2个宽度的指针"],["body","\n"],["body","slice"],["body","数据的动态大小视图"],["body","\n\n\n"],["headingLink","sizedness"],["heading","Sizedness"],["body","\n\n"],["body","如果一个类型 的大小能在编译期确定，也称作 sizedType,那确定类型大小的类型就能在 栈上分配空间。数据的传递也就能通过 值传递或者引用传递的方式"],["body","\n"],["body","如果一个类型的大小不能在编译期确定，也叫作，dst、动态类型大小。无法在栈上分配空间。数据的传递只能通过引用传递"],["body","\n\n"],["body","以下是一些 sized type或者 unsized type"],["body","\n\n"],["body","基本类型"],["body","\n"],["body","元祖类型"],["body","\n"],["body","结构体类型"],["body","\n"],["body","数组类型：固定数组类型、不固定数组类型"],["body","\n"],["body","枚举类型"],["body","\n"],["body","普通指针、字符串指针、数组指针"],["body","\n"],["body","trait类型"],["body","\n"],["body","自定义 unsized类型"],["body","\n\n"],["body","use std::mem::size_of;\n\nfn main() {\n    // primitives\n    assert_eq!(4, size_of::<i32>());\n    assert_eq!(8, size_of::<f64>());\n\n    // tuples\n    assert_eq!(8, size_of::<(i32, i32)>());\n\n    // arrays\n    assert_eq!(0, size_of::<[i32; 0]>());\n    assert_eq!(12, size_of::<[i32; 3]>());\n\n    struct Point {\n        x: i32,\n        y: i32,\n    }\n\n    // structs\n    assert_eq!(8, size_of::<Point>());\n\n    // enums\n    assert_eq!(8, size_of::<Option<i32>>());\n\n    // get pointer width, will be\n    // 4 bytes wide on 32-bit targets or\n    // 8 bytes wide on 64-bit targets\n    const WIDTH: usize = size_of::<&()>();\n\n    // pointers to sized types are 1 width\n    assert_eq!(WIDTH, size_of::<&i32>());\n    assert_eq!(WIDTH, size_of::<&mut i32>());\n    assert_eq!(WIDTH, size_of::<Box<i32>>());\n    assert_eq!(WIDTH, size_of::<fn(i32) -> i32>());\n\n    const DOUBLE_WIDTH: usize = 2 * WIDTH;\n\n    // unsized struct\n    struct Unsized {\n        unsized_field: [i32],\n    }\n\n    // pointers to unsized types are 2 widths\n    assert_eq!(DOUBLE_WIDTH, size_of::<&str>()); // slice\n    assert_eq!(DOUBLE_WIDTH, size_of::<&[i32]>()); // slice\n    assert_eq!(DOUBLE_WIDTH, size_of::<&dyn ToString>()); // trait object\n    assert_eq!(DOUBLE_WIDTH, size_of::<Box<dyn ToString>>()); // trait object\n    assert_eq!(DOUBLE_WIDTH, size_of::<&Unsized>()); // user-defined unsized type\n\n    // unsized types\n    size_of::<str>(); // compile error\n    size_of::<[i32]>(); // compile error\n    size_of::<dyn ToString>(); // compile error\n    size_of::<Unsized>(); // compile error\n}"],["body","\n"],["headingLink","protips"],["heading","proTIPS"],["body","\n\n"],["body","rust中 指向数组的动态大小视图 dynamic sized view 被称为 切片（slice）,&str是字符串切片、&[i32] 是数组切片"],["body","\n"],["body","切片是双宽度的、因为它们存储了 指向 数组的 指针 和 数组中元素的个数"],["body","\n"],["body","trait对象是 双宽度的，因为它们 存储了 指向 数据的指针 和 指向  vnode的指针"],["body","\n"],["body","不确定大小的结构体是 双宽的。因为 它拥有 指针指向 结构体的指针 和 结构体大小的size"],["body","\n"],["body","不确定大小的结构体 只能拥有 一个 不确定大小的 字段 且 只能是 结构体最后一个字段"],["body","\n\n"],["body","总结"],["body","\n\n"],["body","确定大小的 类型可以 分配在 栈上。可以通过值传递"],["body","\n"],["body","不确定大小的类型不能分配在栈上，且必须通过 引用传递"],["body","\n"],["body","不确定大小的类型是双宽度的，除了要记录 指针位置外，还需要记录 数据量大小、或者 vnodetable等"],["body","\n\n"],["headingLink","trait对象trait-objects"],["heading","Trait对象(Trait Objects)"],["body","\n"],["body","Traits默认是?Sized。"],["body","\n"],["body","#![allow(unused)]\nfn main() {\ntrait Trait: ?Sized {}\n\n\ntrait Trait where Self: ?Sized {}\n}"],["body","\n\n"],["body","\n"],["body","默认情况下，trait允许self可能是一个不确定大小类型(unsized type)"],["body","\n"],["body","\n"],["body","\n"],["body","不确定大小类型无法 通过 值传递，所以没法以传值的方式 接收 或返回 self "],["body","\n"],["body","\n"],["body","\n"],["body","但是是 可以编译，如果一旦为这个方法 提供默认的实现，或者实现其他的 都会编译错误"],["body","\n"],["body","\n"],["body","\n"],["body","可以通过 引用传递方式 传递 self"],["body","\n"],["body","#![allow(unused)]\nfn main() {\ntrait Trait {\n    fn method(&self) {} // compiles\n}\n\nimpl Trait for str {\n    fn method(&self) {} // compiles\n}\n}"],["body","\n"],["body","\n"],["body","\n"],["body","可以有更细粒度和更精确的选择 来标记 单个方法 为 Sized"],["body","\n"],["body","trait Trait {\n    fn method(self) where Self: Sized {}\n}\n\nimpl Trait for str {} // compiles!?\n\nfn main() {\n    \"str\".method(); // compile error\n}"],["body","\n"],["body","\n\n"],["headingLink","trait对象的限制trait-object-limitations"],["heading","Trait对象的限制(Trait Object Limitations)"],["body","\n"],["body","即使一个trait是对象安全的，仍然存在sizeness相关的边界情况，这些情况限制了什么类型可以转成trait对象以及多少种trait和什么样的trait可以通过一个trait对象来表示。"],["body","\n"],["headingLink","不能把不确定大小类型unsized-type转成trait对象"],["heading","不能把不确定大小类型(unsized type)转成trait对象"],["body","\n"],["body","类型"],["body","指向数据的指针"],["body","数据长度"],["body","指向Vtable的指针"],["body","总长度"],["body","\n"],["body","&String"],["body","有"],["body","没有"],["body","没有"],["body","1w"],["body","\n"],["body","&str"],["body","有"],["body","有"],["body","没有"],["body","2w"],["body","\n"],["body","&String as & dyn ToString"],["body","有"],["body","没有"],["body","有"],["body","2w"],["body","\n"],["body","&str as & &dyn ToString"],["body","有"],["body","有"],["body","有"],["body","3w"],["body","\n\n\n"],["headingLink","不能创建多trait的对象cannot-create-multi-trait-objects"],["heading","不能创建多Trait的对象(Cannot create Multi-Trait Objects)"],["body","\n"],["body","#![allow(unused)]\nfn main() {\ntrait Trait {}\ntrait Trait2 {}\n\nfn function(t: &(dyn Trait + Trait2)) {}\n}"],["body","\n\n"],["body","一个trait对象指针是双宽度的:存储一个指向数据的指针、和指向vttable的指针"],["body","\n"],["body","这里有 两个 Trait 就存在 指向 两个vtable的 指针  &(dyn Trait+Trait2) 就是三宽度 ，rust最多支持 两个宽度的指针"],["body","\n"],["body","像 Sync 与 Send 这样的 Trait不存在 方法，所以可以有多个"],["body","\n"],["body","解决办法是，借助第三个 Trait实现 上述 两个 Trait,但是也会存在 无法自动向上转型"],["body","\n\n"],["body","trait Trait {\n    fn method(&self) {}\n}\n\ntrait Trait2 {\n    fn method2(&self) {}\n}\n\ntrait Trait3: Trait + Trait2 {}\n\nimpl<T: Trait + Trait2> Trait3 for T {}\n\nstruct Struct;\nimpl Trait for Struct {}\nimpl Trait2 for Struct {}\n\nfn takes_trait(t: &dyn Trait) {}\nfn takes_trait2(t: &dyn Trait2) {}\n\nfn main() {\n    let t: &dyn Trait3 = &Struct;\n    takes_trait(t); // compile error\n    takes_trait2(t); // compile error\n}"],["body","\n\n"],["body","无法自动向上转型：只能显示向上转型"],["body","\n\n"],["body","trait Trait {}\ntrait Trait2 {}\n\ntrait Trait3: Trait + Trait2 {\n    fn as_trait(&self) -> &dyn Trait;\n    fn as_trait2(&self) -> &dyn Trait2;\n}\n\nimpl<T: Trait + Trait2> Trait3 for T {\n    fn as_trait(&self) -> &dyn Trait {\n        self\n    }\n    fn as_trait2(&self) -> &dyn Trait2 {\n        self\n    }\n}\n\nstruct Struct;\nimpl Trait for Struct {}\nimpl Trait2 for Struct {}\n\nfn takes_trait(t: &dyn Trait) {}\nfn takes_trait2(t: &dyn Trait2) {}\n\nfn main() {\n    let t: &dyn Trait3 = &Struct;\n    takes_trait(t.as_trait()); // compiles\n    takes_trait2(t.as_trait2()); // compiles\n}"],["body","\n"],["headingLink","关键点key-takeaway"],["heading","关键点(Key Takeaway)"],["body","\n\n"],["body","Rust不支持超过2个宽度的指针，所以"],["body","\n"],["body","我们不能够把不确定大小类型(unsized type)转换为trait对象"],["body","\n"],["body","我们不能有多trait对象，但是我们可以通过把多个trait合并到一个trait里来解决"],["body","\n\n"],["headingLink","用户定义的不确定大小类型"],["heading","用户定义的不确定大小类型"],["body","\n"],["body","#![allow(unused)]\nfn main() {\nstruct Unsized {\n  unsized_field: [i32],\n}\n}"],["body","\n\n"],["body","可以给结构体 定义一个不确定大小的字段 来定义一个不确定大小的类型"],["body","\n"],["body","不确定大小的结构体 只能有一个不确定大小字段"],["body","\n"],["body","使用一个双宽度 最多只能 追踪 一个 不确定大小字段"],["body","\n\n"],["body","如何实例化该 不确定大小类型："],["body","\n\n"],["body","\n"],["body","尽管如此，根据定义，Unsized总是不确定大小的，没有办法构造一个它的确定性大小版本。"],["body","\n"],["body","\n"],["body","\n"],["body","唯一的解决方法是把这个结构体变成泛型(generic)的，这样它就可以存在于确定性大小和不确定性大小的版本里。"],["body","\n"],["body","\n"],["body","\n"],["body","申明一个该 确定 大小类型 "],["body","\n"],["body","\n"],["body","\n"],["body","然后将其转化为 不确定大小类型"],["body","\n"],["body","\n\n"],["body","struct MaybeSized<T: ?Sized> {\n    maybe_sized: T,\n}\n\nfn main() {\n    // unsized coercion from MaybeSized<[i32; 3]> to MaybeSized<[i32]>\n    let ms: &MaybeSized<[i32]> = &MaybeSized { maybe_sized: [1, 2, 3] };\n}"],["body","\n\n"],["body","用户 定义 不确定大小的类型，目前没有什么使用场景，是一个不成熟的特性"],["body","\n"],["body","std::ffi::OsStr和std::path::Path是标准库里的两个不确定大小结构体"],["body","\n\n"],["headingLink","零大小类型zero-sized-types"],["heading","零大小类型(Zero-Sized Types)"],["body","\n"],["headingLink","单元类型unit-type"],["heading","单元类型(Unit Type)"],["body","\n"],["body","最常见的ZST 是单元类型，也见空元祖"],["body","\n\n"],["body","\n"],["body","所空块 {} 的计算结果为 () "],["body","\n"],["body","\n"],["body","\n"],["body","所有以 分号结尾的 也返回 ()"],["body","\n"],["body","\n"],["body","\n"],["body","没有明确返回类型的 也 返回 ()"],["body","\n"],["body","\n"],["body","\n"],["body","所有 ()都相等"],["body","\n"],["body","\n"],["body","\n"],["body","单元类型的 标准Trait实现"],["body","\n"],["body","#![allow(unused)]\nfn main() {\nuse std::cmp::Ordering;\n\nimpl Default for () {\n    fn default() {}\n}\n\nimpl PartialEq for () {\n    fn eq(&self, _other: &()) -> bool {\n        true\n    }\n    fn ne(&self, _other: &()) -> bool {\n        false\n    }\n}\n\nimpl Ord for () {\n    fn cmp(&self, _other: &()) -> Ordering {\n        Ordering::Equal\n    }\n}\n}"],["body","\n"],["body","\n"],["body","\n"],["body","编译器理解()是零大小类型并且会优化和()实例有关的交互。例如:一个Vec<()>永远不会执行堆分配，从Vec里推进(push)和弹出(pop)()只是对它里面的len字段进行增加或减少。"],["body","\n"],["body","\n\n"],["headingLink","用户定义的单元结构体user-defined-unit-structs"],["heading","用户定义的单元结构体(User-Defined Unit Structs)"],["body","\n"],["body","#![allow(unused)]\nfn main() {\nstruct Struct;\n}"],["body","\n"],["body","单元结构比()更有用的一些属性:"],["body","\n\n"],["body","可以为单元结构体实现 trait，而 空元祖 由于 孤儿规则 阻止"],["body","\n"],["body","单元结构体 可以赋予更有意义的名字"],["body","\n"],["body","单元结构体 默认是非 copy类型的"],["body","\n\n"],["headingLink","never-type"],["heading","Never Type"],["body","\n"],["body","！：它被叫做never类型是因为它表示永远不会产生任何值的计算。"],["body","\n"],["body","never类型不同于 () 它有一些有趣的属性"],["body","\n\n"],["body","! 可以被强制转化到任意类型"],["body","\n"],["body","无法创建 ！ 类型的实例"],["body","\n\n"],["body","#![allow(unused)]\nfn main() {\n// nice for quick prototyping\nfn example<T>(t: &[T]) -> Vec<T> {\n    unimplemented!() // ! coerced to Vec<T>\n}\n\nfn example2() -> i32 {\n    // we know this parse call will never fail\n    match \"123\".parse::<i32>() {\n        Some(num) => num,\n        None => unreachable!(), // ! coerced to i32\n    }\n}\n\nfn example3(bool: someCondition) -> &'static str {\n    if (!someCondition) {\n        panic!() // ! coerced to &str\n    } else {\n        \"str\"\n    }\n}\n}"],["body","\n"],["body","break，continue，和return表达式也有!类型："],["body","\n"],["body","#![allow(unused)]\nfn main() {\nfn example() -> i32 {\n    // we can set the type of x to anything here\n    // since the block never evaluates to any value\n    let x: String = {\n        return 123 // ! coerced to String\n    };\n}\n\nfn example2(nums: &[i32]) -> Vec<i32> {\n    let mut filtered = Vec::new();\n    for num in nums {\n        filtered.push(\n            if *num < 0 {\n                break // ! coerced to i32\n            } else if *num % 2 == 0 {\n                *num\n            } else {\n                continue // ! coerced to i32\n            }\n        );\n    }\n    filtered\n}\n}"],["body","\n"],["body","!的第二个有趣的属性让我们能够让我们在类型级别把特定的状态标记为不可能。让我们看看下面的函数:"],["body","\n"],["body","#![allow(unused)]\nfn main() {\nfn function() -> Result<Success, Error>;\n}"],["body","\n"],["body","#![allow(unused)]\nfn main() {\n//永远也不会失败\nfn function() -> Result<Success, !>;\n//永远也不会成功\nfn function() -> Result<!, Error>;\n}"],["body","\n"],["body","keypoint"],["body","\n\n"],["body","!可以被强制转到到任何其他的类型"],["body","\n"],["body","无法创建!的实例，我们可以使用这一点在类型级别把一个状态标记为不可能的"],["body","\n\n"],["headingLink","用户定义的伪never类型user-defined-pseudo-never-types"],["heading","用户定义的伪Never类型(User-Defined Pseudo Never Types)"],["body","\n"],["body","尽管定义一个能够强制转换到任意其他类型的类型是不可能的"],["body","\n"],["body","但是定义一个无法创建实例的类型是有可能的，例如一个没有任何variant的enum:"],["body","\n"],["body","#![allow(unused)]\nfn main() {\nenum Void {}\n}"],["body","\n"],["body","#![allow(unused)]\nfn main() {\nenum Void {}\n\n// example 1\nimpl FromStr for String {\n    type Err = Void;\n    fn from_str(s: &str) -> Result<String, Self::Err> {\n        Ok(String::from(s))\n    }\n}\n\n// example 2\nfn run_server() -> Result<Void, ConnectionError> {\n    loop {\n        let (request, response) = get_request()?;\n        let result = request.process();\n        response.send(result);\n    }\n}\n}"],["body","\n"],["body","这是Rust标准库里使用的技术，因为String的FromStr实现里的Err类型是std::convert::Infallible， 其定义如下:"],["body","\n"],["body","#![allow(unused)]\nfn main() {\npub enum Infallible {}\n}"],["body","\n"],["headingLink","phantomdata"],["heading","PhantomData"],["body","\n"],["body","PhantomData是一个零大小标记结构体"],["body","\n"],["body","如果不想实现 Send Sync 这项的自动 trait 要么使用 feature 的 !  功能"],["body","\n"],["body","#![allow(unused)]\n#![feature(negative_impls)]\n\nfn main() {\n// this type is Send and Sync\nstruct Struct;\n\n// opt-out of Send trait\nimpl !Send for Struct {}\n\n// opt-out of Sync trait\nimpl !Sync for Struct {}\n}"],["body","\n"],["body","要么增加一个成员变量：是非 send或 sync的"],["body","\n"],["body","#![allow(unused)]\nfn main() {\nuse std::rc::Rc;\n\n// this type is not Send or Sync\nstruct Struct {\n    // adds 8 bytes to every instance\n    _not_send_or_sync: Rc<()>,\n}\n}"],["body","\n"],["body","但是这增加了 trait的大小"],["body","\n"],["body","针对上述的场景，可以使用 PhantomData"],["body","\n"],["body","#![allow(unused)]\nfn main() {\nuse std::rc::Rc;\nuse std::marker::PhantomData;\n\ntype NotSendOrSyncPhantom = PhantomData<Rc<()>>;\n\n// this type is not Send or Sync\nstruct Struct {\n    // adds no additional size to instances\n    _not_send_or_sync: NotSendOrSyncPhantom,\n}\n}"],["body","\n"],["body","关键点(Key Takeaway)"],["body","\n\n"],["body","PhantomData是一个零大小标记结构体，可以用于标记一个包含结构体为拥有特定的属性"],["body","\n\n"],["headingLink","总结conclusion"],["heading","总结(Conclusion)"],["body","\n\n"],["body","只有确定大小类型(sized type)的实例才可以放到栈上，也就是，可以通过传值的方式传递"],["body","\n"],["body","不确定大小类型(unsized tpe)的实例不能放到栈上而且必须通过传引用的方式传递"],["body","\n"],["body","指向不确定大小类型(unsized tpe)的指针是双宽度的，因为除了保存指向数据的指针外，还需要额外的比特位来追踪数据的长度或者指向一个vtable"],["body","\n"],["body","Sized是一个\"自动(auto)\"标记trait"],["body","\n"],["body","所有的泛型类型参数默认是被Sized自动约束"],["body","\n"],["body","如果我们有一个泛型函数，它接收隐于指针后的类型T为参数，例如&T，Box<T>，Rc<T>等，那么我们总是选择退出默认的Sized约束而选用T:?Sized约束"],["body","\n"],["body","利用切片和Rust的自动类型强制转换能够让我们写出灵活的API"],["body","\n"],["body","所有的trait默认都是?Sized"],["body","\n"],["body","对于impl Trait for dyn Trait，要求Trait: ?Sized"],["body","\n"],["body","我们可以在每个方法上要求Self:Sized"],["body","\n"],["body","由Sized约束的trait不能转为trait对象"],["body","\n"],["body","Rust不支持超过2个宽度的指针，因此"],["body","\n"],["body","我们不能把不确定大小类型转为trait对象"],["body","\n"],["body","我们不能有多trait对象，但是我们可以通过把多个trait合并到一个trait里来解决这个问题"],["body","\n"],["body","用户定义的不确定类型大小类型是个不成熟的特性，现在其局限性超过所能带来的益处"],["body","\n"],["body","ZST的所有实例都相等"],["body","\n"],["body","Rust编译器会去优化和ZST相关的交互"],["body","\n"],["body","!可以被强制转换为其他类型"],["body","\n"],["body","无法创建一个!的实例，我们可以利用这一点在类型级别把特定状态标记为不可能"],["body","\n"],["body","PhantomData是一个零大小标记结构体，可以用于把一个包含结构体标记为含有特定属性"],["body","\n\n"],["body","原文链接"],["body","\n"],["headingLink","rust-dyn-关键字"],["heading","Rust-dyn 关键字"],["body","\n"],["body","dyn是trait对象类型的前缀"],["body","\n"],["body","dyn关键字用于强调相关trait的方法是动态分配的。要以这种方式使用trait，它必须是“对象安全”的。"],["body","\n"],["body","与泛型参数或植入型特质不同，编译器不知道被传递的具体类型。也就是说，该类型已经被抹去"],["body","\n"],["body","因此，一个dyn Trait引用包含两个指针"],["body","\n"],["body","一个指针指向数据（例如，一个结构的实例）"],["body","\n"],["body","另一个指针指向方法调用名称与函数指针的映射（被称为虚拟方法表各vtable）"],["body","\n"],["body","impl trait 和 dyn trait 在Rust分别被称为静态分发和动态分发，即当代码涉及多态时，需要某种机制决定实际调动类型。"],["body","\n"],["body","每当在堆上分配内存时，Rust都会尝试尽可能明确。因此，如果你的函数以这种方式返回指向堆的trait指针，则需要使用dyn关键字编写返回类型，如示例2:"],["body","\n"],["body","#![allow(unused)]\nfn main() {\nfn random_animal(random_number: f64) -> Box<dyn Animal> {\n    if random_number < 0.5 {\n        Box::new(Sheep {})\n    } else {\n        Box::new(Cow {})\n    }\n}\n}"],["body","\n\n\n\n                    "],["body","\n\n                    \n                \n            \n\n            \n\n        \n\n\n\n\n        \n\n\n\n        \n        \n        \n\n        \n\n\n    \n    \n\n"]],[["_relative_fp","13newType模式.html"],["title","newType模式.md - RUST学习笔记"],["body","\n    \n        \n        \n\n        \n        \n\n        \n        \n\n        \n\n        \n        \n\n        \n\n        \n        \n\n        \n\n            \n                                \n                \n                    \n                        "],["body","\n                            \n                        "],["body","\n                        "],["body","\n                            \n                        "],["body","\n                        \n                            "],["body","Light"],["body","\n                            "],["body","Rust"],["body","\n                            "],["body","Coal"],["body","\n                            "],["body","Navy"],["body","\n                            "],["body","Ayu"],["body","\n                        \n                    \n\n                    "],["heading","RUST学习笔记"],["body","\n\n                    \n\n                    \n                \n\n\n                \n                \n\n                \n                    "],["body","\n                        \n\n"],["body","\n"],["body","\n\n"],["headingLink","为了类型安全和抽象而使用-newtype-模式"],["heading","为了类型安全和抽象而使用 newtype 模式"],["body","\n"],["headingLink","newtype的功能"],["heading","newType的功能"],["body","\n\n"],["body","\n"],["body","使用newType替代 基本类型 可以确保某值不被混淆或者用来表示一个值的单元"],["body","\n"],["body","\n"],["body","\n"],["body","抽象掉一些类型的实现细节"],["body","\n\n"],["body","封装类型可以暴露出与直接使用其内部私有类型时所不同的公有 API，以便限制其功能。"],["body","\n"],["body","newtype 也可以隐藏其内部的泛型类型。"],["body","\n\n"],["body","例如，可以提供一个封装了 HashMap<i32, String> 的 People 类型，用来储存人名以及相应的 ID。使用 People 的代码只需与提供的公有 API 交互即可，比如向 People 集合增加名字字符串的方法，这样这些代码就无需知道在内部我们将一个 i32 ID 赋予了这个名字了。newtype 模式是一种实现第十七章 “封装隐藏了实现细节” 部分所讨论的隐藏实现细节的封装的轻量级方法。"],["body","\n"],["body","\n\n"],["headingLink","类型别名"],["heading","类型别名"],["body","\n"],["headingLink","什么是类型别名"],["heading","什么是类型别名"],["body","\n"],["body","连同 newtype 模式，Rust 还提供了声明 类型别名（type alias）的能力，使用 type 关键字来给予现有类型另一个名字。例如，可以像这样创建 i32 的别名 Kilometers："],["body","\n"],["body","#![allow(unused)]\nfn main() {\ntype Kilometers = i32;\n}"],["body","\n"],["body","这意味着 Kilometers 是 i32 的 同义词（synonym）；不同于示例 19-23 中创建的 Millimeters 和 Meters 类型。Kilometers 不是一个新的、单独的类型。Kilometers 类型的值将被完全当作 i32 类型值来对待："],["body","\n"],["headingLink","类型别名的使用"],["heading","类型别名的使用"],["body","\n"],["body","类型别名的主要用途是减少重复。例如，可能会有这样很长的类型："],["body","\n"],["body","#![allow(unused)]\nfn main() {\nlet f: Box<dyn Fn() + Send + 'static> = Box::new(|| println!(\"hi\"));\n\nfn takes_long_type(f: Box<dyn Fn() + Send + 'static>) {\n    // --snip--\n}\n\nfn returns_long_type() -> Box<dyn Fn() + Send + 'static> {\n    // --snip--\n}\n\n//使用类型别名\ntype Thunk = Box<dyn Fn() + Send + 'static>;\n\nlet f: Thunk = Box::new(|| println!(\"hi\"));\n\nfn takes_long_type(f: Thunk) {\n    // --snip--\n}\n\nfn returns_long_type() -> Thunk {\n    // --snip--\n}\n}"],["body","\n"],["headingLink","泛型化类型别名"],["heading","泛型化类型别名"],["body","\n"],["body","#![allow(unused)]\nfn main() {\ntype Result<T> = std::result::Result<T, std::io::Error>;\n}"],["body","\n"],["headingLink","从不返回的-never-type"],["heading","从不返回的 never type"],["body","\n\n"],["body","\n"],["body","Rust 有一个叫做 ! 的特殊类型。在类型理论术语中，它被称为 empty type，因为它没有值。我们更倾向于称之为 never type。"],["body","\n"],["body","\n"],["body","\n"],["body","从不返回的函数被称为 发散函数（diverging functions）"],["body","\n"],["body","\n\n"],["headingLink","continue返回-"],["heading","Continue返回 !"],["body","\n"],["body","#![allow(unused)]\nfn main() {\nlet guess: u32 = match guess.trim().parse() {\n    Ok(num) => num,\n    Err(_) => continue,\n};\n}"],["body","\n"],["headingLink","panic返回"],["heading","Panic返回!"],["body","\n"],["body","#![allow(unused)]\nfn main() {\nimpl<T> Option<T> {\n    pub fn unwrap(self) -> T {\n        match self {\n            Some(val) => val,\n            None => panic!(\"called `Option::unwrap()` on a `None` value\"),\n        }\n    }\n}\n}"],["body","\n"],["headingLink","loop返回"],["heading","Loop返回!"],["body","\n"],["body","#![allow(unused)]\nfn main() {\nprint!(\"forever \");\n\nloop {\n    print!(\"and ever \");\n}\n}"],["body","\n"],["headingLink","动态大小类型和-sized-trait"],["heading","动态大小类型和 Sized trait"],["body","\n"],["body","因为 Rust 需要知道例如应该为特定类型的值分配多少空间这样的信息其类型系统的一个特定的角落可能令人迷惑：这就是 动态大小类型（dynamically sized types）的概念。这有时被称为 “DST” 或 “unsized types”，这些类型允许我们处理只有在运行时才知道大小的类型。"],["body","\n"],["body","让我们深入研究一个贯穿本书都在使用的动态大小类型的细节：str。没错，不是 &str，而是 str 本身。str 是一个 DST；直到运行时我们都不知道字符串有多长。因为直到运行时都不能知道大其小，也就意味着不能创建 str 类型的变量，也不能获取 str 类型的参数。考虑一下这些代码，他们不能工作："],["body","\n"],["body","#![allow(unused)]\nfn main() {\nlet s1: str = \"Hello there!\";\nlet s2: str = \"How's it going?\";\n}"],["body","\n"],["body","Rust 需要知道应该为特定类型的值分配多少内存，同时所有同一类型的值必须使用相同数量的内存。如果允许编写这样的代码，也就意味着这两个 str 需要占用完全相同大小的空间，不过它们有着不同的长度。这也就是为什么不可能创建一个存放动态大小类型的变量的原因。"],["body","\n"],["body","那么该怎么办呢？你已经知道了这种问题的答案：s1 和 s2 的类型是 &str 而不是 str。如果你回想第四章 “字符串 slice” 部分，slice 数据结储存了开始位置和 slice 的长度。"],["body","\n"],["body","所以虽然 &T 是一个储存了 T 所在的内存位置的单个值，&str 则是 两个 值：str 的地址和其长度。这样，&str 就有了一个在编译时可以知道的大小：它是 usize 长度的两倍。也就是说，我们总是知道 &str 的大小，而无论其引用的字符串是多长。这里是 Rust 中动态大小类型的常规用法：他们有一些额外的元信息来储存动态信息的大小。这引出了动态大小类型的黄金规则：必须将动态大小类型的值置于某种指针之后。"],["body","\n"],["body","可以将 str 与所有类型的指针结合：比如 Box<str> 或 Rc<str>。事实上，之前我们已经见过了，不过是另一个动态大小类型：trait。每一个 trait 都是一个可以通过 trait 名称来引用的动态大小类型。在第十七章 “为使用不同类型的值而设计的 trait 对象” 部分，我们提到了为了将 trait 用于 trait 对象，必须将他们放入指针之后，比如 &dyn Trait 或 Box<dyn Trait>（Rc<dyn Trait> 也可以）。"],["body","\n"],["body","为了处理 DST，Rust 有一个特定的 trait 来决定一个类型的大小是否在编译时可知：这就是 Sized trait。这个 trait 自动为编译器在编译时就知道大小的类型实现。另外，Rust 隐式的为每一个泛型函数增加了 Sized bound。也就是说，对于如下泛型函数定义："],["body","\n"],["body","#![allow(unused)]\nfn main() {\nfn generic<T>(t: T) {\n    // --snip--\n}\n}"],["body","\n"],["body","实际上被当作如下处理："],["body","\n"],["body","#![allow(unused)]\nfn main() {\nfn generic<T: Sized>(t: T) {\n    // --snip--\n}\n}"],["body","\n"],["body","泛型函数默认只能用于在编译时已知大小的类型。然而可以使用如下特殊语法来放宽这个限制："],["body","\n"],["body","#![allow(unused)]\nfn main() {\nfn generic<T: ?Sized>(t: &T) {\n    // --snip--\n}\n}"],["body","\n"],["body","?Sized trait bound 与 Sized 相对；也就是说，它可以读作 “T 可能是也可能不是 Sized 的”。这个语法只能用于 Sized ，而不能用于其他 trait。"],["body","\n"],["body","另外注意我们将 t 参数的类型从 T 变为了 &T：因为其类型可能不是 Sized 的，所以需要将其置于某种指针之后。在这个例子中选择了引用。"],["body","\n"],["body","例如"],["body","\n"],["body","闭包的存储空间是动态的"],["body","\n"],["body","通过指定包装返回闭包"],["body","\n"],["body","#![allow(unused)]\nfn main() {\nfn returns_closure() -> Box<dyn Fn(i32) -> i32> {\n    Box::new(|x| x + 1)\n}\n}"],["body","\n\n\n\n                    "],["body","\n\n                    \n                \n            \n\n            \n\n        \n\n\n\n\n        \n\n\n\n        \n        \n        \n\n        \n\n\n    \n    \n\n"]],[["_relative_fp","index.html"],["title","rust指针.md - RUST学习笔记"],["body","\n    \n        \n        \n\n        \n        \n\n        \n        \n\n        \n\n        \n        \n\n        \n\n        \n        \n\n        \n\n            \n                                \n                \n                    \n                        "],["body","\n                            \n                        "],["body","\n                        "],["body","\n                            \n                        "],["body","\n                        \n                            "],["body","Light"],["body","\n                            "],["body","Rust"],["body","\n                            "],["body","Coal"],["body","\n                            "],["body","Navy"],["body","\n                            "],["body","Ayu"],["body","\n                        \n                    \n\n                    "],["heading","RUST学习笔记"],["body","\n\n                    \n\n                    \n                \n\n\n                \n                \n\n                \n                    "],["body","\n                        \n\n"],["body","\n"],["body","\n\n"],["headingLink","智能指针简介"],["heading","智能指针简介"],["body","\n\n"],["body","\n"],["body","指针 （pointer）是一个包含内存地址的变量"],["body","\n"],["body","\n"],["body","\n"],["body","这个地址 \"引用\"，或  “指向”（points at）一些其他数据"],["body","\n"],["body","\n"],["body","\n"],["body","Rust 中最常见的指针是 引用（reference）引用以 & 符号为标志并借用了他们所指向的值"],["body","\n"],["body","\n"],["body","\n"],["body","除了引用数据没有任何其他特殊功能。它们也没有任何额外开销，所以应用得最多。"],["body","\n"],["body","\n"],["body","\n"],["body","智能指针（smart pointers）是一类数据结构，他们的表现类似指针，但是拥有额外的元数据和功能"],["body","\n"],["body","\n"],["body","\n"],["body","智能指针的概念并不为 Rust 所独有；其起源于 C++ 并存在于其他语言中"],["body","\n"],["body","\n"],["body","\n"],["body","Rust 标准库中不同的智能指针提供了多于引用的额外功能"],["body","\n"],["body","\n"],["body","\n"],["body","在 Rust 中，普通引用和智能指针的一个额外的区别是  引用是一类只借用数据的指针,智能指针 拥有 他们指向的数据。"],["body","\n"],["body","\n"],["body","\n"],["body","实际上本书中已经出现过一些智能指针，比如第八章的 String 和 Vec<T>，虽然当时我们并不这么称呼它们。这些类型都属于智能指针因为它们拥有一些数据并允许你修改它们"],["body","\n"],["body","\n"],["body","\n"],["body","它们也带有元数据（比如他们的容量）和额外的功能或保证（String 的数据总是有效的 UTF-8 编码）。"],["body","\n"],["body","\n"],["body","\n"],["body","智能指针通常使用结构体实现。智能指针区别于常规结构体的显著特性在于其实现了 Deref 和 Drop trait"],["body","\n"],["body","\n"],["body","\n"],["body","Deref trait 允许智能指针结构体实例表现的像引用一样，这样就可以编写既用于引用、又用于智能指针的代码"],["body","\n"],["body","\n"],["body","\n"],["body","Drop trait 允许我们自定义当智能指针离开作用域时运行的代码。本章会讨论这些 trait 以及为什么对于智能指针来说他们很重要。"],["body","\n"],["body","\n"],["body","\n"],["body","常见的智能指针"],["body","\n"],["body","\n\n\n"],["body","Box<T>，用于在堆上分配值"],["body","\n"],["body","Rc<T>，一个引用计数类型，其数据可以有多个所有者"],["body","\n"],["body","Ref<T> 和 RefMut<T>，通过 RefCell<T> 访问。（ RefCell<T> 是一个在运行时而不是在编译时执行借用规则的类型）。"],["body","\n\n\n"],["body","另外我们会涉及 内部可变性（interior mutability）模式，这是不可变类型暴露出改变其内部值的 API"],["body","\n"],["body","引用循环（reference cycles）会如何泄漏内存，以及如何避免。"],["body","\n\n"],["headingLink","最简单的智能指针boxt"],["heading","最简单的智能指针：Box<T>"],["body","\n"],["headingLink","简介"],["heading","简介"],["body","\n\n"],["body","\n"],["body","最简单直接的智能指针是 box，其类型是 Box<T>"],["body","\n"],["body","\n"],["body","\n"],["body","box 允许你将一个值放在堆上而不是栈上。"],["body","\n"],["body","\n"],["body","\n"],["body","留在栈上的则是指向堆数据的指针"],["body","\n"],["body","\n\n"],["body","除了数据被储存在堆上而不是栈上之外，box 没有性能损失。不过也没有很多额外的功能。它们多用于如下场景："],["body","\n\n"],["body","\n"],["body","当有一个在编译时未知大小的类型，而又想要在需要确切大小的上下文中使用这个类型值的时候"],["body","\n"],["body","box 允许创建递归类型"],["body","\n"],["body","\n"],["body","\n"],["body","当有大量数据并希望在确保数据不被拷贝的情况下转移所有权的时候"],["body","\n"],["body","转移大量数据的所有权可能会花费很长的时间，因为数据在栈上进行了拷贝。为了改善这种情况下的性能，可以通过 box 将这些数据储存在堆上。接着，只有少量的指针数据在栈上被拷贝"],["body","\n"],["body","\n"],["body","\n"],["body","当希望拥有一个值并只关心它的类型是否实现了特定 trait 而不是其具体类型的时候"],["body","\n"],["body","trait 对象（trait object）"],["body","\n"],["body","\n\n"],["headingLink","box-允许创建递归类型"],["heading","Box 允许创建递归类型"],["body","\n"],["headingLink","简介-1"],["heading","简介"],["body","\n\n"],["body","\n"],["body","Rust 需要在编译时知道类型占用多少空间。一种无法在编译时知道大小的类型是 递归类型（recursive type）"],["body","\n"],["body","\n"],["body","\n"],["body","其值的一部分可以是相同类型的另一个值。这种值的嵌套理论上可以无限的进行下去，"],["body","\n"],["body","\n"],["body","\n"],["body","所以 Rust 不知道递归类型需要多少空间。"],["body","\n"],["body","\n"],["body","\n"],["body","不过 box 有一个已知的大小，所以通过在循环类型定义中插入 box，就可以创建递归类型了。"],["body","\n"],["body","\n\n"],["body","enum List {\n    Cons(i32, List),\n    Nil,\n}\n\nuse crate::List::{Cons, Nil};\nfn main() {\n    let list = Cons(1, Cons(2, Cons(3, Nil)));\n}"],["body","\n"],["headingLink","计算非递归类型的大小"],["heading","计算非递归类型的大小"],["body","\n"],["body","#![allow(unused)]\n\nfn main() {\nenum Message {\n    Quit,\n    Move { x: i32, y: i32 },\n    Write(String),\n    ChangeColor(i32, i32, i32),\n}\n}"],["body","\n"],["body","当 Rust 需要知道要为 Message 值分配多少空间时，它可以检查每一个成员并发现 Message::Quit 并不需要任何空间，Message::Move 需要足够储存两个 i32 值的空间，依此类推。因此，Message 值所需的空间等于储存其最大成员的空间大小。"],["body","\n"],["headingLink","使用-boxt给递归类型一个已知的大小"],["heading","使用 Box<T>给递归类型一个已知的大小"],["body","\n"],["body","enum List {\n    Cons(i32, Box<List>),\n    Nil,\n}\n\nuse crate::List::{Cons, Nil};\n\nfn main() {\n    let list = Cons(1,\n        Box::new(Cons(2,\n            Box::new(Cons(3,\n                Box::new(Nil))))));\n}"],["body","\n"],["headingLink","通过-deref-trait-将智能指针当作常规引用处理"],["heading","通过 Deref trait 将智能指针当作常规引用处理"],["body","\n"],["body","\n"],["body","实现 Deref trait 允许我们重载 解引用运算符（dereference operator）*（与乘法运算符或通配符相区别）"],["body","\n"],["body","\n"],["body","\n"],["body","通过这种方式实现 Deref trait 的智能指针可以被当作常规引用来对待，"],["body","\n"],["body","\n\n"],["body","让我们首先看看解引用运算符如何处理常规引用"],["body","\n"],["body","接着尝试定义我们自己的类似 Box<T> 的类型并看看为何解引用运算符不能像引用一样工作"],["body","\n"],["body","我们会探索如何实现 Deref trait 使得智能指针以类似引用的方式工作变为可能"],["body","\n"],["body","最后，我们会讨论 Rust 的 Deref 强制转换（deref coercions）功能以及它是如何处理引用或智能指针的"],["body","\n\n"],["body","我们将要构建的 MyBox<T> 类型与真正的 Box<T> 有一个很大的区别"],["body","\n\n"],["body","我们的版本不会在堆上储存数据"],["body","\n"],["body","这个例子重点关注 Deref，所以其数据实际存放在何处，相比其类似指针的行为来说不算重要。"],["body","\n\n"],["headingLink","通过解引用运算符追踪指针的值"],["heading","通过解引用运算符追踪指针的值"],["body","\n"],["body","\n"],["body","常规引用是一个指针类型，一种理解指针的方式是将其看成指向储存在其他某处值的箭头"],["body","\n"],["body","\n"],["body","fn main() {\n    let x = 5;\n    let y = &x;\n\n    assert_eq!(5, x);\n    assert_eq!(5, *y);\n}"],["body","\n"],["body","不能 将 5 与 y比较 因为 y是 引用类型（指针类型）"],["body","\n"],["body","6 |   assert_eq!(5, y);\n\n |   ^^^^^^^^^^^^^^^^^ no implementation for `{integer} == &{integer}`\n"],["body","\n"],["headingLink","像引用一样使用-boxt"],["heading","像引用一样使用 Box<T>"],["body","\n"],["body","fn main() {\n    let x = 5;\n    let y = Box::new(x);\n\n    assert_eq!(5, x);\n    assert_eq!(5, *y);\n}"],["body","\n"],["headingLink","自定义智能指针"],["heading","自定义智能指针"],["body","\n"],["body","#![allow(unused)]\n\nfn main() {\nuse std::ops::Deref;\n\n\nimpl<T> Deref for MyBox<T> {\n    type Target = T;\n\n    fn deref(&self) -> &T {\n        //返回内部数据的引用\n        &self.0\n    }\n}\n\n//等价于\n*(y.deref()) \n//等价于\n*(&T)\n//等价于\nT\n}"],["body","\n\n"],["body","\n"],["body","deref方法返回值的引用，以及 *(y.deref()) 括号外边的普通解引用仍为必须的原因在于所有权。"],["body","\n"],["body","\n"],["body","\n"],["body","如果 deref 方法直接返回值而不是值的引用，其值（的所有权）将被移出 self"],["body","\n"],["body","\n"],["body","\n"],["body","在这里以及大部分使用解引用运算符的情况下我们并不希望获取 MyBox<T> 内部值的所有权"],["body","\n"],["body","\n"],["body","\n"],["body","每次当我们在代码中使用 * 时， * 运算符都被替换成了先调用 deref 方法再接着使用 * 解引用的操作，且只会发生一次，不会对 * 操作符无限递归替换"],["body","\n"],["body","\n"],["body","\n"],["body","解引用出上面 i32 类型的值就停止了"],["body","\n"],["body","\n\n"],["headingLink","函数和方法的隐式-deref-强制转换"],["heading","函数和方法的隐式 Deref 强制转换"],["body","\n"],["body","\n"],["body","Deref 强制转换（deref coercions）是 Rust 在函数或方法传参上的一种便利"],["body","\n"],["body","\n\n"],["body","\n"],["body","其将实现了 Deref 的类型的引用  转换为原始类型"],["body","\n"],["body","\n"],["body","\n"],["body","通过 Deref 所能够转换的类型的引用"],["body","\n"],["body","\n"],["body","\n"],["body","当这种特定类型的引用作为实参传递给和形参类型不同的函数或方法时，Deref 强制转换将自动发生，这时会有一系列的 deref 方法被调用，把我们提供的类型转换成了参数所需的类型。"],["body","\n"],["body","\n\n"],["body","Deref 强制转换的加入使得 Rust 程序员编写函数和方法调用时无需增加过多显式使用 & 和 * 的引用和解引用。这个功能也使得我们可以编写更多同时作用于引用或智能指针的代码。"],["body","\n"],["headingLink","example"],["heading","example"],["body","\n"],["body","\n"],["body","对于 str的解引用"],["body","\n"],["body","\n"],["body","mod smart_box;\nuse smart_box::MyBox;\nfn main() {\n    let my_box = MyBox::new(1);\n    let my_box1 = MyBox::new(String::from(\"xjq\"));\n    //普通手动解引用\n\t\t//*mybox1 为 String\n    \t//**mybox1 为 str\n    \t//&**mybox1 为 &str\n    print_str(&**my_box1);\n    \n    //自动强制解引用\n    print_str(&my_box1);\n}\n\nfn print_str(str: &str){\n    print!(\"{}\",str);\n}\nlet my_box1 = MyBox::new(String::from(\"xjq\"));\n\nprint_str(&**my_box1);"],["body","\n\n"],["body","Rust 可以通过 deref 调用将 &MyBox<String> 变为 &String"],["body","\n"],["body","Rust 再次调用 deref 将 &String 变为 &str"],["body","\n\n"],["body","fn main() {\n    let m = MyBox::new(String::from(\"Rust\"));\n    hello(&(*m)[..]);\n}"],["body","\n"],["headingLink","deref-强制转换如何与可变性交互"],["heading","Deref 强制转换如何与可变性交互"],["body","\n\n"],["body","\n"],["body","类似于如何使用 Deref trait 重载不可变引用的 * 运算符"],["body","\n"],["body","\n"],["body","\n"],["body","Rust 提供了 DerefMut trait 用于重载可变引用的 * 运算符。"],["body","\n"],["body","\n\n"],["body","Rust 在发现类型和 trait 实现满足三种情况时会进行 Deref 强制转换："],["body","\n\n"],["body","当 T: Deref<Target=U> 时从 &T 到 &U。"],["body","\n"],["body","当 T: DerefMut<Target=U> 时从 &mut T 到 &mut U。"],["body","\n"],["body","当 T: Deref<Target=U> 时从 &mut T 到 &U。"],["body","\n\n"],["body","将一个可变引用转换为不可变引用永远也不会打破借用规则。"],["body","\n"],["headingLink","使用-drop-trait-运行清理代码"],["heading","使用 Drop Trait 运行清理代码"],["body","\n\n"],["body","\n"],["body","对于智能指针模式来说第二个重要的 trait 是 Drop"],["body","\n"],["body","\n"],["body","\n"],["body","其允许我们在值要离开作用域时执行一些代码"],["body","\n"],["body","\n"],["body","\n"],["body","可以为任何类型提供 Drop trait 的实现"],["body","\n"],["body","\n"],["body","\n"],["body","同时所指定的代码被用于释放类似于文件或网络连接的资源"],["body","\n"],["body","\n\n"],["body","我们在智能指针上下文中讨论 Drop 是因为其功能几乎总是用于实现智能指针"],["body","\n\n"],["body","Drop trait 包含在 prelude 中"],["body","\n"],["body","drop 函数体是放置任何当类型实例离开作用域时期望运行的逻辑的地方"],["body","\n\n"],["headingLink","通过-stdmemdrop-提早丢弃值"],["heading","通过 std::mem::drop 提早丢弃值"],["body","\n\n"],["body","整个 Drop trait 存在的意义在于其是自动处理的"],["body","\n"],["body","你可能希望强制运行 drop 方法来释放锁以便作用域中的其他代码可以获取锁"],["body","\n"],["body","Rust 并不允许我们主动调用 Drop trait 的 drop 方法；"],["body","\n"],["body","当我们希望在作用域结束之前就强制释放变量的话，我们应该使用的是由标准库提供的 std::mem::drop。"],["body","\n"],["body","Rust 中的 drop 函数就是这么一个析构函数。"],["body","\n"],["body","因为不能禁用当值离开作用域时自动插入的 drop，并且不能显式调用 drop，如果我们需要强制提早清理值，可以使用 std::mem::drop 函数。"],["body","\n"],["body","std::mem::drop 函数不同于 Drop trait 中的 drop 方法。可以通过传递希望提早强制丢弃的值作为参数"],["body","\n\n"],["headingLink","rct-引用计数智能指针"],["heading","Rc<T> 引用计数智能指针"],["body","\n\n"],["body","\n"],["body","大部分情况下所有权是非常明确的:可以准确地知道哪个变量拥有某个值"],["body","\n"],["body","\n"],["body","\n"],["body","有些情况单个值可能会有多个所有者,例如图数据结构"],["body","\n"],["body","\n"],["body","\n"],["body","为了启用多所有权，Rust 有一个叫做 Rc<T> 的类型。其名称为 引用计数（reference counting）的缩写"],["body","\n"],["body","\n"],["body","\n"],["body","引用计数意味着记录一个值引用的数量来知晓这个值是否仍在被使用。如果某个值有零个引用，就代表没有任何有效引用并可以被清理。"],["body","\n"],["body","\n"],["body","\n"],["body","Rc<T> 用于当我们希望在堆上分配一些内存供程序的多个部分读取，而且无法在编译时确定程序的哪一部分会最后结束使用它的时候"],["body","\n"],["body","\n"],["body","\n"],["body","如果确实知道哪部分是最后一个结束使用的话，就可以令其成为数据的所有者，正常的所有权规则就可以在编译时生效。"],["body","\n"],["body","\n\n"],["body","\n"],["body","注意 Rc<T> 只能用于单线程场景"],["body","\n"],["body","\n"],["headingLink","使用-rct-共享数据"],["heading","使用 Rc<T> 共享数据"],["body","\n\n"],["body","\n"],["body","不必像调用 Rc::clone 增加引用计数那样调用一个函数来减少计数；"],["body","\n"],["body","\n"],["body","\n"],["body","Drop trait 的实现当 Rc<T> 值离开作用域时自动减少引用计数。"],["body","\n"],["body","\n"],["body","\n"],["body","使用 Rc<T> 允许一个值有多个所有者，引用计数则确保只要任何所有者依然存在其值也保持有效。"],["body","\n"],["body","\n"],["body","\n"],["body","通过不可变引用， Rc<T> 允许在程序的多个部分之间只读地共享数据。如果 Rc<T> 也允许多个可变引用,则会违反第四章讨论的借用规则之一：相同位置的多个可变借用可能造成数据竞争和不一致"],["body","\n"],["body","\n\n"],["headingLink","refcellt-和内部可变性模式"],["heading","RefCell<T> 和内部可变性模式"],["body","\n\n"],["body","\n"],["body","内部可变性（Interior mutability）是 Rust 中的一个设计模式"],["body","\n"],["body","\n"],["body","\n"],["body","它允许你即使在有不可变引用时也可以改变数据，这通常是借用规则所不允许的"],["body","\n"],["body","\n"],["body","\n"],["body","为了改变数据，该模式在数据结构中使用 unsafe 代码来模糊 Rust 通常的可变性和借用规则"],["body","\n"],["body","\n"],["body","\n"],["body","我们还未讲到不安全代码；第十九章会学习它们"],["body","\n"],["body","\n"],["body","\n"],["body","当可以确保代码在运行时会遵守借用规则，即使编译器不能保证的情况，可以选择使用那些运用内部可变性模式的类型"],["body","\n"],["body","\n"],["body","\n"],["body","所涉及的 unsafe 代码将被封装进安全的 API 中，而外部类型仍然是不可变的。"],["body","\n"],["body","\n\n"],["headingLink","通过-refcellt-在运行时检查借用规则"],["heading","通过 RefCell<T> 在运行时检查借用规则"],["body","\n"],["body","如下为选择 Box<T>，Rc<T> 或 RefCell<T> 的理由："],["body","\n\n"],["body","Rc<T> 允许相同数据有多个所有者；Box<T> 和 RefCell<T> 有单一所有者。"],["body","\n"],["body","Box<T> 允许在编译时执行不可变或可变借用检查；Rc<T>仅允许在编译时执行不可变借用检查；RefCell<T> 允许在运行时执行不可变或可变借用检查。"],["body","\n"],["body","因为 RefCell<T> 允许在运行时执行可变借用检查，所以我们可以在即便 RefCell<T> 自身是不可变的情况下修改其内部的值。"],["body","\n\n"],["body","在不可变值内部改变值就是 内部可变性 模式。让我们看看何时内部可变性是有用的，并讨论这是如何成为可能的。"],["body","\n"],["headingLink","内部可变性不可变值的可变借用"],["heading","内部可变性：不可变值的可变借用"],["body","\n"],["body","#![allow(unused)]\nfn main() {\nlet vec1 = vec![1, 2, 3];\nlet cell = RefCell::new(vec1);\n\n{\n    let mut ref_mut1 = cell.borrow_mut();\n    ref_mut1.push(4);\n    println!(\"{:?}\", ref_mut1);\n}\nlet mut ref_mut2= cell.borrow_mut();\n}"],["body","\n"],["headingLink","refcellt-在运行时记录借用"],["heading","RefCell<T> 在运行时记录借用"],["body","\n\n"],["body","当创建不可变和可变引用时，我们分别使用 & 和 &mut 语法。对于 RefCell<T> 来说，则是 borrow 和 borrow_mut 方法，这属于 RefCell<T> 安全 API 的一部分"],["body","\n"],["body","borrow 方法返回 Ref<T> 类型的智能指针，borrow_mut 方法返回 RefMut 类型的智能指针"],["body","\n"],["body","这两个类型都实现了 Deref，所以可以当作常规引用对待。"],["body","\n"],["body","RefCell<T> 记录当前有多少个活动的 Ref<T> 和 RefMut<T> 智能指针"],["body","\n"],["body","每次调用 borrow，RefCell<T> 将活动的不可变借用计数加一，当 Ref<T> 值离开作用域时，不可变借用计数减一，就像编译时借用规则一样"],["body","\n"],["body","RefCell<T> 在任何时候只允许有多个不可变借用或一个可变借用。"],["body","\n"],["body","如果我们尝试违反这些规则，相比引用时的编译时错误，RefCell<T> 的实现会在运行时出现 panic"],["body","\n\n"],["headingLink","结合-rct-和-refcellt-来拥有多个可变数据所有者"],["heading","结合 Rc<T> 和 RefCell<T> 来拥有多个可变数据所有者"],["body","\n\n"],["body","RefCell<T> 的一个常见用法是与 Rc<T> 结合"],["body","\n"],["body","Rc<T> 允许对相同数据有多个所有者，不过只能提供数据的不可变访问"],["body","\n"],["body","如果有一个储存了 RefCell<T> 的 Rc<T> 的话，就可以得到有多个所有者 并且 可以修改的值了！"],["body","\n\n"],["body","#![allow(unused)]\nfn main() {\npub fn test_ref_rc(){\n    let vec1 = vec![1, 2, 3];\n    let cell = RefCell::new(vec1);\n    let rc = Rc::new(cell);\n    let rc1 = rc.clone();\n    let rc2 = rc.clone();\n    rc1.borrow_mut().push(4);\n    rc2.borrow_mut().push(5);\n\n    println!(\"{:?}\",rc);\n}\n}"],["body","\n"],["headingLink","引用循环与内存泄漏"],["heading","引用循环与内存泄漏"],["body","\n\n"],["body","Rust 的内存安全性保证使其难以意外地制造永远也不会被清理的内存（被称为 内存泄漏（memory leak））"],["body","\n"],["body","但并不是不可能。与在编译时拒绝数据竞争不同， Rust 并不保证完全地避免内存泄漏，这意味着内存泄漏在 Rust 被认为是内存安全的"],["body","\n"],["body","这一点可以通过 Rc<T> 和 RefCell<T> 看出：创建引用循环的可能性是存在的。这会造成内存泄漏，因为每一项的引用计数永远也到不了 0，其值也永远不会被丢弃。"],["body","\n\n"],["headingLink","制造引用循环"],["heading","制造引用循环"],["body","\n"],["body","\n"],["body","创建一个引用循环：两个 List 值互相指向彼此"],["body","\n"],["body","\n"],["body","fn main() {}\nuse std::rc::Rc;\nuse std::cell::RefCell;\nuse crate::List::{Cons, Nil};\n\n#[derive(Debug)]\nenum List {\n    Cons(i32, RefCell<Rc<List>>),\n    Nil,\n}\n\nimpl List {\n    fn tail(&self) -> Option<&RefCell<Rc<List>>> {\n        match self {\n            Cons(_, item) => Some(item),\n            Nil => None,\n        }\n    }\n}\n\npub fn test_recursive(){\n    let a =  Rc::new( Cons(1, RefCell::new(Rc::new(Nil))) ) ;\n    println!(\"a initial rc count = {}\", Rc::strong_count(&a));\n    println!(\"a next item = {:?}\", a.tail());\n\n\n    let b = Rc::new( Cons(2,RefCell::new(a.clone())) );\n    println!(\"a rc count after b creation = {}\", Rc::strong_count(&a));\n    println!(\"b initial rc count = {}\", Rc::strong_count(&b));\n    println!(\"b next item = {:?}\", b.tail());\n\n\n\n\n    match  a.tail() {\n        None => {}\n        Some(item) => {\n            *item.borrow_mut() = b.clone();\n        }\n    }\n\n    println!(\"b rc count after changing a = {}\", Rc::strong_count(&b));\n    println!(\"a rc count after changing a = {}\", Rc::strong_count(&a));\n}"],["body","\n"],["headingLink","weakref的使用"],["heading","WeakRef的使用"],["body","\n"],["body","#![allow(unused)]\nfn main() {\nuse std::rc::{Rc, Weak};\nuse std::cell::RefCell;\n#[derive(Debug)]\nstruct Node {\n    value: i32,\n    child: RefCell<Vec<Rc<Node>>>,\n    parent: RefCell<Weak<Node>>,\n}\n\nimpl Node {\n    fn new(value: i32, child: Vec<Rc<Node>>) -> Rc<Node> {\n        Rc::new(Node {\n            value,\n            child: RefCell::new(vec![]),\n            parent: RefCell::new(Weak::new()),\n        }\n        )\n    }\n}\n\npub fn test_weak_ref() {\n    //创建节点1\n    let node1 = Node::new(1, vec![]);\n\n    println!(\"node1 parent = {:?}\", node1.parent.borrow().upgrade());\n\n\n    {\n        //创建节点2\n        let node2 = Node::new(2, vec![node1.clone()]);\n\n        println!(\"strong_count:{:?},weak_count:{:?}\",Rc::strong_count(&node2),Rc::weak_count(&node2));\n\n        //将parent赋值为node2\n        *node1.parent.borrow_mut() = Rc::downgrade(&node2);\n\n        println!(\"strong_count:{:?},weak_count:{:?}\",Rc::strong_count(&node2),Rc::weak_count(&node2));\n\n        println!(\"node1 parent = {:?}\", node1.parent.borrow().upgrade());\n    }\n\n    println!(\"node1 parent = {:?}\", node1.parent.borrow().upgrade());\n}\n}"],["body","\n\n\n\n                    "],["body","\n\n                    \n                \n            \n\n            \n\n        \n\n\n\n\n        \n\n\n\n        \n        \n        \n\n        \n\n\n    \n    \n\n"]],[["_relative_fp","5泛型与trait.html"],["title","泛型与trait.md - RUST学习笔记"],["body","\n    \n        \n        \n\n        \n        \n\n        \n        \n\n        \n\n        \n        \n\n        \n\n        \n        \n\n        \n\n            \n                                \n                \n                    \n                        "],["body","\n                            \n                        "],["body","\n                        "],["body","\n                            \n                        "],["body","\n                        \n                            "],["body","Light"],["body","\n                            "],["body","Rust"],["body","\n                            "],["body","Coal"],["body","\n                            "],["body","Navy"],["body","\n                            "],["body","Ayu"],["body","\n                        \n                    \n\n                    "],["heading","RUST学习笔记"],["body","\n\n                    \n\n                    \n                \n\n\n                \n                \n\n                \n                    "],["body","\n                        \n\n"],["body","\n"],["body","\n\n"],["headingLink","泛型的使用"],["heading","泛型的使用"],["body","\n"],["headingLink","函数泛型定义与使用"],["heading","函数泛型定义与使用"],["body","\n"],["body","#![allow(unused)]\nfn main() {\n//定义,写在函数名后面, 使用在函数的任何地方\nfn largest<T>(list: &[T]) -> T {\n    let mut largest = list[0];\n    for &item in list.iter() {\n        if item > largest {\n            largest = item;\n        }\n    }\n    largest\n}\n}"],["body","\n"],["headingLink","结构体泛型定义与使用"],["heading","结构体泛型定义与使用"],["body","\n"],["body","struct Point<T> {\n    x: T,\n    y: T,\n}\n\nfn main() {\n    let wont_work = Point { x: 5, y: 4.0 };\n}"],["body","\n"],["headingLink","枚举定义的泛型"],["heading","枚举定义的泛型"],["body","\n"],["body","#![allow(unused)]\nfn main() {\nenum Option<T> {\n    Some(T),\n    None,\n}\nenum Result<T, E> {\n    Ok(T),\n    Err(E),\n}\n}"],["body","\n"],["headingLink","方法实现中的泛型定义"],["heading","方法实现中的泛型定义"],["body","\n"],["body","#![allow(unused)]\nfn main() {\nstruct Point<T> {\nx: T,\ny: T,\n}\n\n\nimpl Point<f32> {\n    fn distance_from_origin(&self) -> f32 {\n        (self.x.powi(2) + self.y.powi(2)).sqrt()\n    }\n}\n\nimpl<T> Point<T> {\n    fn x(&self) -> &T {\n        &self.x\n    }\n}\n\n//产生新泛型\nstruct Point<T, U> {\n    x: T,\n    y: U,\n}\n\nimpl<T, U> Point<T, U> {\n    fn mixup<V, W>(self, other: Point<V, W>) -> Point<T, W> {\n        Point {\n            x: self.x,\n            y: other.y,\n        }\n    }\n}\n}"],["body","\n"],["headingLink","泛型代码的性能"],["heading","泛型代码的性能"],["body","\n\n"],["body","Rust 实现了泛型，使得使用泛型类型参数的代码相比使用具体类型并没有任何速度上的损失。"],["body","\n"],["body","Rust 通过在编译时进行泛型代码的 单态化（monomorphization）来保证效率。单态化是一个通过填充编译时使用的具体类型，将通用代码转换为特定代码的过程。"],["body","\n"],["body","编译器寻找所有泛型代码被调用的位置并使用泛型代码针对具体类型生成代码。"],["body","\n\n"],["body","让我们看看一个使用标准库中 Option 枚举的例子："],["body","\n"],["body","#![allow(unused)]\nfn main() {\nlet integer = Some(5);\nlet float = Some(5.0);\n}"],["body","\n"],["body","编译器会读取传递给 Option<T> 的值并发现有两种 Option<T>：一个对应 i32 另一个对应 f64"],["body","\n"],["body","为此，它会将泛型定义 Option<T> 展开为 Option_i32 和 Option_f64，接着将泛型定义替换为这两个具体的定义。"],["body","\n"],["headingLink","trait特性"],["heading","Trait(特性)"],["body","\n"],["headingLink","定义"],["heading","定义"],["body","\n\n"],["body","\n"],["body","一个类型的行为由其可供调用的方法构成。"],["body","\n"],["body","\n"],["body","\n"],["body","如果可以对不同类型调用相同的方法的话，这些类型就可以共享相同的行为了。"],["body","\n"],["body","\n"],["body","\n"],["body","trait 定义是一种将方法签名组合起来的方法，目的是定义一个实现某些目的所必需的行为的集合。"],["body","\n"],["body","\n\n"],["body","#![allow(unused)]\nfn main() {\n//trait 体中可以有多个方法\npub trait Summary {\n    fn summarize(&self) -> String;\n}\n}"],["body","\n"],["headingLink","为结构体实现trait"],["heading","为结构体实现Trait"],["body","\n"],["body","#![allow(unused)]\nfn main() {\npub struct NewsArticle {\n    pub headline: String,\n    pub location: String,\n    pub author: String,\n    pub content: String,\n}\n\nimpl Summary for NewsArticle {\n    fn summarize(&self) -> String {\n        format!(\"{}, by {} ({})\", self.headline, self.author, self.location)\n    }\n}\n\npub struct Tweet {\n    pub username: String,\n    pub content: String,\n    pub reply: bool,\n    pub retweet: bool,\n}\n\nimpl Summary for Tweet {\n    fn summarize(&self) -> String {\n        format!(\"{}: {}\", self.username, self.content)\n    }\n}\n}"],["body","\n"],["headingLink","trait-的相干性"],["heading","trait 的相干性"],["body","\n\n"],["body","不能为 外部类型(第三方) 实现 外部 （第三方）trait\n\n"],["body","例如 不能在 aggregator crate 中为 Vec<T> 实现 Display trait"],["body","\n"],["body","因为 Display 和 Vec<T> 都定义于标准库中"],["body","\n"],["body","并不位于 aggregator crate 本地作用域中"],["body","\n"],["body","这个限制是被称为 相干性（coherence） 更具体的说是 孤儿规则（orphan rule）"],["body","\n"],["body","这条规则确保了其他人编写的代码不会破坏你代码"],["body","\n\n"],["body","\n\n"],["headingLink","trait-的默认实现"],["heading","Trait 的默认实现"],["body","\n"],["body","#![allow(unused)]\nfn main() {\npub trait Summary {\n    fn summarize(&self) -> String {\n        String::from(\"(Read more...)\")\n    }\n}\n}"],["body","\n"],["body","默认方法与抽象方法共存"],["body","\n"],["body","#![allow(unused)]\n\nfn main() {\npub trait Summary {\n    fn summarize_author(&self) -> String;\n\n    fn summarize(&self) -> String {\n        format!(\"(Read more from {}...)\", self.summarize_author())\n    }\n}\n}"],["body","\n"],["body","#![allow(unused)]\nfn main() {\ntrait Summary{\n     fn summary(&self) -> String{\n        String::from(\"read more\")\n    }\n}\nimpl Summary for Book{\n\n}\n}"],["body","\n"],["headingLink","trait-作为参数"],["heading","Trait 作为参数"],["body","\n"],["headingLink","traitbound-语法糖"],["heading","TraitBound 语法糖"],["body","\n"],["body","\n"],["body","与 impl Summary 是一样"],["body","\n"],["body","\n"],["body","#![allow(unused)]\nfn main() {\npub fn notify<T: Summary>(item: T) {\n    println!(\"Breaking news! {}\", item.summarize());\n}\n}"],["body","\n"],["body","pub fn notify(item1: impl Summary, item2: impl Summary) {\n与\npub fn notify<T: Summary>(item1: T, item2: T) {\n"],["body","\n"],["body","通过 + 号 指定多个"],["body","\n"],["body","#![allow(unused)]\nfn main() {\npub fn notify(item: impl Summary + Display) {\n与\npub fn notify<T: Summary + Display>(item: T) {\n}"],["body","\n"],["body","通过 where 简化 trait bound"],["body","\n"],["body","#![allow(unused)]\nfn main() {\nfn some_function<T: Display + Clone, U: Clone + Debug>(t: T, u: U) -> i32 {\n与\n\nfn some_function<T, U>(t: T, u: U) -> i32\n    where T: Display + Clone,\n          U: Clone + Debug\n{\n}"],["body","\n"],["headingLink","函数参数"],["heading","函数参数"],["body","\n"],["body","#![allow(unused)]\nfn main() {\npub fn notify(item: impl Summary) {\n    println!(\"Breaking news! {}\", item.summarize());\n}\n}"],["body","\n"],["headingLink","返回类型"],["heading","返回类型"],["body","\n"],["body","#![allow(unused)]\nfn main() {\nfn returns_summarizable() -> impl Summary {\n    Tweet {\n        username: String::from(\"horse_ebooks\"),\n        content: String::from(\"of course, as you probably already know, people\"),\n        reply: false,\n        retweet: false,\n    }\n}\n}"],["body","\n"],["headingLink","使用-trait-bound-有条件地实现方法"],["heading","使用 trait bound 有条件地实现方法"],["body","\n"],["body","\n"],["body","限定泛型的实现 类型"],["body","\n"],["body","\n"],["body","#![allow(unused)]\nfn main() {\nuse std::fmt::Display;\n\nstruct Pair<T> {\n    x: T,\n    y: T,\n}\n\nimpl<T> Pair<T> {\n    fn new(x: T, y: T) -> Self {\n        Self {\n            x,\n            y,\n        }\n    }\n}\n\nimpl<T: Display + PartialOrd> Pair<T> {\n    fn cmp_display(&self) {\n        if self.x >= self.y {\n            println!(\"The largest member is x = {}\", self.x);\n        } else {\n            println!(\"The largest member is y = {}\", self.y);\n        }\n    }\n}\n}"],["body","\n"],["body","例如"],["body","\n"],["body","#![allow(unused)]\nfn main() {\n//标准库为任何实现了 Display trait 的类型实现了 ToString trait。这个 impl 块看起来像这样：\nimpl<T: Display> ToString for T {\n    // --snip--\n}\n//因为标准库有了这些 blanket implementation，我们可以对任何实现了 Display trait 的类型调用由 ToString 定义的 to_string 方法。例如，可以将整型转换为对应的 String 值，因为整型实现了 Display：\n}"],["body","\n"],["headingLink","dyn-trait-trait-对象"],["heading","dyn Trait trait 对象"],["body","\n"],["body","dyn Trait 是使用 trait 对象的新语法，简而言之："],["body","\n\n"],["body","Box<Trait> becomes Box<dyn Trait>"],["body","\n"],["body","&Trait and &mut Trait become &dyn Trait and &mut dyn Trait"],["body","\n\n"],["headingLink","标准库中的-trait"],["heading","标准库中的 Trait"],["body","\n"],["headingLink","debug详细打印"],["heading","Debug详细打印"],["body","\n"],["body","Debug trait 用于开启格式化字符串中的调试格式，其通过在 {} 占位符中增加 :? 表明。"],["body","\n"],["body","需要实现 Debug 的 fmt"],["body","\n"],["body","impl Debug for Address{\n    fn fmt(&self, f: &mut Formatter<'_>) -> Result<(), Error> {\n        write!(f,\"a={}\",self.home)\n    }\n}\n"],["body","\n"],["headingLink","等值比较"],["heading","等值比较"],["body","\n"],["body","相关解释 "],["body","\n"],["headingLink","partitaleq"],["heading","PartitalEq"],["body","\n"],["body","\n"],["body","派生的 PartialEq 实现了 eq 方法。"],["body","\n"],["body","\n\n"],["body","当 PartialEq 在结构体上派生时，只有所有 的字段都相等时两个实例才相等。"],["body","\n"],["body","当在枚举上派生时，每一个成员都和其自身相等，且和其他成员都不相等。"],["body","\n\n"],["headingLink","eq"],["heading","Eq"],["body","\n"],["body","Eq 相比 PartialEq 需要额外满足反身性，即 a == a，对于浮点类型，Rust 只实现了 PartialEq 而不是 Eq，原因就是 NaN != NaN。"],["body","\n"],["headingLink","ord--partialord"],["heading","Ord & PartialOrd"],["body","\n"],["body","类似于 Eq，Ord 指的是 Total Order，需要满足以下三个性质："],["body","\n\n"],["body","反对称性（Antisymmetry）：a <= b 且 a >= b 可推出 a == b"],["body","\n"],["body","传递性（Transitivity）：a <= b 且 b <= c 可推出 a <= c"],["body","\n"],["body","连通性（Connexity）：a <= b 或 a >= b"],["body","\n\n"],["body","而 PartialOrd 无需满足连通性，只满足反对称性和传递性即可。"],["body","\n\n"],["body","反对称性：a < b 则有 !(a > b)，反之亦然"],["body","\n"],["body","传递性：a < b 且 b < c 可推出 a < c，== 和 > 同理"],["body","\n\n"],["headingLink","复制值的-clone-和-copy"],["heading","复制值的 Clone 和 Copy"],["body","\n\n"],["body","可以明确地创建一个值的深拷贝（deep copy），复制过程可能包含任意代码的执行以及堆上数据的复制"],["body","\n"],["body","派生 Clone 实现了 clone 方法，其为整个的类型实现时，在类型的每一部分上调用了 clone 方法。这意味着类型中所有字段或值也必须实现了 Clone，这样才能够派生 Clone 。"],["body","\n\n"],["body","切片转集合时需要clone"],["body","\n"],["body","当在一个切片（slice）上调用 to_vec 方法时，Clone 是必须的。切片并不拥有其所包含实例的类型，但是从 to_vec 中返回的 vector 需要拥有其实例，因此，to_vec 在每个元素上调用 clone。因此，存储在切片中的类型必须实现 Clone。"],["body","\n"],["body","拷贝存储在栈上的数据不需要额外代码"],["body","\n"],["body","Copy trait 允许你通过只拷贝存储在栈上的位来复制值而不需要额外的代码。查阅第四章 “只在栈上的数据：拷贝” 的部分来获取有关 Copy 的更多信息。"],["body","\n"],["headingLink","固定大小的值到值映射的-hash"],["heading","固定大小的值到值映射的 Hash"],["body","\n\n"],["body","\n"],["body","Hash trait 可以实例化一个任意大小的类型，并且能够用哈希（hash）函数将该实例映射到一个固定大小的值上。"],["body","\n"],["body","\n"],["body","\n"],["body","派生 Hash 实现了 hash 方法。hash 方法的派生实现结合了在类型的每部分调用 hash 的结果，这意味着所有的字段或值也必须实现了 Hash，这样才能够派生 Hash。"],["body","\n"],["body","\n\n"],["body","\n"],["body","例如，在 HashMap<K, V> 上存储数据，存放 key 的时候，Hash 是必须的。"],["body","\n"],["body","\n"],["headingLink","默认值的-default"],["heading","默认值的 Default"],["body","\n"],["body","*　Default trait 使你创建一个类型的默认值"],["body","\n"],["body","使用"],["body","\n"],["body","#![allow(unused)]\nfn main() {\npub fn  test_default(){\n    let person = Person {..Default::default()};\n    println!(\"{:?}\",person);\n}\n#[derive(Debug)]\nstruct Person{\n    age:i32,\n    name:String,\n    address:String\n}\n\nimpl Default for Person{\n    fn default() -> Self {\n        Person{\n            age:18,\n            name:\"ssss\".to_owned(),\n            address: \"\".to_owned()\n        }\n    }\n}\n}"],["body","\n"],["headingLink","trait-对象执行动态分发"],["heading","trait 对象执行动态分发"],["body","\n\n"],["body","\n"],["body","当对泛型使用 trait bound 时编译器所进行单态化处理：编译器为每一个被泛型类型参数代替的具体类型生成了非泛型的函数和方法实现。"],["body","\n"],["body","\n"],["body","\n"],["body","单态化所产生的代码进行 静态分发（static dispatch）"],["body","\n"],["body","\n"],["body","\n"],["body","静态分发发生于编译器在编译时就知晓调用了什么方法的时候。这与 动态分发 （dynamic dispatch）相对，这时编译器在编译时无法知晓调用了什么方法。在动态分发的情况下，编译器会生成在运行时确定调用了什么方法的代码。"],["body","\n"],["body","\n\n"],["body","当使用 trait 对象时，Rust 必须使用动态分发"],["body","\n"],["headingLink","trait-对象要求对象安全"],["heading","Trait 对象要求对象安全"],["body","\n"],["body","只有 对象安全（object safe）的 trait 才可以组成 trait 对象"],["body","\n"],["body","如果一个 trait 中所有的方法有如下属性时，则该 trait 是对象安全的："],["body","\n\n"],["body","返回值类型不为 Self"],["body","\n"],["body","方法没有任何泛型类型参数"],["body","\n\n"],["body","一个 trait 的方法不是对象安全的例子是标准库中的 Clone trait。Clone trait 的 clone 方法的参数签名看起来像这样："],["body","\n"],["body","#![allow(unused)]\nfn main() {\npub trait Clone {\n    fn clone(&self) -> Self;\n}\n}"],["body","\n"],["headingLink","高级trait"],["heading","高级Trait"],["body","\n"],["headingLink","trait中的关联类型"],["heading","trait中的关联类型"],["body","\n"],["body","干什么用的?"],["body","\n\n"],["body","提供类似泛型的作用"],["body","\n"],["body","提供迭代的子类型"],["body","\n"],["body","Item 是一个占位类型,在编译时期,会根据具体的实现类去替换"],["body","\n\n"],["body","怎么使用的?"],["body","\n"],["body","定义"],["body","\n"],["body","#![allow(unused)]\n\nfn main() {\npub trait Iterator {\n    type Item;\n\n    fn next(&mut self) -> Option<Self::Item>;\n}\n}"],["body","\n"],["body","使用"],["body","\n"],["body","#![allow(unused)]\nfn main() {\nmpl Iterator for Counter {\n    type Item = u32;\n\n    fn next(&mut self) -> Option<Self::Item> {\n}"],["body","\n"],["headingLink","为什么会要有定义这个而不使用泛型"],["heading","为什么会要有定义这个而不使用泛型?"],["body","\n"],["body","如果使用泛型 的话,每次调用 next方法都得指定泛型具体类型"],["body","\n"],["headingLink","默认类型参数"],["heading","默认类型参数"],["body","\n"],["headingLink","干嘛用的"],["heading","干嘛用的?"],["body","\n\n"],["body","当使用泛型类型参数时，可以为泛型指定一个默认的具体类型。如果默认类型就足够的话，这消除了为具体类型实现 trait 的需要"],["body","\n\n"],["headingLink","如何使用"],["heading","如何使用"],["body","\n"],["body","定义默认类型参数"],["body","\n"],["body","#![allow(unused)]\nfn main() {\n//定义,RHS参数默认使用 实现该Trait 的 类型 \ntrait Add<RHS=Self> {\n    type Output;\n    fn add(self, rhs: RHS) -> Self::Output;\n}\n\n}"],["body","\n"],["body","使用默认类型参数"],["body","\n"],["body","#![allow(unused)]\n\nfn main() {\n#[derive(Debug, PartialEq)]\nstruct Point {\n    x: i32,\n    y: i32,\n}\n\nimpl Add for Point {\n    type Output = Point;\n\n    fn add(self, other: Point) -> Point {\n        Point {\n            x: self.x + other.x,\n            y: self.y + other.y,\n        }\n    }\n}\n}"],["body","\n"],["body","使用自定义类型参数"],["body","\n"],["body","#![allow(unused)]\nfn main() {\nuse std::ops::Add;\n\nstruct Millimeters(u32);\nstruct Meters(u32);\n\nimpl Add<Meters> for Millimeters {\n    type Output = Millimeters;\n\n    fn add(self, other: Meters) -> Millimeters {\n        Millimeters(self.0 + (other.0 * 1000))\n    }\n}\n}"],["body","\n"],["body","为什么要引入这个"],["body","\n\n"],["body","一小部分实现的样板代码是不必要的，这样使用 trait 就更容易了,减少不必要的泛型类型"],["body","\n"],["body","扩展类型而不破坏现有代码。"],["body","\n\n"],["headingLink","完全限定语法"],["heading","完全限定语法"],["body","\n"],["headingLink","干嘛用的-1"],["heading","干嘛用的?"],["body","\n"],["body","#![allow(unused)]\n\nfn main() {\ntrait Pilot {\n    fn fly(&self);\n}\n\ntrait Wizard {\n    fn fly(&self);\n}\n\nstruct Human;\n\nimpl Pilot for Human {\n    fn fly(&self) {\n        println!(\"This is your captain speaking.\");\n    }\n}\n\nimpl Wizard for Human {\n    fn fly(&self) {\n        println!(\"Up!\");\n    }\n}\n\nimpl Human {\n    fn fly(&self) {\n        println!(\"*waving arms furiously*\");\n    }\n}\n}"],["body","\n\n"],["body","当一个类上实现了多个方法,编译器默认调用 使用 impl Type 中的方法"],["body","\n"],["body","使用 完全限定语法可以调用 其他 Trait的方法"],["body","\n\n"],["headingLink","如何使用-1"],["heading","如何使用?"],["body","\n"],["body","全语法"],["body","\n"],["body","<Type as Trait>::function(receiver_if_method, next_arg, ...);"],["body","\n"],["body","使用(类型定义见上)"],["body","\n"],["body","fn main() {\n    let person = Human;\n    Pilot::fly(&person);\n    Wizard::fly(&person);\n    person.fly();\n}"],["body","\n"],["body","使用2"],["body","\n"],["body","fn main() {\n    println!(\"A baby dog is called a {}\", <Dog as Animal>::baby_name());\n}"],["body","\n"],["headingLink","trait中的继承"],["heading","Trait中的继承"],["body","\n"],["headingLink","干什么用的"],["heading","干什么用的?"],["body","\n\n"],["body","\n"],["body","用于在另一个 trait 中使用某 trait 的功能"],["body","\n"],["body","\n"],["body","\n"],["body","Trait 定义指定了 要实现它就 必须先 实现 Display"],["body","\n"],["body","\n\n"],["headingLink","如何使用-2"],["heading","如何使用"],["body","\n"],["body","定义"],["body","\n"],["body","#![allow(unused)]\nfn main() {\nuse std::fmt;\n\ntrait OutlinePrint: fmt::Display {\n    fn outline_print(&self) {\n        let output = self.to_string();\n        let len = output.len();\n        println!(\"{}\", \"*\".repeat(len + 4));\n        println!(\"*{}*\", \" \".repeat(len + 2));\n        println!(\"* {} *\", output);\n        println!(\"*{}*\", \" \".repeat(len + 2));\n        println!(\"{}\", \"*\".repeat(len + 4));\n    }\n}\n}"],["body","\n"],["body","使用"],["body","\n"],["body","#![allow(unused)]\nfn main() {\nstruct Point {\n    x: i32,\n    y: i32,\n}\nimpl OutlinePrint for Point {}\n}"],["body","\n"],["headingLink","为什么要定义这个"],["heading","为什么要定义这个"],["body","\n\n"],["body","广义上来说是为了 重用代码"],["body","\n"],["body","狭义上 就是实现某一trait 需要依赖另一个 trait"],["body","\n"],["body","类似于继承的概念"],["body","\n\n"],["headingLink","解决为-外部类型-实现外部-trait"],["heading","解决为 外部类型 实现外部 Trait"],["body","\n"],["headingLink","背景"],["heading","背景"],["body","\n"],["body","外部类型或Trait"],["body","\n"],["body","即非本地的, 例如标准库,第三方库的类型或Trait"],["body","\n"],["body","孤儿规则 (orphan rule)"],["body","\n\n"],["body","不能为外部类型,实现外部trait"],["body","\n"],["body","避免本地库 影响第三方库的行为"],["body","\n\n"],["body","什么是newType 模式"],["body","\n"],["body","举例"],["body","\n"],["body","#![allow(unused)]\nfn main() {\n//常规定义\nstruct Person{\n\tage:u32,\n\taddress:String\n}\n//newType定义\nstruct Person{\n\tage:Year,\n\taddress:Address\n}\n\nstruct Year(u32);\nstruct Address(String);\n}"],["body","\n"],["body","说明"],["body","\n\n"],["body","\n"],["body","使用这个模式没有运行时性能惩罚，这个封装类型在编译时就被省略了。"],["body","\n"],["body","\n"],["body","\n"],["body","在编写代码时,很快就能知道 某个字段的具体 业务含义"],["body","\n"],["body","\n"],["body","\n"],["body","nwType模式可以在外部类型上实现外部Trait"],["body","\n"],["body","\n\n"],["headingLink","如何使用-3"],["heading","如何使用"],["body","\n"],["body","use std::fmt;\n\nstruct Wrapper(Vec<String>);\n\nimpl fmt::Display for Wrapper {\n    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n        write!(f, \"[{}]\", self.0.join(\", \"))\n    }\n}\n\nfn main() {\n    let w = Wrapper(vec![String::from(\"hello\"), String::from(\"world\")]);\n    println!(\"w = {}\", w);\n}"],["body","\n\n"],["body","\n"],["body","Display 的实现使用 self.0 来访问其内部的 Vec<T>"],["body","\n"],["body","\n"],["body","\n"],["body","此方法的缺点是，因为 Wrapper 是一个新类型，它没有定义于其值之上的方法；必须直接在 Wrapper 上实现 Vec<T> 的所有方法，这样就可以代理到self.0 上 "],["body","\n"],["body","\n"],["body","\n"],["body","如果希望新类型拥有其内部类型的每一个方法，为封装类型实现 Deref trait（第十五章 “通过 Deref trait 将智能指针当作常规引用处理” 部分讨论过）并返回其内部类型是一种解决方案。"],["body","\n"],["body","\n\n\n\n\n                    "],["body","\n\n                    \n                \n            \n\n            \n\n        \n\n\n\n\n        \n\n\n\n        \n        \n        \n\n        \n\n\n    \n    \n\n"]],[["_relative_fp","12ConstantsAndVariables.html"],["title","ConstantsAndVariables.md - RUST学习笔记"],["body","\n    \n        \n        \n\n        \n        \n\n        \n        \n\n        \n\n        \n        \n\n        \n\n        \n        \n\n        \n\n            \n                                \n                \n                    \n                        "],["body","\n                            \n                        "],["body","\n                        "],["body","\n                            \n                        "],["body","\n                        \n                            "],["body","Light"],["body","\n                            "],["body","Rust"],["body","\n                            "],["body","Coal"],["body","\n                            "],["body","Navy"],["body","\n                            "],["body","Ayu"],["body","\n                        \n                    \n\n                    "],["heading","RUST学习笔记"],["body","\n\n                    \n\n                    \n                \n\n\n                \n                \n\n                \n                    "],["body","\n                        \n\n"],["body","\n"],["body","\n\n"],["headingLink","constants-vs-variables"],["heading","Constants v/s Variables"],["body","\n\n"],["body","常量使用  const关键字 声明，变量使用 let关键字申明"],["body","\n"],["body","变量得类型是可选的，常量的类型是必选的"],["body","\n"],["body","let关键字申明的变量是默认 不可变的。也可以使用 mut关键字 使之可变，常量始终不可变"],["body","\n"],["body","常量只能通过 constant expression设置。不能通过 函数调用、或者其他运行时 计算表达式"],["body","\n"],["body","常量可以申明在 任何作用域"],["body","\n"],["body","变量可以被重复定义，后定义的变量覆盖前面的定义，常量不可以"],["body","\n\n\n\n\n                    "],["body","\n\n                    \n                \n            \n\n            \n\n        \n\n\n\n\n        \n\n\n\n        \n        \n        \n\n        \n\n\n    \n    \n\n"]],[["_relative_fp","4迭代与闭包.html"],["title","迭代与闭包.md - RUST学习笔记"],["body","\n    \n        \n        \n\n        \n        \n\n        \n        \n\n        \n\n        \n        \n\n        \n\n        \n        \n\n        \n\n            \n                                \n                \n                    \n                        "],["body","\n                            \n                        "],["body","\n                        "],["body","\n                            \n                        "],["body","\n                        \n                            "],["body","Light"],["body","\n                            "],["body","Rust"],["body","\n                            "],["body","Coal"],["body","\n                            "],["body","Navy"],["body","\n                            "],["body","Ayu"],["body","\n                        \n                    \n\n                    "],["heading","RUST学习笔记"],["body","\n\n                    \n\n                    \n                \n\n\n                \n                \n\n                \n                    "],["body","\n                        \n\n"],["body","\n"],["body","\n\n"],["headingLink","闭包"],["heading","闭包"],["body","\n\n"],["body","\n"],["body","Rust 的 闭包（closures）是可以保存进变量或作为参数传递给其他函数的匿名函数。"],["body","\n"],["body","\n"],["body","\n"],["body","可以在一个地方创建闭包，然后在不同的上下文中执行闭包运算。"],["body","\n"],["body","\n"],["body","\n"],["body","不同于函数，闭包允许捕获调用者作用域中的值。我们将展示闭包的这些功能如何复用代码和自定义行为。"],["body","\n"],["body","\n\n"],["headingLink","闭包写法"],["heading","闭包写法"],["body","\n"],["body","#![allow(unused)]\nfn main() {\n//函数写法,捕获上下文变量\nfn  add_one_v1   (x: u32) -> u32 { x + 1 }\n//闭包完整写法\nlet add_one_v2 = |x: u32| -> u32 { x + 1 };\n//省略类型\nlet add_one_v3 = |x|             { x + 1 };\n//只有一行时省略大括号\nlet add_one_v4 = |x|               x + 1  ;\n}"],["body","\n"],["headingLink","带有泛型的-fn-traint闭包"],["heading","带有泛型的 Fn traint闭包"],["body","\n"],["body","#![allow(unused)]\nfn main() {\n//泛型 T 的定义是 Fn(u32)->u32, 接受一个int返回一个int. 使用了Fn的闭包\nstruct Cacher<T>\n    where T: Fn(u32) -> u32\n{\n    calculation: T,\n    value: Option<u32>,\n}\n}"],["body","\n"],["headingLink","闭包引用变量的场景"],["heading","闭包引用变量的场景"],["body","\n"],["headingLink","默认是不可变引用"],["heading","默认是不可变引用"],["body","\n"],["body","#![allow(unused)]\nfn main() {\n    let str = String::from(\"士大夫大师傅\");\n\n    let consume = || {\n        println!(\"{}\",str);\n    };\n    consume();\n    consume();\n    consume();\n    consume();\n}"],["body","\n"],["headingLink","可变借用"],["heading","可变借用"],["body","\n"],["body","\n"],["body","只能有一个可变借用"],["body","\n"],["body","\n"],["body","#![allow(unused)]\nfn main() {\npub fn test_closure_4(){\n    let mut str = String::from(\"士大夫大师傅\");\n    use std::mem;\n    let mut consume = || {\n        str.push('a');\n        println!(\"{}\",str);\n    };\n    consume();\n    consume();\n}\n//中途借用会报错\npub fn test_closure_4(){\n    let mut str = String::from(\"士大夫大师傅\");\n    use std::mem;\n    let mut consume = || {\n        str.push('a');\n        println!(\"{}\",str);\n    };\n    consume();\n    println!(\"{}\",str);\n    consume();\n}\n\n//借用完毕后可以重新使用\npub fn test_closure_4(){\n    let mut str = String::from(\"士大夫大师傅\");\n    use std::mem;\n    let mut consume = || {\n        str.push('a');\n        println!(\"{}\",str);\n    };\n    consume();\n    consume();\n    println!(\"{}\",str);\n}\n}"],["body","\n"],["headingLink","移动所有权到闭包"],["heading","移动所有权到闭包"],["body","\n"],["body","#![allow(unused)]\nfn main() {\n//除闭包之外的任何地方都不能访问\npub fn test_closure_4(){\n    let mut str = String::from(\"士大夫大师傅\");\n    use std::mem;\n    let mut consume = move || {\n        str.push('a');\n        println!(\"{}\",str);\n    };\n    consume();\n    consume();\n}\n}"],["body","\n"],["headingLink","从闭包中返回可变引用或不可变引用"],["heading","从闭包中返回可变引用或不可变引用"],["body","\n"],["body","#![allow(unused)]\nfn main() {\n//编译错误\npub fn test_closure_4(){\n    let mut str = String::from(\"士大夫大师傅\");\n    use std::mem;\n    let mut consume =  || -> &String{\n        str.push('a');\n        println!(\"{}\",str);\n        &str\n    };\n    consume();\n}\n}"],["body","\n"],["headingLink","从闭包中返回所有权"],["heading","从闭包中返回所有权"],["body","\n"],["body","\n"],["body","只能调用一次"],["body","\n"],["body","\n"],["body","#![allow(unused)]\nfn main() {\npub fn test_closure_4(){\n    let mut str = String::from(\"士大夫大师傅\");\n    use std::mem;\n    let mut consume = move || -> String{\n        str.push('a');\n        println!(\"{}\",str);\n        str\n    };\n    let string = consume();\n    println!(\"{}\",string);\n    //下面的consume会报错,因为所有权被返回出去了\n    consume();\n}\n}"],["body","\n"],["headingLink","从闭包中放弃所有权"],["heading","从闭包中放弃所有权"],["body","\n"],["body","\n"],["body","只能调用一次"],["body","\n"],["body","\n"],["body","#![allow(unused)]\n\nfn main() {\npub fn test_closure_4(){\n    let str = String::from(\"士大夫大师傅\");\n    use std::mem;\n    let consume = || {\n        println!(\"{}\",str);\n        mem::drop(str);\n    };\n    consume();\n    consume();\n    consume();\n    consume();\n}\n}"],["body","\n"],["headingLink","作为输入参数"],["heading","作为输入参数"],["body","\n\n"],["body","\n"],["body","虽然 Rust 无需类型说明就能在大多数时候完成变量捕获，但在编写函数时，这种模糊写法 是不允许的。"],["body","\n"],["body","\n"],["body","\n"],["body","当以闭包作为输入参数时，必须指出闭包的完整类型，它是通过使用以下 trait 中的一种来指定的"],["body","\n"],["body","\n\n"],["headingLink","闭包捕获环境的三种方式"],["heading","闭包捕获环境的三种方式"],["body","\n\n"],["body","Fn：表示捕获方式为通过引用（&T）的闭包"],["body","\n"],["body","FnMut：表示捕获方式为通过可变引用（&mut T）的闭包"],["body","\n"],["body","FnOnce：表示捕获方式为通过值（T）的闭包"],["body","\n\n"],["headingLink","闭包捕获变量的形式"],["heading","闭包捕获变量的形式"],["body","\n"],["body","在满足使用需求的前提下尽量以限制最多的方式捕获"],["body","\n"],["body","// 该函数将闭包作为参数并调用它。\nfn apply<F>(f: F) where\n    // 闭包没有输入值和返回值。\n    F: FnOnce() {\n    // ^ 试一试：将 `FnOnce` 换成 `Fn` 或 `FnMut`。\n\n    f();\n}\n\n// 输入闭包，返回一个 `i32` 整型的函数。\nfn apply_to_3<F>(f: F) -> i32 where\n    // 闭包处理一个 `i32` 整型并返回一个 `i32` 整型。\n    F: Fn(i32) -> i32 {\n\n    f(3)\n}\n\nfn main() {\n    use std::mem;\n    \n    let greeting = \"hello\";\n    // 不可复制的类型。\n    // `to_owned` 从借用的数据创建有所有权的数据。\n    let mut farewell = \"goodbye\".to_owned();\n\n    // 捕获 2 个变量：通过引用捕获 `greeting`，通过值捕获 `farewell`。\n    let diary = || {\n        // `greeting` 通过引用捕获，故需要闭包是 `Fn`。\n        println!(\"I said {}.\", greeting);\n\n        // 下文改变了 `farewell` ，因而要求闭包通过可变引用来捕获它。\n        // 现在需要 `FnMut`。\n        farewell.push_str(\"!!!\");\n        println!(\"Then I screamed {}.\", farewell);\n        println!(\"Now I can sleep. zzzzz\");\n\n        // 手动调用 drop 又要求闭包通过值获取 `farewell`。\n        // 现在需要 `FnOnce`。\n        mem::drop(farewell);\n    };\n\n    // 以闭包作为参数，调用函数 `apply`。\n    apply(diary);\n\n    // 闭包 `double` 满足 `apply_to_3` 的 trait 约束。\n    let double = |x| 2 * x;\n\n    println!(\"3 doubled: {}\", apply_to_3(double));\n}"],["body","\n"],["headingLink","作为输出参数"],["heading","作为输出参数"],["body","\n\n"],["body","\n"],["body","闭包作为输入参数是可能的，所以返回闭包作为输出参数（output parameter）也应该是 可能的。然而返回闭包类型会有问题，"],["body","\n"],["body","\n"],["body","\n"],["body","因为目前 Rust 只支持返回具体（非泛型）的 类型。按照定义，匿名的闭包的类型是未知的，所以只有使用impl Trait才能返回一个闭包。"],["body","\n"],["body","\n\n"],["body","返回值的合法 trait 和前面的略有不同："],["body","\n\n"],["body","Fn：和前面的一样"],["body","\n"],["body","FnMut：和前面的一样"],["body","\n"],["body","FnOnce：不太一样。总之现在你需要返回 [FnBox][fnbox] 类型，目前该类型还是不稳定的。这个情况估计将来会改进。"],["body","\n\n"],["body","除此之外，还必须使用 move 关键字，它表明所有的捕获都是通过值进行的。这是必须 的，因为在函数退出时，任何通过引用的捕获都被丢弃，在闭包中留下无效的引用。"],["body","\n"],["body","fn create_fn() -> impl Fn() {\n    let text = \"Fn\".to_owned();\n\n    move || println!(\"This is a: {}\", text)\n}\n\nfn create_fnmut() -> impl FnMut() {\n    let text = \"FnMut\".to_owned();\n\n    move || println!(\"This is a: {}\", text)\n}\n\nfn main() {\n    let fn_plain = create_fn();\n    let mut fn_mut = create_fnmut();\n\n    fn_plain();\n    fn_mut();\n}"],["body","\n"],["headingLink","迭代"],["heading","迭代"],["body","\n"],["headingLink","定义"],["heading","定义"],["body","\n"],["body","\n"],["body","迭代器都实现了一个叫做 Iterator 的定义于标准库的 trait"],["body","\n"],["body","\n"],["body","#![allow(unused)]\nfn main() {\npub trait Iterator {\n    type Item;\n\n    fn next(&mut self) -> Option<Self::Item>;\n\n    // 此处省略了方法的默认实现\n}\n}"],["body","\n\n"],["body","type Item 和 Self::Item，他们定义了 trait 的 关联类型（associated type）"],["body","\n"],["body","这个 Item 类型被用作 next 方法的返回值类型"],["body","\n\n"],["headingLink","使用"],["heading","使用"],["body","\n"],["body","#![allow(unused)]\nfn main() {\n#[test]\nfn iterator_demonstration() {\n    let v1 = vec![1, 2, 3];\n\n    let mut v1_iter = v1.iter();\n\n    assert_eq!(v1_iter.next(), Some(&1));\n    assert_eq!(v1_iter.next(), Some(&2));\n    assert_eq!(v1_iter.next(), Some(&3));\n    assert_eq!(v1_iter.next(), None);\n}\n}"],["body","\n"],["body","迭代器变量需要是可变的：在迭代器上调用 next 方法改变了迭代器中用来记录序列位置的状态"],["body","\n"],["headingLink","消费迭代器的方式"],["heading","消费迭代器的方式"],["body","\n"],["body","调用 next 方法的方法被称为 消费适配器（consuming adaptors）"],["body","\n"],["headingLink","sum"],["heading","SUM"],["body","\n"],["body","\n"],["body","　调用 sum 之后不再允许使用 v1_iter 因为调用 sum 时它会获取迭代器的所有权。"],["body","\n"],["body","\n"],["body","#![allow(unused)]\nfn main() {\n#[test]\nfn iterator_sum() {\n    let v1 = vec![1, 2, 3];\n\n    let v1_iter = v1.iter();\n\n    let total: i32 = v1_iter.sum();\n\n    assert_eq!(total, 6);\n}\n}"],["body","\n"],["headingLink","产生其他迭代器"],["heading","产生其他迭代器"],["body","\n"],["body","\n"],["body","迭代器适配器（iterator adaptors）"],["body","\n"],["body","\n\n"],["body","\n"],["body","允许我们将当前迭代器变为不同类型的迭代器"],["body","\n"],["body","\n"],["body","\n"],["body","可以链式调用多个迭代器适配器"],["body","\n"],["body","\n\n"],["body","#![allow(unused)]\nfn main() {\nlet v1: Vec<i32> = vec![1, 2, 3];\n\nv1.iter().map(|x| x + 1);\n\n// 迭代器适配器是惰性的,只有真正消费的了才会执行\n}"],["body","\n"],["headingLink","collect收集"],["heading","collect收集"],["body","\n"],["body","#![allow(unused)]\nfn main() {\nlet v2: Vec<_> = v1.iter().map(|x| x + 1).collect();\n}"],["body","\n"],["headingLink","filter过滤"],["heading","filter过滤"],["body","\n"],["body","#![allow(unused)]\nfn main() {\n    shoes.into_iter()\n        .filter(|s| s.size == shoe_size)\n        .collect()\n}"],["body","\n"],["headingLink","自定义迭代器"],["heading","自定义迭代器"],["body","\n"],["headingLink","第一步定义结构体"],["heading","第一步定义结构体"],["body","\n"],["body","#![allow(unused)]\nfn main() {\nstruct Counter{\n    counter:i32,\n    range:i32\n}\n}"],["body","\n"],["headingLink","第二步实现构造函数"],["heading","第二步实现构造函数"],["body","\n"],["body","#![allow(unused)]\nfn main() {\nimpl Counter{\n    fn new(range:i32)->Counter{\n        Counter{\n            counter:0,\n            range\n        }\n    }\n}\n}"],["body","\n"],["headingLink","第三步实现迭代器"],["heading","第三步实现迭代器"],["body","\n"],["body","#![allow(unused)]\nfn main() {\nimpl Iterator for Counter{\n    type Item = i32;\n\n    fn next(&mut self) -> Option<Self::Item> {\n        if self.counter >= self.range {\n            None\n        }else{\n            self.counter+=1;\n            Some(self.counter)\n        }\n    }\n}\n}"],["body","\n"],["headingLink","第四步使用"],["heading","第四步使用"],["body","\n"],["body","#![allow(unused)]\nfn main() {\n    let counter1 = Counter::new(10);\n    let counter2 = Counter::new(11);\n    let counter3 = Counter::new(12);\n\n    counter1.zip(counter2.skip(1)).zip(counter3.skip(2)).for_each(|((x,y),z)|{\n        println!(\"x={},y={},z={}\",x,y,z);\n    });\n}"],["body","\n"],["headingLink","使用迭代器读取命令行"],["heading","使用迭代器读取命令行"],["body","\n"],["body","#![allow(unused)]\nfn main() {\nuse std::env;\n\npub fn test_iter() {\n    env::args().for_each(|e|{\n        println!(\"{}\",e)\n    })\n}\n}"],["body","\n"],["body","#![allow(unused)]\nfn main() {\n // 函数式的写法\n    let sum_of_squared_odd_numbers: u32 =\n        (0..).map(|n| n * n)             // 所有自然数取平方\n             .take_while(|&n| n < upper) // 取小于上限的\n             .filter(|&n| is_odd(n))     // 取奇数\n             .fold(0, |sum, i| sum + i); // 最后加起来\n    println!(\"functional style: {}\", sum_of_squared_odd_numbers);\n}"],["body","\n\n\n\n                    "],["body","\n\n                    \n                \n            \n\n            \n\n        \n\n\n\n\n        \n\n\n\n        \n        \n        \n\n        \n\n\n    \n    \n\n"]],[["_relative_fp","9rust面向对象特性.html"],["title","rust面向对象特性.md - RUST学习笔记"],["body","\n    \n        \n        \n\n        \n        \n\n        \n        \n\n        \n\n        \n        \n\n        \n\n        \n        \n\n        \n\n            \n                                \n                \n                    \n                        "],["body","\n                            \n                        "],["body","\n                        "],["body","\n                            \n                        "],["body","\n                        \n                            "],["body","Light"],["body","\n                            "],["body","Rust"],["body","\n                            "],["body","Coal"],["body","\n                            "],["body","Navy"],["body","\n                            "],["body","Ayu"],["body","\n                        \n                    \n\n                    "],["heading","RUST学习笔记"],["body","\n\n                    \n\n                    \n                \n\n\n                \n                \n\n                \n                    "],["body","\n                        \n\n"],["body","\n"],["body","\n\n"],["headingLink","简述"],["heading","简述"],["body","\n"],["body","关于一个语言被称为面向对象所需的功能，Rust 被很多不同的编程范式影响，包括面向对象编程，函数式编程的特性"],["body","\n"],["headingLink","对象包含数据和行为"],["heading","对象包含数据和行为"],["body","\n"],["body","面向对象的程序是由对象组成的。一个 对象 包含数据和操作这些数据的过程。这些过程通常被称为 方法 或 操作。"],["body","\n"],["body","在这个定义下，Rust 是面向对象的：结构体和枚举包含数据而 impl 块提供了在结构体和枚举之上的方法。"],["body","\n"],["body","虽然带有方法的结构体和枚举并不被 称为 对象，但是他们提供了与对象相同的功能，"],["body","\n"],["headingLink","封装隐藏了实现细节"],["heading","封装隐藏了实现细节"],["body","\n"],["body","对象的实现细节不能被使用对象的代码获取到，所以唯一与对象交互的方式是通过对象提供的公有 API"],["body","\n"],["body","使用对象的代码无法深入到对象内部并直接改变数据或者行为"],["body","\n"],["body","封装使得改变和重构对象的内部时无需改变使用对象的代码"],["body","\n"],["body","可以使用 pub 关键字来决定模块、类型、函数和方法是公有的，而默认情况下其他一切都是私有的"],["body","\n"],["body","#![allow(unused)]\nfn main() {\npub struct AveragedCollection {\n    list: Vec<i32>,\n    average: f64,\n}\n}"],["body","\n"],["body","注意，结构体自身被标记为 pub，这样其他代码就可以使用这个结构体，但是在结构体内部的字段仍然是私有的。这是非常重要的，因为我们希望保证变量被增加到列表或者被从列表删除时，也会同时更新平均值。可以通过在结构体上实现 add、remove 和 average 方法来做到这一点，"],["body","\n"],["body","#![allow(unused)]\n\nfn main() {\nimpl AveragedCollection {\n    pub fn add(&mut self, value: i32) {\n        self.list.push(value);\n        self.update_average();\n    }\n\n    pub fn remove(&mut self) -> Option<i32> {\n        let result = self.list.pop();\n        match result {\n            Some(value) => {\n                self.update_average();\n                Some(value)\n            },\n            None => None,\n        }\n    }\n\n    pub fn average(&self) -> f64 {\n        self.average\n    }\n\n    fn update_average(&mut self) {\n        let total: i32 = self.list.iter().sum();\n        self.average = total as f64 / self.list.len() as f64;\n    }\n}\n}"],["body","\n"],["headingLink","继承作为类型系统与代码共享"],["heading","继承，作为类型系统与代码共享"],["body","\n\n"],["body","\n"],["body","一个对象可以定义为继承另一个对象的定义，这使其可以获得父对象的数据和行为，而无需重新定义。"],["body","\n"],["body","\n"],["body","\n"],["body","如果一个语言必须有继承才能被称为面向对象语言的话，那么 Rust 就不是面向对象的"],["body","\n"],["body","\n"],["body","\n"],["body","选择继承有两个主要的原因。"],["body","\n\n"],["body","第一个是为了重用代码：一旦为一个类型实现了特定行为，继承可以对一个不同的类型重用这个实现,相反 Rust 代码可以使用默认 trait 方法实现来进行共享"],["body","\n"],["body","第二个使用继承的原因与类型系统有关：表现为子类型可以用于父类型被使用的地方。这也被称为 多态（polymorphism），这意味着如果多种对象共享特定的属性，则可以相互替代使用。"],["body","\n\n"],["body","\n\n"],["body","为什么不用继承"],["body","\n\n"],["body","\n"],["body","近来继承作为一种语言设计的解决方案在很多语言中失宠了，因为其时常带有共享多于所需的代码的风险。"],["body","\n"],["body","\n"],["body","\n"],["body","子类不应总是共享其父类的所有特征，但是继承却始终如此。如此会使程序设计更为不灵活，并引入无意义的子类方法调用，或由于方法实际并不适用于子类而造成错误的可能性。某些语言还只允许子类继承一个父类，进一步限制了程序设计的灵活性。"],["body","\n"],["body","\n\n"],["body","因为这些原因，Rust 选择了一个不同的途径，使用 trait 对象而不是继承。让我们看一下 Rust 中的 trait 对象是如何实现多态的。"],["body","\n"],["headingLink","为使用不同类型的值而设计的-trait-对象"],["heading","为使用不同类型的值而设计的 trait 对象"],["body","\n"],["headingLink","gui的component-与draw设计"],["heading","GUI的Component 与Draw设计"],["body","\n"],["headingLink","状态模式的设计"],["heading","状态模式的设计"],["body","\n\n\n\n                    "],["body","\n\n                    \n                \n            \n\n            \n\n        \n\n\n\n\n        \n\n\n\n        \n        \n        \n\n        \n\n\n    \n    \n\n"]],[["_relative_fp","1常见编程概念.html"],["title","常见编程概念.md - RUST学习笔记"],["body","\n    \n        \n        \n\n        \n        \n\n        \n        \n\n        \n\n        \n        \n\n        \n\n        \n        \n\n        \n\n            \n                                \n                \n                    \n                        "],["body","\n                            \n                        "],["body","\n                        "],["body","\n                            \n                        "],["body","\n                        \n                            "],["body","Light"],["body","\n                            "],["body","Rust"],["body","\n                            "],["body","Coal"],["body","\n                            "],["body","Navy"],["body","\n                            "],["body","Ayu"],["body","\n                        \n                    \n\n                    "],["heading","RUST学习笔记"],["body","\n\n                    \n\n                    \n                \n\n\n                \n                \n\n                \n                    "],["body","\n                        \n\n"],["body","\n"],["body","\n\n"],["headingLink","变量"],["heading","变量"],["body","\n"],["headingLink","变量语法"],["heading","变量语法"],["body","\n"],["body","#![allow(unused)]\nfn main() {\n// 自动类型推断语法\nlet x = 5;\n\n//完整语法 ,指定数据类型\nlet y: f32 = 3.0; // f32\n}"],["body","\n"],["headingLink","变量与可变性"],["heading","变量与可变性"],["body","\n\n"],["body","在Rust 中 变量默认是不可改变的（immutable）"],["body","\n"],["body","不能对不可变变量 x 二次赋值"],["body","\n"],["body","使用 mut 声明可变变量 let mut x = 5;"],["body","\n\n"],["headingLink","变量和常量"],["heading","变量和常量"],["body","\n\n"],["body","常量是绑定到一个名称的不允许改变的值"],["body","\n"],["body","常量不光默认不能变，它总是不能变。"],["body","\n"],["body","声明常量使用 const 关键字而不是 let，并且 必须 注明值的类型"],["body","\n"],["body","常量只能被设置为常量表达式，而不能是函数调用的结果，或任何其他只能在运行时计算出的值。"],["body","\n"],["body","example: const MAX_POINTS: u32 = 100_000;"],["body","\n\n"],["headingLink","隐藏shadowing"],["heading","隐藏（Shadowing）"],["body","\n\n"],["body","我们可以定义一个与之前变量同名的新变量，而新变量会 隐藏 之前的变量"],["body","\n"],["body","这意味着使用这个变量时会看到第二个值。可以用相同变量名称来隐藏一个变量，以及重复使用 let 关键字来多次隐藏，"],["body","\n"],["body","隐藏使我们不必使用不同的名字"],["body","\n"],["body","example"],["body","\n\n"],["body","fn main() {\n    let x = 5;\n\n    let x = x + 1;\n\n    let x = x * 2;\n\n    println!(\"The value of x is: {}\", x);\n}"],["body","\n"],["headingLink","数据类型"],["heading","数据类型"],["body","\n"],["body","\n"],["body","在 Rust 中，每一个值都属于某一个 数据类型（data type），两类数据类型子集：标量（scalar）和复合（compound）。"],["body","\n"],["body","\n"],["body","Rust 是 静态类型（statically typed）语言"],["body","\n"],["body","也就是说在编译时就必须知道所有变量的类型。根据值及其使用方式，编译器通常可以推断出我们想要用的类型。当多种类型均有可能时"],["body","\n"],["body","必须增加类型注解 let guess: u32 = \"42\".parse().expect(\"Not a number!\");"],["body","\n"],["headingLink","标量类型"],["heading","标量类型"],["body","\n"],["body","Rust 有四种基本的标量类型：整型、浮点型、布尔类型 字符类型"],["body","\n"],["headingLink","整型"],["heading","整型"],["body","\n"],["body","长度"],["body","有符号"],["body","无符号"],["body","\n"],["body","8-bit"],["body","i8"],["body","u8"],["body","\n"],["body","16-bit"],["body","i16"],["body","u16"],["body","\n"],["body","32-bit"],["body","i32"],["body","u32"],["body","\n"],["body","64-bit"],["body","i64"],["body","u64"],["body","\n"],["body","128-bit"],["body","i128"],["body","u128"],["body","\n"],["body","arch"],["body","isize"],["body","usize"],["body","\n\n\n"],["body","isize 和 usize 类型依赖运行程序的计算机架构：64 位架构上它们是 64 位的， 32 位架构上它们是 32 位的。"],["body","\n"],["headingLink","整型字面量"],["heading","整型字面量"],["body","\n"],["body","数字字面值"],["body","例子"],["body","\n"],["body","Decimal (十进制)"],["body","98_222"],["body","\n"],["body","Hex (十六进制)"],["body","0xff"],["body","\n"],["body","Octal (八进制)"],["body","0o77"],["body","\n"],["body","Binary (二进制)"],["body","0b1111_0000"],["body","\n"],["body","Byte (单字节字符)(仅限于u8)"],["body","b'A'"],["body","\n\n\n"],["body","Rust 数字类型默认是 i32：它通常是最快的，甚至在 64 位系统上也是。isize 或 usize 主要作为某些集合的索引。"],["body","\n"],["headingLink","整型溢出"],["heading","整型溢出"],["body","\n"],["body","比方说有一个 u8 ，它可以存放从零到 255 的值。那么当你将其修改为 256 时会发生什么呢？这被称为 “整型溢出”（“integer overflow” ），关于这一行为 Rust 有一些有趣的规则。当在 debug 模式编译时，Rust 检查这类问题并使程序 panic，这个术语被 Rust 用来表明程序因错误而退出。第九章 “panic! 与不可恢复的错误” 部分会详细介绍 panic。"],["body","\n"],["body","在 release 构建中，Rust 不检测溢出，相反会进行一种被称为二进制补码包装（two’s complement wrapping）的操作。简而言之，256 变成 0，257 变成 1，依此类推。依赖整型溢出被认为是一种错误，即便可能出现这种行为。如果你确实需要这种行为，标准库中有一个类型显式提供此功能，Wrapping。"],["body","\n"],["headingLink","浮点"],["heading","浮点"],["body","\n"],["body","两个原生的 浮点数（floating-point numbers）类型，它们是带小数点的数字。Rust 的浮点数类型是 f32 和 f64，分别占 32 位和 64 位。默认类型是 f64，因为在现代 CPU 中，它与 f32 速度几乎一样，不过精度更高。"],["body","\n"],["headingLink","布尔类型"],["heading","布尔类型"],["body","\n"],["body"," let f: bool = false; // 显式指定类型注解\n"],["body","\n"],["headingLink","字符类型"],["heading","字符类型"],["body","\n"],["body","fn main() {\n    let c = 'z';\n    let z = 'ℤ';\n    let heart_eyed_cat = '😻';\n}\n"],["body","\n"],["body","Rust 的 char 类型的大小为四个字节(four bytes)，并代表了一个 Unicode 标量值（Unicode Scalar Value），这意味着它可以比 ASCII 表示更多内容。在 Rust 中，拼音字母（Accented letters），中文、日文、韩文等字符，emoji（绘文字）以及零长度的空白字符都是有效的 char 值。Unicode 标量值包含从 U+0000 到 U+D7FF 和 U+E000 到 U+10FFFF 在内的值。"],["body","\n"],["headingLink","复合类型"],["heading","复合类型"],["body","\n"],["body","\n"],["body","可以将多个值组合成一个类型。Rust 有两个原生的复合类型：元组（tuple）和数组（array）。"],["body","\n"],["body","\n"],["headingLink","元组类型"],["heading","元组类型"],["body","\n\n"],["body","元组长度固定：一旦声明，其长度不会增大或缩小。"],["body","\n"],["body","圆括号中的逗号分隔的值列表来创建一个元组"],["body","\n"],["body","元组中的每一个位置都有一个类型，而且这些不同值的类型也不必是相同的"],["body","\n\n"],["body","元组解构取值"],["body","\n"],["body","#![allow(unused)]\nfn main() {\nlet tup = (500, 6.4, 1);\n\n    let (x, y, z) = tup;\n\n    println!(\"The value of y is: {}\", y);\n}"],["body","\n"],["body",". 号取值"],["body","\n"],["body","#![allow(unused)]\nfn main() {\n// 也可以使用点号（.）后跟值的索引来直接访问它们\n let x: (i32, f64, u8) = (500, 6.4, 1);\n\n    let five_hundred = x.0;\n\n    let six_point_four = x.1;\n\n    let one = x.2;\n}"],["body","\n"],["headingLink","数组类型"],["heading","数组类型"],["body","\n"],["body","\n"],["body","数组中的每个元素的类型必须相同"],["body","\n"],["body","\n"],["body","#![allow(unused)]\nfn main() {\nlet a = [1, 2, 3, 4, 5];\nlet a: [i32; 5] = [1, 2, 3, 4, 5];\n// let a = [elea-value; array-length]\nlet a = [3; 5];\n}"],["body","\n"],["headingLink","函数"],["heading","函数"],["body","\n\n"],["body","main 函数，它是很多程序的入口点"],["body","\n"],["body","fn 关键字，它用来声明新函数"],["body","\n"],["body","Rust 代码中的函数和变量名使用 snake case 规范风格。在 snake case 中，所有字母都是小写并使用下划线分隔单词。这是一个包含函数定义示例的程序："],["body","\n\n"],["headingLink","函数参数"],["heading","函数参数"],["body","\n"],["body","#![allow(unused)]\nfn main() {\nfn another_function(x: i32, y: i32) {\n    println!(\"The value of x is: {}\", x);\n    println!(\"The value of y is: {}\", y);\n}\n}"],["body","\n"],["headingLink","包含语句和表达式的函数体"],["heading","包含语句和表达式的函数体"],["body","\n\n"],["body","\n"],["body","语句不返回值"],["body","\n"],["body","#![allow(unused)]\nfn main() {\n let x = (let y = 6);\n}"],["body","\n"],["body","\n"],["body","\n"],["body","表达式会计算出一些值  并且你将编写的大部分 Rust 代码是由表达式组成的。"],["body","\n\n"],["body","\n"],["body","考虑一个简单的数学运算，比如 5 + 6，这是一个表达式并计算出值 11。"],["body","\n"],["body","\n"],["body","\n"],["body","表达式可以是语句的一部分：在示例 3-1 中，语句 let y = 6; 中的 6 是一个表达式，它计算出的值是 6。"],["body","\n"],["body","\n"],["body","\n"],["body","函数调用是一个表达式。"],["body","\n"],["body","\n"],["body","\n"],["body","宏调用是一个表达式。"],["body","\n"],["body","\n"],["body","\n"],["body","我们用来创建新作用域的大括号（代码块），{}，也是一个表达式，例如："],["body","\n"],["body","#![allow(unused)]\nfn main() {\n let y = {\n        let x = 3;\n        x + 1\n    };\n}"],["body","\n"],["body","\n\n"],["body","\n\n"],["headingLink","函数返回值"],["heading","函数返回值"],["body","\n"],["body","fn five() -> i32 {\n    5\n}\nfn main() {\n    let x = five();\n    println!(\"The value of x is: {}\", x);\n}"],["body","\n"],["body","#![allow(unused)]\nfn main() {\n//x+1 因为加上了分号 从表达式 变成了 语句\nfn plus_one(x: i32) -> i32 {\n    x + 1;\n}\n如果函数没有返回值,则 使用空元组 () 返回\n}"],["body","\n"],["headingLink","控制流"],["heading","控制流"],["body","\n"],["headingLink","if"],["heading","if"],["body","\n"],["body","\n"],["body","表达式 必须 是 bool 值"],["body","\n"],["body","\n"],["body","    if number < 5 {\n        println!(\"condition was true\");\n    } else {\n        println!(\"condition was false\");\n    }\n"],["body","\n"],["headingLink","if同时也是一个表达式"],["heading","if同时也是一个表达式"],["body","\n"],["body","\n"],["body","if 和 else 分支的值类型必须相同"],["body","\n"],["body","\n"],["body","#![allow(unused)]\nfn main() {\nlet number = if condition {\n        5\n    } else {\n        6\n    };\n\n//error_example\n  let condition = true;\n\n    let number = if condition {\n        5\n    } else {\n        \"six\"\n    };\n}"],["body","\n"],["headingLink","循环"],["heading","循环"],["body","\n"],["headingLink","loop"],["heading","Loop"],["body","\n"],["body","#![allow(unused)]\n\nfn main() {\nloop {\n        println!(\"again!\");\n    }\n\n//循环返回,loop也是一个表达式\n let result = loop {\n        counter += 1;\n\n        if counter == 10 {\n            break counter * 2;\n        }\n    };\n\n\n}"],["body","\n"],["headingLink","while"],["heading","while"],["body","\n"],["body","#![allow(unused)]\nfn main() {\n let mut number = 3;\n\n    while number != 0 {\n        println!(\"{}!\", number);\n\n        number = number - 1;\n    }\n}"],["body","\n"],["body","#![allow(unused)]\nfn main() {\n  let a = [10, 20, 30, 40, 50];\n    let mut index = 0;\n\n    while index < 5 {\n        println!(\"the value is: {}\", a[index]);\n\n        index = index + 1;\n    }\n}"],["body","\n"],["headingLink","for迭代"],["heading","For迭代"],["body","\n"],["body","fn main() {\n    let a = [10, 20, 30, 40, 50];\n\n    for element in a.iter() {\n        println!(\"the value is: {}\", element);\n    }\n}"],["body","\n"],["body","反转"],["body","\n"],["body","fn main() {\n    for number in (1..4).rev() {\n        println!(\"{}!\", number);\n    }\n    println!(\"LIFTOFF!!!\");\n}"],["body","\n\n\n\n                    "],["body","\n\n                    \n                \n            \n\n            \n\n        \n\n\n\n\n        \n\n\n\n        \n        \n        \n\n        \n\n\n    \n    \n\n"]],[["_relative_fp","10rust指针.html"],["title","rust指针.md - RUST学习笔记"],["body","\n    \n        \n        \n\n        \n        \n\n        \n        \n\n        \n\n        \n        \n\n        \n\n        \n        \n\n        \n\n            \n                                \n                \n                    \n                        "],["body","\n                            \n                        "],["body","\n                        "],["body","\n                            \n                        "],["body","\n                        \n                            "],["body","Light"],["body","\n                            "],["body","Rust"],["body","\n                            "],["body","Coal"],["body","\n                            "],["body","Navy"],["body","\n                            "],["body","Ayu"],["body","\n                        \n                    \n\n                    "],["heading","RUST学习笔记"],["body","\n\n                    \n\n                    \n                \n\n\n                \n                \n\n                \n                    "],["body","\n                        \n\n"],["body","\n"],["body","\n\n"],["headingLink","智能指针简介"],["heading","智能指针简介"],["body","\n\n"],["body","\n"],["body","指针 （pointer）是一个包含内存地址的变量"],["body","\n"],["body","\n"],["body","\n"],["body","这个地址 \"引用\"，或  “指向”（points at）一些其他数据"],["body","\n"],["body","\n"],["body","\n"],["body","Rust 中最常见的指针是 引用（reference）引用以 & 符号为标志并借用了他们所指向的值"],["body","\n"],["body","\n"],["body","\n"],["body","除了引用数据没有任何其他特殊功能。它们也没有任何额外开销，所以应用得最多。"],["body","\n"],["body","\n"],["body","\n"],["body","智能指针（smart pointers）是一类数据结构，他们的表现类似指针，但是拥有额外的元数据和功能"],["body","\n"],["body","\n"],["body","\n"],["body","智能指针的概念并不为 Rust 所独有；其起源于 C++ 并存在于其他语言中"],["body","\n"],["body","\n"],["body","\n"],["body","Rust 标准库中不同的智能指针提供了多于引用的额外功能"],["body","\n"],["body","\n"],["body","\n"],["body","在 Rust 中，普通引用和智能指针的一个额外的区别是  引用是一类只借用数据的指针,智能指针 拥有 他们指向的数据。"],["body","\n"],["body","\n"],["body","\n"],["body","实际上本书中已经出现过一些智能指针，比如第八章的 String 和 Vec<T>，虽然当时我们并不这么称呼它们。这些类型都属于智能指针因为它们拥有一些数据并允许你修改它们"],["body","\n"],["body","\n"],["body","\n"],["body","它们也带有元数据（比如他们的容量）和额外的功能或保证（String 的数据总是有效的 UTF-8 编码）。"],["body","\n"],["body","\n"],["body","\n"],["body","智能指针通常使用结构体实现。智能指针区别于常规结构体的显著特性在于其实现了 Deref 和 Drop trait"],["body","\n"],["body","\n"],["body","\n"],["body","Deref trait 允许智能指针结构体实例表现的像引用一样，这样就可以编写既用于引用、又用于智能指针的代码"],["body","\n"],["body","\n"],["body","\n"],["body","Drop trait 允许我们自定义当智能指针离开作用域时运行的代码。本章会讨论这些 trait 以及为什么对于智能指针来说他们很重要。"],["body","\n"],["body","\n"],["body","\n"],["body","常见的智能指针"],["body","\n"],["body","\n\n\n"],["body","Box<T>，用于在堆上分配值"],["body","\n"],["body","Rc<T>，一个引用计数类型，其数据可以有多个所有者"],["body","\n"],["body","Ref<T> 和 RefMut<T>，通过 RefCell<T> 访问。（ RefCell<T> 是一个在运行时而不是在编译时执行借用规则的类型）。"],["body","\n\n\n"],["body","另外我们会涉及 内部可变性（interior mutability）模式，这是不可变类型暴露出改变其内部值的 API"],["body","\n"],["body","引用循环（reference cycles）会如何泄漏内存，以及如何避免。"],["body","\n\n"],["headingLink","最简单的智能指针boxt"],["heading","最简单的智能指针：Box<T>"],["body","\n"],["headingLink","简介"],["heading","简介"],["body","\n\n"],["body","\n"],["body","最简单直接的智能指针是 box，其类型是 Box<T>"],["body","\n"],["body","\n"],["body","\n"],["body","box 允许你将一个值放在堆上而不是栈上。"],["body","\n"],["body","\n"],["body","\n"],["body","留在栈上的则是指向堆数据的指针"],["body","\n"],["body","\n\n"],["body","除了数据被储存在堆上而不是栈上之外，box 没有性能损失。不过也没有很多额外的功能。它们多用于如下场景："],["body","\n\n"],["body","\n"],["body","当有一个在编译时未知大小的类型，而又想要在需要确切大小的上下文中使用这个类型值的时候"],["body","\n"],["body","box 允许创建递归类型"],["body","\n"],["body","\n"],["body","\n"],["body","当有大量数据并希望在确保数据不被拷贝的情况下转移所有权的时候"],["body","\n"],["body","转移大量数据的所有权可能会花费很长的时间，因为数据在栈上进行了拷贝。为了改善这种情况下的性能，可以通过 box 将这些数据储存在堆上。接着，只有少量的指针数据在栈上被拷贝"],["body","\n"],["body","\n"],["body","\n"],["body","当希望拥有一个值并只关心它的类型是否实现了特定 trait 而不是其具体类型的时候"],["body","\n"],["body","trait 对象（trait object）"],["body","\n"],["body","\n\n"],["headingLink","box-允许创建递归类型"],["heading","Box 允许创建递归类型"],["body","\n"],["headingLink","简介-1"],["heading","简介"],["body","\n\n"],["body","\n"],["body","Rust 需要在编译时知道类型占用多少空间。一种无法在编译时知道大小的类型是 递归类型（recursive type）"],["body","\n"],["body","\n"],["body","\n"],["body","其值的一部分可以是相同类型的另一个值。这种值的嵌套理论上可以无限的进行下去，"],["body","\n"],["body","\n"],["body","\n"],["body","所以 Rust 不知道递归类型需要多少空间。"],["body","\n"],["body","\n"],["body","\n"],["body","不过 box 有一个已知的大小，所以通过在循环类型定义中插入 box，就可以创建递归类型了。"],["body","\n"],["body","\n\n"],["body","enum List {\n    Cons(i32, List),\n    Nil,\n}\n\nuse crate::List::{Cons, Nil};\nfn main() {\n    let list = Cons(1, Cons(2, Cons(3, Nil)));\n}"],["body","\n"],["headingLink","计算非递归类型的大小"],["heading","计算非递归类型的大小"],["body","\n"],["body","#![allow(unused)]\n\nfn main() {\nenum Message {\n    Quit,\n    Move { x: i32, y: i32 },\n    Write(String),\n    ChangeColor(i32, i32, i32),\n}\n}"],["body","\n"],["body","当 Rust 需要知道要为 Message 值分配多少空间时，它可以检查每一个成员并发现 Message::Quit 并不需要任何空间，Message::Move 需要足够储存两个 i32 值的空间，依此类推。因此，Message 值所需的空间等于储存其最大成员的空间大小。"],["body","\n"],["headingLink","使用-boxt给递归类型一个已知的大小"],["heading","使用 Box<T>给递归类型一个已知的大小"],["body","\n"],["body","enum List {\n    Cons(i32, Box<List>),\n    Nil,\n}\n\nuse crate::List::{Cons, Nil};\n\nfn main() {\n    let list = Cons(1,\n        Box::new(Cons(2,\n            Box::new(Cons(3,\n                Box::new(Nil))))));\n}"],["body","\n"],["headingLink","通过-deref-trait-将智能指针当作常规引用处理"],["heading","通过 Deref trait 将智能指针当作常规引用处理"],["body","\n"],["body","\n"],["body","实现 Deref trait 允许我们重载 解引用运算符（dereference operator）*（与乘法运算符或通配符相区别）"],["body","\n"],["body","\n"],["body","\n"],["body","通过这种方式实现 Deref trait 的智能指针可以被当作常规引用来对待，"],["body","\n"],["body","\n\n"],["body","让我们首先看看解引用运算符如何处理常规引用"],["body","\n"],["body","接着尝试定义我们自己的类似 Box<T> 的类型并看看为何解引用运算符不能像引用一样工作"],["body","\n"],["body","我们会探索如何实现 Deref trait 使得智能指针以类似引用的方式工作变为可能"],["body","\n"],["body","最后，我们会讨论 Rust 的 Deref 强制转换（deref coercions）功能以及它是如何处理引用或智能指针的"],["body","\n\n"],["body","我们将要构建的 MyBox<T> 类型与真正的 Box<T> 有一个很大的区别"],["body","\n\n"],["body","我们的版本不会在堆上储存数据"],["body","\n"],["body","这个例子重点关注 Deref，所以其数据实际存放在何处，相比其类似指针的行为来说不算重要。"],["body","\n\n"],["headingLink","通过解引用运算符追踪指针的值"],["heading","通过解引用运算符追踪指针的值"],["body","\n"],["body","\n"],["body","常规引用是一个指针类型，一种理解指针的方式是将其看成指向储存在其他某处值的箭头"],["body","\n"],["body","\n"],["body","fn main() {\n    let x = 5;\n    let y = &x;\n\n    assert_eq!(5, x);\n    assert_eq!(5, *y);\n}"],["body","\n"],["body","不能 将 5 与 y比较 因为 y是 引用类型（指针类型）"],["body","\n"],["body","6 |   assert_eq!(5, y);\n\n |   ^^^^^^^^^^^^^^^^^ no implementation for `{integer} == &{integer}`\n"],["body","\n"],["headingLink","像引用一样使用-boxt"],["heading","像引用一样使用 Box<T>"],["body","\n"],["body","fn main() {\n    let x = 5;\n    let y = Box::new(x);\n\n    assert_eq!(5, x);\n    assert_eq!(5, *y);\n}"],["body","\n"],["headingLink","自定义智能指针"],["heading","自定义智能指针"],["body","\n"],["body","#![allow(unused)]\n\nfn main() {\nuse std::ops::Deref;\n\n\nimpl<T> Deref for MyBox<T> {\n    type Target = T;\n\n    fn deref(&self) -> &T {\n        //返回内部数据的引用\n        &self.0\n    }\n}\n\n//等价于\n*(y.deref()) \n//等价于\n*(&T)\n//等价于\nT\n}"],["body","\n\n"],["body","\n"],["body","deref方法返回值的引用，以及 *(y.deref()) 括号外边的普通解引用仍为必须的原因在于所有权。"],["body","\n"],["body","\n"],["body","\n"],["body","如果 deref 方法直接返回值而不是值的引用，其值（的所有权）将被移出 self"],["body","\n"],["body","\n"],["body","\n"],["body","在这里以及大部分使用解引用运算符的情况下我们并不希望获取 MyBox<T> 内部值的所有权"],["body","\n"],["body","\n"],["body","\n"],["body","每次当我们在代码中使用 * 时， * 运算符都被替换成了先调用 deref 方法再接着使用 * 解引用的操作，且只会发生一次，不会对 * 操作符无限递归替换"],["body","\n"],["body","\n"],["body","\n"],["body","解引用出上面 i32 类型的值就停止了"],["body","\n"],["body","\n\n"],["headingLink","函数和方法的隐式-deref-强制转换"],["heading","函数和方法的隐式 Deref 强制转换"],["body","\n"],["body","\n"],["body","Deref 强制转换（deref coercions）是 Rust 在函数或方法传参上的一种便利"],["body","\n"],["body","\n\n"],["body","\n"],["body","其将实现了 Deref 的类型的引用  转换为原始类型"],["body","\n"],["body","\n"],["body","\n"],["body","通过 Deref 所能够转换的类型的引用"],["body","\n"],["body","\n"],["body","\n"],["body","当这种特定类型的引用作为实参传递给和形参类型不同的函数或方法时，Deref 强制转换将自动发生，这时会有一系列的 deref 方法被调用，把我们提供的类型转换成了参数所需的类型。"],["body","\n"],["body","\n\n"],["body","Deref 强制转换的加入使得 Rust 程序员编写函数和方法调用时无需增加过多显式使用 & 和 * 的引用和解引用。这个功能也使得我们可以编写更多同时作用于引用或智能指针的代码。"],["body","\n"],["headingLink","example"],["heading","example"],["body","\n"],["body","\n"],["body","对于 str的解引用"],["body","\n"],["body","\n"],["body","mod smart_box;\nuse smart_box::MyBox;\nfn main() {\n    let my_box = MyBox::new(1);\n    let my_box1 = MyBox::new(String::from(\"xjq\"));\n    //普通手动解引用\n\t\t//*mybox1 为 String\n    \t//**mybox1 为 str\n    \t//&**mybox1 为 &str\n    print_str(&**my_box1);\n    \n    //自动强制解引用\n    print_str(&my_box1);\n}\n\nfn print_str(str: &str){\n    print!(\"{}\",str);\n}\nlet my_box1 = MyBox::new(String::from(\"xjq\"));\n\nprint_str(&**my_box1);"],["body","\n\n"],["body","Rust 可以通过 deref 调用将 &MyBox<String> 变为 &String"],["body","\n"],["body","Rust 再次调用 deref 将 &String 变为 &str"],["body","\n\n"],["body","fn main() {\n    let m = MyBox::new(String::from(\"Rust\"));\n    hello(&(*m)[..]);\n}"],["body","\n"],["headingLink","deref-强制转换如何与可变性交互"],["heading","Deref 强制转换如何与可变性交互"],["body","\n\n"],["body","\n"],["body","类似于如何使用 Deref trait 重载不可变引用的 * 运算符"],["body","\n"],["body","\n"],["body","\n"],["body","Rust 提供了 DerefMut trait 用于重载可变引用的 * 运算符。"],["body","\n"],["body","\n\n"],["body","Rust 在发现类型和 trait 实现满足三种情况时会进行 Deref 强制转换："],["body","\n\n"],["body","当 T: Deref<Target=U> 时从 &T 到 &U。"],["body","\n"],["body","当 T: DerefMut<Target=U> 时从 &mut T 到 &mut U。"],["body","\n"],["body","当 T: Deref<Target=U> 时从 &mut T 到 &U。"],["body","\n\n"],["body","将一个可变引用转换为不可变引用永远也不会打破借用规则。"],["body","\n"],["headingLink","使用-drop-trait-运行清理代码"],["heading","使用 Drop Trait 运行清理代码"],["body","\n\n"],["body","\n"],["body","对于智能指针模式来说第二个重要的 trait 是 Drop"],["body","\n"],["body","\n"],["body","\n"],["body","其允许我们在值要离开作用域时执行一些代码"],["body","\n"],["body","\n"],["body","\n"],["body","可以为任何类型提供 Drop trait 的实现"],["body","\n"],["body","\n"],["body","\n"],["body","同时所指定的代码被用于释放类似于文件或网络连接的资源"],["body","\n"],["body","\n\n"],["body","我们在智能指针上下文中讨论 Drop 是因为其功能几乎总是用于实现智能指针"],["body","\n\n"],["body","Drop trait 包含在 prelude 中"],["body","\n"],["body","drop 函数体是放置任何当类型实例离开作用域时期望运行的逻辑的地方"],["body","\n\n"],["headingLink","通过-stdmemdrop-提早丢弃值"],["heading","通过 std::mem::drop 提早丢弃值"],["body","\n\n"],["body","整个 Drop trait 存在的意义在于其是自动处理的"],["body","\n"],["body","你可能希望强制运行 drop 方法来释放锁以便作用域中的其他代码可以获取锁"],["body","\n"],["body","Rust 并不允许我们主动调用 Drop trait 的 drop 方法；"],["body","\n"],["body","当我们希望在作用域结束之前就强制释放变量的话，我们应该使用的是由标准库提供的 std::mem::drop。"],["body","\n"],["body","Rust 中的 drop 函数就是这么一个析构函数。"],["body","\n"],["body","因为不能禁用当值离开作用域时自动插入的 drop，并且不能显式调用 drop，如果我们需要强制提早清理值，可以使用 std::mem::drop 函数。"],["body","\n"],["body","std::mem::drop 函数不同于 Drop trait 中的 drop 方法。可以通过传递希望提早强制丢弃的值作为参数"],["body","\n\n"],["headingLink","rct-引用计数智能指针"],["heading","Rc<T> 引用计数智能指针"],["body","\n\n"],["body","\n"],["body","大部分情况下所有权是非常明确的:可以准确地知道哪个变量拥有某个值"],["body","\n"],["body","\n"],["body","\n"],["body","有些情况单个值可能会有多个所有者,例如图数据结构"],["body","\n"],["body","\n"],["body","\n"],["body","为了启用多所有权，Rust 有一个叫做 Rc<T> 的类型。其名称为 引用计数（reference counting）的缩写"],["body","\n"],["body","\n"],["body","\n"],["body","引用计数意味着记录一个值引用的数量来知晓这个值是否仍在被使用。如果某个值有零个引用，就代表没有任何有效引用并可以被清理。"],["body","\n"],["body","\n"],["body","\n"],["body","Rc<T> 用于当我们希望在堆上分配一些内存供程序的多个部分读取，而且无法在编译时确定程序的哪一部分会最后结束使用它的时候"],["body","\n"],["body","\n"],["body","\n"],["body","如果确实知道哪部分是最后一个结束使用的话，就可以令其成为数据的所有者，正常的所有权规则就可以在编译时生效。"],["body","\n"],["body","\n\n"],["body","\n"],["body","注意 Rc<T> 只能用于单线程场景"],["body","\n"],["body","\n"],["headingLink","使用-rct-共享数据"],["heading","使用 Rc<T> 共享数据"],["body","\n\n"],["body","\n"],["body","不必像调用 Rc::clone 增加引用计数那样调用一个函数来减少计数；"],["body","\n"],["body","\n"],["body","\n"],["body","Drop trait 的实现当 Rc<T> 值离开作用域时自动减少引用计数。"],["body","\n"],["body","\n"],["body","\n"],["body","使用 Rc<T> 允许一个值有多个所有者，引用计数则确保只要任何所有者依然存在其值也保持有效。"],["body","\n"],["body","\n"],["body","\n"],["body","通过不可变引用， Rc<T> 允许在程序的多个部分之间只读地共享数据。如果 Rc<T> 也允许多个可变引用,则会违反第四章讨论的借用规则之一：相同位置的多个可变借用可能造成数据竞争和不一致"],["body","\n"],["body","\n\n"],["headingLink","refcellt-和内部可变性模式"],["heading","RefCell<T> 和内部可变性模式"],["body","\n\n"],["body","\n"],["body","内部可变性（Interior mutability）是 Rust 中的一个设计模式"],["body","\n"],["body","\n"],["body","\n"],["body","它允许你即使在有不可变引用时也可以改变数据，这通常是借用规则所不允许的"],["body","\n"],["body","\n"],["body","\n"],["body","为了改变数据，该模式在数据结构中使用 unsafe 代码来模糊 Rust 通常的可变性和借用规则"],["body","\n"],["body","\n"],["body","\n"],["body","我们还未讲到不安全代码；第十九章会学习它们"],["body","\n"],["body","\n"],["body","\n"],["body","当可以确保代码在运行时会遵守借用规则，即使编译器不能保证的情况，可以选择使用那些运用内部可变性模式的类型"],["body","\n"],["body","\n"],["body","\n"],["body","所涉及的 unsafe 代码将被封装进安全的 API 中，而外部类型仍然是不可变的。"],["body","\n"],["body","\n\n"],["headingLink","通过-refcellt-在运行时检查借用规则"],["heading","通过 RefCell<T> 在运行时检查借用规则"],["body","\n"],["body","如下为选择 Box<T>，Rc<T> 或 RefCell<T> 的理由："],["body","\n\n"],["body","Rc<T> 允许相同数据有多个所有者；Box<T> 和 RefCell<T> 有单一所有者。"],["body","\n"],["body","Box<T> 允许在编译时执行不可变或可变借用检查；Rc<T>仅允许在编译时执行不可变借用检查；RefCell<T> 允许在运行时执行不可变或可变借用检查。"],["body","\n"],["body","因为 RefCell<T> 允许在运行时执行可变借用检查，所以我们可以在即便 RefCell<T> 自身是不可变的情况下修改其内部的值。"],["body","\n\n"],["body","在不可变值内部改变值就是 内部可变性 模式。让我们看看何时内部可变性是有用的，并讨论这是如何成为可能的。"],["body","\n"],["headingLink","内部可变性不可变值的可变借用"],["heading","内部可变性：不可变值的可变借用"],["body","\n"],["body","#![allow(unused)]\nfn main() {\nlet vec1 = vec![1, 2, 3];\nlet cell = RefCell::new(vec1);\n\n{\n    let mut ref_mut1 = cell.borrow_mut();\n    ref_mut1.push(4);\n    println!(\"{:?}\", ref_mut1);\n}\nlet mut ref_mut2= cell.borrow_mut();\n}"],["body","\n"],["headingLink","refcellt-在运行时记录借用"],["heading","RefCell<T> 在运行时记录借用"],["body","\n\n"],["body","当创建不可变和可变引用时，我们分别使用 & 和 &mut 语法。对于 RefCell<T> 来说，则是 borrow 和 borrow_mut 方法，这属于 RefCell<T> 安全 API 的一部分"],["body","\n"],["body","borrow 方法返回 Ref<T> 类型的智能指针，borrow_mut 方法返回 RefMut 类型的智能指针"],["body","\n"],["body","这两个类型都实现了 Deref，所以可以当作常规引用对待。"],["body","\n"],["body","RefCell<T> 记录当前有多少个活动的 Ref<T> 和 RefMut<T> 智能指针"],["body","\n"],["body","每次调用 borrow，RefCell<T> 将活动的不可变借用计数加一，当 Ref<T> 值离开作用域时，不可变借用计数减一，就像编译时借用规则一样"],["body","\n"],["body","RefCell<T> 在任何时候只允许有多个不可变借用或一个可变借用。"],["body","\n"],["body","如果我们尝试违反这些规则，相比引用时的编译时错误，RefCell<T> 的实现会在运行时出现 panic"],["body","\n\n"],["headingLink","结合-rct-和-refcellt-来拥有多个可变数据所有者"],["heading","结合 Rc<T> 和 RefCell<T> 来拥有多个可变数据所有者"],["body","\n\n"],["body","RefCell<T> 的一个常见用法是与 Rc<T> 结合"],["body","\n"],["body","Rc<T> 允许对相同数据有多个所有者，不过只能提供数据的不可变访问"],["body","\n"],["body","如果有一个储存了 RefCell<T> 的 Rc<T> 的话，就可以得到有多个所有者 并且 可以修改的值了！"],["body","\n\n"],["body","#![allow(unused)]\nfn main() {\npub fn test_ref_rc(){\n    let vec1 = vec![1, 2, 3];\n    let cell = RefCell::new(vec1);\n    let rc = Rc::new(cell);\n    let rc1 = rc.clone();\n    let rc2 = rc.clone();\n    rc1.borrow_mut().push(4);\n    rc2.borrow_mut().push(5);\n\n    println!(\"{:?}\",rc);\n}\n}"],["body","\n"],["headingLink","引用循环与内存泄漏"],["heading","引用循环与内存泄漏"],["body","\n\n"],["body","Rust 的内存安全性保证使其难以意外地制造永远也不会被清理的内存（被称为 内存泄漏（memory leak））"],["body","\n"],["body","但并不是不可能。与在编译时拒绝数据竞争不同， Rust 并不保证完全地避免内存泄漏，这意味着内存泄漏在 Rust 被认为是内存安全的"],["body","\n"],["body","这一点可以通过 Rc<T> 和 RefCell<T> 看出：创建引用循环的可能性是存在的。这会造成内存泄漏，因为每一项的引用计数永远也到不了 0，其值也永远不会被丢弃。"],["body","\n\n"],["headingLink","制造引用循环"],["heading","制造引用循环"],["body","\n"],["body","\n"],["body","创建一个引用循环：两个 List 值互相指向彼此"],["body","\n"],["body","\n"],["body","fn main() {}\nuse std::rc::Rc;\nuse std::cell::RefCell;\nuse crate::List::{Cons, Nil};\n\n#[derive(Debug)]\nenum List {\n    Cons(i32, RefCell<Rc<List>>),\n    Nil,\n}\n\nimpl List {\n    fn tail(&self) -> Option<&RefCell<Rc<List>>> {\n        match self {\n            Cons(_, item) => Some(item),\n            Nil => None,\n        }\n    }\n}\n\npub fn test_recursive(){\n    let a =  Rc::new( Cons(1, RefCell::new(Rc::new(Nil))) ) ;\n    println!(\"a initial rc count = {}\", Rc::strong_count(&a));\n    println!(\"a next item = {:?}\", a.tail());\n\n\n    let b = Rc::new( Cons(2,RefCell::new(a.clone())) );\n    println!(\"a rc count after b creation = {}\", Rc::strong_count(&a));\n    println!(\"b initial rc count = {}\", Rc::strong_count(&b));\n    println!(\"b next item = {:?}\", b.tail());\n\n\n\n\n    match  a.tail() {\n        None => {}\n        Some(item) => {\n            *item.borrow_mut() = b.clone();\n        }\n    }\n\n    println!(\"b rc count after changing a = {}\", Rc::strong_count(&b));\n    println!(\"a rc count after changing a = {}\", Rc::strong_count(&a));\n}"],["body","\n"],["headingLink","weakref的使用"],["heading","WeakRef的使用"],["body","\n"],["body","#![allow(unused)]\nfn main() {\nuse std::rc::{Rc, Weak};\nuse std::cell::RefCell;\n#[derive(Debug)]\nstruct Node {\n    value: i32,\n    child: RefCell<Vec<Rc<Node>>>,\n    parent: RefCell<Weak<Node>>,\n}\n\nimpl Node {\n    fn new(value: i32, child: Vec<Rc<Node>>) -> Rc<Node> {\n        Rc::new(Node {\n            value,\n            child: RefCell::new(vec![]),\n            parent: RefCell::new(Weak::new()),\n        }\n        )\n    }\n}\n\npub fn test_weak_ref() {\n    //创建节点1\n    let node1 = Node::new(1, vec![]);\n\n    println!(\"node1 parent = {:?}\", node1.parent.borrow().upgrade());\n\n\n    {\n        //创建节点2\n        let node2 = Node::new(2, vec![node1.clone()]);\n\n        println!(\"strong_count:{:?},weak_count:{:?}\",Rc::strong_count(&node2),Rc::weak_count(&node2));\n\n        //将parent赋值为node2\n        *node1.parent.borrow_mut() = Rc::downgrade(&node2);\n\n        println!(\"strong_count:{:?},weak_count:{:?}\",Rc::strong_count(&node2),Rc::weak_count(&node2));\n\n        println!(\"node1 parent = {:?}\", node1.parent.borrow().upgrade());\n    }\n\n    println!(\"node1 parent = {:?}\", node1.parent.borrow().upgrade());\n}\n}"],["body","\n\n\n\n                    "],["body","\n\n                    \n                \n            \n\n            \n\n        \n\n\n\n\n        \n\n\n\n        \n        \n        \n\n        \n\n\n    \n    \n\n"]],[["_relative_fp","8结构体.html"],["title","结构体.md - RUST学习笔记"],["body","\n    \n        \n        \n\n        \n        \n\n        \n        \n\n        \n\n        \n        \n\n        \n\n        \n        \n\n        \n\n            \n                                \n                \n                    \n                        "],["body","\n                            \n                        "],["body","\n                        "],["body","\n                            \n                        "],["body","\n                        \n                            "],["body","Light"],["body","\n                            "],["body","Rust"],["body","\n                            "],["body","Coal"],["body","\n                            "],["body","Navy"],["body","\n                            "],["body","Ayu"],["body","\n                        \n                    \n\n                    "],["heading","RUST学习笔记"],["body","\n\n                    \n\n                    \n                \n\n\n                \n                \n\n                \n                    "],["body","\n                        \n\n"],["body","\n"],["body","\n\n"],["headingLink","结构体"],["heading","结构体"],["body","\n"],["headingLink","定义"],["heading","定义"],["body","\n"],["body","fn main() {\nstruct User {\n    username: String,\n    email: String,\n    sign_in_count: u64,\n    active: bool,\n}\n}"],["body","\n"],["headingLink","使用"],["heading","使用"],["body","\n"],["body","#![allow(unused)]\nfn main() {\nlet user1 = User {\n    email: String::from(\"someone@example.com\"),\n    username: String::from(\"someusername123\"),\n    active: true,\n    sign_in_count: 1,\n};\n}"],["body","\n"],["headingLink","赋值"],["heading","赋值"],["body","\n"],["body","#![allow(unused)]\nfn main() {\nlet mut user1 = User {\n    email: String::from(\"someone@example.com\"),\n    username: String::from(\"someusername123\"),\n    active: true,\n    sign_in_count: 1,\n};\nuser1.email = String::from(\"anotheremail@example.com\");\n}"],["body","\n"],["headingLink","字段同名时的简化写法"],["heading","字段同名时的简化写法"],["body","\n"],["body","#![allow(unused)]\nfn main() {\nfn build_user(email: String, username: String) -> User {\n    User {\n        email,\n        username,\n        active: true,\n        sign_in_count: 1,\n    }\n}\n}"],["body","\n"],["headingLink","使用结构体更新语法创建示例对象"],["heading","使用结构体更新语法创建示例对象"],["body","\n"],["body","#![allow(unused)]\nfn main() {\nlet user2 = User {\n    email: String::from(\"another@example.com\"),\n    username: String::from(\"anotherusername567\"),\n    active: user1.active,\n    sign_in_count: user1.sign_in_count,\n};\n}"],["body","\n"],["headingLink","使用没有命名的元组结构体创建不同的类型"],["heading","使用没有命名的元组结构体创建不同的类型"],["body","\n"],["body","\n#![allow(unused)]\nfn main() {\nstruct Color(i32, i32, i32);\nstruct Point(i32, i32, i32);\n\nlet black = Color(0, 0, 0);\nlet origin = Point(0, 0, 0);\n}"],["body","\n"],["headingLink","没有任何字段的类单元结构体"],["heading","没有任何字段的类单元结构体"],["body","\n"],["body","我们也可以定义一个没有任何字段的结构体！它们被称为 类单元结构体（unit-like structs）因为它们类似于 ()，即 unit 类型。类单元结构体常常在你想要在某个类型上实现 trait 但不需要在类型中存储数据的时候发挥作用"],["body","\n"],["body","#![allow(unused)]\nfn main() {\n    struct A();\n    let a  =A();\n}"],["body","\n"],["headingLink","结构体的所有权"],["heading","结构体的所有权"],["body","\n\n"],["body","\n"],["body","一般情况  结构体拥有其 子字段的所有权, "],["body","\n"],["body","\n"],["body","\n"],["body","可以使结构体存储被其他对象拥有的数据的引用，不过这么做的话需要用上 生命周期（lifetimes），"],["body","\n"],["body","\n"],["body","\n"],["body","生命周期确保结构体引用的数据有效性跟结构体本身保持一致"],["body","\n"],["body","\n\n"],["headingLink","定义方法"],["heading","定义方法"],["body","\n"],["body","#[derive(Debug)]\nstruct Rectangle {\n    width: u32,\n    height: u32,\n}\nimpl Rectangle {\n    fn area(&self) -> u32 {\n        self.width * self.height\n    }\n}\nfn main() {\n    let rect1 = Rectangle { width: 30, height: 50 };\n    println!(\n        \"The area of the rectangle is {} square pixels.\",\n        rect1.area()\n    );\n}"],["body","\n\n"],["body","在 area 的签名中，使用 &self 来替代 rectangle: &Rectangle"],["body","\n\n"],["headingLink","枚举"],["heading","枚举"],["body","\n"],["headingLink","使用枚举"],["heading","使用枚举"],["body","\n"],["body","定义"],["body","\n"],["body","#![allow(unused)]\nfn main() {\nenum IpAddrKind {\n    V4,\n    V6,\n}\n}"],["body","\n"],["body","取值"],["body","\n"],["body","#![allow(unused)]\nfn main() {\nlet four = IpAddrKind::V4;\nlet six = IpAddrKind::V6;\n}"],["body","\n"],["body","#![allow(unused)]\nfn main() {\nfn route(ip_type: IpAddrKind) { }\nroute(IpAddrKind::V4);\nroute(IpAddrKind::V6);\n}"],["body","\n"],["body","每个成员可以处理不同类型和数量的数据"],["body","\n"],["body","#![allow(unused)]\nfn main() {\nenum IpAddr {\n    V4(u8, u8, u8, u8),\n    V6(String),\n}\n\nlet home = IpAddr::V4(127, 0, 0, 1);\n\nlet loopback = IpAddr::V6(String::from(\"::1\"));\n}"],["body","\n"],["body","示例"],["body","\n"],["body","#![allow(unused)]\nfn main() {\nenum Message {\n    Quit,\n    Move { x: i32, y: i32 }, //匿名结构体\n    Write(String),//string类型\n    ChangeColor(i32, i32, i32), //元组\n}\n}"],["body","\n"],["body","使用 impl 来为结构体定义方法"],["body","\n"],["headingLink","option枚举"],["heading","Option枚举"],["body","\n"],["body","#![allow(unused)]\nfn main() {\nenum Option<T> {\n    Some(T),\n    None,\n}\n}"],["body","\n"],["body","Option<T> 枚举是如此有用以至于它甚至被包含在了 prelude 之中，你不需要将其显式引入作用域"],["body","\n"],["body","#![allow(unused)]\nfn main() {\n//直接使用\nSome()\nNone\nlet y: Option<i8> = Some(5);\n}"],["body","\n"],["headingLink","match控制流运算符"],["heading","Match控制流运算符"],["body","\n\n"],["body","它允许我们将一个值与一系列的模式相比较，并根据相匹配的模式执行相应代码"],["body","\n"],["body","模式可由字面值、变量、通配符和许多其他内容构成"],["body","\n\n"],["body","#![allow(unused)]\nfn main() {\n//match匹配枚举\nenum Coin {\n    Penny,\n    Nickel,\n    Dime,\n    Quarter,\n}\n\nfn value_in_cents(coin: Coin) -> u8 {\n    match coin {\n        Coin::Penny => 1,\n        Coin::Nickel => 5,\n        Coin::Dime => 10,\n        Coin::Quarter => 25,\n    }\n}\n}"],["body","\n"],["body","枚举的变量获取"],["body","\n"],["body","#![allow(unused)]\n\nfn main() {\nfn plus_one(x: Option<i32>) -> Option<i32> {\n    match x {\n        None => None,\n        Some(i) => Some(i + 1),\n    }\n}\n\nlet five = Some(5);\nlet six = plus_one(five);\nlet none = plus_one(None);\n}"],["body","\n"],["body","枚举的匹配时穷尽的 通过指定默认块"],["body","\n"],["body","\n#![allow(unused)]\nfn main() {\nlet some_u8_value = 0u8;\nmatch some_u8_value {\n    1 => println!(\"one\"),\n    3 => println!(\"three\"),\n    5 => println!(\"five\"),\n    7 => println!(\"seven\"),\n    _ => (),\n}\n}"],["body","\n"],["headingLink","if-let-简洁控制流"],["heading","if let 简洁控制流"],["body","\n"],["body","#![allow(unused)]\n\nfn main() {\nlet mut count = 0;\nif let Coin::Quarter(state) = coin {\n    println!(\"State quarter from {:?}!\", state);\n} else {\n    count += 1;\n}\n\nif coin\n}"],["body","\n\n\n\n                    "],["body","\n\n                    \n                \n            \n\n            \n\n        \n\n\n\n\n        \n\n\n\n        \n        \n        \n\n        \n\n\n    \n    \n\n"]],[["_relative_fp","rfcs.html"],["title","rfcs - RUST学习笔记"],["body","\n    \n        \n        \n\n        \n        \n\n        \n        \n\n        \n\n        \n        \n\n        \n\n        \n        \n\n        \n\n            \n                                \n                \n                    \n                        "],["body","\n                            \n                        "],["body","\n                        "],["body","\n                            \n                        "],["body","\n                        \n                            "],["body","Light"],["body","\n                            "],["body","Rust"],["body","\n                            "],["body","Coal"],["body","\n                            "],["body","Navy"],["body","\n                            "],["body","Ayu"],["body","\n                        \n                    \n\n                    "],["heading","RUST学习笔记"],["body","\n\n                    \n\n                    \n                \n\n\n                \n                \n\n                \n                    "],["body","\n                        \n\n"],["body","\n"],["body","\n\n\n\n\n                    "],["body","\n\n                    \n                \n            \n\n            \n\n        \n\n\n\n\n        \n\n\n\n        \n        \n        \n\n        \n\n\n    \n    \n\n"]],[["_relative_fp","rfcs/0911-const-fn.html"],["title","-const-fn.md - RUST学习笔记"],["body","\n    \n        \n        \n\n        \n        \n\n        \n        \n\n        \n\n        \n        \n\n        \n\n        \n        \n\n        \n\n            \n                                \n                \n                    \n                        "],["body","\n                            \n                        "],["body","\n                        "],["body","\n                            \n                        "],["body","\n                        \n                            "],["body","Light"],["body","\n                            "],["body","Rust"],["body","\n                            "],["body","Coal"],["body","\n                            "],["body","Navy"],["body","\n                            "],["body","Ayu"],["body","\n                        \n                    \n\n                    "],["heading","RUST学习笔记"],["body","\n\n                    \n\n                    \n                \n\n\n                \n                \n\n                \n                    "],["body","\n                        \n\n"],["body","\n"],["body","\n\n"],["headingLink","summary"],["heading","Summary"],["body","\n"],["body","允许将一般函数和 继承过来的函数 标记为 const,使它们能够在常量上下文中调用，并带有常量参数"],["body","\n"],["headingLink","motivation"],["heading","Motivation"],["body","\n"],["body","#![allow(unused)]\n\nfn main() {\n#[lang=\"unsafe_cell\"]\nstruct UnsafeCell<T> { pub value: T }\nstruct AtomicUsize { v: UnsafeCell<usize> }\nconst ATOMIC_USIZE_INIT: AtomicUsize = AtomicUsize {\n    v: UnsafeCell { value: 0 }\n};\n\n}"],["body","\n\n"],["body","为了能在 const 字段中 直接初始化结构体，上述例子只能 将 字段 设置为 pub"],["body","\n"],["body","有了const函数后，可以避免上述的情况"],["body","\n\n"],["body","#![allow(unused)]\nfn main() {\npub mod unsafe_cell {\n    pub struct UnsafeCell<T> {  value: T }\n    pub struct AtomicUsize {  v: UnsafeCell<usize> }\n    pub const  fn new(a:usize)->AtomicUsize{\n        AtomicUsize {\n            v:UnsafeCell{\n                value:a\n            }\n        }\n    }\n}\nuse unsafe_cell::*;\nconst ATOMIC_USIZE_INIT: AtomicUsize = unsafe_cell::new(0);\n}"],["body","\n"],["headingLink","detailed-design"],["heading","Detailed design"],["body","\n\n"],["body","函数和继承方法可以标记为 const："],["body","\n"],["body","只允许 简单的 参数 按值传递"],["body","\n"],["body","const 函数体会当做 一个 const 代码块"],["body","\n\n"],["body","#![allow(unused)]\nfn main() {\nconst FOO: Foo = {\n    // Currently, only item \"statements\" are allowed here.\n    stmts;\n    // The function's arguments and constant expressions can be freely combined.\n    expr\n}\n}"],["body","\n"],["headingLink","const规则"],["heading","const规则"],["body","\n\n"],["body","当前支持的 expr是"],["body","\n\n"],["headingLink","expr"],["heading","expr"],["body","\n\n"],["body","基础类型字面量"],["body","\n"],["body","ADTS（tuples、arrays、structs、enum variants"],["body","\n"],["body","基础类型的一元操作、二元操作。unary/binary "],["body","\n"],["body","强制转换、字段访问、索引"],["body","\n"],["body","无捕获闭包"],["body","\n"],["body","引用和块（只 item statmts,和 tail expression）"],["body","\n\n"],["headingLink","no-side-effects"],["heading","no side-effects"],["body","\n\n"],["body","赋值语句"],["body","\n"],["body","non-const function  调用"],["body","\n"],["body","inline assembly)"],["body","\n\n"],["headingLink","structenum-values-not-allowded-for-copy-trait"],["heading","struct/enum values not allowded for copy trait"],["body","\n"],["body","struct/enum values are not allowed if their type implements Drop, but this is not transitive, allowing the (perfectly harmless) creation of, e.g. None::<Vec<T>> (as an aside, this rule could be used to allow [x; N] even for non-Copy types of x, but that is out of the scope of this RFC)"],["body","\n"],["headingLink","references-are-truly-immutable"],["heading","references are truly immutable,"],["body","\n\n"],["body","no value with interior mutability can be placed behind a reference,"],["body","\n"],["body","mutable references can only be created from zero-sized values (e.g. &mut || {}) -  this allows a reference to be represented just by its value, with no guarantees for the actual address in memory"],["body","\n\n"],["headingLink","raw-pointer"],["heading","raw pointer"],["body","\n\n"],["body","raw pointers can only be created from an integer, a reference or another raw pointer"],["body","\n"],["body","cannot be dereferenced or cast back to an integer, which means any constant raw pointer can be represented by either a constant integer or references"],["body","\n\n"],["headingLink","loops"],["heading","loops"],["body","\n\n"],["body","as a result of not having any side-effects, loops would only affect termination, which has no practical value, thus remaining unimplemented"],["body","\n\n"],["headingLink","conditional-control-flow"],["heading","conditional control flow"],["body","\n\n"],["body","although more useful than loops, conditional control flow (if/else and match) also remains unimplemented and only match would pose a challenge"],["body","\n\n"],["headingLink","immutable-let-bindings"],["heading","immutable let bindings"],["body","\n\n"],["body","immutable let bindings in blocks have the same status and implementation difficulty as if/else and they both suffer from a lack of demand (blocks were originally introduced to const/static for scoping items used only in the initializer of a global)."],["body","\n\n"],["headingLink","可以从任何常量表达式调用-const-函数和方法"],["heading","可以从任何常量表达式调用 const 函数和方法："],["body","\n"],["body","#![allow(unused)]\n\nfn main() {\n// Standalone example.\nstruct Point { x: i32, y: i32 }\n\nimpl Point {\n    const fn new(x: i32, y: i32) -> Point {\n        Point { x: x, y: y }\n    }\n\n    const fn add(self, other: Point) -> Point {\n        Point::new(self.x + other.x, self.y + other.y)\n    }\n}\n\nconst ORIGIN: Point = Point::new(0, 0);\n\nconst fn sum_test(xs: [Point; 3]) -> Point {\n    xs[0].add(xs[1]).add(xs[2])\n}\n\nconst A: Point = Point::new(1, 0);\nconst B: Point = Point::new(0, 1);\nconst C: Point = A.add(B);\nconst D: Point = sum_test([A, B, C]);\n\n// Assuming the Foo::new methods used here are const.\nstatic FLAG: AtomicBool = AtomicBool::new(true);\nstatic COUNTDOWN: AtomicUsize = AtomicUsize::new(10);\n#[thread_local]\nstatic TLS_COUNTER: Cell<u32> = Cell::new(1);\n\n}"],["body","\n"],["body","Type parameters and their bounds are not restricted, though trait methods cannot be called, as they are never const in this design. Accessing trait methods can still be useful - for example, they can be turned into function pointers:"],["body","\n"],["body","#![allow(unused)]\nfn main() {\nconst fn arithmetic_ops<T: Int>() -> [fn(T, T) -> T; 4] {\n    [Add::add, Sub::sub, Mul::mul, Div::div]\n}\n}"],["body","\n"],["body","const functions can also be unsafe, allowing construction of types that require invariants to be maintained (e.g. std::ptr::Unique requires a non-null pointer)"],["body","\n"],["body","#![allow(unused)]\nfn main() {\nstruct OptionalInt(u32);\nimpl OptionalInt {\n    /// Value must be non-zero\n    const unsafe fn new(val: u32) -> OptionalInt {\n        OptionalInt(val)\n    }\n}\n}"],["body","\n\n\n\n                    "],["body","\n\n                    \n                \n            \n\n            \n\n        \n\n\n\n\n        \n\n\n\n        \n        \n        \n\n        \n\n\n    \n    \n\n"]],[["_relative_fp","rfcs/0195-associated-items.html"],["title","-associated-items.md - RUST学习笔记"],["body","\n    \n        \n        \n\n        \n        \n\n        \n        \n\n        \n\n        \n        \n\n        \n\n        \n        \n\n        \n\n            \n                                \n                \n                    \n                        "],["body","\n                            \n                        "],["body","\n                        "],["body","\n                            \n                        "],["body","\n                        \n                            "],["body","Light"],["body","\n                            "],["body","Rust"],["body","\n                            "],["body","Coal"],["body","\n                            "],["body","Navy"],["body","\n                            "],["body","Ayu"],["body","\n                        \n                    \n\n                    "],["heading","RUST学习笔记"],["body","\n\n                    \n\n                    \n                \n\n\n                \n                \n\n                \n                    "],["body","\n                        \n\n"],["body","\n"],["body","\n\n\n"],["body","Start Date: 2014-08-04"],["body","\n"],["body","RFC PR #: rust-lang/rfcs#195"],["body","\n"],["body","Rust Issue #: rust-lang/rust#17307"],["body","\n\n"],["headingLink","summary"],["heading","Summary"],["body","\n"],["body","该RFC使用关联项扩展特性，从而实现泛型编程 更方便、可扩展和强大，特别的，traits将包含一系列方法"],["body","\n\n"],["body","Associated functions (already present as \"static\" functions)"],["body","\n"],["body","Associated consts"],["body","\n"],["body","Associated types"],["body","\n"],["body","Associated lifetimes"],["body","\n\n"],["body","这个RFC还为 multidispatch traits 提供了一种机制，其中根据不同类型选择不同的 trait实现。"],["body","\n"],["body","注意:在 RFC 246引入const和静态项之间的区别之前，这个RFC已经被接受了。该文本已经被 更新，以 澄清：关联常量而不是静态，并提供了对关联常量初始实现的限制 的摘要，除了这个修改之外，没有其他的新语法 影响这个提案的修改"],["body","\n"],["headingLink","motivation"],["heading","Motivation"],["body","\n"],["body","\n"],["body","动机"],["body","\n"],["body","\n"],["body","关联项发挥作用的一个典型例子是数据结构，比如 图，至少包含三种类型:节点、边和图本身。"],["body","\n"],["body","在今天的《Rust》中，为了将 graph 设计为 通用的trait，你必须采用 与图关联的其他类型作为 参数"],["body","\n"],["body","#![allow(unused)]\nfn main() {\ntrait Graph<N, E> {\n    fn has_edge(&self, &N, &N) -> bool;\n    ...\n}\n}"],["body","\n"],["body","把节点和边类型当做参数这令人困惑，因为任何 具体的图类型他们的边跟节点的类型都是确定的、唯一的"],["body","\n"],["body","同时，这也带来了不遍，因为使用 泛型的 图的代码 也同样被迫 参数化，即使不是所有的类型都是相关的"],["body","\n"],["body","#![allow(unused)]\nfn main() {\n//使用N、E参数化了,所以G必须也是参数化的\nfn distance<N, E, G: Graph<N, E>>(graph: &G, start: &N, end: &N) -> uint { ... }\n}"],["body","\n"],["body","使用关联的类型，图trait 可以明确表明  节点和 边类型由impl决定:"],["body","\n"],["body","#![allow(unused)]\nfn main() {\ntrait Graph {\n    type N;\n    type E;\n    fn has_edge(&self, &N, &N) -> bool;\n}\n}"],["body","\n"],["body","客户端可以 直接使用关联类型 表示 图类型"],["body","\n"],["body","#![allow(unused)]\nfn main() {\nfn distance<G: Graph>(graph: &G, start: &G::N, end: &G::N) -> uint { ... }\n}"],["body","\n"],["body","下面的小节扩展了 关联类型 的上述好处"],["body","\n"],["headingLink","associated-types-engineering-benefits-for-generics"],["heading","Associated types: engineering benefits for generics"],["body","\n"],["body","\n"],["body","泛型的工程好处"],["body","\n"],["body","\n"],["body","关联类型提供了几个工程上的好处"],["body","\n\n"],["body","\n"],["body","Readability and scalability:可读性和可伸缩性"],["body","\n"],["body","关联类型可以一次性抽象整个类型族，而不需要分别命名它们"],["body","\n"],["body","这提高了 泛型代码的可读性 (就像上面的 distance 函数). "],["body","\n"],["body","它还 使泛型更具“可伸缩性”:traits可以合并其他相关的特性 类型不会给不关心这些的客户带来额外的负担"],["body","\n"],["body","相比之下，在今天的Rust中，将额外的通用参数添加到 Trait经常感觉像是一个非常“重量级”的举动。"],["body","\n"],["body","\n"],["body","\n"],["body","Ease of refactor ing/evolution：易于重构"],["body","\n"],["body","因为trait的用户不必单独参数化它 相关的类型，可以添加新的关联类型而不破坏所有 现有的客户端代码。"],["body","\n"],["body","相反，在今天的Rust中，关联类型只能通过给 一个trait 添加更多的类型参数，这会破坏所有使用到这个trait的代码。"],["body","\n"],["body","\n\n"],["headingLink","clearer-trait-matching"],["heading","Clearer trait matching"],["body","\n"],["body","\n"],["body","清晰的trait匹配"],["body","\n"],["body","\n"],["body","traits的类型参数 要么是 输入、输出"],["body","\n\n"],["body","\n"],["body","Inputs. “input”类型参数用于确定使用哪个类型的实现"],["body","\n"],["body","\n"],["body","\n"],["body","Outputs. \"output\" 类型参数 在选择实现时没有作用。"],["body","\n"],["body","\n\n"],["body","输入和输出类型在类型推理和   trait 一致性规则 中起着重要作用，这后面会有更详细的描述"],["body","\n"],["body","在目前绝大多数的库中，唯一的输入类型是' Self ' 类型实现trait，所有其他特征类型参数都是输出"],["body","\n"],["body","例如，trait  Iterator<A> 接受元素的类型形参' A ' 但这种类型总是由具体的“Self”决定的 类型(e.g. Items<u8>) ，A类型通常是输出类型"],["body","\n"],["body","Additional input type parameters are useful for cases like binary operators,\nwhere you may want the impl to depend on the types of both\narguments. For example, you might want a trait"],["body","\n"],["body","#![allow(unused)]\nfn main() {\ntrait Add<Rhs, Sum> {\n    fn add(&self, rhs: &Rhs) -> Sum;\n}\n}"],["body","\n"],["body","将' Self '和' Rhs '类型视为输入，将' Sum '类型视为输出 (因为它是由参数类型唯一决定的)。这将允许 ' impl ' s取决于' Rhs '类型，即使' Self '类型是相同的:"],["body","\n"],["body","#![allow(unused)]\nfn main() {\nimpl Add<int, int> for int { ... }\nimpl Add<Complex, Complex> for int { ... }\n}"],["body","\n"],["body","今天的Rust没有明确区分输入类型和输出类型 参数特征。如果你试图提供上面的两个impl，你 会收到如下错误"],["body","\n"],["body","error: conflicting implementations for trait `Add`\n"],["body","\n"],["body","这个RFC通过"],["body","\n\n"],["body","将所有trait类型参数视为输入类型，并且"],["body","\n"],["body","提供关联类型，即输出类型"],["body","\n\n"],["body","在这个设计中，“Add”trait将会像下面这样写和实现:"],["body","\n"],["body","#![allow(unused)]\nfn main() {\n// Self and Rhs are *inputs*\ntrait Add<Rhs> {\n    type Sum; // Sum is an *output*\n    fn add(&self, &Rhs) -> Sum;\n}\n\nimpl Add<int> for int {\n    type Sum = int;\n    fn add(&self, rhs: &int) -> int { ... }\n}\n\nimpl Add<Complex> for int {\n    type Sum = Complex;\n    fn add(&self, rhs: &Complex) -> Complex { ... }\n}\n}"],["body","\n"],["body","通过这种方法，一个trait声明像trait Add<Rhs>{…} 定义了一个“家族”特征，每个“Rhs”选择一类家族"],["body","\n"],["headingLink","expressiveness"],["heading","Expressiveness"],["body","\n"],["body","\n"],["body","善于表现；表情丰富"],["body","\n"],["body","\n"],["body","今天的rust  已经可以表达 Associated types、lifetimes、functions，尽管这样做很笨拙(如上所述)。"],["body","\n"],["body","但associated _consts_不能表达。"],["body","\n"],["body","例如，今天的Rust包含了各种数字traits，包括 ' Float '，当前必须将常量公开为静态函数:"],["body","\n"],["body","#![allow(unused)]\nfn main() {\ntrait Float {\n    fn nan() -> Self;\n    fn infinity() -> Self;\n    fn neg_infinity() -> Self;\n    fn neg_zero() -> Self;\n    fn pi() -> Self;\n    fn two_pi() -> Self;\n    ...\n} \n}"],["body","\n"],["body","因为这些函数不能用在常量表达式中，"],["body","\n"],["body","float类型的模块 同样导出了一组单独的常量作为 const,而没有使用 traits"],["body","\n"],["body","相关的常量将允许常量直接存在于特征上:"],["body","\n"],["body","#![allow(unused)]\nfn main() {\ntrait Float {\n    const NAN: Self;\n    const INFINITY: Self;\n    const NEG_INFINITY: Self;\n    const NEG_ZERO: Self;\n    const PI: Self;\n    const TWO_PI: Self;\n    ...\n}\n}"],["body","\n"],["headingLink","why-now"],["heading","Why now?"],["body","\n"],["body","撇开上述动机不谈，添加 associated types 的原因可能并不明显, 现在(即1.0之前)很重要。主要有两个原因。"],["body","\n"],["body","首先，这里展示的设计是“不”向后兼容的，因为它 为了trait实现匹配的目的，将trait类型参数重新解释为输入 匹配"],["body","\n"],["body","输入/输出的区别对一致性规则、类型推断和解析都有区别，这些都将在后面的 RFC。"],["body","\n"],["body","当然，也有可能给出一个不太理想的设计 关联类型可以稍后添加，而不需要更改 已有的特征类型参数解析"],["body","\n"],["body","例如，类型参数可以是显式的 标记为输入，否则假定为输出。这将是 不幸的是，因为关联的类型也是输出"],["body","\n"],["body","这会使语言 具有两种指定traits的输出类型的方法"],["body","\n"],["body","但第二个原因是库的稳定过程:"],["body","\n\n"],["body","\n"],["body","由于trait类型参数的大多数现有用途都是作为输出，它们实际上应该是关联类型。对这些api做出承诺：他们目前面临的风险是，将库置于一个这样的设计中：关联类型 添加后 即原有代码就会被抛弃。这种风险可能会 可以通过不同的向后兼容的 相关项设计来缓解，但是 以牺牲语言本身为代价。"],["body","\n"],["body","\n"],["body","\n"],["body","二元运算符的特征(例如。' Add ')应该是multidispatch"],["body","\n"],["body","\n"],["body","\n"],["body","It does not seem possible to stabilize them now in a way that will support moving to multidispatch later."],["body","\n"],["body","\n"],["body","\n"],["body","当前的库中还存在一些棘手的问题,"],["body","\n\n"],["body","such as the _equivmethods accumulating in HashMap, 这可以通过关联类型来解决"],["body","\n"],["body","(请参阅下面的“Defaults”以获得关于这个特定示例的更多信息。) 额外的 示例包括：错误传播的 trait、类型转换的 trait"],["body","\n\n"],["body","\n\n"],["headingLink","detailed-design"],["heading","Detailed design"],["body","\n"],["body","\n"],["body","详细设计"],["body","\n"],["body","\n"],["headingLink","trait-headers"],["heading","Trait headers"],["body","\n"],["body","Trait头是根据以下语法写的"],["body","\n"],["body","TRAIT_HEADER =\n  'trait' IDENT [ '<' INPUT_PARAMS '>' ] [ ':' BOUNDS ] [ WHERE_CLAUSE ]\n\nINPUT_PARAMS = INPUT_TY { ',' INPUT_TY }* [ ',' ]\nINPUT_PARAM  = IDENT [ ':' BOUNDS ]\n\nBOUNDS = BOUND { '+' BOUND }* [ '+' ]\nBOUND  = IDENT [ '<' ARGS '>' ]\n\nARGS   = INPUT_ARGS\n       | OUTPUT_CONSTRAINTS\n       | INPUT_ARGS ',' OUTPUT_CONSTRAINTS\n\nINPUT_ARGS = TYPE { ',' TYPE }*\n\nOUTPUT_CONSTRAINTS = OUTPUT_CONSTRAINT { ',' OUTPUT_CONSTRAINT }*\nOUTPUT_CONSTRAINT  = IDENT '=' TYPE\n"],["body","\n"],["body","注意：WHERE_CLAUSE and BOUND 的语法 在下面的 \"Constraining associated types\" 节中详细解释"],["body","\n"],["body","一个trait的所有类型参数都被认为是输入，可以用来选择 一个“impl”;"],["body","\n"],["body","从概念上讲，每个不同实例的类型 都会产生一个 截然不同的trait。更多细节在\"The input/output type\ndistinction\"一节中给出 区别”。"],["body","\n"],["headingLink","trait-bodies-defining-associated-items"],["heading","Trait bodies: defining associated items"],["body","\n"],["body","Trait bodies扩展成包含 三种新事物："],["body","\n"],["body","consts, types and lifetimes:"],["body","\n"],["body","TRAIT = TRAIT_HEADER '{' TRAIT_ITEM* '}'\nTRAIT_ITEM =\n  ... <existing productions>\n  | 'const' IDENT ':' TYPE [ '=' CONST_EXP ] ';'\n  | 'type' IDENT [ ':' BOUNDS ] [ WHERE_CLAUSE ] [ '=' TYPE ] ';'\n  | 'lifetime' LIFETIME_IDENT ';'\n"],["body","\n"],["body","Traits已经支持 关联函数，就是之前 称作：“static”的函数"],["body","\n"],["body","关联类型上的 BOUNDS and WHERE_CLAUSE  是对 trait的挑选、假设"],["body","\n"],["body","#![allow(unused)]\nfn main() {\ntrait Graph {\n    type N: Show + Hash;\n    type E: Show + Hash;\n    ...\n}\n\nimpl Graph for MyGraph {\n    // Both MyNode and MyEdge must implement Show and Hash\n    type N = MyNode;\n    type E = MyEdge;\n    ...\n}\n\nfn print_nodes<G: Graph>(g: &G) {\n    // here, can assume G::N implements Show\n    ...\n}\n}"],["body","\n"],["headingLink","namespacingshadowing-for-associated-types"],["heading","Namespacing/shadowing for associated types"],["body","\n"],["body","\n"],["body","关联类型的命名空间/遮蔽"],["body","\n"],["body","\n"],["body","关联类型可以与作用域中现有类型具有相同的名称，除trait的类型参数之外:"],["body","\n"],["body","#![allow(unused)]\nfn main() {\nstruct Foo { ... }\n\ntrait Bar<Input> {\n    type Foo; // this is allowed\n    fn into_foo(self) -> Foo; // this refers to the trait's Foo\n\n    type Input; // this is NOT allowed\n}\n}"],["body","\n"],["body","By not allowing name clashes between input and output types,\nkeep open the possibility of later allowing syntax like:"],["body","\n"],["body","通过不允许输入和输出类型之间的名称冲突， 保留以后允许 如下语法的可能性"],["body","\n"],["body","#![allow(unused)]\nfn main() {\nBar<Input=u8, Foo=uint>\n}"],["body","\n"],["body","where both input and output parameters are constrained by name. And anyway,\nthere is no use for clashing input/output names."],["body","\n"],["body","其中输入和输出参数都由名称约束。无论如何, 输入/输出名称冲突是没有用的。"],["body","\n"],["body","在名字冲突的情况下，如上面的' Foo '，由于某种原因 如果trait需要引用 外部 Foo，它总是可以通过使用' type 别名来做到这一点 在 trait 之外。"],["body","\n"],["headingLink","defaults"],["heading","Defaults"],["body","\n"],["body","注意，关联的常量和类型都允许默认值，就像trait一样 方法和函数可以提供默认值。"],["body","\n"],["body","作为一种代码重用机制和一种扩展方法，默认值都是有用的 "],["body","\n"],["body","然而，关联类型的默认值提出了一个有趣的问题：默认方法可以采用默认类型吗"],["body","\n"],["body","#![allow(unused)]\nfn main() {\ntrait ContainerKey : Clone + Hash + Eq {\n    type Query: Hash = Self;\n    fn compare(&self, other: &Query) -> bool { self == other }\n    fn query_to_key(q: &Query) -> Self { q.clone() };\n}\n\nimpl ContainerKey for String {\n    type Query = str;\n    fn compare(&self, other: &str) -> bool {\n        self.as_slice() == other\n    }\n    fn query_to_key(q: &str) -> String {\n        q.into_string()\n    }\n}\n\nimpl<K,V> HashMap<K,V> where K: ContainerKey {\n    fn find(&self, q: &K::Query) -> &V { ... }\n}\n}"],["body","\n"],["body","在这个例子中，' ContainerKey ' trait被用来关联一个' Query ' '类型 (用于查找)具有拥有的键类型"],["body","\n"],["body","这解决了 HashMap中棘手的问题:使用 &str索引，而不是 &String索引"],["body","\n"],["body","#![allow(unused)]\nfn main() {\n// H: HashMap<String, SomeType>\nH.find(\"some literal\")\n}"],["body","\n"],["body","而不是写作："],["body","\n"],["body","#![allow(unused)]\nfn main() {\nH.find(&\"some literal\".to_string())`\n}"],["body","\n"],["body","当前的解决方案包括使用' _equiv '方法复制API表面 使用了一些微妙的“Equiv”特征，但也使用了关联类型方法 使得提供一个覆盖相同用例的简单、单一的API变得容易。"],["body","\n"],["body","' ContainerKey '的默认值只是假设拥有键和查找键 类型是相同的"],["body","\n"],["body","但是默认方法必须假定默认值 关联类型，才能正常工作。"],["body","\n"],["body","不可用 覆盖 Query类型、而保留默认方法。"],["body","\n"],["body","我们用一种非常简单的方法来处理这个问题:"],["body","\n\n"],["body","如果一个trait 覆盖了任何默认的关联类型，它们也必须覆盖 覆盖所有默认函数和方法。"],["body","\n"],["body","否则，trait实现者可以有选择地覆盖单个默认值 方法/函数，就像今天一样。"],["body","\n\n"],["headingLink","trait-implementations"],["heading","Trait implementations"],["body","\n"],["body","triat实现语法"],["body","\n"],["body","IMPL_ITEM =\n  ... <existing productions>\n  | 'const' IDENT ':' TYPE '=' CONST_EXP ';'\n  | 'type' IDENT' '=' 'TYPE' ';'\n  | 'lifetime' LIFETIME_IDENT '=' LIFETIME_REFERENCE ';'\n"],["body","\n"],["body","类中的任何“type”实现必须满足所有边界和where子句"],["body","\n"],["headingLink","referencing-associated-items"],["heading","Referencing associated items"],["body","\n"],["body","\n"],["body","引用关联项"],["body","\n"],["body","\n"],["body","关联项是通过路径引用的"],["body","\n"],["body","表达式路径语法为 作为[UFCS]的一部分更新(https://github.com/rust-lang/rfcs/pull/132)，"],["body","\n"],["body","但 容纳相关的类型和生命周期，我们需要更新类型路径 语法。"],["body","\n"],["body","完整的语法如下:"],["body","\n"],["body","EXP_PATH\n  = EXP_ID_SEGMENT { '::' EXP_ID_SEGMENT }*\n  | TYPE_SEGMENT { '::' EXP_ID_SEGMENT }+\n  | IMPL_SEGMENT { '::' EXP_ID_SEGMENT }+\nEXP_ID_SEGMENT   = ID [ '::' '<' TYPE { ',' TYPE }* '>' ]\n\nTY_PATH\n  = TY_ID_SEGMENT { '::' TY_ID_SEGMENT }*\n  | TYPE_SEGMENT { '::' TY_ID_SEGMENT }*\n  | IMPL_SEGMENT { '::' TY_ID_SEGMENT }+\n\nTYPE_SEGMENT = '<' TYPE '>'\nIMPL_SEGMENT = '<' TYPE 'as' TRAIT_REFERENCE '>'\nTRAIT_REFERENCE = ID [ '<' TYPE { ',' TYPE * '>' ]\n"],["body","\n"],["body","下面是一些示例路径，以及它们可能引用的内容"],["body","\n"],["body","#![allow(unused)]\nfn main() {\n// Expression paths ///////////////////////////////////////////////////////////////\n\na::b::c         // reference to a function `c` in module `a::b`\na::<T1, T2>     // the function `a` instantiated with type arguments `T1`, `T2`\nVec::<T>::new   // reference to the function `new` associated with `Vec<T>`\n<Vec<T> as SomeTrait>::some_fn\n                // reference to the function `some_fn` associated with `SomeTrait`,\n                //   as implemented by `Vec<T>`\nT::size_of      // the function `size_of` associated with the type or trait `T`\n<T>::size_of    // the function `size_of` associated with `T` _viewed as a type_\n<T as SizeOf>::size_of\n                // the function `size_of` associated with `T`'s impl of `SizeOf`\n\n// Type paths /////////////////////////////////////////////////////////////////////\n\na::b::C         // reference to a type `C` in module `a::b`\nA<T1, T2>       // type A instantiated with type arguments `T1`, `T2`\nVec<T>::Iter    // reference to the type `Iter` associated with `Vec<T>\n<Vec<T> as SomeTrait>::SomeType\n                // reference to the type `SomeType` associated with `SomeTrait`,\n                //   as implemented by `Vec<T>`\n}"],["body","\n"],["headingLink","ways-to-reference-items"],["heading","Ways to reference items"],["body","\n"],["body","接下来，我们将详细介绍每种路径的含义。  为了便于讨论，我们假设已经定义了一个trait类似于"],["body","\n"],["body","#![allow(unused)]\nfn main() {\ntrait Container {\n    type E;\n    fn empty() -> Self;\n    fn insert(&mut self, E);\n    fn contains(&self, &E) -> bool where E: PartialEq;\n    ...\n}\n\nimpl<T> Container for Vec<T> {\n    type E = T;\n    fn empty() -> Vec<T> { Vec::new() }\n    ...\n}\n}"],["body","\n"],["headingLink","via-an-id_segment-prefix"],["heading","Via an ID_SEGMENT prefix"],["body","\n"],["body","\n"],["body","通过ID_SEGEMENT 前缀 访问"],["body","\n"],["body","\n"],["headingLink","当前缀解析为类型时"],["heading","当前缀解析为类型时"],["body","\n"],["body","获取关联项的最常见方法是通过  带有特征限制类型参数 :"],["body","\n"],["body","#![allow(unused)]\nfn main() {\nfn pick<C: Container>(c: &C) -> Option<&C::E> { ... }\n\nfn mk_with_two<C>() -> C where C: Container, C::E = uint {\n    let mut cont = C::empty();  // reference to associated function\n    cont.insert(0);\n    cont.insert(1);\n    cont\n}\n}"],["body","\n"],["body","要使这些引用有效，必须知道类型参数才能实现 相关的特征:"],["body","\n"],["body","#![allow(unused)]\nfn main() {\n// Knowledge via bounds\nfn pick<C: Container>(c: &C) -> Option<&C::E> { ... }\n\n// ... or equivalently,  where clause\nfn pick<C>(c: &C) -> Option<&C::E> where C: Container { ... }\n\n// Knowledge via ambient constraints\nstruct TwoContainers<C1: Container, C2: Container>(C1, C2);\nimpl<C1: Container, C2: Container> TwoContainers<C1, C2> {\n    fn pick_one(&self) -> Option<&C1::E> { ... }\n    fn pick_other(&self) -> Option<&C2::E> { ... }\n}\n}"],["body","\n"],["body","请注意' Vec<T>::E '和' Vec::<T>::empty '也是有效的类型和函数"],["body","\n"],["body","对于像' C::E '或' Vec<T>::E '这样的情况，路径以' ID_SEGMENT '开头，前缀本身解析为_type: ' C '和' Vec<T> '都是类型。在 一般情况下，路径PREFIX::REST_OF_PATH，其中PREFIX解析为类型是 等价于使用' TYPE_SEGMENT 前缀 <PREFIX>::REST_OF_PATH 。因此,对于 下面的例子都是等价的:"],["body","\n"],["body","#![allow(unused)]\nfn main() {\nfn pick<C: Container>(c: &C) -> Option<&C::E> { ... }\nfn pick<C: Container>(c: &C) -> Option<&<C>::E> { ... }\nfn pick<C: Container>(c: &C) -> Option<&<<C>::E>> { ... }\n}"],["body","\n"],["body","TYPE_SEGMENT前缀的行为将在下一小节中描述。"],["body","\n"],["headingLink","当前缀解析为trait时"],["heading","当前缀解析为trait时"],["body","\n"],["body","ID_SEGMENT 前缀可以解析为trait' 其行为不同于 ' TYPE_SEGMENT '的类型"],["body","\n"],["body","如下:"],["body","\n"],["body","#![allow(unused)]\nfn main() {\n// a reference Container::insert is roughly equivalent to:\nfn trait_insert<C: Container>(c: &C, e: C::E);\n\n// a reference <Container>::insert is roughly equivalent to:\nfn object_insert<E>(c: &Container<E=E>, e: E);\n}"],["body","\n"],["body","trait前缀"],["body","\n\n"],["body","\n"],["body","A path PREFIX::REST resolves to the item/path REST defined within\nTrait, while treating the type implementing the trait as a type parameter."],["body","\n"],["body","\n"],["body","\n"],["body","A path <PREFIX>::REST treats PREFIX as a (DST-style) type, and is\nhence usable only with trait objects. See the\nUFCS RFC for more detail."],["body","\n"],["body","\n\n"],["body","请注意，像' Container::E '这样的路径虽然在语法上是有效的，但将失败 ，因为没有办法告诉使用哪个“impl”。 Container::empty '的函数大致相当于:"],["body","\n"],["body","#![allow(unused)]\nfn main() {\nfn trait_empty<C: Container>() -> C;\n}"],["body","\n"],["headingLink","via-a-type_segment-prefix"],["heading","Via a TYPE_SEGMENT prefix"],["body","\n"],["body","\n"],["body","The following text is slightly changed from the\nUFCS RFC."],["body","\n"],["body","\n"],["body","当路径以' TYPE_SEGMENT '开头时，它是一个类型相对路径"],["body","\n"],["body","如果这已经是一个全部路径，则解析到指定的 类型。如果路径继续(例如，' <int>::size_of ')，那么下一个段是 使用以下过程进行解析。"],["body","\n"],["body","该过程旨在模拟 方法查找，因此对方法查找的任何更改也可能会更改 此查找算法。"],["body","\n"],["body","Given a path <T>::m::...:"],["body","\n\n"],["body","Search for members of inherent impls defined on T (if any) with\nthe name m. If any are found, the path resolves to that item."],["body","\n"],["body","Otherwise, let IN_SCOPE_TRAITS be the set of traits that are in\nscope and which contain a member named m:\n\n"],["body","Let IMPLEMENTED_TRAITS be those traits from IN_SCOPE_TRAITS\nfor which an implementation exists that (may) apply to T.\n\n"],["body","There can be ambiguity in the case that T contains type inference\nvariables."],["body","\n\n"],["body","\n"],["body","If IMPLEMENTED_TRAITS is not a singleton set, report an ambiguity\nerror. Otherwise, let TRAIT be the member of IMPLEMENTED_TRAITS."],["body","\n"],["body","If TRAIT is ambiguously implemented for T, report an\nambiguity error and request further type information."],["body","\n"],["body","Otherwise, rewrite the path to <T as Trait>::m::... and\ncontinue."],["body","\n\n"],["body","\n\n"],["headingLink","via-a-impl_segment-prefix"],["heading","Via a IMPL_SEGMENT prefix"],["body","\n"],["body","\n"],["body","The following text is somewhat different from the\nUFCS RFC."],["body","\n"],["body","\n"],["body","When a path begins with an IMPL_SEGMENT, it is a reference to an item defined\nfrom a trait. Note that such paths must always have a follow-on member m (that\nis, <T as Trait> is not a complete path, but <T as Trait>::m is)."],["body","\n"],["body","To resolve the path, first search for an applicable implementation of Trait\nfor T. If no implementation can be found -- or the result is ambiguous -- then\nreport an error.  Note that when T is a type parameter, a bound T: Trait\nguarantees that there is such an implementation, but does not count for\nambiguity purposes."],["body","\n"],["body","Otherwise, resolve the path to the member of the trait with the substitution\nSelf => T and continue."],["body","\n"],["body","This apparently straightforward algorithm has some subtle consequences, as\nillustrated by the following example:"],["body","\n"],["body","#![allow(unused)]\nfn main() {\ntrait Foo {\n    type T;\n    fn as_T(&self) -> &T;\n}\n\n// A blanket impl for any Show type T\nimpl<T: Show> Foo for T {\n    type T = T;\n    fn as_T(&self) -> &T { self }\n}\n\nfn bounded<U: Foo>(u: U) where U::T: Show {\n    // Here, we just constrain the associated type directly\n    println!(\"{}\", u.as_T())\n}\n\nfn blanket<U: Show>(u: U) {\n    // the blanket impl applies to U, so we know that `U: Foo` and\n    // <U as Foo>::T = U (and, of course, U: Show)\n    println!(\"{}\", u.as_T())\n}\n\nfn not_allowed<U: Foo>(u: U) {\n    // this will not compile, since <U as Trait>::T is not known to\n    // implement Show\n    println!(\"{}\", u.as_T())\n}\n}"],["body","\n"],["body","This example includes three generic functions that make use of an associated\ntype; the first two will typecheck, while the third will not."],["body","\n\n"],["body","\n"],["body","The first case, bounded, places a Show constraint directly on the\notherwise-abstract associated type U::T. Hence, it is allowed to assume that\nU::T: Show, even though it does not know the concrete implementation of\nFoo for U."],["body","\n"],["body","\n"],["body","\n"],["body","The second case, blanket, places a Show constraint on the type U, which\nmeans that the blanket impl of Foo applies even though we do not know the\nconcrete type that U will be. That fact means, moreover, that we can\ncompute exactly what the associated type U::T will be, and know that it will\nsatisfy Show. Coherence guarantees that that the blanket impl is the only\none that could apply to U. (See the section \"Impl specialization\" under\n\"Unresolved questions\" for a deeper discussion of this point.)"],["body","\n"],["body","\n"],["body","\n"],["body","The third case assumes only that U: Foo, and therefore nothing is known\nabout the associated type U::T. In particular, the function cannot assume\nthat U::T: Show."],["body","\n"],["body","\n\n"],["body","The resolution rules also interact with instantiation of type parameters in an\nintuitive way. For example:"],["body","\n"],["body","#![allow(unused)]\nfn main() {\ntrait Graph {\n    type N;\n    type E;\n    ...\n}\n\nimpl Graph for MyGraph {\n    type N = MyNode;\n    type E = MyEdge;\n    ...\n}\n\nfn pick_node<G: Graph>(t: &G) -> &G::N {\n    // the type G::N is abstract here\n    ...\n}\n\nlet G = MyGraph::new();\n...\npick_node(G) // has type: <MyGraph as Graph>::N = MyNode\n}"],["body","\n"],["body","Assuming there are no blanket implementations of Graph, the pick_node\nfunction knows nothing about the associated type G::N. However, a client of\npick_node that instantiates it with a particular concrete graph type will also\nknow the concrete type of the value returned from the function -- here, MyNode."],["body","\n"],["headingLink","scoping-of-trait-and-impl-items"],["heading","Scoping of trait and impl items"],["body","\n"],["body","Associated types are frequently referred to in the signatures of a trait's\nmethods and associated functions, and it is natural and convenient to refer to\nthem directly."],["body","\n"],["body","In other words, writing this:"],["body","\n"],["body","#![allow(unused)]\nfn main() {\ntrait Graph {\n    type N;\n    type E;\n    fn has_edge(&self, &N, &N) -> bool;\n    ...\n}\n}"],["body","\n"],["body","is more appealing than writing this:"],["body","\n"],["body","#![allow(unused)]\nfn main() {\ntrait Graph {\n    type N;\n    type E;\n    fn has_edge(&self, &Self::N, &Self::N) -> bool;\n    ...\n}\n}"],["body","\n"],["body","This RFC proposes to treat both trait and impl bodies (both\ninherent and for traits) the same way we treat mod bodies: all\nitems being defined are in scope. In particular, methods are in scope\nas UFCS-style functions:"],["body","\n"],["body","#![allow(unused)]\nfn main() {\ntrait Foo {\n    type AssocType;\n    lifetime 'assoc_lifetime;\n    const ASSOC_CONST: uint;\n    fn assoc_fn() -> Self;\n\n    // Note: 'assoc_lifetime and AssocType in scope:\n    fn method(&self, Self) -> &'assoc_lifetime AssocType;\n\n    fn default_method(&self) -> uint {\n        // method in scope UFCS-style, assoc_fn in scope\n        let _ = method(self, assoc_fn());\n        ASSOC_CONST // in scope\n    }\n}\n\n// Same scoping rules for impls, including inherent impls:\nstruct Bar;\nimpl Bar {\n    fn foo(&self) { ... }\n    fn bar(&self) {\n        foo(self); // foo in scope UFCS-style\n        ...\n    }\n}\n}"],["body","\n"],["body","Items from super traits are not in scope, however. See\nthe discussion on super traits below for more detail."],["body","\n"],["body","These scope rules provide good ergonomics for associated types in\nparticular, and a consistent scope model for language constructs that\ncan contain items (like traits, impls, and modules). In the long run,\nwe should also explore imports for trait items, i.e. use Trait::some_method, but that is out of scope for this RFC."],["body","\n"],["body","Note that, according to this proposal, associated types/lifetimes are not in\nscope for the optional where clause on the trait header. For example:"],["body","\n"],["body","#![allow(unused)]\nfn main() {\ntrait Foo<Input>\n    // type parameters in scope, but associated types are not:\n    where Bar<Input, Self::Output>: Encodable {\n\n    type Output;\n    ...\n}\n}"],["body","\n"],["body","This setup seems more intuitive than allowing the trait header to refer directly\nto items defined within the trait body."],["body","\n"],["body","It's also worth noting that trait-level where clauses are never needed for\nconstraining associated types anyway, because associated types also have where\nclauses. Thus, the above example could (and should) instead be written as\nfollows:"],["body","\n"],["body","#![allow(unused)]\nfn main() {\ntrait Foo<Input> {\n    type Output where Bar<Input, Output>: Encodable;\n    ...\n}\n}"],["body","\n"],["headingLink","constraining-associated-types"],["heading","Constraining associated types"],["body","\n"],["body","Associated types are not treated as parameters to a trait, but in some cases a\nfunction will want to constrain associated types in some way. For example, as\nexplained in the Motivation section, the Iterator trait should treat the\nelement type as an output:"],["body","\n"],["body","#![allow(unused)]\nfn main() {\ntrait Iterator {\n    type A;\n    fn next(&mut self) -> Option<A>;\n    ...\n}\n}"],["body","\n"],["body","For code that works with iterators generically, there is no need to constrain\nthis type:"],["body","\n"],["body","#![allow(unused)]\nfn main() {\nfn collect_into_vec<I: Iterator>(iter: I) -> Vec<I::A> { ... }\n}"],["body","\n"],["body","But other code may have requirements for the element type:"],["body","\n\n"],["body","That it implements some traits (bounds)."],["body","\n"],["body","That it unifies with a particular type."],["body","\n\n"],["body","These requirements can be imposed via where clauses:"],["body","\n"],["body","#![allow(unused)]\nfn main() {\nfn print_iter<I>(iter: I) where I: Iterator, I::A: Show { ... }\nfn sum_uints<I>(iter: I) where I: Iterator, I::A = uint { ... }\n}"],["body","\n"],["body","In addition, there is a shorthand for equality constraints:"],["body","\n"],["body","#![allow(unused)]\nfn main() {\nfn sum_uints<I: Iterator<A = uint>>(iter: I) { ... }\n}"],["body","\n"],["body","In general, a trait like:"],["body","\n"],["body","#![allow(unused)]\nfn main() {\ntrait Foo<Input1, Input2> {\n    type Output1;\n    type Output2;\n    lifetime 'a;\n    const C: bool;\n    ...\n}\n}"],["body","\n"],["body","can be written in a bound like:"],["body","\n"],["body","T: Foo<I1, I2>\nT: Foo<I1, I2, Output1 = O1>\nT: Foo<I1, I2, Output2 = O2>\nT: Foo<I1, I2, Output1 = O1, Output2 = O2>\nT: Foo<I1, I2, Output1 = O1, 'a = 'b, Output2 = O2>\nT: Foo<I1, I2, Output1 = O1, 'a = 'b, C = true, Output2 = O2>\n"],["body","\n"],["body","The output constraints must come after all input arguments, but can appear in\nany order."],["body","\n"],["body","Note that output constraints are allowed when referencing a trait in a type or\na bound, but not in an IMPL_SEGMENT path:"],["body","\n\n"],["body","As a type: fn foo(obj: Box<Iterator<A = uint>> is allowed."],["body","\n"],["body","In a bound: fn foo<I: Iterator<A = uint>>(iter: I) is allowed."],["body","\n"],["body","In an IMPL_SEGMENT: <I as Iterator<A = uint>>::next is not allowed."],["body","\n\n"],["body","The reason not to allow output constraints in IMPL_SEGMENT is that such paths\nare references to a trait implementation that has already been determined -- it\ndoes not make sense to apply additional constraints to the implementation when\nreferencing it."],["body","\n"],["body","Output constraints are a handy shorthand when using trait bounds, but they are a\nnecessity for trait objects, which we discuss next."],["body","\n"],["headingLink","trait-objects"],["heading","Trait objects"],["body","\n"],["body","When using trait objects, the Self type is \"erased\", so different types\nimplementing the trait can be used under the same trait object type:"],["body","\n"],["body","#![allow(unused)]\nfn main() {\nimpl Show for Foo { ... }\nimpl Show for Bar { ... }\n\nfn make_vec() -> Vec<Box<Show>> {\n    let f = Foo { ... };\n    let b = Bar { ... };\n    let mut v = Vec::new();\n    v.push(box f as Box<Show>);\n    v.push(box b as Box<Show>);\n    v\n}\n}"],["body","\n"],["body","One consequence of erasing Self is that methods using the Self type as\narguments or return values cannot be used on trait objects, since their types\nwould differ for different choices of Self."],["body","\n"],["body","In the model presented in this RFC, traits have additional input parameters\nbeyond Self, as well as associated types that may vary depending on all of the\ninput parameters. This raises the question: which of these types, if any, are\nerased in trait objects?"],["body","\n"],["body","The approach we take here is the simplest and most conservative: when using a\ntrait as a type (i.e., as a trait object), all input and output types must\nbe provided as part of the type. In other words, only the Self type is\nerased, and all other types are specified statically in the trait object type."],["body","\n"],["body","Consider again the following example:"],["body","\n"],["body","#![allow(unused)]\nfn main() {\ntrait Foo<Input1, Input2> {\n    type Output1;\n    type Output2;\n    lifetime 'a;\n    const C: bool;\n    ...\n}\n}"],["body","\n"],["body","Unlike the case for static trait bounds, which do not have to specify any of the\nassociated types, lifetimes, or consts, (but do have to specify the input types),\ntrait object types must specify all of the types:"],["body","\n"],["body","#![allow(unused)]\nfn main() {\nfn consume_foo<T: Foo<I1, I2>>(t: T) // this is valid\nfn consume_obj(t: Box<Foo<I1, I2>>)  // this is NOT valid\n\n// but this IS valid:\nfn consume_obj(t: Box<Foo<I1, I2, Output1 = O2, Output2 = O2, 'a = 'static, C = true>>)\n}"],["body","\n"],["body","With this design, it is clear that none of the non-Self types are erased as\npart of trait objects. But it leaves wiggle room to relax this restriction\nlater on: trait object types that are not allowed under this design can be given\nmeaning in some later design."],["body","\n"],["headingLink","inherent-associated-items"],["heading","Inherent associated items"],["body","\n"],["body","All associated items are also allowed in inherent impls, so a definition like\nthe following is allowed:"],["body","\n"],["body","#![allow(unused)]\nfn main() {\nstruct MyGraph { ... }\nstruct MyNode { ... }\nstruct MyEdge { ... }\n\nimpl MyGraph {\n    type N = MyNode;\n    type E = MyEdge;\n\n    // Note: associated types in scope, just as with trait bodies\n    fn has_edge(&self, &N, &N) -> bool {\n        ...\n    }\n\n    ...\n}\n}"],["body","\n"],["body","Inherent associated items are referenced similarly to trait associated items:"],["body","\n"],["body","#![allow(unused)]\nfn main() {\nfn distance(g: &MyGraph, from: &MyGraph::N, to: &MyGraph::N) -> uint { ... }\n}"],["body","\n"],["body","Note, however, that output constraints do not make sense for inherent outputs:"],["body","\n"],["body","#![allow(unused)]\nfn main() {\n// This is *not* a legal type:\nMyGraph<N = SomeNodeType>\n}"],["body","\n"],["headingLink","the-inputoutput-type-distinction"],["heading","The input/output type distinction"],["body","\n"],["body","When designing a trait that references some unknown type, you now have the\noption of taking that type as an input parameter, or specifying it as an output\nassociated type. What are the ramifications of this decision?"],["body","\n"],["headingLink","coherence-implications"],["heading","Coherence implications"],["body","\n"],["body","Input types are used when determining which impl matches, even for the same\nSelf type:"],["body","\n"],["body","#![allow(unused)]\nfn main() {\ntrait Iterable1<A> {\n    type I: Iterator<A>;\n    fn iter(self) -> I;\n}\n\n// These impls have distinct input types, so are allowed\nimpl Iterable1<u8> for Foo { ... }\nimpl Iterable1<char> for Foo { ... }\n\ntrait Iterable2 {\n    type A;\n    type I: Iterator<A>;\n    fn iter(self) -> I;\n}\n\n// These impls apply to a common input (Foo), so are NOT allowed\nimpl Iterable2 for Foo { ... }\nimpl Iterable2 for Foo { ... }\n}"],["body","\n"],["body","More formally, the coherence property is revised as follows:"],["body","\n\n"],["body","Given a trait and values for all its type parameters (inputs, including\nSelf), there is at most one applicable impl."],["body","\n\n"],["body","In the trait reform RFC, coherence\nis guaranteed by maintaining two other key properties, which are revised as\nfollows:"],["body","\n"],["body","Orphan check: Every implementation must meet one of\nthe following conditions:"],["body","\n\n"],["body","\n"],["body","The trait being implemented (if any) must be defined in the current crate."],["body","\n"],["body","\n"],["body","\n"],["body","At least one of the input type parameters (including but not\nnecessarily Self) must meet the following grammar, where C\nis a struct or enum defined within the current crate:"],["body","\n"],["body","T = C\n  | [T]\n  | [T, ..n]\n  | &T\n  | &mut T\n  | ~T\n  | (..., T, ...)\n  | X<..., T, ...> where X is not bivariant with respect to T\n"],["body","\n"],["body","\n\n"],["body","Overlapping instances: No two implementations can be instantiable\nwith the same set of types for the input type parameters."],["body","\n"],["body","See the trait reform RFC for more\ndiscussion of these properties."],["body","\n"],["headingLink","type-inference-implications"],["heading","Type inference implications"],["body","\n"],["body","Finally, output type parameters can be inferred/resolved as soon as there is\na matching impl based on the input type parameters. Because of the\ncoherence property above, there can be at most one."],["body","\n"],["body","On the other hand, even if there is only one applicable impl, type inference\nis not allowed to infer the input type parameters from it. This restriction\nmakes it possible to ensure crate concatenation: adding another crate may add\nimpls for a given trait, and if type inference depended on the absence of such\nimpls, importing a crate could break existing code."],["body","\n"],["body","In practice, these inference benefits can be quite valuable. For example, in the\nAdd trait given at the beginning of this RFC, the Sum output type is\nimmediately known once the input types are known, which can avoid the need for\ntype annotations."],["body","\n"],["headingLink","limitations"],["heading","Limitations"],["body","\n"],["body","The main limitation of associated items as presented here is about associated\ntypes in particular. You might be tempted to write a trait like the following:"],["body","\n"],["body","#![allow(unused)]\nfn main() {\ntrait Iterable {\n    type A;\n    type I: Iterator<&'a A>; // what is the lifetime here?\n    fn iter<'a>(&'a self) -> I;  // and how to connect it to self?\n}\n}"],["body","\n"],["body","The problem is that, when implementing this trait, the return type I of iter\nmust generally depend on the lifetime of self. For example, the corresponding\nmethod in Vec looks like the following:"],["body","\n"],["body","#![allow(unused)]\nfn main() {\nimpl<T> Vec<T> {\n    fn iter(&'a self) -> Items<'a, T> { ... }\n}\n}"],["body","\n"],["body","This means that, given a Vec<T>, there isn't a single type Items<T> for\niteration -- rather, there is a family of types, one for each input lifetime.\nIn other words, the associated type I in the Iterable needs to be\n\"higher-kinded\": not just a single type, but rather a family:"],["body","\n"],["body","#![allow(unused)]\nfn main() {\ntrait Iterable {\n    type A;\n    type I<'a>: Iterator<&'a A>;\n    fn iter<'a>(&self) -> I<'a>;\n}\n}"],["body","\n"],["body","In this case, I is parameterized by a lifetime, but in other cases (like\nmap) an associated type needs to be parameterized by a type."],["body","\n"],["body","In general, such higher-kinded types (HKTs) are a much-requested feature for\nRust, and they would extend the reach of associated types. But the design and\nimplementation of higher-kinded types is, by itself, a significant investment.\nThe point of view of this RFC is that associated items bring the most important\nchanges needed to stabilize our existing traits (and add a few key others),\nwhile HKTs will allow us to define important traits in the future but are not\nnecessary for 1.0."],["body","\n"],["headingLink","encoding-higher-kinded-types"],["heading","Encoding higher-kinded types"],["body","\n"],["body","That said, it's worth pointing out that variants of higher-kinded types can be\nencoded in the system being proposed here."],["body","\n"],["body","For example, the Iterable example above can be written in the following\nsomewhat contorted style:"],["body","\n"],["body","#![allow(unused)]\nfn main() {\ntrait IterableOwned {\n    type A;\n    type I: Iterator<A>;\n    fn iter_owned(self) -> I;\n}\n\ntrait Iterable {\n    fn iter<'a>(&'a self) -> <&'a Self>::I where &'a Self: IterableOwned {\n        IterableOwned::iter_owned(self)\n    }\n}\n}"],["body","\n"],["body","The idea here is to define a trait that takes, as input type/lifetimes\nparameters, the parameters to any HKTs. In this case, the trait is implemented\non the type &'a Self, which includes the lifetime parameter."],["body","\n"],["body","We can in fact generalize this technique to encode arbitrary HKTs:"],["body","\n"],["body","#![allow(unused)]\nfn main() {\n// The kind * -> *\ntrait TypeToType<Input> {\n    type Output;\n}\ntype Apply<Name, Elt> where Name: TypeToType<Elt> = Name::Output;\n\nstruct Vec_;\nstruct DList_;\n\nimpl<T> TypeToType<T> for Vec_ {\n    type Output = Vec<T>;\n}\n\nimpl<T> TypeToType<T> for DList_ {\n    type Output = DList<T>;\n}\n\ntrait Mappable\n{\n    type E;\n    type HKT where Apply<HKT, E> = Self;\n\n    fn map<F>(self, f: E -> F) -> Apply<HKT, F>;\n}\n}"],["body","\n"],["body","While the above demonstrates the versatility of associated types and where\nclauses, it is probably too much of a hack to be viable for use in libstd."],["body","\n"],["headingLink","associated-consts-in-generic-code"],["heading","Associated consts in generic code"],["body","\n"],["body","If the value of an associated const depends on a type parameter (including\nSelf), it cannot be used in a constant expression. This restriction will\nalmost certainly be lifted in the future, but this raises questions outside the\nscope of this RFC."],["body","\n"],["headingLink","staging"],["heading","Staging"],["body","\n"],["body","Associated lifetimes are probably not necessary for the 1.0 timeframe. While we\ncurrently have a few traits that are parameterized by lifetimes, most of these\ncan go away once DST lands."],["body","\n"],["body","On the other hand, associated lifetimes are probably trivial to implement once\nassociated types have been implemented."],["body","\n"],["headingLink","other-interactions"],["heading","Other interactions"],["body","\n"],["headingLink","interaction-with-implied-bounds"],["heading","Interaction with implied bounds"],["body","\n"],["body","As part of the\nimplied bounds\nidea, it may be desirable for this:"],["body","\n"],["body","#![allow(unused)]\nfn main() {\nfn pick_node<G>(g: &G) -> &<G as Graph>::N\n}"],["body","\n"],["body","to be sugar for this:"],["body","\n"],["body","#![allow(unused)]\nfn main() {\nfn pick_node<G: Graph>(g: &G) -> &<G as Graph>::N\n}"],["body","\n"],["body","But this feature can easily be added later, as part of a general implied bounds RFC."],["body","\n"],["headingLink","future-proofing-specialization-of-impls"],["heading","Future-proofing: specialization of impls"],["body","\n"],["body","In the future, we may wish to relax the \"overlapping instances\" rule so that one\ncan provide \"blanket\" trait implementations and then \"specialize\" them for\nparticular types. For example:"],["body","\n"],["body","#![allow(unused)]\nfn main() {\ntrait Sliceable {\n    type Slice;\n    // note: not using &self here to avoid need for HKT\n    fn as_slice(self) -> Slice;\n}\n\nimpl<'a, T> Sliceable for &'a T {\n    type Slice = &'a T;\n    fn as_slice(self) -> &'a T { self }\n}\n\nimpl<'a, T> Sliceable for &'a Vec<T> {\n    type Slice = &'a [T];\n    fn as_slice(self) -> &'a [T] { self.as_slice() }\n}\n}"],["body","\n"],["body","But then there's a difficult question:"],["body","\n"],["body","fn dice<A>(a: &A) -> &A::Slice where &A: Slicable {\n    a // is this allowed?\n}\n"],["body","\n"],["body","Here, the blanket and specialized implementations provide incompatible\nassociated types. When working with the trait generically, what can we assume\nabout the associated type? If we assume it is the blanket one, the type may\nchange during monomorphization (when specialization takes effect)!"],["body","\n"],["body","The RFC does allow generic code to \"see\" associated types provided by blanket\nimplementations, so this is a potential problem."],["body","\n"],["body","Our suggested strategy is the following. If at some later point we wish to add\nspecialization, traits would have to opt in explicitly. For such traits, we\nwould not allow generic code to \"see\" associated types for blanket\nimplementations; instead, output types would only be visible when all input\ntypes were concretely known. This approach is backwards-compatible with the RFC,\nand is probably a good idea in any case."],["body","\n"],["headingLink","alternatives"],["heading","Alternatives"],["body","\n"],["headingLink","multidispatch-through-tuple-types"],["heading","Multidispatch through tuple types"],["body","\n"],["body","This RFC clarifies trait matching by making trait type parameters inputs to\nmatching, and associated types outputs."],["body","\n"],["body","A more radical alternative would be to remove type parameters from traits, and\ninstead support multiple input types through a separate multidispatch mechanism."],["body","\n"],["body","In this design, the Add trait would be written and implemented as follows:"],["body","\n"],["body","#![allow(unused)]\nfn main() {\n// Lhs and Rhs are *inputs*\ntrait Add for (Lhs, Rhs) {\n    type Sum; // Sum is an *output*\n    fn add(&Lhs, &Rhs) -> Sum;\n}\n\nimpl Add for (int, int) {\n    type Sum = int;\n    fn add(left: &int, right: &int) -> int { ... }\n}\n\nimpl Add for (int, Complex) {\n    type Sum = Complex;\n    fn add(left: &int, right: &Complex) -> Complex { ... }\n}\n}"],["body","\n"],["body","The for syntax in the trait definition is used for multidispatch traits, here\nsaying that impls must be for pairs of types which are bound to Lhs and\nRhs respectively. The add function can then be invoked in UFCS style by\nwriting"],["body","\n"],["body","#![allow(unused)]\nfn main() {\nAdd::add(some_int, some_complex)\n}"],["body","\n"],["body","Advantages of the tuple approach:"],["body","\n\n"],["body","\n"],["body","It does not force a distinction between Self and other input types, which in\nsome cases (including binary operators like Add) can be artificial."],["body","\n"],["body","\n"],["body","\n"],["body","Makes it possible to specify input types without specifying the trait:\n<(A, B)>::Sum rather than <A as Add<B>>::Sum."],["body","\n"],["body","\n\n"],["body","Disadvantages of the tuple approach:"],["body","\n\n"],["body","\n"],["body","It's more painful when you do want a method rather than a function."],["body","\n"],["body","\n"],["body","\n"],["body","Requires where clauses when used in bounds: where (A, B): Trait rather\nthan A: Trait<B>."],["body","\n"],["body","\n"],["body","\n"],["body","It gives two ways to write single dispatch: either without for, or using\nfor with a single-element tuple."],["body","\n"],["body","\n"],["body","\n"],["body","There's a somewhat jarring distinction between single/multiple dispatch\ntraits, making the latter feel \"bolted on\"."],["body","\n"],["body","\n"],["body","\n"],["body","The tuple syntax is unusual in acting as a binder of its types, as opposed to\nthe Trait<A, B> syntax."],["body","\n"],["body","\n"],["body","\n"],["body","Relatedly, the generics syntax for traits is immediately understandable (a\nfamily of traits) based on other uses of generics in the language, while the\ntuple notation stands alone."],["body","\n"],["body","\n"],["body","\n"],["body","Less clear story for trait objects (although the fact that Self is the only\nerased input type in this RFC may seem somewhat arbitrary)."],["body","\n"],["body","\n\n"],["body","On balance, the generics-based approach seems like a better fit for the language\ndesign, especially in its interaction with methods and the object system."],["body","\n"],["headingLink","a-backwards-compatible-version"],["heading","A backwards-compatible version"],["body","\n"],["body","Yet another alternative would be to allow trait type parameters to be either\ninputs or outputs, marking the inputs with a keyword in:"],["body","\n"],["body","#![allow(unused)]\nfn main() {\ntrait Add<in Rhs, Sum> {\n    fn add(&Lhs, &Rhs) -> Sum;\n}\n}"],["body","\n"],["body","This would provide a way of adding multidispatch now, and then adding associated\nitems later on without breakage. If, in addition, output types had to come after\nall input types, it might even be possible to migrate output type parameters\nlike Sum above into associated types later."],["body","\n"],["body","This is perhaps a reasonable fallback, but it seems better to introduce a clean\ndesign with both multidispatch and associated items together."],["body","\n"],["headingLink","unresolved-questions"],["heading","Unresolved questions"],["body","\n"],["headingLink","super-traits"],["heading","Super traits"],["body","\n"],["body","This RFC largely ignores super traits."],["body","\n"],["body","Currently, the implementation of super traits treats them identically to a\nwhere clause that bounds Self, and this RFC does not propose to change\nthat. However, a follow-up RFC should clarify that this is the intended\nsemantics for super traits."],["body","\n"],["body","Note that this treatment of super traits is, in particular, consistent with the\nproposed scoping rules, which do not bring items from super traits into scope in\nthe body of a subtrait; they must be accessed via Self::item_name."],["body","\n"],["headingLink","equality-constraints-in-where-clauses"],["heading","Equality constraints in where clauses"],["body","\n"],["body","This RFC allows equality constraints on types for associated types, but does not\npropose a similar feature for where clauses. That will be the subject of a\nfollow-up RFC."],["body","\n"],["headingLink","multiple-trait-object-bounds-for-the-same-trait"],["heading","Multiple trait object bounds for the same trait"],["body","\n"],["body","The design here makes it possible to write bounds or trait objects that mention\nthe same trait, multiple times, with different inputs:"],["body","\n"],["body","#![allow(unused)]\nfn main() {\nfn mulit_add<T: Add<int> + Add<Complex>>(t: T) -> T { ... }\nfn mulit_add_obj(t: Box<Add<int> + Add<Complex>>) -> Box<Add<int> + Add<Complex>> { ... }\n}"],["body","\n"],["body","This seems like a potentially useful feature, and should be unproblematic for\nbounds, but may have implications for vtables that make it problematic for trait\nobjects. Whether or not such trait combinations are allowed will likely depend\non implementation concerns, which are not yet clear."],["body","\n"],["headingLink","generic-associated-consts-in-match-patterns"],["heading","Generic associated consts in match patterns"],["body","\n"],["body","It seems desirable to allow constants that depend on type parameters in match\npatterns, but it's not clear how to do so while still checking exhaustiveness\nand reachability of the match arms. Most likely this requires new forms of\nwhere clause, to constrain associated constant values."],["body","\n"],["body","For now, we simply defer the question."],["body","\n"],["headingLink","generic-associated-consts-in-array-sizes"],["heading","Generic associated consts in array sizes"],["body","\n"],["body","It would be useful to be able to use trait-associated constants in generic code."],["body","\n"],["body","#![allow(unused)]\nfn main() {\n// Shouldn't this be OK?\nconst ALIAS_N: usize = <T>::N;\nlet x: [u8; <T>::N] = [0u8; ALIAS_N];\n// Or...\nlet x: [u8; T::N + 1] = [0u8; T::N + 1];\n}"],["body","\n"],["body","However, this causes some problems. What should we do with the following case in\ntype checking, where we need to prove that a generic is valid for any T?"],["body","\n"],["body","#![allow(unused)]\nfn main() {\nlet x: [u8; T::N + T::N] = [0u8; 2 * T::N];\n}"],["body","\n"],["body","We would like to handle at least some obvious cases (e.g. proving that\nT::N == T::N), but without trying to prove arbitrary statements about\narithmetic. The question of how to do this is deferred."],["body","\n\n\n\n                    "],["body","\n\n                    \n                \n            \n\n            \n\n        \n\n\n\n\n        \n\n\n\n        \n        \n        \n\n        \n\n\n    \n    \n\n"]],[["_relative_fp","6函数式编程.html"],["title","函数式编程.md - RUST学习笔记"],["body","\n    \n        \n        \n\n        \n        \n\n        \n        \n\n        \n\n        \n        \n\n        \n\n        \n        \n\n        \n\n            \n                                \n                \n                    \n                        "],["body","\n                            \n                        "],["body","\n                        "],["body","\n                            \n                        "],["body","\n                        \n                            "],["body","Light"],["body","\n                            "],["body","Rust"],["body","\n                            "],["body","Coal"],["body","\n                            "],["body","Navy"],["body","\n                            "],["body","Ayu"],["body","\n                        \n                    \n\n                    "],["heading","RUST学习笔记"],["body","\n\n                    \n\n                    \n                \n\n\n                \n                \n\n                \n                    "],["body","\n                        \n\n"],["body","\n"],["body","\n\n"],["headingLink","实例1"],["heading","实例1"],["body","\n"],["body","#![allow(unused)]\nfn main() {\n// 函数式的写法\nlet sum_of_squared_odd_numbers: u32 =\n    (0..).map(|n| n * n)             // 所有自然数取平方\n         .take_while(|&n| n < upper) // 取小于上限的\n         .filter(|&n| is_odd(n))     // 取奇数\n         .fold(0, |sum, i| sum + i); // 最后加起来\nprintln!(\"functional style: {}\", sum_of_squared_odd_numbers);\n}"],["body","\n\n\n\n                    "],["body","\n\n                    \n                \n            \n\n            \n\n        \n\n\n\n\n        \n\n\n\n        \n        \n        \n\n        \n\n\n    \n    \n\n"]],[["_relative_fp","16const类型与函数.html"],["title","const类型与函数.md - RUST学习笔记"],["body","\n    \n        \n        \n\n        \n        \n\n        \n        \n\n        \n\n        \n        \n\n        \n\n        \n        \n\n        \n\n            \n                                \n                \n                    \n                        "],["body","\n                            \n                        "],["body","\n                        "],["body","\n                            \n                        "],["body","\n                        \n                            "],["body","Light"],["body","\n                            "],["body","Rust"],["body","\n                            "],["body","Coal"],["body","\n                            "],["body","Navy"],["body","\n                            "],["body","Ayu"],["body","\n                        \n                    \n\n                    "],["heading","RUST学习笔记"],["body","\n\n                    \n\n                    \n                \n\n\n                \n                \n\n                \n                    "],["body","\n                        \n\n"],["body","\n"],["body","\n\n"],["headingLink","const-typestraits-and-implementations-in-rust"],["heading","const types,traits and implementations in rust"],["body","\n"],["body","Rust 允许以  const 和 const fn 的形式 的有限形式 编译时函数 执行\n"],["body","\n"],["body","虽然最初，const似乎 是一个 合理的简单功能，但它最终提出了大量有趣而复杂得设计问题，\nconst fn  是一种非常受限的函数\n：不允许带trait bound的泛型参数：这是因为需要考虑 const代码与 运行时代码 交互的问题"],["body","\n"],["body","但是很难确定一个满足所有要求，又尽可能简约的设计，"],["body","\n"],["headingLink","proposed-design"],["heading","Proposed design"],["body","\n"],["body","\n"],["body","建议设计"],["body","\n"],["body","\n\n"],["body","最要的概念是如何将 const函数 视为 运行时函数或转换为运行时函数"],["body","\n"],["body","始终能够 在运行时调用 const函数"],["body","\n\n"],["body","#![allow(unused)]\nfn main() {\nconst fn foo<A: T>(A) -> A;\n}"],["body","\n"],["body","这个cost函数将会以如下方式解析"],["body","\n\n"],["body","在编译时调用 foo时，必须有一个 类型为A的const常量，且实现了trait T，且 实现 T for A 必须也是 const的实现"],["body","\n"],["body","在运行时调 foo时，没有特殊要求"],["body","\n\n"],["body","#![allow(unused)]\nfn main() {\nfn bar<A: T>(A) -> A;\n}"],["body","\n\n"],["body","bar不能在编译时调用"],["body","\n"],["body","在运行时调 foo时，没有特殊要求"],["body","\n\n"],["headingLink","const-implementations"],["heading","const implementations"],["body","\n"],["body","\n"],["body","cost实现"],["body","\n"],["body","\n\n"],["body","对于 trait T ，类型A的实现必须要满足：每个函数都必须是 const函数"],["body","\n"],["body","如果视线中有一个不是 const函数，则该实现 不是 const实现"],["body","\n"],["body","如果存在 默认方法，必须也得覆盖，除非默认方法本来就是 const"],["body","\n\n"],["headingLink","const-functions-with-generic-trait-bound-types"],["heading","const functions with generic trait bound types"],["body","\n"],["body","\n"],["body","具有泛型trait绑定类型的 const 函数"],["body","\n"],["body","\n"],["body","#![allow(unused)]\nfn main() {\nconst fn baz<A: T>(A) -> A;\n}"],["body","\n"],["body","只接受 tarit T的 const实现的 类型A"],["body","\n"],["headingLink","explicitly-const-trait-bounds"],["heading","Explicitly-const trait bounds"],["body","\n"],["body","\n"],["body","显示const trait 绑定"],["body","\n"],["body","\n"],["body","#![allow(unused)]\nfn main() {\nfn baz<A: const T>(A) -> A {\n    // We can only call a `T` method of `A`\n    // in a `const` variable declaration\n    // if we know `A` `const`-implements `T`,\n    // so the trait bound must explicitly\n    // be `const`.\n    const X: bool = <A as T>::choice();\n    ...\n}\n}"],["body","\n"],["body","如果 在函数内部 显示调用了 trait的方法。则必须声明为 impl T for A is const "],["body","\n"],["headingLink","const-in-traits"],["heading","const in traits"],["body","\n"],["body","#![allow(unused)]\nfn main() {\n//要求所有实现都必须 const实现 choice\ntrait T {\n    const fn choice() -> bool;\n    ...\n}\nfn baz<A: T>(A) -> A {\n    // Now, `<A: const T>` is not needed, since\n    // `choice` is always const in any implementation\n    // of `T`.\n    const X: bool = <A as T>::choice();\n    ...\n}\n}"],["body","\n"],["headingLink","opting-out-of-const-trait-bounds-with-const"],["heading","Opting out of const trait bounds with ?const"],["body","\n"],["body","\n"],["body","选择性退出 const实现"],["body","\n"],["body","\n"],["body","#![allow(unused)]\nfn main() {\ntrait T {\n    const fn choice() -> bool;\n\n    fn validate(u8) -> bool;\n}\n\nstruct S;\n\nimpl T for S {\n    const fn choice() -> bool {\n        ...\n    }\n\n    fn validate(u8) -> bool {\n        ...\n    }\n}\n\nconst fn bar<A: T>(A) -> A {\n    let x: bool = <A as T>::choice();\n    ...\n}\n}"],["body","\n\n"],["body","如果某个函数 中只使用到了 某个 trait的某个 const函数"],["body","\n"],["body","但是在函数申明时 必须要求 const 实现： trait实现里的所有方法都必须是 const"],["body","\n"],["body","可以通过  显式 const trait bounds 选择退出 来放宽 此要求 ：?const"],["body","\n\n"],["body","#![allow(unused)]\nfn main() {\nconst fn bar_opt_ct<A: ?const T>(A) -> A {\n    let x: bool = <A as T>::choice();\n    ...\n}\n}"],["body","\n\n"],["body","默认的  const fn  需要 const trait bounds ，而对于运行时没有要求"],["body","\n"],["body","以 ?const 为前缀的 trait bounds 不需要 const traits bounds 。在编译时、或者运行时"],["body","\n\n"],["headingLink","removal-of-the-const-keyword"],["heading","Removal of the const keyword"],["body","\n"],["body","由于任何 const 函数都可以在运行时调用，因此它也必须是有效的非 const 函数（在适当的翻译之后）：这就是我们定义的直觉和动机。转换只是修改函数签名，而不更改正文。这种转换非常简单，只需从函数中删除 const 前缀并删除任何 ？const 边界即可。"],["body","\n"],["headingLink","syntactic-sugar-for-const-on-traits-and-impls"],["heading","Syntactic sugar for const on traits and impls"],["body","\n"],["body","\n"],["body","const 语法糖"],["body","\n"],["body","\n"],["body","可以将 trait 申明为 const 或者 将 实现 声明为 trait"],["body","\n"],["body","#![allow(unused)]\nfn main() {\nconst trait V {\n    fn foo(C) -> D;\n    fn bar(E) -> F;\n}\n// ...desugars to...\ntrait V {\n    const fn foo(C) -> D;\n    const fn bar(E) -> F;\n}\n\nstruct P;\n\nconst impl V for P {\n    fn foo(C) -> D;\n    fn bar(E) -> F;\n}\n// ...desugars to...\nimpl V for P {\n    const fn foo(C) -> D;\n    const fn bar(E) -> F;\n}\n\n}"],["body","\n"],["body","参考文章"],["body","\n\n\n\n                    "],["body","\n\n                    \n                \n            \n\n            \n\n        \n\n\n\n\n        \n\n\n\n        \n        \n        \n\n        \n\n\n    \n    \n\n"]],[["_relative_fp","17Rust库API设计文档规范.html"],["title","Rust库API设计文档规范.md - RUST学习笔记"],["body","\n    \n        \n        \n\n        \n        \n\n        \n        \n\n        \n\n        \n        \n\n        \n\n        \n        \n\n        \n\n            \n                                \n                \n                    \n                        "],["body","\n                            \n                        "],["body","\n                        "],["body","\n                            \n                        "],["body","\n                        \n                            "],["body","Light"],["body","\n                            "],["body","Rust"],["body","\n                            "],["body","Coal"],["body","\n                            "],["body","Navy"],["body","\n                            "],["body","Ayu"],["body","\n                        \n                    \n\n                    "],["heading","RUST学习笔记"],["body","\n\n                    \n\n                    \n                \n\n\n                \n                \n\n                \n                    "],["body","\n                        \n\n"],["body","\n"],["body","\n\n"],["headingLink","什么是优雅的-api"],["heading","什么是优雅的 API"],["body","\n\n"],["body","\n"],["body","方法名清晰易懂，以让调用了这个 API 的代码易于阅读。"],["body","\n"],["body","\n"],["body","\n"],["body","有规律、可猜测的方法名在使用 API 时也很有用，可以减少阅读文档的需求。"],["body","\n"],["body","\n"],["body","\n"],["body","每个 API 都有至少要有文档和一小段示例代码。"],["body","\n"],["body","\n"],["body","\n"],["body","用户几乎不需要编写样板代码（boilerplate code）来使用这个 API，因为"],["body","\n\n"],["body","它广泛接受各种输入类型（当然类型转换是显式的）"],["body","\n"],["body","并且也有足以应付大部分常用情况的一键 API"],["body","\n\n"],["body","\n"],["body","\n"],["body","充分利用类型来防止逻辑错误，但不会太妨碍使用。"],["body","\n"],["body","\n"],["body","\n"],["body","返回有意义的错误，并且在文档中注明会导致 panic 的情况。"],["body","\n"],["body","\n\n"],["headingLink","技术"],["heading","技术"],["body","\n"],["body","\n"],["body","有一些 Rust RFC 描述了标准库的命名方案。你也应该遵循它们，以让用户能迅速上手使用你的库。"],["body","\n"],["body","\n\n"],["body","\n"],["body","RFC 199 解释说应该使用 mut、move 或 ref 作为后缀，来根据参数的可变性区分方法。"],["body","\n"],["body","\n"],["body","\n"],["body","RFC 344 定义了一些有意思的约定，比如："],["body","\n\n"],["body","如何在方法名称中引用类型名称（如 &mut [T] 变成 mut_slice、*mut T 变成 mut ptr），"],["body","\n"],["body","如何命名返回迭代器的方法，"],["body","\n"],["body","getter 方法应该被命名为 field_name 而 setter 方法应该被命名为 set_field_name，"],["body","\n"],["body","如何命名 trait：“优先选择（及物）动词、名词，然后是形容词；避免语法后缀（如 able）”，而且“如果这个 trait 只有一个主要方法，可以考虑用方法名称来命名 trait 本身”，"],["body","\n\n"],["body","\n"],["body","\n"],["body","RFC 430 描述了一些通用的大小写约定（总结：CamelCase 用于类型级别，snake_case 用于变量级别）。"],["body","\n"],["body","\n"],["body","\n"],["body","RFC 445 希望你为扩展 trait（extension trait）添加 Ext 后缀。"],["body","\n"],["body","\n\n"],["body","除了 RFC 199 和 RFC 344 （见上）规定的以外，还有一些其他的关于如何选择方法名称的约定，目前还没有在 RFC 中提及。这些约定大部分都在旧的 Rust 风格指南和 @llogiq 的文章 Rustic Bits 以及 clippy 的 wrong_self_convention 检测项中提到了。这里总结一下。"],["body","\n"],["body","方法名称"],["body","参数"],["body","备注"],["body","举例"],["body","\n"],["body","new"],["body","无 self，通常 >= 1 1"],["body","构造器，另参见 Default"],["body","Box::new、std::net::Ipv4Addr::new"],["body","\n"],["body","with_..."],["body","无 self，>= 1"],["body","其他构造器"],["body","Vec::with_capacity、regex::Regex::with_size_limit"],["body","\n"],["body","from_..."],["body","1"],["body","参见转换 trait（conversion traits）"],["body","String::from_utf8_lossy"],["body","\n"],["body","as_..."],["body","&self"],["body","无开销的转换，返回数据的一个视图（view）"],["body","str::as_bytes、uuid::Uuid::as_bytes"],["body","\n"],["body","to_..."],["body","&self"],["body","昂贵的转换"],["body","str::to_string、std::path::Path::to_str"],["body","\n"],["body","into_..."],["body","self（消耗）"],["body","可能昂贵的转换，参见 转换 trait（conversion traits）"],["body","std::fs::File::into_raw_fd"],["body","\n"],["body","is_..."],["body","&self（或无）"],["body","期望返回 bool"],["body","slice::is_empty、Result::is_ok、std::path::Path::is_file"],["body","\n"],["body","has_..."],["body","&self （或无）"],["body","期望返回 bool"],["body","regex_syntax::Expr::has_bytes"],["body","\n\n\n"],["headingLink","文档测试"],["heading","文档测试"],["body","\n"],["body","编写带有示例代码的文档可以展示 API 的用法而且还能获得自动测试\n详见第一版 TRPL（The Rust Programming Language）的[文档](详见第一版 TRPL（The Rust Programming Language）的文档一节。)一节。"],["body","\n"],["body","#![allow(unused)]\nfn main() {\n/// 使用魔法操作数字\n///\n/// # 示例\n///\n/// ```rust\n/// assert_eq!(min( 0,   14),    0);\n/// assert_eq!(min( 0, -127), -127);\n/// assert_eq!(min(42,  666),   42);\n/// ```(由于 hexo markdown 渲染辣鸡，此处加点文字避免被渲染为单独代码块）\nfn min(lhs: i32, rhs: i32) -> i32 {\n\tif lhs < rhs { lhs } else { rhs }\n}\n\n}"],["body","\n"],["body","你还可以使用 #![deny(missing_docs)] 来强制保证每个公开 API 都有文档。你可能也会对我的这篇提出了 Rust 文档格式化约定的文章感兴趣。"],["body","\n"],["headingLink","不要在-api-中使用-字符串类型"],["heading","不要在 API 中使用 “字符串类型”"],["body","\n"],["body","\n"],["body","尽量使用枚举"],["body","\n"],["body","\n"],["body","enum Color { Red, Green, Blue, LightGoldenRodYellow }\n\nfn color_me(input: &str, color: Color) { /* ... */ }\n\nfn main() {\n    color_me(\"surprised\", Color::Blue);\n}"],["body","\n"],["headingLink","全是常量的模块"],["heading","全是常量的模块"],["body","\n"],["body","或者，如果你想表达更复杂的值的话，则可以定义一个新的 struct，然后定义一堆公共常量。然后把这些常量放到模块中，用户就可以使用与 enum 类似的语法来访问它们了。"],["body","\n"],["body","pub mod output_options {\n    pub struct OutputOptions { /* ... */ }\n    \n    impl OutputOptions { fn new(/* ... */) -> OutputOptions { /* ... */ } }\n    \n    pub const DEFAULT: OutputOptions = OutputOptions { /* ... */ };\n    pub const SLIM: OutputOptions = OutputOptions { /* ... */ };\n    pub const PRETTY: OutputOptions = OutputOptions { /* ... */ };\n}\n\nfn output(f: &Foo, opts: OutputOptions) { /* ... */ }\n\nfn main() {\n    let foo = Foo::new();\n    \n    output(foo, output_options::PRETTY);\n}"],["body","\n"],["headingLink","使用-fromstr-来解析字符串"],["heading","使用 FromStr 来解析字符串"],["body","\n"],["body","在某些情况下，你的用户确实不得不使用字符串，比如：从环境变量中读取或者读取他们的用户的输入作为参数——也就是说，他们没办法在代码中编写（静态）字符串传递给你的 API（这个也是我们尝试阻止的）。这种情况下就需要使用 FromStr triat 了，它抽象了 “解析字符串到 Rust 数据类型” 的行为。"],["body","\n"],["body","// 选择 A: 你来解析\nfn output_a(f: &Foo, color: &str) -> Result<Bar, ParseError> {\n    // 这里使用解析后的类型遮蔽掉了原来的 `color`\n    let color: Color = try!(color.parse());\n\n    f.to_bar(&color)\n}\n\n// 选择 B: 用户来解析\nfn output_b(f: &Foo, color: &Color) -> Bar {\n    f.to_bar(color)\n}\n\nfn main() {\n    let foo = Foo::new();\n\n    // 选择 A: 你来解析，用户来处理 API 错误\n    output_a(foo, \"Green\").expect(\"Error :(\");\n\n    // 选择 B: 用户传入有效类型，所以不需要处理错误\n    output_b(foo, Color::Green);\n\n    // 选择 B: 用户使用字符串，需要自己解析并处理错误\n    output_b(foo, \"Green\".parse().except(\"Parse error!\"));\n}"],["body","\n"],["headingLink","错误处理"],["heading","错误处理"],["body","\n"],["body","TRPL 中对于错误处理有一章写得很不错。"],["body","\n"],["body","也有一些 crate 可以用来减少编写良好错误类型所需的样板代码，比如 quick-error 和 error-chain。"],["body","\n"],["headingLink","公共类型别名"],["heading","公共类型别名"],["body","\n"],["body","如果你的内部代码常常使用某个参数相同的泛型类型，此时可以使用类型别名。如果你想把这些类型公开给你的用户，你也应该把这些别名同样公开给用户（当然记得文档）。"],["body","\n"],["body","一个常见情况是 E 为固定值的 Result<T, E> 类型。比如 std::io::Result<T> 是 Result<T, std::io::Error> 的别名，std::fmt::Result 是 Result<(), std::fmt::Error> 的别名，serde_json::error::Result<T> 是 Result<T, serde_json::error::Error> 的别名。"],["body","\n"],["headingLink","使用转换-trait"],["heading","使用转换 trait"],["body","\n"],["body","一个良好实践是永远也不要在参数中使用 &String 和 &Vec，取而代之使用 &str 和 &[T]，后者允许传入更多类型。（基本上是所有能 deref 到字符串或切片（slice）的类型）"],["body","\n"],["body","与其使用具体类型作为参数，不如使用拥有严格约束的泛型。这样做的缺点是文档的可读性会降低，因为它充满了大量复杂的泛型约束！"],["body","\n"],["body","std::convert 为提供了一些方便的工具："],["body","\n\n"],["body","AsMut：一个便宜的（低消耗）、可变引用到可变引用的转换。"],["body","\n"],["body","AsRef：一个便宜的，引用到引用的转换。"],["body","\n"],["body","From： 通过转换来构造自身"],["body","\n"],["body","Into：一个消耗会自身的转换，可能会比较昂贵（高开销）。"],["body","\n"],["body","TryFrom：尝试通过转换来构造自身"],["body","\n"],["body","TryInto：尝试消耗自身转的换，可能会比较昂贵。"],["body","\n\n"],["body","你可能也会喜欢这篇关于如何在 Rust 中进行方便地道的转换的文章."],["body","\n"],["headingLink","cow"],["heading","Cow"],["body","\n"],["body","如果你需要处理很多不确定是否需要进行分配（allocate）的东西，你应该使用Cow<'a, B>，它可以让你抽象借用和拥有所有权的数据。"],["body","\n"],["body","fn foo(p: PathBuf)"],["body","fn foo<P: Into>(p: P)"],["body","\n"],["body","用户需要把数据转为 PathBuf"],["body","由库来调用 .into() 进行转换"],["body","\n"],["body","用户进行分配"],["body","看不出：库可能进行分配"],["body","\n"],["body","用户需要关心 PathBuf 是什么、如何创建"],["body","用户可以传递 String 、OsString，或者 PathBuf 都行"],["body","\n\n\n"],["headingLink","intooption_"],["heading","Into<Option<_>>"],["body","\n"],["body","这个 PR 添加了一个 impl<T> From<T> for Option<T>，在 Rust 1.12 中正式实装。寥寥几行代码赋予了你编写可以被直接调用而不需要写一大堆 Some(...) 的 API 的能力。"],["body","\n"],["body","之前"],["body","\n"],["body","// 对于 API 作者来说很容易编写，文档也很易于阅读\nfn foo(lorem: &str, ipsum: Option<i32>, dolor: Option<i32>, sit: Option<i32>) {\n    println!(\"{}\", lorem);\n}\n\nfn main() {\n    foo(\"bar\", None, None, None);               // 看起来有些奇怪\n    foo(\"bar\", Some(42), None, None);           // 还好\n    foo(\"bar\", Some(42), Some(1337), Some(-1)); // 停！太多…… Some 了……\n}"],["body","\n"],["body","现在"],["body","\n"],["body","// 对于 API 作者来说得多打点字\n// （而且遗憾的是，每个参数都需要被单独指定——否则 Rust 只会根据第一个参数推断类型。\n// 这种写法阅读来不是很方便，文档可能也没那么好看）\nfn foo<I, D, S>(lorem: &str, ipsum: I, dolor: D, sit: S) where\n    I: Into<Option<i32>>,\n    D: Into<Option<i32>>,\n    S: Into<Option<i32>>,\n{\n    println!(\"{}\", lorem);\n}\n\nfn main() {\n    foo(\"bar\", None, None, None); // 仍然奇怪\n    foo(\"bar\", 42, None, None);   // 不错\n    foo(\"bar\", 42, 1337, -1);     // Wow，棒棒！请务必这样编写 API！\n}"],["body","\n"],["headingLink","关于可能较长的编译时间的说明"],["heading","关于可能较长的编译时间的说明"],["body","\n"],["body","如果你有："],["body","\n\n"],["body","很多类型参数（比如用于转换 trait）"],["body","\n"],["body","用在一个很复杂/大型的函数上面"],["body","\n"],["body","这个函数用得还很多"],["body","\n\n"],["body","然后 rustc 将会根据不同参数编译这个函数的大量排列组合（泛型函数的单态化），这会导致很长的编译时间。"],["body","\n"],["body","bluss 在 Reddit 上提到可以使用 “去泛型” 技术来规避这个问题：你的（公共）泛型函数只简单地调用另一个（私有）非泛型函数，这样这个私有函数就只会被编译一次。"],["body","\n"],["body","bluss 给的例子是 std::fs::OpenOptions::open 的实现（来自 Rust 1.12 的源码）和 image crate 的 这个PR，它将 open 函数修改成了这个样子："],["body","\n"],["body","#![allow(unused)]\nfn main() {\npub fn open<P>(path: P) -> ImageResult<DynamicImage> where P: AsRef<Path> {\n    // 简单的包装函数，在调用 open_impl 之前去掉泛型\n    open_impl(path.as_ref())\n}\n}"],["body","\n"],["headingLink","惰性"],["heading","惰性"],["body","\n"],["body","尽管 Rust 不能像 Haskell 一样对表达式进行惰性计算，但是你仍然可以使用一些技术来优雅地省略不必要的计算和分配。"],["body","\n"],["headingLink","使用迭代器iterator"],["heading","使用迭代器（Iterator）"],["body","\n"],["body","标准库中最绝妙的构造之一是 Iterator，它是一个 trait，允许类似生成器的值迭代，而你只需要为此实现一个 next 方法2。Rust 的迭代器是惰性的，你需要显式地调用一个消费函数才会开始迭代。只是编写 \"hello\".chars().filter(char::is_white_space) 不会对数据进行任何操作，直到你对它调用像 .collect::() 这样的方法。"],["body","\n"],["headingLink","迭代器作为参数"],["heading","迭代器作为参数"],["body","\n"],["body","使用迭代器作为输入可能会让你的 API 更加难以阅读（T: Iterator<Item=Thingy> vs &[Thingy]），但是可以让用户避免内存分配。"],["body","\n"],["body","不过，事实上，你可能也并不想接受一个宽泛的 Iterator：而是使用 IntoIterator 。这样你就可以得到一个通过调用 .into_iter() 就能轻松转换为迭代器的类型。判断哪些类型实现了 IntoIterator 也很简单——就如文档中所说的："],["body","\n"],["headingLink","类似-iterator-的-trait"],["heading","类似 Iterator 的 trait"],["body","\n"],["body","futures::Stream：如 futures 教程所说，类似 Iterator::next 返回 OptionSelf::Item，Stream::poll 返回一个 OptionSelf::Item 的异步结果（或者返回一个错误）。"],["body","\n"],["headingLink","接受闭包"],["heading","接受闭包"],["body","\n"],["body","如果有一个可能比较昂贵的值（暂称为类型 Value），而且它并不会在所有的分支中都被使用到，这时可以考虑使用一个返回这个值的闭包（Fn() -> Value）。"],["body","\n"],["body","一个实际例子是 Result 中的 unwrap_or 和 unwrap_or_else："],["body","\n"],["body","#![allow(unused)]\nfn main() {\nlet res: Result<i32, &str> = Err(\"oh noes\");\nres.unwrap_or(42); // 立即返回 `42`\n\nlet res: Result<i32, &str> = Err(\"oh noes\");\nres.unwrap_or_else(|msg| msg.len() as i32); // 将会在需要的时候调用闭包计算\n}"],["body","\n"],["headingLink","关于惰性的小技巧"],["heading","关于惰性的小技巧"],["body","\n"],["body","让 Deref 完成所有的工作：为你的类型实现 Deref，让它来完成实际的计算逻辑。这个crate lazy实现了一个能为你完成这件事情的宏（不过需要 unstable 特性）。"],["body","\n"],["headingLink","提升易用性的-trait"],["heading","提升易用性的 trait"],["body","\n"],["body","这里列举了一些你应该试着为你的类型实现的 trait，它们可以让你的类型更加易用："],["body","\n\n"],["body","实现或者派生（derive）“常用” 的 trait 比如 Debug、Hash、PartialEq、PartialOrd、Eq、Ord"],["body","\n"],["body","实现或者派生Default，而不是编写一个不接受任何参数的 new 方法。"],["body","\n"],["body","如果你正在为一个类型实现一个可以将它的数据作为 Iterator 返回的方法，你也应该考虑为这个类型实现IntoIterator。（仅有一种迭代数据的主要方式时，才建议这么做。 另请参见上面有关迭代器的部分。）"],["body","\n"],["body","如果你的自定义数据类型和 std 中的基本类型 T 很相似，请考虑为它实现 Deref<Target=T>，不过请不要滥用——Deref 不是用来模拟继承的！"],["body","\n"],["body","不要编写一个接受字符串作为参数然后返回一个实例的构造方法，请使用FromStr"],["body","\n\n"],["headingLink","为输入参数实现自定义-trait"],["heading","为输入参数实现自定义 trait"],["body","\n"],["body","例：str::find\nstr::find<P: Pattern>(p: P) 接受一个Pattern作为输入，char、str、FnMut(char) -> bool 等类型都实现了这个 trait"],["body","\n"],["body","#![allow(unused)]\nfn main() {\n\"Lorem ipsum\".find('L');\n\"Lorem ipsum\".find(\"ipsum\");\n\"Lorem ipsum\".find(char::is_whitespace);\n}"],["body","\n"],["headingLink","扩展-trait"],["heading","扩展 trait"],["body","\n"],["body","尽量使用标准库中定义的类型和 trait，因为大部分 Rust 程序员都了解它们，它们经过了充分的测试并且有良好的文档。不过，由于 Rust 标准库倾向于提供有语义含义的类型3，这些类型包含的方法可能对你的 API 来说还不够。幸运的是，Rust 的 “孤儿规则（orphan rules）” 赋予了为任何类型实现任何 trait 的能力——前提是类型和 trait 中的任意一个是在当前 crate 中定义的。"],["body","\n"],["headingLink","装饰结果"],["heading","装饰结果"],["body","\n"],["body","如 Florian 在 “Decorating Results” 中写到的，你可以使用这种方法来编写并实现 trait 来为内置类型如 Result 实现自己的方法。举例："],["body","\n"],["body","pub trait GrandResultExt {\n    fn party(self) -> Self;\n}\n\nimpl GrandResultExt for Result<String, Box<Error>> {\n    fn party(self) -> Result<String, Box<Error>> {\n        if self.is_ok() {\n          println!(\"Wooohoo! 🎉\");\n        }\n        self\n    }\n}\n\n// 用户代码\nfn main() {\n    let fortune = library_function()\n        .method_returning_result()\n        .party()\n        .unwrap_or(\"Out of luck.\".to_string());\n}"],["body","\n"],["body","Florian 在 lazers 的真实代码中使用了这样的模式装饰了 BoxFuture（来自 futures crate）以让代码更加可读："],["body","\n"],["body","#![allow(unused)]\nfn main() {\nlet my_database = client\n    .find_database(\"might_not_exist\")\n    .or_create();\n\n}"],["body","\n"],["headingLink","扩展-trait-1"],["heading","扩展 trait"],["body","\n"],["body","到目前为止，我们已经通过定义并实现自己的 trait 扩展了类型上的可用方法。但你还可以定义扩展其他 trait 的 trait（trait MyTrait: BufRead + Debug {}）。最突出的例子是 itertools crate，它为 std 的迭代器添加了一大堆方法。"],["body","\n"],["headingLink","建造者模式"],["heading","建造者模式"],["body","\n"],["body","通过将一堆小方法串联在一起你可以让复杂的 API 更加易于调用。这个和 Session Type 非常搭（稍后会提到）。derive_builder crate 可以用来为自定义的 struct 自动生成（简单的）Builder"],["body","\n"],["body","例： std::fs::OpenOptions"],["body","\n"],["body","#![allow(unused)]\nfn main() {\nuse std::fs::OpenOptions;\nlet file = OpenOptions::new().read(true).write(true).open(\"foo.txt\");\n}"],["body","\n"],["headingLink","session-type"],["heading","Session Type"],["body","\n"],["body","你可以在类型系统中编码一个状态机。"],["body","\n\n"],["body","每个状态都有不同的类型。"],["body","\n"],["body","每个状态类型都实现了不同的方法。"],["body","\n"],["body","一些方法会消耗这个状态类型（获取所有权）并且返回另一个状态类型。"],["body","\n\n"],["body","这个技巧在 Rust 中工作地非常良好，因为你的方法可以将数据移动到新的类型中，并且保证在之后你就无法访问旧状态了。"],["body","\n"],["body","这是一个关于邮寄包裹的小例子："],["body","\n"],["body","#![allow(unused)]\nfn main() {\nlet p: OpenPackage = Package::new();\nlet p: OpenPackage = package.insert([stuff, padding, padding]);\n\nlet p: ClosedPackage = package.seal_up();\n\n// let p: OpenPackage = package.insert([more_stuff]);\n//~^ ERROR: No method named `insert` on `ClosedPackage`\n\nlet p: DeliveryTracking = package.send(address, postage);\n\n}"],["body","\n"],["body","一个很好的实际例子是 /u/ssokolow 在 /r/rust 的这个帖子 中给出的："],["body","\n"],["body","Hyper 使用这个方法来在编译时保证，你不可能做出诸如 “在请求/响应主体已经开始后又来设置 HTTP 头” 这种经常在 PHP 网站上看到的事。（编译器可以捕获这个错误，因为在该状态下的连接上没有 “set header” 方法，并且由于过时引用会失效，所以被引用的一定是正确的状态。）"],["body","\n"],["body","hyper::server 文档中更详细地解释了这是如何实现的。另一个有趣的想法可以在 lazers-replicator crate 中找到：它使用 std::convert::From来在状态中转换。"],["body","\n"],["headingLink","更多信息"],["heading","更多信息："],["body","\n\n"],["body","文章 “Beyond Memory Safety With Types” 描述了这项技术如何被用来实现一个漂亮并且类型安全的 IMAP 协议。"],["body","\n"],["body","论文 “Session types for Rust” (PDF)，作者 Thomas Bracht Laumann Jespersen, Philip Munksgaard, and Ken Friis Larsen (2015). DOI"],["body","\n"],["body","Andrew Hobden 的帖子 “Pretty State Machine Patterns in Rust” 展示了一些在 Rust 的类型系统中实现状态机的方法。"],["body","\n\n"],["headingLink","使用生命周期"],["heading","使用生命周期"],["body","\n"],["body","在静态类型语言中，为你的 API 指定类型和 trait 约束是必不可少的，如前文所说的，它们可以帮助防止逻辑错误。此外，Rust 的类型系统还提供了另一个维度：你还可以描述你的数据的生命周期（并编写生命周期约束）。"],["body","\n"],["body","这可以让你（作为开发者）更轻松地对待借用的数据（而不是使用开销更大的拥有所有权的数据）。尽可能地使用引用在 Rust 中是一个良好实践，因为高性能和 “零分配” 的库也是语言的卖点之一。"],["body","\n"],["body","不过，你应该尽可能为此编写良好的文档，因为理解生命周期和处理引用对于你的库用户来说可能是个挑战，尤其是对于 Rust 新手来说。"],["body","\n"],["body","由于某些原因（可能是比较简短），很多生命周期都被命名为 'a、'b或类似的无意义字符，不过如果你了解引用的生命周期对应的资源的话，你可以找到更好的名称。举例来说，如果你将文件读入到内存并且处理对这块内存的引用，可以将它的生命周期命名为 'file，或者如果你在处理一个 TCP 请求并且解析它的数据，则可以将生命周期命名为 'req。"],["body","\n"],["headingLink","将析构代码放在-drop-中"],["heading","将析构代码放在 drop 中"],["body","\n"],["body","Rust 的所有权规则不仅能用于内存：如果你的数据类型表示着外部资源（比如 TCP 连接），则在超出作用域时，你可以使用 Drop trait 关闭、释放或清理该资源。你可以像在其他语言中使用析构函数（或者 try ... catch ... finally）一样使用它。\n实际的例子有："],["body","\n\n"],["body","引用计数类型 Rc 和 Arc 使用 Drop 来减少引用计数（并且在计数归零的时候释放拥有的数据）。"],["body","\n"],["body","MutexGuard 使用 Drop 来释放它对 Mutex 的锁。"],["body","\n"],["body","diesel crate 用 Drop 来关闭数据库连接（比如 SQLite）。"],["body","\n\n"],["headingLink","案例学习"],["heading","案例学习"],["body","\n"],["body","在 API 设计中使用了一些不错的技巧的 Rust 库："],["body","\n\n"],["body","hyper：Session Type（见上文）"],["body","\n"],["body","diesel：使用拥有复杂的关联类型的 trait 将 SQL 查询编码为类型"],["body","\n"],["body","futures：高度抽象并且拥有良好文档的 crate"],["body","\n\n"],["headingLink","其他设计模式"],["heading","其他设计模式"],["body","\n"],["body","我在这里介绍的是编写接口的设计模式，即面向用户的 API。虽然我认为其中的一些模式只适用于编写库，但许多模式也同样适用于编写通用应用程序的代码。"],["body","\n"],["body","你可以在 Rust Design Patterns 仓库中找到更多信息"],["body","\n"],["body","Update 2017-04-27：这篇文章发布以来，Rust 库团队的 @brson 已经发布了一个相当全面的 Rust API Guidelines 文档，囊括了我的所有建议，并且内容更全面。"],["body","\n4\n"],["body","在其他强类型语言中有一句口号 “making illegal states unrepresentable”。我第一次听说这个是在人们谈论 Haskell 的时候，这也是 F# for fun and profit 的这篇文章的标题，和 Richard Feldman 在 elm-conf 2016 上的这篇演讲。"],["body","\n\n"],["body","本文链接"],["body","\n\n\n\n                    "],["body","\n\n                    \n                \n            \n\n            \n\n        \n\n\n\n\n        \n\n\n\n        \n        \n        \n\n        \n\n\n    \n    \n\n"]],[["_relative_fp","2所有权.html"],["title","所有权.md - RUST学习笔记"],["body","\n    \n        \n        \n\n        \n        \n\n        \n        \n\n        \n\n        \n        \n\n        \n\n        \n        \n\n        \n\n            \n                                \n                \n                    \n                        "],["body","\n                            \n                        "],["body","\n                        "],["body","\n                            \n                        "],["body","\n                        \n                            "],["body","Light"],["body","\n                            "],["body","Rust"],["body","\n                            "],["body","Coal"],["body","\n                            "],["body","Navy"],["body","\n                            "],["body","Ayu"],["body","\n                        \n                    \n\n                    "],["heading","RUST学习笔记"],["body","\n\n                    \n\n                    \n                \n\n\n                \n                \n\n                \n                    "],["body","\n                        \n\n"],["body","\n"],["body","\n\n"],["headingLink","认识所有权"],["heading","认识所有权"],["body","\n"],["body","\n"],["body","所有权（系统）是 Rust 最为与众不同的特性，它让 Rust 无需垃圾回收（garbage collector）即可保障内存安全。因此，理解 Rust 中所有权如何工作是十分重要的。本章，我们将讲到所有权以及相关功能：借用、slice 以及 Rust 如何在内存中布局数据。"],["body","\n"],["body","\n"],["body","变量的所有权总是遵循相同的模式：将值赋给另一个变量时移动它"],["body","\n"],["headingLink","所有权"],["heading","所有权"],["body","\n"],["headingLink","规则"],["heading","规则"],["body","\n\n"],["body","Rust 中的每一个值都有一个被称为其 所有者（owner）的变量。"],["body","\n"],["body","值在任一时刻有且只有一个所有者。"],["body","\n"],["body","当所有者（变量）离开作用域，这个值将被丢弃。"],["body","\n\n"],["headingLink","变量作用域"],["heading","变量作用域"],["body","\n"],["body","\n"],["body","变量 s 绑定到了一个字符串字面值，这个字符串值是硬编码进程序代码中的。这个变量从声明的点开始直到当前 作用域 结束时都是有效的"],["body","\n"],["body","\n"],["body","{                      // s 在这里无效, 它尚未声明\n    let s = \"hello\";   // 从此处起，s 是有效的\n\n    // 使用 s\n}                      // 此作用域已结\n"],["body","\n"],["headingLink","string类型"],["heading","String类型"],["body","\n"],["body","// 这两个冒号（::）是运算符，允许将特定的 from 函数置于 String 类型的命名空间（namespace）\nlet s = String::from(\"hello\");\n"],["body","\n"],["body","内存在拥有它的变量离开作用域后就被自动释放。下面是示例 4-1 中作用域例子的一个使用 String 而不是字符串字面值的版本："],["body","\n"],["body","这是一个将 String 需要的内存返回给操作系统的很自然的位置：当 s 离开作用域的时候。当变量离开作用域，Rust 为我们调用一个特殊的函数。这个函数叫做 drop，在这里 String 的作者可以放置释放内存的代码。Rust 在结尾的 } 处自动调用 drop。"],["body","\n"],["headingLink","变量与数据交互的方式"],["heading","变量与数据交互的方式"],["body","\n"],["headingLink","移动"],["heading","移动"],["body","\n"],["body","//基础类型是 移动\nlet x = 5;\nlet y = x;\n"],["body","\n"],["body","引用类型的移动"],["body","\n"],["body","#![allow(unused)]\n\nfn main() {\nlet s1 = String::from(\"hello\");\nlet s2 = s1; //赋值给s1之后s1不在有效,编译器禁止使用 s1\n}"],["body","\n"],["headingLink","克隆"],["heading","克隆"],["body","\n"],["body","#![allow(unused)]\nfn main() {\nlet s1 = String::from(\"hello\");\nlet s2 = s1.clone();\n\nprintln!(\"s1 = {}, s2 = {}\", s1, s2);\n}"],["body","\n\n"],["body","\n"],["body","Rust 有一个叫做 Copy trait 的特殊注解,可以用在类似整型这样的存储在栈上的类型上"],["body","\n"],["body","\n"],["body","\n"],["body","如果一个类型拥有 Copy trait，一个旧的变量在将其赋值给其他变量后仍然可用"],["body","\n"],["body","\n"],["body","\n"],["body","Rust 不允许自身或其任何部分实现了 Drop trait 的类型使用 Copy trait"],["body","\n"],["body","\n"],["body","\n"],["body","要学习如何为你的类型增加 Copy 注解，请阅读附录 C 中的 “可派生的 trait”。"],["body","\n"],["body","\n\n"],["body","任何简单标量值的组合可以是 Copy 的，不需要分配内存或某种形式资源的类型是 Copy 的。如下是一些 Copy 的类型："],["body","\n\n"],["body","所有整数类型，比如 u32。"],["body","\n"],["body","布尔类型，bool，它的值是 true 和 false。"],["body","\n"],["body","所有浮点数类型，比如 f64。"],["body","\n"],["body","字符类型，char。"],["body","\n"],["body","元组，当且仅当其包含的类型也都是 Copy 的时候。比如，(i32, i32) 是 Copy 的，但 (i32, String) 就不是。"],["body","\n\n"],["headingLink","所有权与函数"],["heading","所有权与函数"],["body","\n"],["body","\n"],["body","将值传递给函数在语义上与给变量赋值相似。向函数传递值可能会移动或者复制，就像赋值语句一样。"],["body","\n"],["body","\n"],["body","fn main() {\n    let s = String::from(\"hello\");  // s 进入作用域\n\n    takes_ownership(s);             // s 的值移动到函数里 ...\n                                    // ... 所以到这里不再有效\n\n    let x = 5;                      // x 进入作用域\n\n    makes_copy(x);                  // x 应该移动函数里，\n                                    // 但 i32 是 Copy 的，所以在后面可继续使用 x\n\n} // 这里, x 先移出了作用域，然后是 s。但因为 s 的值已被移走，\n  // 所以不会有特殊操作\n\nfn takes_ownership(some_string: String) { // some_string 进入作用域\n    println!(\"{}\", some_string);\n} // 这里，some_string 移出作用域并调用 `drop` 方法。占用的内存被释放\n\nfn makes_copy(some_integer: i32) { // some_integer 进入作用域\n    println!(\"{}\", some_integer);\n} // 这里，some_integer 移出作用域。不会有特殊操作\n"],["body","\n"],["headingLink","引用与借用"],["heading","引用与借用"],["body","\n"],["headingLink","引用与借用-1"],["heading","引用与借用"],["body","\n"],["body","fn main() {\n    let s1 = String::from(\"hello\");\n\n    let len = calculate_length(&s1);\n\n    println!(\"The length of '{}' is {}.\", s1, len);\n}\n\nfn calculate_length(s: &String) -> usize {\n    s.len()\n}"],["body","\n"],["body","其次，注意我们传递 &s1 给 calculate_length，同时在函数定义中，我们获取 &String 而不是 String。"],["body","\n"],["body","与使用 & 引用相反的操作是 解引用（dereferencing），它使用解引用运算符，*。我们将会在第八章遇到一些解引用运算符，并在第十五章详细讨论解引用。"],["body","\n"],["body","同理，函数签名使用 & 来表明参数 s 的类型是一个引用。让我们增加一些解释性的注释："],["body","\n"],["body","#![allow(unused)]\nfn main() {\nfn calculate_length(s: &String) -> usize { // s 是对 String 的引用\n    s.len()\n} // 这里，s 离开了作用域。但因为它并不拥有引用值的所有权，\n  // 所以什么也不会发生\n}"],["body","\n"],["body","我们将获取引用作为函数参数称为 借用（borrowing）。"],["body","\n"],["body","正如变量默认是不可变的，引用也一样。（默认）不允许修改引用的值\n"],["body","\n"],["headingLink","可变引用"],["heading","可变引用"],["body","\n"],["body","#![allow(unused)]\nfn main() {\nfn change(some_string: &mut String) {\n    some_string.push_str(\", world\");\n}\n}"],["body","\n\n"],["body","当有可变引用时 只能存在一个,其他的都会失效,不可用"],["body","\n\n"],["headingLink","悬垂引用"],["heading","悬垂引用"],["body","\n"],["body","#![allow(unused)]\nfn main() {\n//报错 s已经被释放了\nfn dangle() -> &String {\n    let s = String::from(\"hello\");\n\n    &s\n}\n//正确,所有权被移动出去，所以没有值被释放\nfn no_dangle() -> String {\n    let s = String::from(\"hello\");\n\n    s\n}\n}"],["body","\n\n"],["body","在任意给定时间，要么 只能有一个可变引用，要么 只能有多个不可变引用。"],["body","\n"],["body","引用必须总是有效的。"],["body","\n\n"],["headingLink","slice引用"],["heading","slice引用"],["body","\n"],["body","\n"],["body","slice 允许你引用集合中一段连续的元素序列，而不用引用整个集合。"],["body","\n"],["body","拥有某值的不可变引用时，就不能再获取一个可变引用"],["body","\n"],["body","\n"],["body","字符串slice"],["body","\n"],["body","#![allow(unused)]\n\nfn main() {\nlet s = String::from(\"hello world\");\nlet hello = &s[0..5];\nlet world = &s[6..11];\n}"],["body","\n"],["body","range 语法"],["body","\n"],["body","#![allow(unused)]\nfn main() {\nlet s = String::from(\"hello\");\n\nlet slice = &s[0..2];\nlet slice = &s[..2];\n\nlet slice = &s[0..len];\nlet slice = &s[..];\n}"],["body","\n\n\n\n                    "],["body","\n\n                    \n                \n            \n\n            \n\n        \n\n\n\n\n        \n\n\n\n        \n        \n        \n\n        \n\n\n    \n    \n\n"]],[["_relative_fp","11模式匹配.html"],["title","模式匹配.md - RUST学习笔记"],["body","\n    \n        \n        \n\n        \n        \n\n        \n        \n\n        \n\n        \n        \n\n        \n\n        \n        \n\n        \n\n            \n                                \n                \n                    \n                        "],["body","\n                            \n                        "],["body","\n                        "],["body","\n                            \n                        "],["body","\n                        \n                            "],["body","Light"],["body","\n                            "],["body","Rust"],["body","\n                            "],["body","Coal"],["body","\n                            "],["body","Navy"],["body","\n                            "],["body","Ayu"],["body","\n                        \n                    \n\n                    "],["heading","RUST学习笔记"],["body","\n\n                    \n\n                    \n                \n\n\n                \n                \n\n                \n                    "],["body","\n                        \n\n"],["body","\n"],["body","\n\n"],["headingLink","模式由如下一些内容组合而成"],["heading","模式由如下一些内容组合而成"],["body","\n\n"],["body","字面值"],["body","\n"],["body","解构的数组、枚举、结构体或者元组"],["body","\n"],["body","变量"],["body","\n"],["body","通配符"],["body","\n"],["body","占位符"],["body","\n\n"],["headingLink","模式匹配使用场景"],["heading","模式匹配使用场景"],["body","\n"],["headingLink","match-分支"],["heading","match 分支"],["body","\n"],["body","#![allow(unused)]\nfn main() {\nmatch VALUE {\n    PATTERN => EXPRESSION,\n    PATTERN => EXPRESSION,\n    PATTERN => EXPRESSION,\n}\n}"],["body","\n"],["headingLink","if-let-条件表达式"],["heading","if let 条件表达式"],["body","\n"],["body","\n"],["body","编写等同于只关心一个情况的 match 语句简写的"],["body","\n"],["body","\n\n"],["body","\n"],["body","也可以组合并匹配 if let、else if 和 else if let 表达式。"],["body","\n"],["body","\n"],["body","\n"],["body","这相比 match 表达式一次只能将一个值与模式比较提供了更多灵活性；"],["body","\n"],["body","\n"],["body","\n"],["body","一系列 if let、else if、else if let 分支并不要求其条件相互关联"],["body","\n"],["body","\n\n"],["headingLink","while-let-条件循环"],["heading","while let 条件循环"],["body","\n\n"],["body","示例一 : 定义一个 枚举集合 ,循环打印"],["body","\n\n"],["headingLink","for循环"],["heading","for循环"],["body","\n"],["body","#![allow(unused)]\nfn main() {\nfor (index, value) in v.iter().enumerate() {\n    println!(\"{} is at index {}\", value, index);\n}\n\nfor pattern in v.iter(){\n\tstatement\n}\n}"],["body","\n"],["headingLink","let-语句"],["heading","let 语句"],["body","\n"],["body","let PATTERN = EXPRESSION;\n\nlet (x, y) = (1, 2, 3);\n"],["body","\n"],["headingLink","函数参数"],["heading","函数参数"],["body","\n"],["body","fn print_coordinates(&(x, y): &(i32, i32)) {\n    println!(\"Current location: ({}, {})\", x, y);\n}\n\nfn main() {\n    let point = (3, 5);\n    print_coordinates(&point);\n}"],["body","\n"],["headingLink","可反驳性与非反驳性"],["heading","可反驳性与非反驳性"],["body","\n\n"],["body","let 语句和 for 循环只能接受不可反驳的模式"],["body","\n"],["body","if let和while let 只接受 可反驳模式"],["body","\n\n"],["headingLink","变量覆盖"],["heading","变量覆盖"],["body","\n"],["body","match 会开始一个新作用域，match 表达式中作为模式的一部分声明的变量会覆盖 match 结构之外的同名变量"],["body","\n"],["body","fn main() {\n    let x = Some(5);\n    let y = 10;\n\n    match x {\n        Some(50) => println!(\"Got 50\"),\n        Some(y) => println!(\"Matched, y = {:?}\", y),\n        _ => println!(\"Default case, x = {:?}\", x),\n    }\n\n    println!(\"at the end: x = {:?}, y = {:?}\", x, y);\n}"],["body","\n"],["headingLink","多模式"],["heading","多模式"],["body","\n"],["body","#![allow(unused)]\n\nfn main() {\nlet x = 1;\n\nmatch x {\n    1 | 2 => println!(\"one or two\"),\n    3 => println!(\"three\"),\n    _ => println!(\"anything\"),\n}\n}"],["body","\n"],["headingLink","范围匹配"],["heading","范围匹配"],["body","\n"],["body","\n"],["body","只允许数字和char"],["body","\n"],["body","\n"],["body","#![allow(unused)]\n\nfn main() {\nlet x = 5;\n\nmatch x {\n    1..=5 => println!(\"one through five\"),\n    _ => println!(\"something else\"),\n}\n}"],["body","\n"],["headingLink","匹配结构体"],["heading","匹配结构体"],["body","\n"],["body","struct Point {\n    x: i32,\n    y: i32,\n}\n\nfn main() {\n    let p = Point { x: 0, y: 7 };\n\n    let Point { x: a, y: b } = p;\n    assert_eq!(0, a);\n    assert_eq!(7, b);\n}"],["body","\n"],["headingLink","匹配枚举"],["heading","匹配枚举"],["body","\n"],["body","enum Message {\n    Quit,\n    Move { x: i32, y: i32 },\n    Write(String),\n    ChangeColor(i32, i32, i32),\n}\n\nfn main() {\n    let msg = Message::ChangeColor(0, 160, 255);\n\n    match msg {\n        Message::Quit => {\n            println!(\"The Quit variant has no data to destructure.\")\n        }\n        Message::Move { x, y } => {\n            println!(\n                \"Move in the x direction {} and in the y direction {}\",\n                x,\n                y\n            );\n        }\n        Message::Write(text) => println!(\"Text message: {}\", text),\n        Message::ChangeColor(r, g, b) => {\n            println!(\n                \"Change the color to red {}, green {}, and blue {}\",\n                r,\n                g,\n                b\n            )\n        }\n    }\n}"],["body","\n"],["headingLink","嵌套匹配"],["heading","嵌套匹配"],["body","\n"],["body","\n#![allow(unused)]\nfn main() {\nstruct Point {\n    x: i32,\n    y: i32,\n}\n\nlet ((feet, inches), Point {x, y}) = ((3, 10), Point { x: 3, y: -10 });\n}\n"],["body","\n"],["headingLink","忽略模式"],["heading","忽略模式"],["body","\n"],["body","//忽略函数参数\nfn foo(_: i32, y: i32) {\n    println!(\"This code only uses the y parameter: {}\", y);\n}\n\nfn main() {\n    foo(3, 4);\n}\n"],["body","\n"],["body","嵌套忽略"],["body","\n"],["body","\n#![allow(unused)]\nfn main() {\nlet mut setting_value = Some(5);\nlet new_setting_value = Some(10);\n\nmatch (setting_value, new_setting_value) {\n    (Some(_), Some(_)) => {\n        println!(\"Can't overwrite an existing customized value\");\n    }\n    _ => {\n        setting_value = new_setting_value;\n    }\n}\n\nprintln!(\"setting is {:?}\", setting_value);\n}\n\n#![allow(unused)]\nfn main() {\nlet mut setting_value = Some(5);\nlet new_setting_value = Some(10);\n\nmatch (setting_value, new_setting_value) {\n    (Some(_), Some(_)) => {\n        println!(\"Can't overwrite an existing customized value\");\n    }\n    _ => {\n        setting_value = new_setting_value;\n    }\n}\n\nprintln!(\"setting is {:?}\", setting_value);\n}\n"],["body","\n"],["body","忽略元组多个部分"],["body","\n"],["body","#![allow(unused)]\nfn main() {\nlet numbers = (2, 4, 8, 16, 32);\n\nmatch numbers {\n    (first, _, third, _, fifth) => {\n        println!(\"Some numbers: {}, {}, {}\", first, third, fifth)\n    },\n}\n}"],["body","\n"],["body","_下划线开头的变量,可以避免编译器警告"],["body","\n"],["body","fn main() {\n    let _x = 5;\n    let y = 10;\n}"],["body","\n"],["body","用 .. 忽略剩余值"],["body","\n"],["body","#![allow(unused)]\nfn main() {\nstruct Point {\n    x: i32,\n    y: i32,\n    z: i32,\n}\n\nlet origin = Point { x: 0, y: 0, z: 0 };\n\nmatch origin {\n    Point { x, .. } => println!(\"x is {}\", x),\n}\n}"],["body","\n"],["headingLink","匹配守卫"],["heading","匹配守卫"],["body","\n"],["headingLink","条件匹配"],["heading","条件匹配"],["body","\n"],["body","#![allow(unused)]\nfn main() {\nlet num = Some(4);\n\nmatch num {\n    Some(x) if x < 5 => println!(\"less than five: {}\", x),\n    Some(x) => println!(\"{}\", x),\n    None => (),\n}\n}"],["body","\n"],["headingLink","范围匹配-1"],["heading","范围匹配"],["body","\n"],["body","#![allow(unused)]\nfn main() {\nmatch msg {\n    Message::Hello { id: id_variable @ 3..=7 } => {\n        println!(\"Found an id in range: {}\", id_variable)\n    },\n    Message::Hello { id: 10..=12 } => {\n        println!(\"Found an id in another range\")\n    },\n    Message::Hello { id } => {\n        println!(\"Found some other id: {}\", id)\n    },\n}\n}"],["body","\n\n\n\n                    "],["body","\n\n                    \n                \n            \n\n            \n\n        \n\n\n\n\n        \n\n\n\n        \n        \n        \n\n        \n\n\n    \n    \n\n"]],[["_relative_fp","19.线程间数据共享.html"],["title","线程间数据共享.md - RUST学习笔记"],["body","\n    \n        \n        \n\n        \n        \n\n        \n        \n\n        \n\n        \n        \n\n        \n\n        \n        \n\n        \n\n            \n                                \n                \n                    \n                        "],["body","\n                            \n                        "],["body","\n                        "],["body","\n                            \n                        "],["body","\n                        \n                            "],["body","Light"],["body","\n                            "],["body","Rust"],["body","\n                            "],["body","Coal"],["body","\n                            "],["body","Navy"],["body","\n                            "],["body","Ayu"],["body","\n                        \n                    \n\n                    "],["heading","RUST学习笔记"],["body","\n\n                    \n\n                    \n                \n\n\n                \n                \n\n                \n                    "],["body","\n                        \n\n"],["body","\n"],["body","\n\n"],["headingLink","rust中的arc与mutex"],["heading","Rust中的Arc与Mutex"],["body","\n\n"],["body","\n"],["body","通常情况下，当你在并发环境中共享数据时，要么使用共享内存，要么以消息形式传递数据。"],["body","\n"],["body","\n"],["body","\n"],["body","你可能经常听到传递消息（例如使用 Channel）是处理并发的首选方式，但我认为由于 Rust 中的所有权模型，二者在安全性或正确性上的区别并不像在其他语言中那么大"],["body","\n"],["body","\n"],["body","\n"],["body","更具体地说：安全的 Rust 不允许有数据竞争。这也是为什么当我在 Rust 中选择消息传递或共享内存时，主要考虑的是便利性而非安全性。"],["body","\n"],["body","\n"],["body","\n"],["body","如果你选择以共享内存的方式进行数据共享，你会发现，没有Arc和Mutex几乎寸步难行。"],["body","\n"],["body","\n"],["body","\n"],["body","Arc是一种智能指针，它能够让你在多线程之间安全地共享某个值。Mutex是另一种类型包装器（wrapper），它使得某个值可以在多线程之间被安全地修改"],["body","\n"],["body","\n"],["body","\n"],["body","为了完全理解这些概念，让我们先来了解 Rust 的所有权模型。"],["body","\n"],["body","\n\n"],["headingLink","rust-中的所有权ownership-in-rust"],["heading","Rust 中的所有权（Ownership in Rust）"],["body","\n"],["body","所有权模型"],["body","\n\n"],["body","一个值只能有一个所有者"],["body","\n"],["body","可以对一个值拥有多个不可变引用"],["body","\n"],["body","对一个值只能有一个可变引用"],["body","\n\n"],["body","让我们来看看这几条规则是如何工作的。给定一个User结构体，它包含一个字段name，类型为String。我们创建一个线程，并使用user打印一条消息。"],["body","\n"],["body","use std::thread::spawn;\n\n#[derive(Debug)]\nstruct User {\n    name: String\n}\n\nfn main() {\n    let user = User { name: \"drogus\".to_string() };\n\n    spawn(move || {\n        println!(\"Hello from the first thread {}\", user.name);\n    }).join().unwrap();\n}"],["body","\n"],["body","目前为止一切顺利，程序按照预期编译并输出信息。现在我们添加第二个线程（对应代码中的 t2），也去访问user实例。"],["body","\n"],["body","1 fn main() {\n2     let user = User { name: \"drogus\".to_string() };\n3\n4     let t1 = spawn(move || {\n5         println!(\"Hello from the first thread {}\", user.name);\n6     });\n7\n8     let t2 = spawn(move || {\n9         println!(\"Hello from the second thread {}\", user.name);\n10     });\n11\n12     t1.join().unwrap();\n13     t2.join().unwrap();\n14 }"],["body","\n"],["body","编译代码会错误，一个值只能有一个所有者。我们尝试，通过不可变引用的方式来引用该变量"],["body","\n"],["body","移除了闭包中的move关键字，并让线程不可变地借用（borrow） user，或者换句话说，我使用了一个由&表示的共享引用"],["body","\n"],["body","fn main() {\n    let user = User { name: \"drogus\".to_string() };\n\n    let t1 = spawn(|| {\n        println!(\"Hello from the first thread {}\", &user.name);\n    });\n\n    let t2 = spawn(|| {\n        println!(\"Hello from the second thread {}\", &user.name);\n    });\n\n    t1.join().unwrap();\n    t2.join().unwrap();\n}"],["body","\n\n"],["body","\n"],["body","现在，编译器报出的信息说，闭包可能比当前函数（main）的生存周期更长。换言之，也就是说 Rust 编译器无法保证线程中的闭包能够在 main 函数结束之前结束。"],["body","\n"],["body","\n"],["body","\n"],["body","user被线程借用，但是它被 main 函数所拥有。这种场景下，如果 main 函数结束，user就会离开作用域然后被销毁（Drop）。"],["body","\n"],["body","\n"],["body","\n"],["body","因此，如果按照上面的方式在线程间共享user，那么就可能会出现这种情况——线程尝试去读取已经被释放的内存。"],["body","\n"],["body","\n"],["body","\n"],["body","这是一种未定义行为并且我们也不希望出现这种情况。"],["body","\n"],["body","\n\n"],["body","编译器的提示信息还告诉我们，把变量user移动到线程中进而避免借用可能是有帮助的。不过这种情况我们在一开始就尝试了，并不太好。现在，有两种方式可以解决这个问题，其中之一便是Arc。不过，让我们先来了解另一种方式：scope thread。"],["body","\n"],["headingLink","scoped-threads"],["heading","Scoped threads"],["body","\n"],["body","Scoped threads 这一特性既可以通过crossbeam这个库获取。本文使用了 crossbeam 提供的实现，但两种方式在使用上区别不大。在Cargo.toml中的依赖项中加入"],["body","\n"],["body","crossbeam = \"0.8\"，下面的代码就可以解决之前的问题。"],["body","\n"],["body","use crossbeam::scope;\n\n#[derive(Debug)]\nstruct User {\n    name: String,\n}\n\nfn main() {\n    let user = User {\n        name: \"drogus\".to_string(),\n    };\n\n    scope(|s| {\n        s.spawn(|_| {\n            println!(\"Hello from the first thread {}\", &user.name);\n        });\n\n        s.spawn(|_| {\n            println!(\"Hello from the second thread {}\", &user.name);\n        });\n    })\n    .unwrap();\n}"],["body","\n\n"],["body","Scoped threads 的工作原理是，在某作用域内创建的所有线程都能被保证先于scope闭包结束。也就是说\n\n"],["body","在作用域闭包（scoped closure）离开作用域之前，线程被 join 并等待完成。得益于此，编译器知道没有任何借用会比所有者生存周期更长。"],["body","\n"],["body","一个有趣的事情在这里值得注意，作为一个人类读者，我们会把这两个程序都解释为有效。\n\n"],["body","在 Rust 拒绝的版本中，我们在main()函数结束之前就 join 了两个线程，所以将user与线程共享实际上是安全的。"],["body","\n"],["body","不幸的是，这是你在用 Rust 编写时可能遇到的情况。"],["body","\n"],["body","编写一个能接受所有有效程序的编译器是不可能的，因此我们只能退而求其次：编写一个能拒绝所有无效程序的编译器，但代价是过于严格。"],["body","\n"],["body","Scoped threads 是专门为了让我们以编译器可以接受的方式编写这种代码而加入的特性。"],["body","\n\n"],["body","\n"],["body","尽管 Scoped threads 有用，但并非所有的场合都适用，例如在编写异步（async）代码时，下面让我们来看看Arc。"],["body","\n\n"],["body","\n\n"],["headingLink","arc"],["heading","Arc"],["body","\n"],["body","Arc是一种能够使得数据在线程间安全共享的智能指针，其名字是Atomic Reference Counter三个单词的首字母缩写。"],["body","\n"],["body","它的工作方式从本质上来讲，是对将要共享的数据进行包装，并表现为此数据的一个指针。Arc会追踪这个指针的所有拷贝，当最后一份拷贝离开作用域时，它就会安全释放内存。通过Arc解决之前问题的方案如下。"],["body","\n"],["body","1 use std::thread::spawn;\n2 use std::sync::Arc;\n3\n4 #[derive(Debug)]\n5 struct User {\n6     name: String\n7 }\n8\n9 fn main() {\n10     let user_original = Arc::new(User { name: \"drogus\".to_string() });\n11\n12    let user = user_original.clone();\n13    let t1 = spawn(move || {\n14        println!(\"Hello from the first thread {}\", user.name);\n15    });\n16\n17    let user = user_original.clone();\n18    let t2 = spawn(move || {\n19        println!(\"Hello from the first thread {}\", user.name);\n20    });\n21\n22    t1.join().unwrap();\n23    t2.join().unwrap();\n24}"],["body","\n"],["headingLink","send-and-sync"],["heading","Send and Sync"],["body","\n"],["body","让我们再深入一点儿。如果你看过Arc的文档，你应该会看到它实现了 Send 和 Sync[3]，但前提是被Arc包装的类型也实现了Send和Sync。为了理解这是什么意思以及它为何以这种方式实现，让我们从Send和Sync的定义开始看看。"],["body","\n"],["body","**《The Rustonomicon》[4]**对Send和Sync的定义如下："],["body","\n\n"],["body","如果一个类型能够被安全地发送到另一个线程，那么这个类型是Send；"],["body","\n"],["body","如果一个类型能够安全地在线程间共享，那么这个类型是Sync。（当且仅当&T 是Send时，T 是Sync）"],["body","\n\n"],["body","Send和Sync是作为一类标记 trait 存在，它们不提供任何需要被实现的方法，也不需要你去实现任何东西。它们的作用在于告知编译器某个类型在线程间可以被发送和共享的特性"],["body","\n"],["body","让我们先从看起来相对直观的Send开始。它意味着你不能把一个!Send（读作：非Send）的类型发送到另一个线程"],["body","\n"],["body","例如，你不能把它发送到 channel，也不能移动到一个线程里。以下面的代码为例，它就无法编译。"],["body","\n\n"],["body","\n"],["body","Send和Sync是自动派生的，这意味着如果一个类型的所有字段都满足Send，那么这个类型也就自动实现了Send"],["body","\n"],["body","\n"],["body","\n"],["body","这段代码使用了一个实验特性negative_impls，其作用在于让我们显式地告诉编译器，我想要把这个类型标记为!Send"],["body","\n"],["body","\n\n"],["body","如果你创建一个 channel 然后把foo发送至另一个线程，也会发生同样的事情。如果现在用上Arc会怎么样呢？你或许已经猜到，这没什么用，还是会以相同的方式报错（对于!Sync也是一样的，Arc需要同时满足这两个）。"],["body","\n"],["body","#![feature(negative_impls)]\n\n#[derive(Debug)]\nstruct Foo {}\nimpl !Send for Foo {}\n\nfn main() {\n    let foo = Arc::new(Foo {});\n    spawn(move || {\n        dbg!(foo);\n    });\n}"],["body","\n"],["body","为什么会这样呢？Arc不是能够包装我们的类型并赋予它更多的能力么？确实如此，但Arc无法让我们的类型变成线程安全的。我会在文章末尾给出一个更深入的例子来解释原因，但是现在，我们先继续学习如何使用这些类型把。"],["body","\n"],["headingLink","使用-mutex-修改数据"],["heading","使用 Mutex 修改数据"],["body","\n"],["body","现在，我们开始讨论Mutex。Mutex在许多语言中都被视作（互斥）信号量（Semaphores）。你创建了一个 mutex 对象，通过每次只允许一个线程访问的方式，用它保护一段特定的代码段。在 Rust 中，Mutex更像是一个包装器（wrapper）。它让你在锁定 mutex 之后才能访问内部的值。Mutex 通常与 Arc 结合使用能够让线程间共享变量更加简单。让我们看看下面的示例："],["body","\n"],["body","1 use std::time::Duration;\n2 use std::{thread, thread::sleep};\n3 use std::sync::{Arc, Mutex};\n4\n5 struct User {\n6     name: String\n7 }\n8\n9 fn main() {\n10     let user_original = Arc::new(Mutex::new(User { name: String::from(\"drogus\") }));\n11\n12     let user = user_original.clone();\n13     let t1 = thread::spawn(move || {\n14         let mut locked_user = user.lock().unwrap();\n15         locked_user.name = String::from(\"piotr\");\n16        // after locked_user goes out of scope, mutex will be unlocked again,\n17         // but you can also explicitly unlock it with:\n18         // drop(locked_user);\n19     });\n20\n21     let user = user_original.clone();\n22     let t2 = thread::spawn(move || {\n23         sleep(Duration::from_millis(10));\n24\n25        // it will print: Hello piotr\n26        println!(\"Hello {}\", user.lock().unwrap().name);\n27     });\n28\n29     t1.join().unwrap();\n30     t2.join().unwrap();\n31}"],["body","\n\n"],["body","\n"],["body","让我们看看这段代码。在 main()函数的第一行，我们创建了一个User结构体的实例并用Mutex和Arc对其进行包装"],["body","\n"],["body","\n"],["body","\n"],["body","通过Arc，我们可以轻松克隆指针并在线程间共享Mutex"],["body","\n"],["body","\n"],["body","\n"],["body","在第 14 行，你可以看到 mutex 被锁定并且在那之后底层的值可以被这个线程独占地使用"],["body","\n"],["body","\n"],["body","\n"],["body","接着，我们在下一行代码对它的值进行修改。当离开作用域或我们手动调用drop(locked_user)时，mutex 被解除锁定。"],["body","\n"],["body","\n"],["body","\n"],["body","在第二个线程中，我们等待 10ms 并打印出name。打印出的name应该是在第一个线程中被更新后的内容。这一次 lock 操作在同一行语句完成，所以在这条语句结束后，mutex 就会被解除锁定。"],["body","\n"],["body","\n"],["body","\n"],["body","值得注意的是，我们在调用lock()后紧接着调用的unwrap()方法。标准库中的Mutex有一个被污染（poisoned）的概念。如果一个线程在 mutex 被锁定时 panic 了，我们无法确认Mutex中的值是否仍然有效，因此默认采取的行为是返回一个 error 而不是 guard。所以，Mutex要么返回一个装有值的Ok()变量或者一个 error。可以从文档获取更多的信息。一般而言，并不推荐在生产代码中使用unwrap()方法，但对于Mutex而言却是一个有效的方式——如果一个 Mutex 已经被污染了，我们可能判断出程序状态是无效的，并使程序崩溃。"],["body","\n"],["body","\n"],["body","\n"],["body","另一个关于Mutex 有趣的事情是，只要 Mutex 中的类型是Send，Mutex 就会是Sync。这是因为Mutex确保只有一线程可以访问到内部的值，因此在线程间共享Mutex 是安全的。"],["body","\n"],["body","\n\n"],["headingLink","mutex-add-sync-to-a-send-type"],["heading","Mutex: add Sync to a Send type"],["body","\n"],["body","可能你还记得文章开头说过，Arc需要底层的类型是Send+Sync，才能让Arc也是Send+Sync。Mutex只需要底层的类型是Send，就能够让 Mutex 是Send+Sync。换句话说，Mutex 将会使一个!Sync的类型Sync，因此，你可以在线程间共享和修改它。"],["body","\n"],["headingLink","mutex-without-arc"],["heading","Mutex without Arc?"],["body","\n"],["body","Mutex 是否可以不与Arc一起而单独使用，对于一个Send类型的 Mutex 满足Send+Sync，这意味着什么？"],["body","\n"],["body","如果我们可以用类似 scope threads 的方式，完全可以脱离Arc单独使用Mutex："],["body","\n"],["body","use crossbeam::scope;\nuse std::{sync::Mutex, thread::sleep, time::Duration};\n\n#[derive(Debug)]\nstruct User {\n    name: String,\n}\n\nfn main() {\n    let user = Mutex::new(User {\n        name: \"drogus\".to_string(),\n    });\n\n    scope(|s| {\n        s.spawn(|_| {\n            user.lock().unwrap().name = String::from(\"piotr\");\n        });\n\n        s.spawn(|_| {\n            sleep(Duration::from_millis(10));\n\n            // should print: Hello piotr\n            println!(\"Hello {}\", user.lock().unwrap().name);\n        });\n    })\n    .unwrap();\n}"],["body","\n"],["body","在这段程序中，我们实现了相同的目标。我们正在两个独立线程中访问Mutex所包装的值，但是通过引用共享Mutex而没有使用Arc。但这并非总是可行的，比如在异步代码中，因此Mutex总是搭配Arc使用。"],["body","\n"],["headingLink","为什么-arc-需要类型是-sync"],["heading","为什么 Arc 需要类型是 Sync"],["body","\n"],["body","为什么Arc需要底层的类型同时满足Send和Sync才能让自己是Send和Sync"],["body","\n"],["body","让我们以 Cell 为例。Cell 包装某个类型并使其具有内部可变性，或换句话说，它让我们可以在一个不可变的结构体上修改其内部的某个值。Cell是Send，但它也是!Sync。"],["body","\n"],["body","use std::cell::Cell;\n\nstruct User {\n    age: Cell<usize>\n}\n\nfn main() {\n    let user = User { age: Cell::new(30) };\n\n    user.age.set(36);\n\n    // will print: Age: 36\n    println!(\"Age: {}\", user.age.get());\n}"],["body","\n"],["body","Cell在某些情况下是有用的，但它不是线程安全的，也就是说它是!Sync。如果你想在多个线程间共享一个由Cell包装的值，这可能会让两个线程修改同一处内存，例如："],["body","\n"],["body","// this example will not compile, `Cell` is `!Sync` and thus\n// `Arc` will be `!Sync` and `!Send`\nuse std::cell::Cell;\n\nstruct User {\n    age: Cell<usize>\n}\n\nfn main() {\n    let user_original = Arc::new(User { age: Cell::new(30) });\n    let user = user_original.clone();\n    std::thread::spawn(move || {\n        user.age.set(2);\n    });\n\n    let user = user_original.clone();\n    std::thread::spawn(move || {\n        user.age.set(3);\n    });\n}"],["body","\n\n"],["body","\n"],["body","如果这段代码运行，它可能会导致未定义行为。这就是为什么Arc无法与!Send或!Sync的类型一起工作。同时，Cell是 Send，这意味着它可以在线程间被发送。"],["body","\n"],["body","\n"],["body","\n"],["body","为什么？发送(Send)，或换个词-移动(Move)，不会让一个值被多个线程访问，它必须只能被一个线程拥有。一旦你把它移动到另一个线程，之前的线程就不再拥有这个值。基于这一点，我们总是在局部（local）修改一个 Cell。"],["body","\n"],["body","\n\n"],["headingLink","为什么-arc-需要类型"],["heading","为什么 Arc 需要类型"],["body","\n\n"],["body","\n"],["body","为什么Arc不会为一个!Send 类型提供Send特性：在 Rust 中，有一种类型是!Send，它就是Rc。Rc 是 Arc 的胞妹，但它不是原子的，Rc 仅用作引用计数器"],["body","\n"],["body","\n"],["body","\n"],["body","它的作用与 Arc 基本相同，但只能在单线程中使用"],["body","\n"],["body","\n"],["body","\n"],["body","它既不能在线程之间共享，也不能在线程之间移动。让我们来看看为什么"],["body","\n"],["body","\n\n"],["body","// this code won't compile, Rc is !Send and !Sync\nuse std::rc::Rc;\n\nfn main() {\n    let foo = Rc::new(1);\n\n    let foo_clone = foo.clone();\n    std::thread::spawn(move || {\n        dbg!(foo_clone);\n    });\n\n    let foo_clone = foo.clone();\n    std::thread::spawn(move || {\n        dbg!(foo_clone);\n    });\n}"],["body","\n"],["body","这段代码不会被编译，因为Rc是!Sync+!Send。它内部的计数器不是原子的，因此在线程间共享它会导致不准确的引用计数。现在假设Arc能够让!Send类型变成Send:"],["body","\n"],["body","use std::rc::Rc;\nuse std::sync::Arc;\n\n#[derive(Debug)]\nstruct User {\n    name: Rc<String>,\n}\nunsafe impl Send for User {}\nunsafe impl Sync for User {}\n\nfn main() {\n    let foo = Arc::new(User {\n        name: Rc::new(String::from(\"drogus\")),\n    });\n\n    let foo_clone = foo.clone();\n    std::thread::spawn(move || {\n        let name = foo_clone.name.clone();\n    });\n\n    let foo_clone = foo.clone();\n    std::thread::spawn(move || {\n        let name = foo_clone.name.clone();\n    });\n}"],["body","\n"],["body","这段代码可以编译，但它是错误的，请不要在实际代码中这样写！在这里，我定义了一个User结构体，其内部有个Rc类型的成员。因为Send和Sync是自动派生的，并且 Rc 是!Send+!Sync，所以 User 结构体也应该是!Send+!Sync。但是我们可以显式地告诉编译器把它标记为其他，在这段代码中使用不安全的 impl 语法标记为了Send+Sync。"],["body","\n"],["body","现在你可以清楚地看到，如果Arc允许!Send类型在线程间发送，会出什么问题了。在这个例子中，Arc的克隆被移动到不同的线程，然后没有任何东西阻止我们克隆 Rc 类型。并且因为 Rc 不是线程安全的，它可能会导致不准确的引用计数进而导致内存中的对象被过早释放或永不释放。"],["body","\n"],["headingLink","总结"],["heading","总结"],["body","\n"],["body","Auto Trait ：RUST中的一种自动派生的trait，只要 其 结构体的成员都是 实现了 某AutoTrait，则该结构体也 实现 某AutoTriat"],["body","\n"],["body","Send & Sync：对于线程间变量共享 RUST定义了两种 AutoTrait。"],["body","\n"],["body","​\tSend：表示该Trait 可以安全的在线程间 move"],["body","\n"],["body","​\tSync： 表示该Trait 可以安全的在 现成间 共享"],["body","\n"],["body","Arc： 原子引用计数、其Send、Sync特性取决于成员"],["body","\n"],["body","Mutex：互斥锁、使得 !Sync  的成员 变成  Sync "],["body","\n"],["body","Cell：Send + !Sync"],["body","\n"],["body","Rc:  !send + !sync"],["body","\n"],["body","转载文章：https://zhuanlan.zhihu.com/p/523959791"],["body","\n\n\n\n                    "],["body","\n\n                    \n                \n            \n\n            \n\n        \n\n\n\n\n        \n\n\n\n        \n        \n        \n\n        \n\n\n    \n    \n\n"]],[["_relative_fp","15依赖管理.html"],["title","依赖管理.md - RUST学习笔记"],["body","\n    \n        \n        \n\n        \n        \n\n        \n        \n\n        \n\n        \n        \n\n        \n\n        \n        \n\n        \n\n            \n                                \n                \n                    \n                        "],["body","\n                            \n                        "],["body","\n                        "],["body","\n                            \n                        "],["body","\n                        \n                            "],["body","Light"],["body","\n                            "],["body","Rust"],["body","\n                            "],["body","Coal"],["body","\n                            "],["body","Navy"],["body","\n                            "],["body","Ayu"],["body","\n                        \n                    \n\n                    "],["heading","RUST学习笔记"],["body","\n\n                    \n\n                    \n                \n\n\n                \n                \n\n                \n                    "],["body","\n                        \n\n"],["body","\n"],["body","\n\n"],["headingLink","包和箱crate"],["heading","包和箱(crate)"],["body","\n\n"],["body","\n"],["body","crate 是一个二进制项或者库,例如某个第三方包"],["body","\n"],["body","\n"],["body","\n"],["body","crate root 是一个源文件，Rust 编译器以它为起始点,并构成你的 crate 的根模块"],["body","\n"],["body","\n"],["body","\n"],["body","包（package） 是提供一系列功能的一个或者多个 crate,整个项目工程"],["body","\n"],["body","\n"],["body","\n"],["body","一个包会包含有一个 Cargo.toml 文件，阐述如何去构建这些 crate。"],["body","\n"],["body","\n\n"],["headingLink","包规则"],["heading","包规则"],["body","\n\n"],["body","一个包中至多 只能 包含一个库 crate(library crate)；"],["body","\n"],["body","包中可以包含任意多个二进制 crate(binary crate)；"],["body","\n"],["body","包中至少包含一个 crate，无论是库的还是二进制的"],["body","\n\n"],["headingLink","示例"],["heading","示例"],["body","\n"],["body","//Cargo 会给我们的包创建一个 Cargo.toml 文件\ncargo new my-project\n"],["body","\n"],["headingLink","cargo-遵循的一个约定"],["heading","Cargo 遵循的一个约定"],["body","\n\n"],["body","src/main.rs 就是一个与包同名的二进制 crate 的 crate 根"],["body","\n"],["body","如果包目录中包含 src/lib.rs，则包带有与其同名的库 crate，且 src/lib.rs 是 crate 根。"],["body","\n"],["body","crate 根文件将由 Cargo 传递给 rustc 来实际构建库或者二进制项目。"],["body","\n\n"],["body","在此，我们有了一个只包含 src/main.rs 的包，意味着它只含有一个名为 my-project 的二进制 crate。如果一个包同时含有 src/main.rs 和 src/lib.rs，则它有两个 crate：一个库和一个二进制项，且名字都与包相同。通过将文件放在 src/bin 目录下，一个包可以拥有多个二进制 crate：每个 src/bin 下的文件都会被编译成一个独立的二进制 crate。"],["body","\n"],["body","src/main.rs 和 src/lib.rs 叫做 crate 根。之所以这样叫它们是因为这两个文件的内容都分别在 crate 模块结构的根组成了一个名为 crate 的模块，该结构被称为 模块树（module tree）。"],["body","\n"],["body","路径有两种形式："],["body","\n\n"],["body","绝对路径（absolute path）从 crate 根开始，以 crate 名或者字面值 crate 开头。"],["body","\n"],["body","相对路径（relative path）从当前模块开始，以 self、super 或当前模块的标识符开头。"],["body","\n\n"],["headingLink","使用-use-关键字将名称引入作用域"],["heading","使用 use 关键字将名称引入作用域"],["body","\n"],["body","#![allow(unused)]\nfn main() {\nmod front_of_house {\n    pub mod hosting {\n        pub fn add_to_waitlist() {}\n    }\n}\n\nuse front_of_house::hosting;\n\npub fn eat_at_restaurant() {\n    hosting::add_to_waitlist();\n    hosting::add_to_waitlist();\n    hosting::add_to_waitlist();\n}\n}"],["body","\n"],["headingLink","创建惯用的-use-路径"],["heading","创建惯用的 use 路径"],["body","\n"],["body","#![allow(unused)]\nfn main() {\nmod front_of_house {\n    pub mod hosting {\n        pub fn add_to_waitlist() {}\n    }\n}\n\nuse crate::front_of_house::hosting::add_to_waitlist;\n\npub fn eat_at_restaurant() {\n    add_to_waitlist();\n    add_to_waitlist();\n    add_to_waitlist();\n}\n}"],["body","\n"],["headingLink","使用父模块将两个具有相同名称的类型引入同一作用域"],["heading","使用父模块将两个具有相同名称的类型引入同一作用域"],["body","\n"],["body","#![allow(unused)]\nfn main() {\nuse std::fmt::Result;\nuse std::io::Result as IoResult;\n\nfn function1() -> Result {\n    // --snip--\n}\n\nfn function2() -> IoResult<()> {\n    // --snip--\n}\n}"],["body","\n"],["headingLink","使用as重命名"],["heading","使用as重命名"],["body","\n"],["body","\n#![allow(unused)]\nfn main() {\nuse std::fmt::Result;\nuse std::io::Result as IoResult;\n\nfn function1() -> Result {\n    // --snip--\n    Ok(())\n}\n\nfn function2() -> IoResult<()> {\n    // --snip--\n    Ok(())\n}\n}"],["body","\n"],["headingLink","使用-pub-use-重导出名称"],["heading","使用 pub use 重导出名称"],["body","\n"],["body","mod front_of_house {\n    pub mod hosting {\n        pub fn add_to_waitlist() {}\n    }\n}\n\npub use crate::front_of_house::hosting;\n\npub fn eat_at_restaurant() {\n    hosting::add_to_waitlist();\n    hosting::add_to_waitlist();\n    hosting::add_to_waitlist();\n}\nfn main() {}\n"],["body","\n"],["body","使用pub use  可以使得使用该模块的 访问到内部的模块"],["body","\n"],["headingLink","使用外部包"],["heading","使用外部包"],["body","\n"],["body","[dependencies]\nrand = \"0.5.5\"\n\n//使用\nuse rand::Rng;\nfn main() {\n    let secret_number = rand::thread_rng().gen_range(1, 101);\n}"],["body","\n"],["body","标准库"],["body","\n"],["body","\n#![allow(unused)]\nfn main() {\nuse std::collections::HashMap;\n}"],["body","\n"],["headingLink","嵌套路径来消除大量的-use-行"],["heading","嵌套路径来消除大量的 use 行"],["body","\n"],["body","\n#![allow(unused)]\nfn main() {\nuse std::{cmp::Ordering, io};\n// ---snip---\n}\n\n#![allow(unused)]\nfn main() {\nuse std::io;\nuse std::io::Write;\n}\n\n\n#![allow(unused)]\nfn main() {\nuse std::io::{self, Write};\n}"],["body","\n"],["headingLink","通过-glob-运算符将所有的公有定义引入作用域"],["heading","通过 glob 运算符将所有的公有定义引入作用域"],["body","\n"],["body","#![allow(unused)]\nfn main() {\nuse std::collections::*;\n}"],["body","\n"],["headingLink","将模块分割进不同文件"],["heading","将模块分割进不同文件"],["body","\n\n"],["body","每一个crate就是一个根模块。如：exp, lip, lip1, lip2, lip3。"],["body","\n"],["body","独立的一个文件就是一个mod,文件名就是mod名；但是main.rs, lib.rs, mod.rs除外，mod.rs的模块名就是其所在目录的名字； 而main.rs, lib.rs 的目录结构，如：exp/src/main.rs或 lip/src/lib.rs ;两者的mod名分别是exp和lip。"],["body","\n"],["body","文件和文件夹内的mod 及其内部定义的函数默认都是private的，除非pub声明公开。"],["body","\n"],["body","一个文件夹直接包含mod.rs ，如: rust_mod_study/lip2/src/worker/mod.rs ;则 worker就是模块名； 并且mod.rs为此模块的入口文件，此文件夹内的其他子模块都要在mod.rs中 pub mod 模块名，声明后，外部方可看到。"],["body","\n"],["body","如果一个元素是私有的，那么只有本模块内的元素以及它的子模块可以访问。"],["body","\n"],["body","如果一个元素是公开的，那么它上一层的模块就有权访问它。"],["body","\n"],["body","如果存在与文件同名的目录， 则在该目录下定义的模块都是该文件的子模块.（2018 edition有效）如：rust_mod_study/lip3/src/caller.rs ;``rust_mod_study/lip3/src/caller/callerin.rs;"],["body","\n\n"],["body","特别注意，callerin这个mod必须在caller.rs中以pub mod callerin;形式声明，否则外部看不到； 最终模块路径为：lip3::caller::callerin::call();"],["body","\n\n"],["body","rust 2018 edition 不再需要在根模块中使用extern crate xxx;语法导入第三方包。如在文件main.rs , lib.rs中不再需要extern crate xxx语法导入第三方包, 如:rust_mod_study/exp/src/main.rs 中的extern crate xxx可以去掉了。只需在Cargo.toml中配置好， 然后在代码中以模块路径访问即可，如：modx::mody::modz::fnx()； 也可以use一下，缩短路径。"],["body","\n"],["body","rust 如何引用未发布的本地crate, 特别之处在exp/Cargo.toml中， 如："],["body","\n\n"],["body","[package]\nname = \"exp\"\nversion = \"0.1.0\"\nauthors = [\"yujinliang <285779289@qq.com>\"]\nedition = \"2018\"\n\n# See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html\n[dependencies]\nlip = {path= \"../lip\" }\nlip1 = {path= \"../lip1\" }\nlip2 = {path= \"../lip2\" }\nlip3 = {path= \"../lip3\" } \n\n"],["body","\n\n"],["body","\n"],["body","目录结构：Cargo.lock Cargo.toml exp lip lip1 lip2 lip3 target在同一个父目录rust_mod_study中；其中exp/src/main.rs引用lip开头的所有模块。"],["body","\n"],["body","\n"],["body","\n"],["body","配置rust workspace, 在rust_mod_study/Cargo.toml中加入以下配置即可，如：\n```\n[workspace]\nmembers = [\"exp\", \"lip\", \"lip1\", \"lip2\", \"lip3\"]\n```"],["body","\n"],["body","\n"],["body","\n"],["body","在rust_mod_study/exp中给出一个例子用于说明：在同一个crate下各个子mod间的可见性和引用方法"],["body","\n"],["body","\n\n\n"],["body","首先各个子mod都需要在main.rs(属于crate顶级mod)中声明自己， 如： mod producer; mod consumer; mod switcher;等 ，只有这样各个子mod才能看到彼此，才能引用。"],["body","\n"],["body","每一个子mod可以用use crate::xxx形式引用在1.中声明的mod, 如：use crate::producer;等。"],["body","\n"],["body","每一个子mod自身默认都是自私的，除非以pub , pub use等打开为公用。"],["body","\n"],["body","对于pub struct 其field默认仍然是private的，需要pub声明为公用。"],["body","\n\n"],["body","总结： 父mod可以引用其子mod, 但是在父模块中仍然需要声明后方可应用子模块，如：mod 子模块名 ；而每一个子模块，只可以看到在其父模块中声明过的子mod, 但是仍需use crate::子模块名 来引用一下后方可用。\n我是在rust 1.39中做的实验， 时间急促，水平有限，如有谬误，欢迎指正，感谢啦！"],["body","\n\n"],["body","所有的例子代码都在rust_mod_study目录中 `"],["body","\n\n\n\n\n                    "],["body","\n\n                    \n                \n            \n\n            \n\n        \n\n\n\n\n        \n\n\n\n        \n        \n        \n\n        \n\n\n    \n    \n\n"]],[["_relative_fp","3常见集合.html"],["title","常见集合.md - RUST学习笔记"],["body","\n    \n        \n        \n\n        \n        \n\n        \n        \n\n        \n\n        \n        \n\n        \n\n        \n        \n\n        \n\n            \n                                \n                \n                    \n                        "],["body","\n                            \n                        "],["body","\n                        "],["body","\n                            \n                        "],["body","\n                        \n                            "],["body","Light"],["body","\n                            "],["body","Rust"],["body","\n                            "],["body","Coal"],["body","\n                            "],["body","Navy"],["body","\n                            "],["body","Ayu"],["body","\n                        \n                    \n\n                    "],["heading","RUST学习笔记"],["body","\n\n                    \n\n                    \n                \n\n\n                \n                \n\n                \n                    "],["body","\n                        \n\n"],["body","\n"],["body","\n\n"],["headingLink","vectort"],["heading","Vector<T>"],["body","\n"],["headingLink","新建vector"],["heading","新建Vector"],["body","\n"],["body","//新建一个空的 vector 来储存 i32 类型的值\n#![allow(unused)]\nfn main() {\nlet v: Vec<i32> = Vec::new();\n}"],["body","\n"],["body","使用宏"],["body","\n"],["body","#![allow(unused)]\nfn main() {\nlet v = vec![1, 2, 3];\n}"],["body","\n"],["headingLink","更新-vector"],["heading","更新 vector"],["body","\n"],["body","#![allow(unused)]\n\nfn main() {\nlet mut v = Vec::new();\n\nv.push(5);\nv.push(6);\n}"],["body","\n"],["headingLink","读取"],["heading","读取"],["body","\n"],["body","索引语法"],["body","\n"],["body","#![allow(unused)]\nfn main() {\nlet v = vec![1, 2, 3, 4, 5];\nlet third: &i32 = &v[2];\nprintln!(\"The third element is {}\", third);\nmatch v.get(2) {\n    Some(third) => println!(\"The third element is {}\", third),\n    None => println!(\"There is no third element.\"),\n}\n}"],["body","\n"],["body","get语法"],["body","\n"],["body","#![allow(unused)]\nfn main() {\nlet v = vec![1, 2, 3, 4, 5];\n\nlet does_not_exist = &v[100];\nlet does_not_exist = v.get(100);\n}"],["body","\n"],["headingLink","集合中的-所有权检查"],["heading","集合中的 所有权检查"],["body","\n"],["body","#![allow(unused)]\nfn main() {\n//编译会报错\nlet mut v = vec![1, 2, 3, 4, 5];\n\nlet first = &v[0];\n\nv.push(6);\n\nprintln!(\"The first element is: {}\", first);\n}"],["body","\n"],["body","在 vector 的结尾增加新元素时，在没有足够空间将所有所有元素依次相邻存放的情况下，可能会要求分配新内存并将老的元素拷贝到新的空间中。这时，第一个元素的引用就指向了被释放的内存。借用规则阻止程序陷入这种状况"],["body","\n"],["headingLink","遍历"],["heading","遍历"],["body","\n"],["body","可变遍历"],["body","\n"],["body","#![allow(unused)]\n\nfn main() {\nlet mut v = vec![100, 32, 57];\nfor i in &mut v {\n    *i += 50;\n}\n}"],["body","\n"],["headingLink","string字符串"],["heading","String字符串"],["body","\n"],["headingLink","什么是字符串类型"],["heading","什么是字符串类型"],["body","\n\n"],["body","Rust 的核心语言中只有一种字符串类型, str"],["body","\n"],["body","字符串 slice，它通常以被借用的形式出现 &str"],["body","\n"],["body","称作 String 的类型是由标准库提供的,而没有写进核心语言部分，它是可增长的、可变的、有所有权的、UTF-8 编码的字符串类型"],["body","\n\n"],["headingLink","新建字符串"],["heading","新建字符串"],["body","\n"],["headingLink","new关键字"],["heading","new关键字"],["body","\n"],["body","#![allow(unused)]\nfn main() {\nlet mut s = String::new();\n}"],["body","\n"],["headingLink","tostring转string"],["heading","toString()转string"],["body","\n"],["body","\n"],["body","用于任何实现了 Display的 trait"],["body","\n"],["body","\n"],["body","#![allow(unused)]\n\nfn main() {\nlet data = \"initial contents\";\n\nlet s = data.to_string();\n\n// 该方法也可直接用于字符串字面值：\nlet s = \"initial contents\".to_string();\n}"],["body","\n"],["headingLink","从字面量转string"],["heading","从字面量转String"],["body","\n"],["body","\n"],["body","字符串是 UTF-8 编码的"],["body","\n"],["body","\n"],["body","#![allow(unused)]\nfn main() {\nlet s = String::from(\"initial contents\");\n}"],["body","\n"],["headingLink","更新字符串"],["heading","更新字符串"],["body","\n"],["body","#![allow(unused)]\nfn main() {\nlet mut s = String::from(\"foo\");\ns.push_str(\"bar\");\n\nlet mut s1 = String::from(\"foo\");\nlet s2 = \"bar\";\ns1.push_str(s2);\nprintln!(\"s2 is {}\", s2);\n\n\nlet mut s = String::from(\"lo\");\ns.push('l');\n}"],["body","\n"],["headingLink","拼接字符串"],["heading","拼接字符串"],["body","\n"],["headingLink","使用加号运算符"],["heading","使用加号运算符"],["body","\n"],["body","\n"],["body","add函数"],["body","\n"],["body","\n"],["body","fn add(self, s: &str) -> String {\n"],["body","\n"],["body","#![allow(unused)]\nfn main() {\nlet s1 = String::from(\"Hello, \");\nlet s2 = String::from(\"world!\");\nlet s3 = s1 + &s2; // 注意 s1 被移动了，不能继续使用\n}"],["body","\n"],["body","所有权分析"],["body","\n"],["body","​\t会取得第一个参数的所有权,然后将剩余的字符串复制在该字符串的后面"],["body","\n"],["headingLink","索引字符串"],["heading","索引字符串"],["body","\n"],["body","\n"],["body","String 是一个 Vec<u8> 的封装"],["body","\n"],["body","\n"],["body","#![allow(unused)]\nfn main() {\nlet len = String::from(\"Hola\").len();\n\nlet hello = \"Здравствуйте\";\nlet answer = &hello[0];\n}"],["body","\n"],["body","底层以字节存储"],["body","\n"],["body","Rust 不允许使用索引获取 String 字符的原因是"],["body","\n\n"],["body","\n"],["body","索引操作预期总是需要常数时间 (O(1))。但是对于 String 不可能保证这样的性能"],["body","\n"],["body","\n"],["body","\n"],["body","因为 Rust 必须从开头到索引位置遍历来确定有多少有效的字符"],["body","\n"],["body","\n\n"],["headingLink","字符串-slice"],["heading","字符串 slice"],["body","\n"],["body","\n"],["body","可以使用 [] 和一个 range 来创建含特定字节的字符串 slice："],["body","\n"],["body","\n"],["body","#![allow(unused)]\nfn main() {\nlet hello = \"Здравствуйте\";\nlet s = &hello[0..4];\n//访问也是按字节访问的\n}"],["body","\n"],["headingLink","字符串遍历"],["heading","字符串遍历"],["body","\n"],["body","如果你需要操作单独的 Unicode 标量值，最好的选择是使用 chars 方法。对 “नमस्ते” 调用 chars 方法会将其分开并返回六个 char 类型的值"],["body","\n"],["body","#![allow(unused)]\n\nfn main() {\nfor c in \"नमस्ते\".chars() {\n    println!(\"{}\", c);\n}\n\n//返回原始字节\nfor b in \"नमस्ते\".bytes() {\n    println!(\"{}\", b);\n}\n}"],["body","\n"],["headingLink","hashmap"],["heading","HashMap"],["body","\n"],["headingLink","新建hashmap"],["heading","新建HashMap"],["body","\n"],["headingLink","构造函数构建"],["heading","构造函数构建"],["body","\n"],["body","#![allow(unused)]\nfn main() {\nuse std::collections::HashMap;\nlet mut scores = HashMap::new();\nscores.insert(String::from(\"Blue\"), 10);\nscores.insert(String::from(\"Yellow\"), 50);\n}"],["body","\n"],["headingLink","使用元组构建"],["heading","使用元组构建"],["body","\n"],["body","\n"],["body","使用一个元组的 vector 的 collect 方法，其中每个元组包含一个键值对。collect 方法可以将数据收集进一系列的集合类型，包括 HashMap"],["body","\n"],["body","\n"],["body","#![allow(unused)]\nfn main() {\nuse std::collections::HashMap;\nlet teams  = vec![String::from(\"Blue\"), String::from(\"Yellow\")];\nlet initial_scores = vec![10, 50];\n//zip方法创建一个元组, 将两个vec按索引对应创建\nlet scores: HashMap<_, _> = teams.iter().zip(initial_scores.iter()).collect();\n}"],["body","\n"],["headingLink","hashmap所有权"],["heading","HashMap所有权"],["body","\n\n"],["body","对于像 i32 这样的实现了 Copy trait 的类型，其值可以拷贝进哈希 map。"],["body","\n"],["body","对于像 String 这样拥有所有权的值，其值将被移动而哈希 map 会成为这些值的所有者"],["body","\n\n"],["body","#![allow(unused)]\nfn main() {\nuse std::collections::HashMap;\n\nlet field_name = String::from(\"Favorite color\");\nlet field_value = String::from(\"Blue\");\n\nlet mut map = HashMap::new();\nmap.insert(field_name, field_value);\n// 这里 field_name 和 field_value 不再有效，\n// 尝试使用它们看看会出现什么编译错误\n}"],["body","\n"],["headingLink","hashmap访问"],["heading","hashMap访问"],["body","\n"],["headingLink","get-返回-optionv"],["heading","get 返回 Option<V>"],["body","\n"],["body","#![allow(unused)]\nfn main() {\nuse std::collections::HashMap;\n\nlet mut scores = HashMap::new();\n\nscores.insert(String::from(\"Blue\"), 10);\nscores.insert(String::from(\"Yellow\"), 50);\n\nlet team_name = String::from(\"Blue\");\nlet score = scores.get(&team_name);\n}"],["body","\n"],["headingLink","遍历map"],["heading","遍历Map"],["body","\n"],["body","#![allow(unused)]\nfn main() {\nfor (key, value) in &scores {\n    println!(\"{}: {}\", key, value);\n}\n}"],["body","\n"],["headingLink","更新hashmap"],["heading","更新HashMap"],["body","\n"],["headingLink","覆盖旧的键值"],["heading","覆盖旧的键值"],["body","\n"],["body","#![allow(unused)]\nfn main() {\nscores.insert(String::from(\"Blue\"), 10);\nscores.insert(String::from(\"Blue\"), 25);\n}"],["body","\n"],["headingLink","键不存在时插入"],["heading","键不存在时插入"],["body","\n"],["body","\n#![allow(unused)]\nfn main() {\nuse std::collections::HashMap;\n\nlet mut scores = HashMap::new();\nscores.insert(String::from(\"Blue\"), 10);\n\nscores.entry(String::from(\"Yellow\")).or_insert(50);\nscores.entry(String::from(\"Blue\")).or_insert(50);\n\nprintln!(\"{:?}\", scores);\n}"],["body","\n"],["headingLink","根据旧值更新新值"],["heading","根据旧值更新新值"],["body","\n"],["body","or_insert 方法事实上会返回这个键的值的一个可变引用（&mut V）。这里我们将这个可变引用储存在 count 变量中"],["body","\n"],["body","\n#![allow(unused)]\nfn main() {\nuse std::collections::HashMap;\n\nlet text = \"hello world wonderful world\";\n\nlet mut map = HashMap::new();\n\nfor word in text.split_whitespace() {\n    let count = map.entry(word).or_insert(0);\n    *count += 1;\n}\n\nprintln!(\"{:?}\", map);\n}"],["body","\n"],["headingLink","哈希函数"],["heading","哈希函数"],["body","\n\n"],["body","\n"],["body","HashMap 默认使用一种 “密码学安全的”（“cryptographically strong” ）1 哈希函数，它可以抵抗拒绝服务（Denial of Service, DoS）攻击。"],["body","\n"],["body","\n"],["body","\n"],["body","然而这并不是可用的最快的算法，不过为了更高的安全性值得付出一些性能的代价。"],["body","\n"],["body","\n"],["body","\n"],["body","如果性能监测显示此哈希函数非常慢，以致于你无法接受，你可以指定一个不同的 hasher 来切换为其它函数。hasher 是一个实现了 BuildHasher trait 的类型"],["body","\n"],["body","\n\n\n\n\n                    "],["body","\n\n                    \n                \n            \n\n            \n\n        \n\n\n\n\n        \n\n\n\n        \n        \n        \n\n        \n\n\n    \n    \n\n"]]]